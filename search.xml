<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下生成core dump文件</title>
    <url>/2020/02/28/2020-02-28-how-to-generate-core-dump-file/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Linux上运行C程序发生段错误后，没有core文件生成，调试不便。</p>
<span id="more"></span>

<h2 id="生成core文件步骤"><a href="#生成core文件步骤" class="headerlink" title="生成core文件步骤"></a>生成core文件步骤</h2><ol>
<li>敲ulimit -a，查看系统core文件大小限制，如第一行core file size值为0，表示没打开core文件设置<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image1.png"></li>
<li>敲ulimit -c [kbytes], 设置系统允许生成的core文件大小, 如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -c 1024        设置core文件最大为1024K</span><br><span class="line">ulimit -c unlimited   不限制core文件大小</span><br><span class="line">ulimit -c 0           不生成core文件</span><br></pre></td></tr></table></figure></li>
<li>运行C程序，段错误后，在当前目录生成core文件。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image2.png"></li>
</ol>
<p><strong>问题:</strong><br>多次运行程序发生段错误后，新生成的core文件会把旧的core文件覆盖，怎么区分并保留多个core文件?</p>
<p><strong>解决方法:</strong><br>敲 echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid, 将每次产生的core文件的文件名中是否添加pid作为扩展。如果添加则文件内容为1，反之为0。<br><img src="/2020/02/28/2020-02-28-how-to-generate-core-dump-file/image3.png"><br>如上图，两次coredump后，会根据pid生成不同的core文件。</p>
<p><strong>指定core文件的输出格式和路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo /path/to/core.%t.%e.%p &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次UDP sendto函数错误解决</title>
    <url>/2020/03/29/2020-03-29-solve-sendto-error/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在编写使用select函数的TCP和UDP回射程序，出现UDP的sendto错误，现象如下：</p>
<ul>
<li><p>服务端正常启动后，调用select函数监听TCP和UDP套接字, 可以正常处理TCP请求。</p>
</li>
<li><p>UDP客户端可以连接到服务端，但接收标准输入后无回显，阻塞于recvfrom。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>经排查，发现服务端处理UDP请求的代码有问题，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len);</span><br><span class="line">	sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>udp_echo函数，先用recvfrom读取UDP客户端发送的字符串，再使用sendto将该字符串送回客户端。代码中没有判断recvfrom, sendto函数的返回值，为了获取出错信息改写如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udp_echo</span><span class="params">(<span class="type">int</span> udpfd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> recvline[MAXLINE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> len;</span><br><span class="line">	<span class="keyword">if</span>((n = recvfrom(udpfd, recvline, MAXLINE, <span class="number">0</span>, (SA*)&amp;cliaddr, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err_sys(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sendto(udpfd, recvline, n, <span class="number">0</span>, (SA*)&amp;cliaddr, len) != n) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">		err_sys(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行程序，输出如下:<br>$ error: Invalid argument<br>$ sendto error</p>
<p>错误原因在于cliaddr参数没有初始化。<strong>sockaddr_in结构体在使用之前，需要先使用bzero&#x2F;memset函数初始化为0</strong>，否则出现赋值不完整导致参数无效。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>变量使用之前最好初始化。</p>
</li>
<li><p>注意判断函数的返回值，可以使用包裹函数。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>标准IO库的缓冲模式</title>
    <url>/2020/03/22/2020-03-22-buffered-mode-of-standard-IO-lib/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时候，代码中明明执行了printf语句打印到终端，却没有看到输出的内容。</p>
<p>写文件的时候，明明成功执行了fwrite, fprintf语句，文件却没有写入相应的内容。</p>
<p>想搞清楚这些问题产生的原因，需要了解标准I&#x2F;O库的缓冲模式。</p>
<span id="more"></span>

<h2 id="标准I-O与unbuffered-I-O"><a href="#标准I-O与unbuffered-I-O" class="headerlink" title="标准I&#x2F;O与unbuffered I&#x2F;O"></a>标准I&#x2F;O与unbuffered I&#x2F;O</h2><p>linux对I&#x2F;O文件操作分为不带缓存I&#x2F;O(unbuffered I&#x2F;O)和带缓存I&#x2F;O(即标准I&#x2F;O)</p>
<p>《APUE》中对术语unbuffered的定义: “The term <em>unbuffered</em> means that each read or write invokes a system call in the kernel”</p>
<p><a href="https://blog.csdn.net/qq_33366098/article/details/77923722">这篇文章</a>讲了unbuffered I&#x2F;O和标准I&#x2F;O的区别，以下引用其中的描述：</p>
<p>不带缓存I&#x2F;O，是指每次read, write都会进入内核，执行一次系统调用，不带缓存不是指直接对磁盘进行读写。比如read,write函数，它们属于系统调用，在用户态没有缓存，但是在内核是有缓存器的。如内核缓存未满，写入的数据还是在内核缓存，并没有真正写入硬盘。需要等待缓存写满或者内核需要重用该缓存以存放其他磁盘块数据时，才进行实际硬盘读写，这种方式被称为延迟写(delayed write)</p>
<p>带缓存I&#x2F;O也叫标准I&#x2F;O。标准I&#x2F;O会在用户态建立一个缓存区，以尽可能减少read和write调用的次数，提高效率。</p>
<p>unbuffered I&#x2F;O操作数据流向：数据-&gt;内核缓存区-&gt;磁盘</p>
<p>标准I&#x2F;O操作数据流向：数据-&gt;流缓存区-&gt;内核缓存区-&gt;磁盘</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I&#x2F;O库提供三种模式的缓冲: 全缓冲、行缓冲、不带缓冲</p>
<h3 id="全缓冲-fully-buffered"><a href="#全缓冲-fully-buffered" class="headerlink" title="全缓冲(fully buffered)"></a>全缓冲(fully buffered)</h3><p>这种情况下，在填满标准I&#x2F;O缓冲区后才进行实际I&#x2F;O操作。对于驻留在磁盘上的文件通常用全缓冲。</p>
<h3 id="行缓冲-line-buffered"><a href="#行缓冲-line-buffered" class="headerlink" title="行缓冲(line buffered)"></a>行缓冲(line buffered)</h3><p>这种情况下，当输入或输出遇到换行符，或者缓冲区已满时进行实际I&#x2F;O操作。当流涉及一个终端时，通常使用行缓冲。</p>
<h3 id="不带缓冲-unbuffered"><a href="#不带缓冲-unbuffered" class="headerlink" title="不带缓冲(unbuffered)"></a>不带缓冲(unbuffered)</h3><p>这种情况下，标准I&#x2F;O库不对字符进行缓冲存储。例如标准出错流stderr通常是不带缓冲的，这使得出错信息可以尽快显示。</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>1.这里的实际I&#x2F;O操作不是指读写硬盘操作，而是指执行read, write系统调用。</p>
<p>2.缓冲类型与具体的标准I&#x2F;O函数无关，与读写的文件类型有关。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="例1-全缓冲"><a href="#例1-全缓冲" class="headerlink" title="例1 全缓冲"></a>例1 全缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[] = &quot;hello world&quot;;</span><br><span class="line">	FILE *fp = fopen(&quot;./text&quot;, &quot;w+&quot;);	// 省略了判空操作^_^</span><br><span class="line">	fprintf(fp, &quot;%s\n&quot;, str);</span><br><span class="line">    // fflush(fp);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，进入死循环后，观察text文件发现内容为空，hello world字符串并没有写入。</p>
<p>这是因为对于磁盘上的文件默认是全缓冲的。因为写入的字符串长度小于缓冲区大小(我的ubuntu机器上，为4096字节)，所以不会直接写入文件。</p>
<p>如需要立即输出，可以在for循环之前调用fflush函数，将缓冲区的内容写入磁盘。</p>
<p>这解释了为什么有时明明成功执行了fwrite,fprintf语句，文件却没有写入相应的内容。</p>
<h3 id="例2-行缓冲"><a href="#例2-行缓冲" class="headerlink" title="例2 行缓冲"></a>例2 行缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stdout, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序，发现终端没有输出，即使fprintf已经执行。</p>
<p>这是因为涉及终端的流默认是行缓冲的，当输入或输出遇到换行符时才进行实际I&#x2F;O操作。</p>
<p>如果需要执行fprintf后立即打印，只需在”hello world”后添加换行符’\n’</p>
<p>这个例子解释了为什么有时代码中执行了printf语句打印到终端，却没有看到输出的内容。</p>
<h3 id="例3-无缓冲"><a href="#例3-无缓冲" class="headerlink" title="例3 无缓冲"></a>例3 无缓冲</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">	fprintf(stderr, &quot;hello world&quot;);</span><br><span class="line">	for( ; ; ) &#123;</span><br><span class="line">		sleep(10);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行程序,  终端立即输出hello world。可以看出标准错误是不带缓冲的。目的是使出错信息可以尽快显示。</p>
<h3 id="例4-缓冲类型与读写的文件类型有关"><a href="#例4-缓冲类型与读写的文件类型有关" class="headerlink" title="例4 缓冲类型与读写的文件类型有关"></a>例4 缓冲类型与读写的文件类型有关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	printf(&quot;before fork\n&quot;);</span><br><span class="line"></span><br><span class="line">	if((pid = fork()) &lt; 0) &#123;	// fork失败直接返回-1</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; else if(pid &gt; 0) &#123;		// 父进程</span><br><span class="line">		wait(NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;pid = %d, hello\n&quot;, getpid());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行程序, 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">before fork</span><br><span class="line">pid = 6033, hello</span><br><span class="line">pid = 6032, hello</span><br><span class="line">$ ./a.out &gt; output.txt		#将输出重定向到output.txt文件</span><br><span class="line">$ cat output.txt</span><br><span class="line">before fork</span><br><span class="line">pid = 6077, hello</span><br><span class="line">before fork</span><br><span class="line">pid = 6076, hello</span><br></pre></td></tr></table></figure>

<p>发现两次输出的内容不同，将输出重定向到文件时，会多打印一行”before fork”，原因如下：</p>
<p><strong>如果标准输出连到终端设备，默认是行缓冲的</strong>。”before fork”只输出一次，原因是调用第一个printf后，标准输出缓冲区由换行符冲洗，“before fork”被立即打印。</p>
<p><strong>如果将标准输出重定向到文件，默认是全缓冲的</strong>。”befork fork”会输出两次，原因是调用第一个printf后数据“before fork”仍旧在缓冲区，然后调用fork函数，将父进程数据空间复制到子进程，此时该缓冲区也被复制到子进程。最后当父子进程终止时，各自冲洗其缓冲区的副本。</p>
<p>这个例子说明，缓冲类型与读写的文件类型有关，与具体I&#x2F;O函数无关。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://blog.csdn.net/qq_33366098/article/details/77923722">https://blog.csdn.net/qq_33366098&#x2F;article&#x2F;details&#x2F;77923722</a><br>【2】<a href="https://www.yanbinghu.com/2019/12/01/27836.html">https://www.yanbinghu.com/2019/12/01/27836.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>隐式函数声明[-Wimplicit-function-declaration]</title>
    <url>/2024/08/18/2020-04-11-what-is-implicit-function-declaration/</url>
    <content><![CDATA[<h2 id="什么是隐式函数声明"><a href="#什么是隐式函数声明" class="headerlink" title="什么是隐式函数声明"></a>什么是隐式函数声明</h2><p>C语言中，函数调用前不一定要声明。如果没有声明，编译器会自动按照一种隐式声明规则，为调用函数的C代码产生汇编代码。</p>
<span id="more"></span>

<h2 id="忽略隐式函数声明警告的危害"><a href="#忽略隐式函数声明警告的危害" class="headerlink" title="忽略隐式函数声明警告的危害"></a>忽略隐式函数声明警告的危害</h2><p>编译so库时会出现未定义符号，导致加载该so的程序执行出错。举例如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123; <span class="comment">// 调用add方法，求三数和</span></span><br><span class="line">	retunr <span class="title function_">ad</span><span class="params">(a, b)</span> + c; <span class="comment">// 这里本意调用add(a, b)，笔误写成ad(a, b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将add.c编译成libadd.so，编译不报错，仅提示隐式函数声明警告，用ldd -r查看该so, 发现未定义符号ad。<br><img src="/2024/08/18/2020-04-11-what-is-implicit-function-declaration/image1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ldd -r libadd.so</span><br><span class="line">undefined symbol: ad (./libadd.so)</span><br></pre></td></tr></table></figure>

<p>此时写一个main程序，调用libadd.so中的sum方法求三数之和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main程序出错，错误原因在于<strong>编写add.c时将符号add错写成了ad，由于忽视隐式函数声明警告，导致该错误没有在编译add.c的时候及时发现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -L. -ladd</span><br><span class="line">./libadd.so: undefined reference to `ad&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<ul>
<li>对于用dlopen动态加载该so库的程序，如指定RTLD_NOW，dlopen立即失败；如指定RTLD_LAZY延迟绑定，则dlopen成功，但dlsym加载引用了未定义符号的函数(如sum函数)会出错，示例main程序如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libadd.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">	<span class="keyword">if</span>(handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> (*add)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*sum)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	add = dlsym(handle, <span class="string">&quot;add&quot;</span>);	<span class="comment">// add方法正常执行</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 = %d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	sum = dlsym(handle, <span class="string">&quot;sum&quot;</span>);	<span class="comment">// 出错，报未定义符号ad</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 = %d\n&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc main.c -ldl</span><br><span class="line">$ ./a.out</span><br><span class="line">1 + 2 = 3</span><br><span class="line">./a.out: symbol lookup error: ./libadd.so: undefined symbol: ad</span><br></pre></td></tr></table></figure>
<p>虽然编译成功，libadd.so可以加载，add函数可以执行，但执行sum函数时报未定义符号错。如及时处理隐式函数声明警告，可以在编译add.c的时候就发现该问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>函数先声明再使用，包含必要的头文件。</p>
</li>
<li><p>重视编译器的隐式函数声明警告, 可开启-Werror选项检查, 不要简单使用-Wno忽略该编译告警。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
