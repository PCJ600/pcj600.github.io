<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>CSAPP malloc实验 | PC&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="实验简介实现自己的动态内存分配器（malloc、free、realloc）。 预备知识 阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。 阅读writeup的全部内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP malloc实验">
<meta property="og:url" content="https://pcj600.github.io/2020/0926191511.html">
<meta property="og:site_name" content="PC&#39;s Blog">
<meta property="og:description" content="实验简介实现自己的动态内存分配器（malloc、free、realloc）。 预备知识 阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。 阅读writeup的全部内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image1.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image2.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image3.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image4.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image5.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image6.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image7.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image8.png">
<meta property="article:published_time" content="2020-09-26T11:15:11.000Z">
<meta property="article:modified_time" content="2024-08-18T11:19:09.964Z">
<meta property="article:author" content="PC">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pcj600.github.io/2020/0926191511/image1.png">
  
    <link rel="alternate" href="/atom.xml" title="PC's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PC&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Life is short, Play more!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://pcj600.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="next-2020-09-26-csapp-malloclab" class="h-entry article article-type-next" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/0926191511.html" class="article-date">
  <time class="dt-published" datetime="2020-09-26T11:15:11.000Z" itemprop="datePublished">2020-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSAPP/">CSAPP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      CSAPP malloc实验
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h3><p>实现自己的动态内存分配器（<code>malloc</code>、<code>free</code>、<code>realloc</code>）。</p>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li>阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。</li>
<li>阅读<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>的全部内容。</li>
</ul>
<span id="more"></span>

<h4 id="分配器的设计要求"><a href="#分配器的设计要求" class="headerlink" title="分配器的设计要求"></a>分配器的设计要求</h4><ul>
<li>处理任意请求序列，分配器不可以假设分配和释放请求的顺序。</li>
<li>立即响应请求, 不允许分配器为了提高性能重新排列或缓冲请求。</li>
<li>只使用堆。</li>
<li>对齐块，以保存任何类型的数据对象。</li>
<li>不修改已分配的块，分配器只能操作和改变空闲块。</li>
</ul>
<h4 id="分配器的设计目标"><a href="#分配器的设计目标" class="headerlink" title="分配器的设计目标"></a>分配器的设计目标</h4><ul>
<li>最大化吞吐率 —— 每个<code>malloc</code>, <code>free</code>执行的指令越少，吞吐率会越好。</li>
<li>最大化内存利用率。</li>
</ul>
<h4 id="实现问题"><a href="#实现问题" class="headerlink" title="实现问题"></a>实现问题</h4><p>关键是把握<strong>吞吐率</strong>和<strong>内存利用率</strong>之间的平衡。</p>
<ul>
<li>空闲块组织 —— 如何记录空闲块？</li>
<li>放置 —— 如何选一个合适的空闲块来放置一个新分配的块？ （首次适配&#x2F;下次适配&#x2F;最优适配）</li>
<li>分割 —— 将一个新分配块放到某个空闲块后，如何处理这个空闲块的剩余部分？</li>
<li>合并 —— 如何处理一个刚被释放的块？ （立即合并&#x2F;延迟合并）</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>代码下载：<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab-handout.tar">http://csapp.cs.cmu.edu/3e/malloclab-handout.tar</a></p>
<p>目标是实现<code>mm.c</code>中的如下函数, 原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用两种方式实现<code>malloc</code>，分别如下：</p>
<ul>
<li>隐式空闲链表 + 首次适配&#x2F;下一次适配。</li>
<li>显示空闲链表 + 分离的空闲链表 +  分离适配。</li>
</ul>
<h3 id="隐式空闲链表法"><a href="#隐式空闲链表法" class="headerlink" title="隐式空闲链表法"></a>隐式空闲链表法</h3><p>原书9.9.6节详细介绍了隐式空闲链表法，并贴出了所有源代码。代码实现细节请参考原书或者 <a target="_blank" rel="noopener" href="https://github.com/PCJ600/MallocLab/tree/br64">https://github.com/PCJ600/MallocLab/tree/br64</a></p>
<h5 id="隐式空闲链表的形式如下："><a href="#隐式空闲链表的形式如下：" class="headerlink" title="隐式空闲链表的形式如下："></a>隐式空闲链表的形式如下：</h5><p><img src="/2020/0926191511/image1.png"></p>
<ul>
<li>每个堆块使用边界标记法。头部大小为4字节，前29位表示块大小，后3位表示这个块是否空闲；脚部(ftr)是头部(hdr)的副本。目的是<strong>将合并前面的堆块时的搜索时间降到常数</strong>。</li>
<li><strong>第1个填充字用于8字节对齐访问</strong>。考虑64位场景，如不添加填充字，heap_listp的值不能整除8，不满足对齐条件！</li>
<li>序言块和结尾块的设计是消除合并时边界条件的技巧。</li>
<li>按8字节对齐要求， 一个堆块最小为 4(头部) + 8(payload) + 4(脚部) &#x3D; 16字节</li>
<li>为什么是”隐式”的？——  因为空闲块是通过头部中大小字段隐含地连接着，从而间接遍历整个空闲块的集合。</li>
</ul>
<h4 id="1-初始化堆-——-mm-init函数"><a href="#1-初始化堆-——-mm-init函数" class="headerlink" title="1. 初始化堆 —— mm_init函数"></a>1. 初始化堆 —— mm_init函数</h4><p><code>mm_init</code>步骤如下：</p>
<ul>
<li><p>首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。</p>
</li>
<li><p>调<code>extend_heap</code>扩展堆，创建初始的空闲块，大小为4096字节。</p>
</li>
</ul>
<h4 id="2-扩展堆-——-extend-heap函数"><a href="#2-扩展堆-——-extend-heap函数" class="headerlink" title="2. 扩展堆 —— extend_heap函数"></a>2. 扩展堆 —— extend_heap函数</h4><p>函数原型: <code>static void *extend_heap(size_t words);</code></p>
<p>以下两种场景需要扩展堆：</p>
<ul>
<li>调用<code>mm_init</code>初始化堆时。</li>
<li>调用<code>mm_malloc</code>找不到合适的空闲块时。</li>
</ul>
<p>举例：堆上扩展4096个字节，堆数组前后变化如下：</p>
<p><img src="/2020/0926191511/image2.png"></p>
<h4 id="3-释放和合并块-——-mm-free和coalesce函数"><a href="#3-释放和合并块-——-mm-free和coalesce函数" class="headerlink" title="3. 释放和合并块 —— mm_free和coalesce函数"></a>3. 释放和合并块 —— mm_free和coalesce函数</h4><p>调用<code>mm_free</code>释放块，步骤如下：</p>
<ul>
<li><p>将当前块的头部和脚部中的分配位清零。</p>
</li>
<li><p>将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。</p>
</li>
</ul>
<p>调用<code>coalesce</code>合并前后的合并块，原型：<code>static void *coalesce(void *bp);</code>，分四种情况：</p>
<ul>
<li>情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。</li>
<li>情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp</li>
<li>情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
<li>情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
</ul>
<p>说的比较啰嗦，以下画图帮助理解：</p>
<p><strong>情况2:</strong> 前面的块已分配，后面的块空闲</p>
<p><img src="/2020/0926191511/image3.png"></p>
<p><strong>注意：</strong> <font color = 'red'><strong>如采用下次适配策略，在情况3、情况4合并后可能出现pre_listp指针不再指向一个块的payload段，报payload overlap错!</strong></font></p>
<p>因此必须更新<code>pre_listp</code>。这里简单将<code>pre_listp</code>指向合并后的新块的<code>payload</code>即可。</p>
<p><strong>情况3：</strong> 前面的块是空闲的，后面的块是分配的</p>
<p><img src="/2020/0926191511/image4.png"></p>
<p><strong>情况4：</strong> 前面和后面的块均空闲<br><img src="/2020/0926191511/image5.png"><br>[O#### 4. 分配块 —— mm_malloc</p>
<h5 id="mm-malloc步骤"><a href="#mm-malloc步骤" class="headerlink" title="mm_malloc步骤"></a>mm_malloc步骤</h5><ul>
<li><p>调整请求块的大小，需不低于16字节（8字节对齐要求），并舍入到8的整数倍。</p>
</li>
<li><p>根据请求块的大小，搜索空闲链表寻找合适的空闲块：</p>
<ul>
<li>如果找到合适的块，将请求块放置到这个合适的块中，并可选地分割这个块</li>
<li>如找不到合适的块，调<code>extend_heap</code>扩展堆，分配新的空闲块。将请求块放到这个新的空闲块里，并可选地分割这个块</li>
</ul>
</li>
</ul>
<h5 id="适配算法"><a href="#适配算法" class="headerlink" title="适配算法"></a>适配算法</h5><p>分配器搜索空闲块的方式由放置策略决定，常见策略有首次适配、下一次适配等。</p>
<ul>
<li><p>首次适配： 从头搜索空闲链表，选择第一个合适地空闲块。</p>
</li>
<li><p>下一次适配： 从上次查询结束的地方开始搜索空闲链表。</p>
</li>
</ul>
<h5 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h5><p>如分割后剩下的块不小于最小块大小(16字节)，才分割这个块。</p>
<p>设空闲块大小为M字节，<code>malloc</code>请求的块大小为N字节。只有M - N &gt;&#x3D; 16，才分割这个块。</p>
<p><img src="/2020/0926191511/image6.png"></p>
<h4 id="5-实现mm-realloc"><a href="#5-实现mm-realloc" class="headerlink" title="5. 实现mm_realloc"></a>5. 实现mm_realloc</h4><p><code>mm_realloc</code>原型：<code>void *mm_realloc(void *ptr, size_t size)</code></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>中提到了<code>mm_realloc</code>的所有实现要点，如下：</p>
<ul>
<li>如果ptr为NULL， 等价于调用mm_malloc</li>
<li>如果size为0, 等价于调用mm_free</li>
<li>如ptr不为NULL且size不为0， 参考realloc函数的实现： <code>man 3 realloc</code></li>
</ul>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>执行<code>./mdriver -t traces/ -V</code>，查看详细结果：</p>
<p>首次适配: 44 (util) + 24 (thru) &#x3D; 68&#x2F;100</p>
<p>下一次适配：43 (util) + 40 (thru) &#x3D; 83&#x2F;100</p>
<h3 id="分离空闲链表法"><a href="#分离空闲链表法" class="headerlink" title="分离空闲链表法"></a>分离空闲链表法</h3><p>实现代码参考：<a target="_blank" rel="noopener" href="https://github.com/PCJ600/MallocLab">https://github.com/PCJ600/MallocLab</a></p>
<p>使用分离的空闲链表，分配器会维护一个空闲链表的数组。每个空闲链表和一个大小类关联，被组织成某种类型的显式或隐式链表。笔者这里使用以下方案：</p>
<ul>
<li>链表结构为<strong>显式的双向链表</strong></li>
<li>大小类分为 {16-31},{32,63},{64,127}, …, {4096, 8191}, … 链表个数<code>MAX_LIST_NUM</code> 默认设置为20，可调整。</li>
<li>考虑兼容性，分配器需要在32位&#x2F;64位环境下都能正常运行。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>32位机器上，指针大小为4字节；64位机器上， 指针大小为8字节。可使用<code>sizeof(intptr_t)</code>表示指针大小, <code>intptr_t</code>类型是ISO C99定义的，可参考<code>/usr/include/stdint.h</code></li>
<li>实验要求不使用全局变量，可以将分离链表的头指针放到堆中。</li>
<li>默认Makefile采用<code>-m32</code>选项，64位环境下需要改成<code>-m64</code>。</li>
<li>实验涉及大量指针操作，编码极易出错。需掌握基本的gdb调试手段、并编写代码检查堆区和分离链表。</li>
</ul>
<h4 id="显式的双向链表的堆块结构"><a href="#显式的双向链表的堆块结构" class="headerlink" title="显式的双向链表的堆块结构"></a>显式的双向链表的堆块结构</h4><p><img src="/2020/0926191511/image7.png"></p>
<ul>
<li><p>对于空闲块，<code>pred</code>保存上一个空闲块的地址，<code>succ</code>保存下一个空闲块的地址。</p>
</li>
<li><p>使用双向链表结构，适配算法的时间复杂度从O(块总数)降到O(空闲块总数)。</p>
</li>
<li><p>不难得出：32位系统，块至少为16字节；64位系统，块至少为24字节。</p>
</li>
</ul>
<h3 id="如何调试？"><a href="#如何调试？" class="headerlink" title="如何调试？"></a>如何调试？</h3><ul>
<li>设置编译选项<code>-g -O0</code>取消编译优化。</li>
<li>设置编译选项<code>-g3 -gdwarf-2</code>调试宏。</li>
<li>可以设置<code>-DDEBUG</code>宏，通过编译宏控制是否打印调试信息。</li>
<li>实现<code>mm_print</code>函数，在gdb中通过<code>call mm_print()</code>打印堆区和分离链表。</li>
</ul>
<h4 id="打印堆数组状态和所有分离链表-——-mm-print函数设计"><a href="#打印堆数组状态和所有分离链表-——-mm-print函数设计" class="headerlink" title="打印堆数组状态和所有分离链表 —— mm_print函数设计"></a>打印堆数组状态和所有分离链表 —— mm_print函数设计</h4><ul>
<li><p>打印堆数组中每个块的头部、脚部、大小、分配位、payload指针。</p>
</li>
<li><p>打印堆数组中所有分离链表头指针的值。</p>
</li>
<li><p>打印每条分离链表的所有块的头部、脚部、大小、分配位、payload指针。</p>
</li>
</ul>
<h4 id="堆区和分离链表检查-——-mm-check函数设计"><a href="#堆区和分离链表检查-——-mm-check函数设计" class="headerlink" title="堆区和分离链表检查 —— mm_check函数设计"></a>堆区和分离链表检查 —— mm_check函数设计</h4><p><strong>检查堆区状态，包括：</strong></p>
<ul>
<li>检查序言块、结尾块的指针、大小、分配位是否正确。</li>
<li>检查每个块的payload指针是否满足对齐要求。</li>
<li>检查每个块的payload指针是否在堆区的合法地址范围内(<code>mem_heap_lo() ~ mem_heap_hi()</code>之间)。</li>
<li>检查每个块的头部和脚部是否一致。</li>
<li>检查每个块的大小是否不低于最小块的大小，是否为4&#x2F;8字节的倍数。</li>
<li>采用立即合并策略时，检查不存在任意两个相邻的空闲块。</li>
</ul>
<p><strong>检查分离链表状态，包括：</strong></p>
<ul>
<li><p>检查链表中所有指针是否在堆区的合法地址范围内。</p>
</li>
<li><p>检查双向链表实现是否正确，是否每个指针A的后继为B时，B的前驱也同时为A。</p>
</li>
<li><p>检查分离链表中所有的空闲块是否与堆数组的空闲块中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个空闲块是否都能在分离链表中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个已占用块是否都不在分离链表中。</p>
</li>
</ul>
<p><strong>针对malloc做如下检查：</strong></p>
<ul>
<li>malloc返回前，检查指针p是否在堆数组中，如不在堆数组中说明出错。</li>
<li>malloc返回前，检查指针p对应的块大小是否不小于malloc请求的大小。</li>
</ul>
<p><strong>针对free做如下检查：</strong></p>
<ul>
<li><p>调用free时，先检查指针p是否在堆区的合法地址范围内。</p>
</li>
<li><p>调用free时，先检查p是否指向了堆数组中某个已分配块。</p>
</li>
</ul>
<p>实现代码参考： <a target="_blank" rel="noopener" href="https://github.com/PCJ600/MallocLab/blob/master/mm.c">https://github.com/PCJ600/MallocLab/blob/master/mm.c</a>  <code>mm_check</code>函数</p>
<h4 id="指针运算、宏定义"><a href="#指针运算、宏定义" class="headerlink" title="指针运算、宏定义"></a>指针运算、宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~(ALIGNMENT-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4                                     <span class="comment">// 4字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8                                     <span class="comment">// 双字: 8字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)                         <span class="comment">// 4096字节, 执行extend_heap一次, 堆上扩展的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc))		<span class="comment">// 设置分配位， 前29位表示块大小，后3位表示是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)             (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)        (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)        (GET(p) &amp; ~(0x1))        <span class="comment">// 获取块大小, 这里块大小不会超过2^32字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p)       (GET(p) &amp; 0x1)           <span class="comment">// 判断这个块是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型读写，使用intptr_t兼容32位/64位机器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_P(p)           (*(intptr_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_P(p, val)      (*(intptr_t *)(p) = (intptr_t)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离链表: |(16-31)|(32-63)|(64-127)|(128-255)| ..... |(2^23,2^24-1)|，这里设置20条链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LIST_NUM 20                                 <span class="comment">// 分离链表最大数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INDEX 4                                     <span class="comment">// 最小块为16字节, 即2^4。这里MIN_INDEX表示分离链表中第一条链表的最小块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_BLOCK_SIZE (DSIZE + 2 * sizeof(intptr_t))	<span class="comment">// 块大小的最小值，32位为16字节， 64位为24字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR(bp)     ((char *)(bp))						<span class="comment">// 强转成char *类型指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV(bp)    ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp)    ((char *)(bp) + sizeof(intptr_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PREV(bp) ((char *)(GET_P(PREV(bp))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) ((char *)(GET_P(SUCC(bp))))</span></span><br></pre></td></tr></table></figure>

<h4 id="辅助函数设计"><a href="#辅助函数设计" class="headerlink" title="辅助函数设计"></a>辅助函数设计</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>; <span class="comment">/* 将大小为size的空闲块插入分离空闲链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 从分离链表中删除指定块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 合并空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;  	   <span class="comment">/* 放置大小为size的块到p指向的空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>;         <span class="comment">/* 扩展堆 */</span></span><br><span class="line"><span class="comment">/* 在所有分离链表中找合适空闲块，返回空闲块指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_free_block</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* 将p指向的块插入第idx个分离链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">/* 移除第i条分离链表上的节点p; 如p不在链表中，则删除失败返回false,否则返回true */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">delete_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">int</span> size, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node"></a>insert_node</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; list_size) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_node_by_list_index(p, size, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="delete-node"><a href="#delete-node" class="headerlink" title="delete_node"></a>delete_node</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= list_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找每条分离链表，尝试从链表中删除p</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delete_node_by_list_index(p, size, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="coalesace"><a href="#coalesace" class="headerlink" title="coalesace"></a>coalesace</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;             <span class="comment">// 前后块均已分配，不可合并</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;			<span class="comment">// 前面的块已分配，后面的块未分配</span></span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;		<span class="comment">// 前面的块未分配，后面的块已分配</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p)));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                     <span class="comment">// 前后两个块都空闲，一次性合并三个块</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p))) + GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="place"><a href="#place" class="headerlink" title="place"></a>place</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位系统，块最小为 4 + 2 * 4 + 4 = 16字节</span></span><br><span class="line"><span class="comment">// 64位系统, 块最小为 4 + 2 * 8 + 4 = 24字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">int</span> delta_size = max_size - size;</span><br><span class="line">    delete_node(p);</span><br><span class="line">    <span class="comment">// 如剩余大小少于最小块大小, 不做分割</span></span><br><span class="line">    <span class="keyword">if</span> (delta_size &lt; MIN_BLOCK_SIZE) &#123;</span><br><span class="line">        PUT(HDRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则需要分割，并将分割后的空闲块加到空闲链表</span></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    insert_node(NEXT_BLKP(p), delta_size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    size = ALIGN(size);</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((p = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;extend_heap failed! mem_sbrk return -1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> coalesce(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化堆-——-mm-init"><a href="#初始化堆-——-mm-init" class="headerlink" title="初始化堆 —— mm_init"></a>初始化堆 —— mm_init</h4><p>调用mm_init后，堆数组结构如下图所示：<br><img src="/2020/0926191511/image8.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4字节对齐块 + MAX_LIST_NUM * DSIZE字节的空闲链表头指针 + 2个4字节序言块 + 4字节结尾块</span></span><br><span class="line">    <span class="type">char</span> *p = mem_sbrk(MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>) + <span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)p == (<span class="type">void</span> *)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有空闲链表的头指针初始为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        PUT_P(p + i * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p += MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>);</span><br><span class="line"></span><br><span class="line">    PUT(p, <span class="number">0</span>);								<span class="comment">// 4字节对齐块，填0;</span></span><br><span class="line">    PUT(p + WSIZE, PACK(DSIZE, <span class="number">1</span>));			<span class="comment">// 序言块头部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>));		<span class="comment">// 序言块脚部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));			<span class="comment">// 结尾快，4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = extend_heap(CHUNKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分配块-——-mm-malloc"><a href="#分配块-——-mm-malloc" class="headerlink" title="分配块 —— mm_malloc"></a>分配块 —— mm_malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = get_malloc_size(size);	<span class="comment">// 得到调整后的malloc请求大小</span></span><br><span class="line">    <span class="comment">// 寻找空闲链表是否有合适的空闲块。如果没找到合适的空闲块, 需要扩展堆</span></span><br><span class="line">    <span class="type">void</span> *p = find_free_block(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mm_malloc, extend_heap failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = place(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放块-——-mm-free"><a href="#释放块-——-mm-free" class="headerlink" title="释放块 —— mm_free"></a>释放块 —— mm_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 将释放后的空闲块重新插入到分离链表中</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重分配块-——-mm-realloc"><a href="#重分配块-——-mm-realloc" class="headerlink" title="重分配块 —— mm_realloc"></a>重分配块 —— mm_realloc</h4><p>函数原型：<code>void *mm_realloc(void *p, size_t size)</code>， 优化点如下：</p>
<ul>
<li><p>如<code>size</code>小于原来的块大小，简单返回原块即可。</p>
</li>
<li><p>如下一块为空闲块，且<code>空闲块大小 + 原块大小 &gt;= size</code>, 直接合并这两个块。</p>
</li>
<li><p>否则，只能用<code>malloc</code>申请新的空闲块，复制原块，再调用<code>free</code>释放原块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果realloc请求的size小于原来的大小，简单返回原块</span></span><br><span class="line">    size = get_malloc_size(size);</span><br><span class="line">    <span class="type">int</span> old_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑下一个块是否空闲块，能否直接合并</span></span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="keyword">if</span> (!next_alloc &amp;&amp; (next_size &gt;= size - old_size)) &#123;</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用malloc申请新的空闲块，复制原块内容，并调用free释放原块</span></span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    ptr = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, oldptr, old_size);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ./mdriver -t traces/ -V</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000886  6430</span><br><span class="line"> 1       yes   99%    5848  0.000793  7379</span><br><span class="line"> 2       yes   99%    6648  0.000903  7359</span><br><span class="line"> 3       yes   99%    5380  0.000749  7182</span><br><span class="line"> 4       yes   66%   14400  0.001754  8212</span><br><span class="line"> 5       yes   96%    4800  0.001114  4308</span><br><span class="line"> 6       yes   95%    4800  0.001112  4317</span><br><span class="line"> 7       yes   55%   12000  0.004104  2924</span><br><span class="line"> 8       yes   51%   24000  0.014884  1612</span><br><span class="line"> 9       yes   87%   14401  0.001490  9667</span><br><span class="line">10       yes   67%   14401  0.001074 13405</span><br><span class="line">Total          83%  112372  0.028862  3893</span><br><span class="line"></span><br><span class="line">Perf index = 50 (util) + 40 (thru) = 90/100</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a target="_blank" rel="noopener" href="https://littlecsd.net/2019/02/14/csapp-Malloclab/">https://littlecsd.net/2019/02/14/csapp-Malloclab/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liqiuhao/p/8252373.html">https://www.cnblogs.com/liqiuhao/p/8252373.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://pcj600.github.io/2020/0926191511.html" data-id="cm2puzlwq001m4cvwc7xtcblv" data-title="CSAPP malloc实验" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/1114192034.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          sem_open打开信号量失败案例分析
        
      </div>
    </a>
  
  
    <a href="/2020/0829191318.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Linux常见控制字符介绍</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CMake/">CMake</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSAPP/">CSAPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Django/">Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GDB/">GDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RPM/">RPM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Squid/">Squid</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VMware/">VMware</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Win/">Win</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ansible/">ansible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/awk/">awk</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/curl/">curl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/draft/">draft</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/interview/">interview</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/investment/">investment</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iptables/">iptables</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/systemd/">systemd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/troubleshooting/">troubleshooting</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/wget/">wget</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/" rel="tag">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CLISH/" rel="tag">CLISH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDB/" rel="tag">GDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRUB/" rel="tag">GRUB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPM/" rel="tag">RPM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Squid/" rel="tag">Squid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Traceroute/" rel="tag">Traceroute</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VMware/" rel="tag">VMware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Win/" rel="tag">Win</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ansible/" rel="tag">ansible</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/" rel="tag">awk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chronyd/" rel="tag">chronyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crontab/" rel="tag">crontab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/curl/" rel="tag">curl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frontend/" rel="tag">frontend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/" rel="tag">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/investment/" rel="tag">investment</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iptables/" rel="tag">iptables</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/" rel="tag">other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/systemd/" rel="tag">systemd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tar/" rel="tag">tar</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/troubleshooting/" rel="tag">troubleshooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wget/" rel="tag">wget</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Assembly/" style="font-size: 11.11px;">Assembly</a> <a href="/tags/C/" style="font-size: 13.33px;">C</a> <a href="/tags/CLISH/" style="font-size: 10px;">CLISH</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/CSAPP/" style="font-size: 13.33px;">CSAPP</a> <a href="/tags/Django/" style="font-size: 12.22px;">Django</a> <a href="/tags/Docker/" style="font-size: 14.44px;">Docker</a> <a href="/tags/GDB/" style="font-size: 13.33px;">GDB</a> <a href="/tags/GRUB/" style="font-size: 10px;">GRUB</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LeetCode/" style="font-size: 13.33px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Network/" style="font-size: 13.33px;">Network</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/RPM/" style="font-size: 12.22px;">RPM</a> <a href="/tags/Redis/" style="font-size: 17.78px;">Redis</a> <a href="/tags/Shell/" style="font-size: 11.11px;">Shell</a> <a href="/tags/Squid/" style="font-size: 14.44px;">Squid</a> <a href="/tags/Traceroute/" style="font-size: 10px;">Traceroute</a> <a href="/tags/VMware/" style="font-size: 12.22px;">VMware</a> <a href="/tags/Win/" style="font-size: 12.22px;">Win</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/awk/" style="font-size: 10px;">awk</a> <a href="/tags/chronyd/" style="font-size: 10px;">chronyd</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/curl/" style="font-size: 10px;">curl</a> <a href="/tags/frontend/" style="font-size: 10px;">frontend</a> <a href="/tags/gcc/" style="font-size: 10px;">gcc</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/investment/" style="font-size: 17.78px;">investment</a> <a href="/tags/iptables/" style="font-size: 12.22px;">iptables</a> <a href="/tags/k8s/" style="font-size: 15.56px;">k8s</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/systemd/" style="font-size: 12.22px;">systemd</a> <a href="/tags/tar/" style="font-size: 10px;">tar</a> <a href="/tags/troubleshooting/" style="font-size: 18.89px;">troubleshooting</a> <a href="/tags/wget/" style="font-size: 10px;">wget</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/1026143114.html">Hexo搭建博客问题记录</a>
          </li>
        
          <li>
            <a href="/2024/1026131638.html">华宝添益(511990)折价套利记录</a>
          </li>
        
          <li>
            <a href="/2024/1026131259.html">chronyd配置了local的NTP server后, NTP报文出现public ip的问题</a>
          </li>
        
          <li>
            <a href="/2024/1017202436.html">MySQL8.0以上版本如何重置密码</a>
          </li>
        
          <li>
            <a href="/2024/1017195632.html">在Rocky Linux上安装Docker</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 PC<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>