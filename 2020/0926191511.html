<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="VLyEpKy1Jq3gcpFmB3W8Ql0f4f-G35UyYi1NJ8Towq0">
  <meta name="baidu-site-verification" content="codeva-dRzuqywF6U">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pcj600.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="实验简介实现自己的动态内存分配器（malloc、free、realloc）。 预备知识 阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。 阅读writeup的全部内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP malloc实验">
<meta property="og:url" content="https://pcj600.github.io/2020/0926191511.html">
<meta property="og:site_name" content="PC&#39;s Blog">
<meta property="og:description" content="实验简介实现自己的动态内存分配器（malloc、free、realloc）。 预备知识 阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。 阅读writeup的全部内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image1.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image2.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image3.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image4.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image5.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image6.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image7.png">
<meta property="og:image" content="https://pcj600.github.io/2020/0926191511/image8.png">
<meta property="article:published_time" content="2020-09-26T11:15:11.000Z">
<meta property="article:modified_time" content="2025-06-03T08:15:45.087Z">
<meta property="article:author" content="PC">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pcj600.github.io/2020/0926191511/image1.png">

<link rel="canonical" href="https://pcj600.github.io/2020/0926191511.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CSAPP malloc实验 | PC's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PC's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">41</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">53</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">205</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pcj600.github.io/2020/0926191511.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="PC">
      <meta itemprop="description" content="PC的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PC's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP malloc实验
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-26 19:15:11" itemprop="dateCreated datePublished" datetime="2020-09-26T19:15:11+08:00">2020-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3><span id="实验简介">实验简介</span></h3><p>实现自己的动态内存分配器（<code>malloc</code>、<code>free</code>、<code>realloc</code>）。</p>
<h3><span id="预备知识">预备知识</span></h3><ul>
<li>阅读《CSAPP原书第3版》 9.9小节 —— 动态内存分配。</li>
<li>阅读<a target="_blank" rel="noopener external nofollow noreferrer" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>的全部内容。</li>
</ul>
<span id="more"></span>

<h4><span id="分配器的设计要求">分配器的设计要求</span></h4><ul>
<li>处理任意请求序列，分配器不可以假设分配和释放请求的顺序。</li>
<li>立即响应请求, 不允许分配器为了提高性能重新排列或缓冲请求。</li>
<li>只使用堆。</li>
<li>对齐块，以保存任何类型的数据对象。</li>
<li>不修改已分配的块，分配器只能操作和改变空闲块。</li>
</ul>
<h4><span id="分配器的设计目标">分配器的设计目标</span></h4><ul>
<li>最大化吞吐率 —— 每个<code>malloc</code>, <code>free</code>执行的指令越少，吞吐率会越好。</li>
<li>最大化内存利用率。</li>
</ul>
<h4><span id="实现问题">实现问题</span></h4><p>关键是把握<strong>吞吐率</strong>和<strong>内存利用率</strong>之间的平衡。</p>
<ul>
<li>空闲块组织 —— 如何记录空闲块？</li>
<li>放置 —— 如何选一个合适的空闲块来放置一个新分配的块？ （首次适配&#x2F;下次适配&#x2F;最优适配）</li>
<li>分割 —— 将一个新分配块放到某个空闲块后，如何处理这个空闲块的剩余部分？</li>
<li>合并 —— 如何处理一个刚被释放的块？ （立即合并&#x2F;延迟合并）</li>
</ul>
<h3><span id="实验步骤">实验步骤</span></h3><p>代码下载：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://csapp.cs.cmu.edu/3e/malloclab-handout.tar">http://csapp.cs.cmu.edu/3e/malloclab-handout.tar</a></p>
<p>目标是实现<code>mm.c</code>中的如下函数, 原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这里使用两种方式实现<code>malloc</code>，分别如下：</p>
<ul>
<li>隐式空闲链表 + 首次适配&#x2F;下一次适配。</li>
<li>显示空闲链表 + 分离的空闲链表 +  分离适配。</li>
</ul>
<h3><span id="隐式空闲链表法">隐式空闲链表法</span></h3><p>原书9.9.6节详细介绍了隐式空闲链表法，并贴出了所有源代码。代码实现细节请参考原书或者 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/PCJ600/MallocLab/tree/br64">https://github.com/PCJ600/MallocLab/tree/br64</a></p>
<h5><span id="隐式空闲链表的形式如下">隐式空闲链表的形式如下：</span></h5><p><img data-src="/2020/0926191511/image1.png"></p>
<ul>
<li>每个堆块使用边界标记法。头部大小为4字节，前29位表示块大小，后3位表示这个块是否空闲；脚部(ftr)是头部(hdr)的副本。目的是<strong>将合并前面的堆块时的搜索时间降到常数</strong>。</li>
<li><strong>第1个填充字用于8字节对齐访问</strong>。考虑64位场景，如不添加填充字，heap_listp的值不能整除8，不满足对齐条件！</li>
<li>序言块和结尾块的设计是消除合并时边界条件的技巧。</li>
<li>按8字节对齐要求， 一个堆块最小为 4(头部) + 8(payload) + 4(脚部) &#x3D; 16字节</li>
<li>为什么是”隐式”的？——  因为空闲块是通过头部中大小字段隐含地连接着，从而间接遍历整个空闲块的集合。</li>
</ul>
<h4><span id="1-初始化堆-mm_init函数">1. 初始化堆 —— mm_init函数</span></h4><p><code>mm_init</code>步骤如下：</p>
<ul>
<li><p>首先在堆上分配16个字节，包括4字节对齐块，8字节序言块，4字节结尾块。</p>
</li>
<li><p>调<code>extend_heap</code>扩展堆，创建初始的空闲块，大小为4096字节。</p>
</li>
</ul>
<h4><span id="2-扩展堆-extend_heap函数">2. 扩展堆 —— extend_heap函数</span></h4><p>函数原型: <code>static void *extend_heap(size_t words);</code></p>
<p>以下两种场景需要扩展堆：</p>
<ul>
<li>调用<code>mm_init</code>初始化堆时。</li>
<li>调用<code>mm_malloc</code>找不到合适的空闲块时。</li>
</ul>
<p>举例：堆上扩展4096个字节，堆数组前后变化如下：</p>
<p><img data-src="/2020/0926191511/image2.png"></p>
<h4><span id="3-释放和合并块-mm_free和coalesce函数">3. 释放和合并块 —— mm_free和coalesce函数</span></h4><p>调用<code>mm_free</code>释放块，步骤如下：</p>
<ul>
<li><p>将当前块的头部和脚部中的分配位清零。</p>
</li>
<li><p>将这个块与它邻接的前后空闲块进行合并，采用立即合并策略。</p>
</li>
</ul>
<p>调用<code>coalesce</code>合并前后的合并块，原型：<code>static void *coalesce(void *bp);</code>，分四种情况：</p>
<ul>
<li>情况1：前面的块和后面的块都已分配 —— 不可能合并，简单返回bp即可。</li>
<li>情况2：前面的块已分配，后面的块空闲 —— 用当前块和后面块的大小之和更新当前块的头部和后面块的脚部。返回bp</li>
<li>情况3：前面的块是空闲的，后面的块是分配的 —— 用两块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
<li>情况4：前面和后面的块都是空闲的 —— 用三个块大小之和更新前面块的头部和后面块的脚部。返回<code>PREV_BLKP(bp)</code></li>
</ul>
<p>说的比较啰嗦，以下画图帮助理解：</p>
<p><strong>情况2:</strong> 前面的块已分配，后面的块空闲</p>
<p><img data-src="/2020/0926191511/image3.png"></p>
<p><strong>注意：</strong> <font color="red"><strong>如采用下次适配策略，在情况3、情况4合并后可能出现pre_listp指针不再指向一个块的payload段，报payload overlap错!</strong></font></p>
<p>因此必须更新<code>pre_listp</code>。这里简单将<code>pre_listp</code>指向合并后的新块的<code>payload</code>即可。</p>
<p><strong>情况3：</strong> 前面的块是空闲的，后面的块是分配的</p>
<p><img data-src="/2020/0926191511/image4.png"></p>
<p><strong>情况4：</strong> 前面和后面的块均空闲<br><img data-src="/2020/0926191511/image5.png"><br>[O#### 4. 分配块 —— mm_malloc</p>
<h5><span id="mm_malloc步骤">mm_malloc步骤</span></h5><ul>
<li><p>调整请求块的大小，需不低于16字节（8字节对齐要求），并舍入到8的整数倍。</p>
</li>
<li><p>根据请求块的大小，搜索空闲链表寻找合适的空闲块：</p>
<ul>
<li>如果找到合适的块，将请求块放置到这个合适的块中，并可选地分割这个块</li>
<li>如找不到合适的块，调<code>extend_heap</code>扩展堆，分配新的空闲块。将请求块放到这个新的空闲块里，并可选地分割这个块</li>
</ul>
</li>
</ul>
<h5><span id="适配算法">适配算法</span></h5><p>分配器搜索空闲块的方式由放置策略决定，常见策略有首次适配、下一次适配等。</p>
<ul>
<li><p>首次适配： 从头搜索空闲链表，选择第一个合适地空闲块。</p>
</li>
<li><p>下一次适配： 从上次查询结束的地方开始搜索空闲链表。</p>
</li>
</ul>
<h5><span id="分割策略">分割策略</span></h5><p>如分割后剩下的块不小于最小块大小(16字节)，才分割这个块。</p>
<p>设空闲块大小为M字节，<code>malloc</code>请求的块大小为N字节。只有M - N &gt;&#x3D; 16，才分割这个块。</p>
<p><img data-src="/2020/0926191511/image6.png"></p>
<h4><span id="5-实现mm_realloc">5. 实现mm_realloc</span></h4><p><code>mm_realloc</code>原型：<code>void *mm_realloc(void *ptr, size_t size)</code></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://csapp.cs.cmu.edu/3e/malloclab.pdf">writeup</a>中提到了<code>mm_realloc</code>的所有实现要点，如下：</p>
<ul>
<li>如果ptr为NULL， 等价于调用mm_malloc</li>
<li>如果size为0, 等价于调用mm_free</li>
<li>如ptr不为NULL且size不为0， 参考realloc函数的实现： <code>man 3 realloc</code></li>
</ul>
<h4><span id="实验结果">实验结果</span></h4><p>执行<code>./mdriver -t traces/ -V</code>，查看详细结果：</p>
<p>首次适配: 44 (util) + 24 (thru) &#x3D; 68&#x2F;100</p>
<p>下一次适配：43 (util) + 40 (thru) &#x3D; 83&#x2F;100</p>
<h3><span id="分离空闲链表法">分离空闲链表法</span></h3><p>实现代码参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/PCJ600/MallocLab">https://github.com/PCJ600/MallocLab</a></p>
<p>使用分离的空闲链表，分配器会维护一个空闲链表的数组。每个空闲链表和一个大小类关联，被组织成某种类型的显式或隐式链表。笔者这里使用以下方案：</p>
<ul>
<li>链表结构为<strong>显式的双向链表</strong></li>
<li>大小类分为 {16-31},{32,63},{64,127}, …, {4096, 8191}, … 链表个数<code>MAX_LIST_NUM</code> 默认设置为20，可调整。</li>
<li>考虑兼容性，分配器需要在32位&#x2F;64位环境下都能正常运行。</li>
</ul>
<h4><span id="注意事项">注意事项</span></h4><ul>
<li>32位机器上，指针大小为4字节；64位机器上， 指针大小为8字节。可使用<code>sizeof(intptr_t)</code>表示指针大小, <code>intptr_t</code>类型是ISO C99定义的，可参考<code>/usr/include/stdint.h</code></li>
<li>实验要求不使用全局变量，可以将分离链表的头指针放到堆中。</li>
<li>默认Makefile采用<code>-m32</code>选项，64位环境下需要改成<code>-m64</code>。</li>
<li>实验涉及大量指针操作，编码极易出错。需掌握基本的gdb调试手段、并编写代码检查堆区和分离链表。</li>
</ul>
<h4><span id="显式的双向链表的堆块结构">显式的双向链表的堆块结构</span></h4><p><img data-src="/2020/0926191511/image7.png"></p>
<ul>
<li><p>对于空闲块，<code>pred</code>保存上一个空闲块的地址，<code>succ</code>保存下一个空闲块的地址。</p>
</li>
<li><p>使用双向链表结构，适配算法的时间复杂度从O(块总数)降到O(空闲块总数)。</p>
</li>
<li><p>不难得出：32位系统，块至少为16字节；64位系统，块至少为24字节。</p>
</li>
</ul>
<h3><span id="如何调试">如何调试？</span></h3><ul>
<li>设置编译选项<code>-g -O0</code>取消编译优化。</li>
<li>设置编译选项<code>-g3 -gdwarf-2</code>调试宏。</li>
<li>可以设置<code>-DDEBUG</code>宏，通过编译宏控制是否打印调试信息。</li>
<li>实现<code>mm_print</code>函数，在gdb中通过<code>call mm_print()</code>打印堆区和分离链表。</li>
</ul>
<h4><span id="打印堆数组状态和所有分离链表-mm_print函数设计">打印堆数组状态和所有分离链表 —— mm_print函数设计</span></h4><ul>
<li><p>打印堆数组中每个块的头部、脚部、大小、分配位、payload指针。</p>
</li>
<li><p>打印堆数组中所有分离链表头指针的值。</p>
</li>
<li><p>打印每条分离链表的所有块的头部、脚部、大小、分配位、payload指针。</p>
</li>
</ul>
<h4><span id="堆区和分离链表检查-mm_check函数设计">堆区和分离链表检查 —— mm_check函数设计</span></h4><p><strong>检查堆区状态，包括：</strong></p>
<ul>
<li>检查序言块、结尾块的指针、大小、分配位是否正确。</li>
<li>检查每个块的payload指针是否满足对齐要求。</li>
<li>检查每个块的payload指针是否在堆区的合法地址范围内(<code>mem_heap_lo() ~ mem_heap_hi()</code>之间)。</li>
<li>检查每个块的头部和脚部是否一致。</li>
<li>检查每个块的大小是否不低于最小块的大小，是否为4&#x2F;8字节的倍数。</li>
<li>采用立即合并策略时，检查不存在任意两个相邻的空闲块。</li>
</ul>
<p><strong>检查分离链表状态，包括：</strong></p>
<ul>
<li><p>检查链表中所有指针是否在堆区的合法地址范围内。</p>
</li>
<li><p>检查双向链表实现是否正确，是否每个指针A的后继为B时，B的前驱也同时为A。</p>
</li>
<li><p>检查分离链表中所有的空闲块是否与堆数组的空闲块中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个空闲块是否都能在分离链表中找到并匹配。</p>
</li>
<li><p>检查堆数组中每个已占用块是否都不在分离链表中。</p>
</li>
</ul>
<p><strong>针对malloc做如下检查：</strong></p>
<ul>
<li>malloc返回前，检查指针p是否在堆数组中，如不在堆数组中说明出错。</li>
<li>malloc返回前，检查指针p对应的块大小是否不小于malloc请求的大小。</li>
</ul>
<p><strong>针对free做如下检查：</strong></p>
<ul>
<li><p>调用free时，先检查指针p是否在堆区的合法地址范围内。</p>
</li>
<li><p>调用free时，先检查p是否指向了堆数组中某个已分配块。</p>
</li>
</ul>
<p>实现代码参考： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/PCJ600/MallocLab/blob/master/mm.c">https://github.com/PCJ600/MallocLab/blob/master/mm.c</a>  <code>mm_check</code>函数</p>
<h4><span id="指针运算-宏定义">指针运算、宏定义</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~(ALIGNMENT-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4                                     <span class="comment">// 4字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8                                     <span class="comment">// 双字: 8字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)                         <span class="comment">// 4096字节, 执行extend_heap一次, 堆上扩展的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc))		<span class="comment">// 设置分配位， 前29位表示块大小，后3位表示是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)             (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)        (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)        (GET(p) &amp; ~(0x1))        <span class="comment">// 获取块大小, 这里块大小不会超过2^32字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p)       (GET(p) &amp; 0x1)           <span class="comment">// 判断这个块是否已分配</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型读写，使用intptr_t兼容32位/64位机器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_P(p)           (*(intptr_t *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT_P(p, val)      (*(intptr_t *)(p) = (intptr_t)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离链表: |(16-31)|(32-63)|(64-127)|(128-255)| ..... |(2^23,2^24-1)|，这里设置20条链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LIST_NUM 20                                 <span class="comment">// 分离链表最大数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_INDEX 4                                     <span class="comment">// 最小块为16字节, 即2^4。这里MIN_INDEX表示分离链表中第一条链表的最小块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_BLOCK_SIZE (DSIZE + 2 * sizeof(intptr_t))	<span class="comment">// 块大小的最小值，32位为16字节， 64位为24字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR(bp)     ((char *)(bp))						<span class="comment">// 强转成char *类型指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)    ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)    ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV(bp)    ((char *)(bp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC(bp)    ((char *)(bp) + sizeof(intptr_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PREV(bp) ((char *)(GET_P(PREV(bp))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SUCC(bp) ((char *)(GET_P(SUCC(bp))))</span></span><br></pre></td></tr></table></figure>

<h4><span id="辅助函数设计">辅助函数设计</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>; <span class="comment">/* 将大小为size的空闲块插入分离空闲链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 从分离链表中删除指定块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span>; 			   <span class="comment">/* 合并空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span>;  	   <span class="comment">/* 放置大小为size的块到p指向的空闲块 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span>;         <span class="comment">/* 扩展堆 */</span></span><br><span class="line"><span class="comment">/* 在所有分离链表中找合适空闲块，返回空闲块指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_free_block</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/* 将p指向的块插入第idx个分离链表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size, <span class="type">int</span> idx)</span>;</span><br><span class="line"><span class="comment">/* 移除第i条分离链表上的节点p; 如p不在链表中，则删除失败返回false,否则返回true */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">delete_node_by_list_index</span><span class="params">(<span class="type">void</span> *p, <span class="type">int</span> size, <span class="type">int</span> idx)</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="insert_node">insert_node</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_node</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; list_size) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert_node_by_list_index(p, size, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="delete_node">delete_node</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_node</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> list_size;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        list_size = (<span class="number">1</span> &lt;&lt; (MIN_INDEX + i));</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= list_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找每条分离链表，尝试从链表中删除p</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delete_node_by_list_index(p, size, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="coalesace">coalesace</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev_alloc = GET_ALLOC(HDRP(PREV_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(p)));</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;             <span class="comment">// 前后块均已分配，不可合并</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;			<span class="comment">// 前面的块已分配，后面的块未分配</span></span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;		<span class="comment">// 前面的块未分配，后面的块已分配</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p)));</span><br><span class="line">        PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                     <span class="comment">// 前后两个块都空闲，一次性合并三个块</span></span><br><span class="line">        delete_node(PREV_BLKP(p));</span><br><span class="line">        delete_node(p);</span><br><span class="line">        delete_node(NEXT_BLKP(p));</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(p))) + GET_SIZE(HDRP(NEXT_BLKP(p)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(p)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        p = PREV_BLKP(p);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="place">place</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位系统，块最小为 4 + 2 * 4 + 4 = 16字节</span></span><br><span class="line"><span class="comment">// 64位系统, 块最小为 4 + 2 * 8 + 4 = 24字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">place</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_size = GET_SIZE(HDRP(p));</span><br><span class="line">    <span class="type">int</span> delta_size = max_size - size;</span><br><span class="line">    delete_node(p);</span><br><span class="line">    <span class="comment">// 如剩余大小少于最小块大小, 不做分割</span></span><br><span class="line">    <span class="keyword">if</span> (delta_size &lt; MIN_BLOCK_SIZE) &#123;</span><br><span class="line">        PUT(HDRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(p), PACK(max_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则需要分割，并将分割后的空闲块加到空闲链表</span></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">1</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(NEXT_BLKP(p)), PACK(delta_size, <span class="number">0</span>));</span><br><span class="line">    insert_node(NEXT_BLKP(p), delta_size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="extend_heap">extend_heap</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    size = ALIGN(size);</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="keyword">if</span> ((p = mem_sbrk(size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;extend_heap failed! mem_sbrk return -1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(p), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(p)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    insert_node(p, size);</span><br><span class="line">    <span class="keyword">return</span> coalesce(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="初始化堆-mm_init">初始化堆 —— mm_init</span></h4><p>调用mm_init后，堆数组结构如下图所示：<br><img data-src="/2020/0926191511/image8.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4字节对齐块 + MAX_LIST_NUM * DSIZE字节的空闲链表头指针 + 2个4字节序言块 + 4字节结尾块</span></span><br><span class="line">    <span class="type">char</span> *p = mem_sbrk(MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>) + <span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">void</span> *)p == (<span class="type">void</span> *)(<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有空闲链表的头指针初始为NULL</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LIST_NUM; ++i) &#123;</span><br><span class="line">        PUT_P(p + i * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p += MAX_LIST_NUM * <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>);</span><br><span class="line"></span><br><span class="line">    PUT(p, <span class="number">0</span>);								<span class="comment">// 4字节对齐块，填0;</span></span><br><span class="line">    PUT(p + WSIZE, PACK(DSIZE, <span class="number">1</span>));			<span class="comment">// 序言块头部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">2</span> * WSIZE, PACK(DSIZE, <span class="number">1</span>));		<span class="comment">// 序言块脚部，4字节</span></span><br><span class="line">    PUT(p + <span class="number">3</span> * WSIZE, PACK(<span class="number">0</span>, <span class="number">1</span>));			<span class="comment">// 结尾快，4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = extend_heap(CHUNKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="分配块-mm_malloc">分配块 —— mm_malloc</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    size = get_malloc_size(size);	<span class="comment">// 得到调整后的malloc请求大小</span></span><br><span class="line">    <span class="comment">// 寻找空闲链表是否有合适的空闲块。如果没找到合适的空闲块, 需要扩展堆</span></span><br><span class="line">    <span class="type">void</span> *p = find_free_block(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = extend_heap(MAX(size, CHUNKSIZE))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mm_malloc, extend_heap failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = place(p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="释放块-mm_free">释放块 —— mm_free</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 将释放后的空闲块重新插入到分离链表中</span></span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="重分配块-mm_realloc">重分配块 —— mm_realloc</span></h4><p>函数原型：<code>void *mm_realloc(void *p, size_t size)</code>， 优化点如下：</p>
<ul>
<li><p>如<code>size</code>小于原来的块大小，简单返回原块即可。</p>
</li>
<li><p>如下一块为空闲块，且<code>空闲块大小 + 原块大小 &gt;= size</code>, 直接合并这两个块。</p>
</li>
<li><p>否则，只能用<code>malloc</code>申请新的空闲块，复制原块，再调用<code>free</code>释放原块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果realloc请求的size小于原来的大小，简单返回原块</span></span><br><span class="line">    size = get_malloc_size(size);</span><br><span class="line">    <span class="type">int</span> old_size = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑下一个块是否空闲块，能否直接合并</span></span><br><span class="line">    <span class="type">int</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));</span><br><span class="line">    <span class="keyword">if</span> (!next_alloc &amp;&amp; (next_size &gt;= size - old_size)) &#123;</span><br><span class="line">        delete_node(NEXT_BLKP(ptr));</span><br><span class="line">        PUT(HDRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(ptr), PACK(next_size + old_size, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能使用malloc申请新的空闲块，复制原块内容，并调用free释放原块</span></span><br><span class="line">    <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">    ptr = mm_malloc(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, oldptr, old_size);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="实验结果">实验结果</span></h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ./mdriver -t traces/ -V</span><br><span class="line">Results for mm malloc:</span><br><span class="line">trace  valid  util     ops      secs  Kops</span><br><span class="line"> 0       yes   99%    5694  0.000886  6430</span><br><span class="line"> 1       yes   99%    5848  0.000793  7379</span><br><span class="line"> 2       yes   99%    6648  0.000903  7359</span><br><span class="line"> 3       yes   99%    5380  0.000749  7182</span><br><span class="line"> 4       yes   66%   14400  0.001754  8212</span><br><span class="line"> 5       yes   96%    4800  0.001114  4308</span><br><span class="line"> 6       yes   95%    4800  0.001112  4317</span><br><span class="line"> 7       yes   55%   12000  0.004104  2924</span><br><span class="line"> 8       yes   51%   24000  0.014884  1612</span><br><span class="line"> 9       yes   87%   14401  0.001490  9667</span><br><span class="line">10       yes   67%   14401  0.001074 13405</span><br><span class="line">Total          83%  112372  0.028862  3893</span><br><span class="line"></span><br><span class="line">Perf index = 50 (util) + 40 (thru) = 90/100</span><br></pre></td></tr></table></figure>

<h3><span id="参考资料">参考资料</span></h3><p>《深入理解计算机系统 原书第3版》</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://littlecsd.net/2019/02/14/csapp-Malloclab/">https://littlecsd.net/2019/02/14/csapp-Malloclab/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/liqiuhao/p/8252373.html">https://www.cnblogs.com/liqiuhao/p/8252373.html</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="PC 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="PC 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>PC
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://pcj600.github.io/2020/0926191511.html" title="CSAPP malloc实验">https://pcj600.github.io/2020/0926191511.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>所有文章都欢迎转载, 注明出处即可.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/0829191318.html" rel="prev" title="Linux常见控制字符介绍">
      <i class="fa fa-chevron-left"></i> Linux常见控制字符介绍
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/1114192034.html" rel="next" title="sem_open打开信号量失败案例分析">
      sem_open打开信号量失败案例分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">实验简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">分配器的设计要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">分配器的设计目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">实现问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">实验步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">隐式空闲链表法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">隐式空闲链表的形式如下：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">1. 初始化堆 —— mm_init函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">2. 扩展堆 —— extend_heap函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">3. 释放和合并块 —— mm_free和coalesce函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">mm_malloc步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">适配算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">分割策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">5. 实现mm_realloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">分离空闲链表法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">显式的双向链表的堆块结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">如何调试？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">打印堆数组状态和所有分离链表 —— mm_print函数设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">堆区和分离链表检查 —— mm_check函数设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">指针运算、宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">辅助函数设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">insert_node</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">delete_node</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">coalesace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">place</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-text">extend_heap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">初始化堆 —— mm_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">分配块 —— mm_malloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">释放块 —— mm_free</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">重分配块 —— mm_realloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text">实验结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PC"
      src="/images/avatar.jpg">
  <!-- <p class="site-author-name" itemprop="name">PC</p> -->
  <div class="site-description" itemprop="description">PC的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">205</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/pcj_888" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;pcj_888" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-weibo fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        



<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PC</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">856k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:58</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        
  <script async src="/js/busuanzi.js"></script>









      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<script type="text/javascript" src="/js/clicklove.js"></script>
